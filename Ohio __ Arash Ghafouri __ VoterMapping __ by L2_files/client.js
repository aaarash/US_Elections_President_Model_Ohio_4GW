/*global setTimeout: false, console: false */(function(){var a={},b=this,c=b.async;typeof module!="undefined"&&module.exports?module.exports=a:b.async=a,a.noConflict=function(){return b.async=c,a};var d=function(a,b){if(a.forEach)return a.forEach(b);for(var c=0;c<a.length;c+=1)b(a[c],c,a)},e=function(a,b){if(a.map)return a.map(b);var c=[];return d(a,function(a,d,e){c.push(b(a,d,e))}),c},f=function(a,b,c){return a.reduce?a.reduce(b,c):(d(a,function(a,d,e){c=b(c,a,d,e)}),c)},g=function(a){if(Object.keys)return Object.keys(a);var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(c);return b},h=function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0;c<a.length;c+=1)if(a[c]===b)return c;return-1};typeof process=="undefined"||!process.nextTick?a.nextTick=function(a){setTimeout(a,0)}:a.nextTick=process.nextTick,a.forEach=function(a,b,c){if(!a.length)return c();var e=0;d(a,function(d){b(d,function(b){b?(c(b),c=function(){}):(e+=1,e===a.length&&c())})})},a.forEachSeries=function(a,b,c){if(!a.length)return c();var d=0,e=function(){b(a[d],function(b){b?(c(b),c=function(){}):(d+=1,d===a.length?c():e())})};e()},a.forEachLimit=function(a,b,c,d){if(!a.length||b<=0)return d();var e=0,f=0,g=0;(function h(){if(e===a.length)return d();while(g<b&&f<a.length)c(a[f],function(b){b?(d(b),d=function(){}):(e+=1,g-=1,e===a.length?d():h())}),f+=1,g+=1})()};var i=function(b){return function(){var c=Array.prototype.slice.call(arguments);return b.apply(null,[a.forEach].concat(c))}},j=function(b){return function(){var c=Array.prototype.slice.call(arguments);return b.apply(null,[a.forEachSeries].concat(c))}},k=function(a,b,c,d){var f=[];b=e(b,function(a,b){return{index:b,value:a}}),a(b,function(a,b){c(a.value,function(c,d){f[a.index]=d,b(c)})},function(a){d(a,f)})};a.map=i(k),a.mapSeries=j(k),a.reduce=function(b,c,d,e){a.forEachSeries(b,function(a,b){d(c,a,function(a,d){c=d,b(a)})},function(a){e(a,c)})},a.inject=a.reduce,a.foldl=a.reduce,a.reduceRight=function(b,c,d,f){var g=e(b,function(a){return a}).reverse();a.reduce(g,c,d,f)},a.foldr=a.reduceRight;var l=function(a,b,c,d){var f=[];b=e(b,function(a,b){return{index:b,value:a}}),a(b,function(a,b){c(a.value,function(c){c&&f.push(a),b()})},function(a){d(e(f.sort(function(a,b){return a.index-b.index}),function(a){return a.value}))})};a.filter=i(l),a.filterSeries=j(l),a.select=a.filter,a.selectSeries=a.filterSeries;var m=function(a,b,c,d){var f=[];b=e(b,function(a,b){return{index:b,value:a}}),a(b,function(a,b){c(a.value,function(c){c||f.push(a),b()})},function(a){d(e(f.sort(function(a,b){return a.index-b.index}),function(a){return a.value}))})};a.reject=i(m),a.rejectSeries=j(m);var n=function(a,b,c,d){a(b,function(a,b){c(a,function(c){c?(d(a),d=function(){}):b()})},function(a){d()})};a.detect=i(n),a.detectSeries=j(n),a.some=function(b,c,d){a.forEach(b,function(a,b){c(a,function(a){a&&(d(!0),d=function(){}),b()})},function(a){d(!1)})},a.any=a.some,a.every=function(b,c,d){a.forEach(b,function(a,b){c(a,function(a){a||(d(!1),d=function(){}),b()})},function(a){d(!0)})},a.all=a.every,a.sortBy=function(b,c,d){a.map(b,function(a,b){c(a,function(c,d){c?b(c):b(null,{value:a,criteria:d})})},function(a,b){if(a)return d(a);var c=function(a,b){var c=a.criteria,d=b.criteria;return c<d?-1:c>d?1:0};d(null,e(b.sort(c),function(a){return a.value}))})},a.auto=function(a,b){b=b||function(){};var c=g(a);if(!c.length)return b(null);var e={},h=[],i=function(a){h.unshift(a)},j=function(a){for(var b=0;b<h.length;b+=1)if(h[b]===a){h.splice(b,1);return}},k=function(){d(h.slice(0),function(a){a()})};i(function(){g(e).length===c.length&&(b(null,e),b=function(){})}),d(c,function(c){var d=a[c]instanceof Function?[a[c]]:a[c],g=function(a){if(a)b(a),b=function(){};else{var d=Array.prototype.slice.call(arguments,1);d.length<=1&&(d=d[0]),e[c]=d,k()}},h=d.slice(0,Math.abs(d.length-1))||[],l=function(){return f(h,function(a,b){return a&&e.hasOwnProperty(b)},!0)};if(l())d[d.length-1](g,e);else{var m=function(){l()&&(j(m),d[d.length-1](g,e))};i(m)}})},a.waterfall=function(b,c){if(!b.length)return c();c=c||function(){};var d=function(b){return function(e){if(e)c(e),c=function(){};else{var f=Array.prototype.slice.call(arguments,1),g=b.next();g?f.push(d(g)):f.push(c),a.nextTick(function(){b.apply(null,f)})}}};d(a.iterator(b))()},a.parallel=function(b,c){c=c||function(){};if(b.constructor===Array)a.map(b,function(a,b){a&&a(function(a){var c=Array.prototype.slice.call(arguments,1);c.length<=1&&(c=c[0]),b.call(null,a,c)})},c);else{var d={};a.forEach(g(b),function(a,c){b[a](function(b){var e=Array.prototype.slice.call(arguments,1);e.length<=1&&(e=e[0]),d[a]=e,c(b)})},function(a){c(a,d)})}},a.series=function(b,c){c=c||function(){};if(b.constructor===Array)a.mapSeries(b,function(a,b){a&&a(function(a){var c=Array.prototype.slice.call(arguments,1);c.length<=1&&(c=c[0]),b.call(null,a,c)})},c);else{var d={};a.forEachSeries(g(b),function(a,c){b[a](function(b){var e=Array.prototype.slice.call(arguments,1);e.length<=1&&(e=e[0]),d[a]=e,c(b)})},function(a){c(a,d)})}},a.iterator=function(a){var b=function(c){var d=function(){return a.length&&a[c].apply(null,arguments),d.next()};return d.next=function(){return c<a.length-1?b(c+1):null},d};return b(0)},a.apply=function(a){var b=Array.prototype.slice.call(arguments,1);return function(){return a.apply(null,b.concat(Array.prototype.slice.call(arguments)))}};var o=function(a,b,c,d){var e=[];a(b,function(a,b){c(a,function(a,c){e=e.concat(c||[]),b(a)})},function(a){d(a,e)})};a.concat=i(o),a.concatSeries=j(o),a.whilst=function(b,c,d){b()?c(function(e){if(e)return d(e);a.whilst(b,c,d)}):d()},a.until=function(b,c,d){b()?d():c(function(e){if(e)return d(e);a.until(b,c,d)})},a.queue=function(b,c){var e=0,f={tasks:[],concurrency:c,saturated:null,empty:null,drain:null,push:function(b,e){b.constructor!==Array&&(b=[b]),d(b,function(b){f.tasks.push({data:b,callback:typeof e=="function"?e:null}),f.saturated&&f.tasks.length==c&&f.saturated(),a.nextTick(f.process)})},process:function(){if(e<f.concurrency&&f.tasks.length){var a=f.tasks.shift();f.empty&&f.tasks.length==0&&f.empty(),e+=1,b(a.data,function(){e-=1,a.callback&&a.callback.apply(a,arguments),f.drain&&f.tasks.length+e==0&&f.drain(),f.process()})}},length:function(){return f.tasks.length},running:function(){return e}};return f};var p=function(a){return function(b){var c=Array.prototype.slice.call(arguments,1);b.apply(null,c.concat([function(b){var c=Array.prototype.slice.call(arguments,1);typeof console!="undefined"&&(b?console.error&&console.error(b):console[a]&&d(c,function(b){console[a](b)}))}]))}};a.log=p("log"),a.dir=p("dir"),a.memoize=function(a,b){var c={},d={};b=b||function(a){return a};var e=function(){var e=Array.prototype.slice.call(arguments),f=e.pop(),g=b.apply(null,e);g in c?f.apply(null,c[g]):g in d?d[g].push(f):(d[g]=[f],a.apply(null,e.concat([function(){c[g]=arguments;var a=d[g];delete d[g];for(var b=0,e=a.length;b<e;b++)a[b].apply(null,arguments)}])))};return e.unmemoized=a,e},a.unmemoize=function(a){return function(){return(a.unmemoized||a).apply(null,arguments)}}})();
(function () {
  var gju = this.gju = {};

  // Export the geojson object for **CommonJS**
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = gju;
  }

  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js
  gju.lineStringsIntersect = function (l1, l2) {
    var intersects = [];
    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {
      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {
        var a1 = {
          x: l1.coordinates[i][1],
          y: l1.coordinates[i][0]
        },
          a2 = {
            x: l1.coordinates[i + 1][1],
            y: l1.coordinates[i + 1][0]
          },
          b1 = {
            x: l2.coordinates[j][1],
            y: l2.coordinates[j][0]
          },
          b2 = {
            x: l2.coordinates[j + 1][1],
            y: l2.coordinates[j + 1][0]
          },
          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
        if (u_b != 0) {
          var ua = ua_t / u_b,
            ub = ub_t / u_b;
          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
            intersects.push({
              'type': 'Point',
              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]
            });
          }
        }
      }
    }
    if (intersects.length == 0) intersects = false;
    return intersects;
  }

  // Bounding Box

  function boundingBoxAroundPolyCoords (coords) {
    var xAll = [], yAll = []

    for (var i = 0; i < coords[0].length; i++) {
      xAll.push(coords[0][i][1])
      yAll.push(coords[0][i][0])
    }

    xAll = xAll.sort(function (a,b) { return a - b })
    yAll = yAll.sort(function (a,b) { return a - b })

    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]
  }

  gju.pointInBoundingBox = function (point, bounds) {
    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) 
  }

  // Point in Polygon
  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices

  function pnpoly (x,y,coords) {
    var vert = [ [0,0] ]

    for (var i = 0; i < coords.length; i++) {
      for (var j = 0; j < coords[i].length; j++) {
        vert.push(coords[i][j])
      }
	  vert.push(coords[i][0])
      vert.push([0,0])
    }

    var inside = false
    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {
      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside
    }

    return inside
  }

  gju.pointInPolygon = function (p, poly) {
    var coords = (poly.type == "Polygon") ? [ poly.coordinates ] : poly.coordinates

    var insideBox = false
    for (var i = 0; i < coords.length; i++) {
      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true
    }
    if (!insideBox) return false

    var insidePoly = false
    for (var i = 0; i < coords.length; i++) {
      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true
    }

    return insidePoly
  }

  // support multi (but not donut) polygons
  gju.pointInMultiPolygon = function (p, poly) {
    var coords_array = (poly.type == "MultiPolygon") ? [ poly.coordinates ] : poly.coordinates

    var insideBox = false
    var insidePoly = false
    for (var i = 0; i < coords_array.length; i++){
      var coords = coords_array[i];
      for (var j = 0; j < coords.length; j++) {
        if (!insideBox){
          if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[j]))) {
            insideBox = true
          }
        }
      }
      if (!insideBox) return false
      for (var j = 0; j < coords.length; j++) {
        if (!insidePoly){
          if (pnpoly(p.coordinates[1], p.coordinates[0], coords[j])) {
            insidePoly = true
          }
        }
      }
    }

    return insidePoly
  }

  gju.numberToRadius = function (number) {
    return number * Math.PI / 180;
  }

  gju.numberToDegree = function (number) {
    return number * 180 / Math.PI;
  }

  // written with help from @tautologe
  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {
    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],
      dist = (radiusInMeters / 1000) / 6371,
      // convert meters to radiant
      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],
      steps = steps || 15,
      // 15 sided circle
      poly = [[center[0], center[1]]];
    for (var i = 0; i < steps; i++) {
      var brng = 2 * Math.PI * i / steps;
      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)
              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));
      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),
                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));
      poly[i] = [];
      poly[i][1] = gju.numberToDegree(lat);
      poly[i][0] = gju.numberToDegree(lng);
    }
    return {
      "type": "Polygon",
      "coordinates": [poly]
    };
  }

  // assumes rectangle starts at lower left point
  gju.rectangleCentroid = function (rectangle) {
    var bbox = rectangle.coordinates[0];
    var xmin = bbox[0][0],
      ymin = bbox[0][1],
      xmax = bbox[2][0],
      ymax = bbox[2][1];
    var xwidth = xmax - xmin;
    var ywidth = ymax - ymin;
    return {
      'type': 'Point',
      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]
    };
  }

  // from http://www.movable-type.co.uk/scripts/latlong.html
  gju.pointDistance = function (pt1, pt2) {
    var lon1 = pt1.coordinates[0],
      lat1 = pt1.coordinates[1],
      lon2 = pt2.coordinates[0],
      lat2 = pt2.coordinates[1],
      dLat = gju.numberToRadius(lat2 - lat1),
      dLon = gju.numberToRadius(lon2 - lon1),
      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))
        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),
      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return (6371 * c) * 1000; // returns meters
  },

  // checks if geometry lies entirely within a circle
  // works with Point, LineString, Polygon
  gju.geometryWithinRadius = function (geometry, center, radius) {
    if (geometry.type == 'Point') {
      return gju.pointDistance(geometry, center) <= radius;
    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {
      var point = {};
      var coordinates;
      if (geometry.type == 'Polygon') {
        // it's enough to check the exterior ring of the Polygon
        coordinates = geometry.coordinates[0];
      } else {
        coordinates = geometry.coordinates;
      }
      for (var i in coordinates) {
        point.coordinates = coordinates[i];
        if (gju.pointDistance(point, center) > radius) {
          return false;
        }
      }
    }
    return true;
  }

  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
  gju.area = function (polygon) {
    var area = 0;
    // TODO: polygon holes at coordinates[1]
    var points = polygon.coordinates[0];
    var j = points.length - 1;
    var p1, p2;

    for (var i = 0; i < points.length; j = i++) {
      var p1 = {
        x: points[i][1],
        y: points[i][0]
      };
      var p2 = {
        x: points[j][1],
        y: points[j][0]
      };
      area += p1.x * p2.y;
      area -= p1.y * p2.x;
    }

    area /= 2;
    return area * 1000;
  },

  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
  gju.centroid = function (polygon) {
    var f, x = 0,
      y = 0;
    // TODO: polygon holes at coordinates[1]
    var points = polygon.coordinates[0];
    var j = points.length - 1;
    var p1, p2;

    for (var i = 0; i < points.length; j = i++) {
      var p1 = {
        x: points[i][1],
        y: points[i][0]
      };
      var p2 = {
        x: points[j][1],
        y: points[j][0]
      };
      f = p1.x * p2.y - p2.x * p1.y;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
    }

    f = gju.area(polygon) * 6;
    return {
      'type': 'Point',
      'coordinates': [y / f, x / f]
    };
  },

  gju.simplify = function (source, kink) { /* source[] array of geojson points */
    /* kink	in metres, kinks above this depth kept  */
    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */
    kink = kink || 20;
    source = source.map(function (o) {
      return {
        lng: o.coordinates[0],
        lat: o.coordinates[1]
      }
    });

    var n_source, n_stack, n_dest, start, end, i, sig;
    var dev_sqr, max_dev_sqr, band_sqr;
    var x12, y12, d12, x13, y13, d13, x23, y23, d23;
    var F = (Math.PI / 180.0) * 0.5;
    var index = new Array(); /* aray of indexes of source points to include in the reduced line */
    var sig_start = new Array(); /* indices of start & end of working section */
    var sig_end = new Array();

    /* check for simple cases */

    if (source.length < 3) return (source); /* one or two points */

    /* more complex case. initialize stack */

    n_source = source.length;
    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */
    band_sqr *= band_sqr;
    n_dest = 0;
    sig_start[0] = 0;
    sig_end[0] = n_source - 1;
    n_stack = 1;

    /* while the stack is not empty  ... */
    while (n_stack > 0) {

      /* ... pop the top-most entries off the stacks */

      start = sig_start[n_stack - 1];
      end = sig_end[n_stack - 1];
      n_stack--;

      if ((end - start) > 1) { /* any intermediate points ? */

        /* ... yes, so find most deviant intermediate point to
        either side of line joining start & end points */

        x12 = (source[end].lng - source[start].lng);
        y12 = (source[end].lat - source[start].lat);
        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);
        x12 *= Math.cos(F * (source[end].lat + source[start].lat)); /* use avg lat to reduce lng */
        d12 = (x12 * x12) + (y12 * y12);

        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {

          x13 = source[i].lng - source[start].lng;
          y13 = source[i].lat - source[start].lat;
          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);
          x13 *= Math.cos(F * (source[i].lat + source[start].lat));
          d13 = (x13 * x13) + (y13 * y13);

          x23 = source[i].lng - source[end].lng;
          y23 = source[i].lat - source[end].lat;
          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);
          x23 *= Math.cos(F * (source[i].lat + source[end].lat));
          d23 = (x23 * x23) + (y23 * y23);

          if (d13 >= (d12 + d23)) dev_sqr = d23;
          else if (d23 >= (d12 + d13)) dev_sqr = d13;
          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle
          if (dev_sqr > max_dev_sqr) {
            sig = i;
            max_dev_sqr = dev_sqr;
          }
        }

        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */
          /* ... no, so transfer current start point */
          index[n_dest] = start;
          n_dest++;
        } else { /* ... yes, so push two sub-sections on stack for further processing */
          n_stack++;
          sig_start[n_stack - 1] = sig;
          sig_end[n_stack - 1] = end;
          n_stack++;
          sig_start[n_stack - 1] = start;
          sig_end[n_stack - 1] = sig;
        }
      } else { /* ... no intermediate points, so transfer current start point */
        index[n_dest] = start;
        n_dest++;
      }
    }

    /* transfer last point */
    index[n_dest] = n_source - 1;
    n_dest++;

    /* make return array */
    var r = new Array();
    for (var i = 0; i < n_dest; i++)
      r.push(source[index[i]]);

    return r.map(function (o) {
      return {
        type: "Point",
        coordinates: [o.lng, o.lat]
      }
    });
  }

  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint
  gju.destinationPoint = function (pt, brng, dist) {
    dist = dist/6371;  // convert dist to angular distance in radians
    brng = gju.numberToRadius(brng);

    var lon1 = gju.numberToRadius(pt.coordinates[0]);
    var lat1 = gju.numberToRadius(pt.coordinates[1]);

    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +
                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),
                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

    return {
      'type': 'Point',
      'coordinates': [gju.numberToDegree(lon2), gju.numberToDegree(lat2)]
    };
  };

})();

/*!
Copyright © 2006-2007 Kevin C. Olbrich
Copyright © 2010-2013 LIM SAS (http://lim.eu) - Julien Sanchez

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/*jshint eqeqeq:true, immed:true, undef:true */
/*global module:false, define:false */
(function (root, factory) {
    if (typeof exports === "object") {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else {
        // Browser globals
        root.Qty = factory();
    }
}(this, function() {
  var UNITS = {
    /* prefixes */
    "<googol>" : [["googol"], 1e100, "prefix"],
    "<kibi>"  :  [["Ki","Kibi","kibi"], Math.pow(2,10), "prefix"],
    "<mebi>"  :  [["Mi","Mebi","mebi"], Math.pow(2,20), "prefix"],
    "<gibi>"  :  [["Gi","Gibi","gibi"], Math.pow(2,30), "prefix"],
    "<tebi>"  :  [["Ti","Tebi","tebi"], Math.pow(2,40), "prefix"],
    "<pebi>"  :  [["Pi","Pebi","pebi"], Math.pow(2,50), "prefix"],
    "<exi>"   :  [["Ei","Exi","exi"], Math.pow(2,60), "prefix"],
    "<zebi>"  :  [["Zi","Zebi","zebi"], Math.pow(2,70), "prefix"],
    "<yebi>"  :  [["Yi","Yebi","yebi"], Math.pow(2,80), "prefix"],
    "<yotta>" :  [["Y","Yotta","yotta"], 1e24, "prefix"],
    "<zetta>" :  [["Z","Zetta","zetta"], 1e21, "prefix"],
    "<exa>"   :  [["E","Exa","exa"], 1e18, "prefix"],
    "<peta>"  :  [["P","Peta","peta"], 1e15, "prefix"],
    "<tera>"  :  [["T","Tera","tera"], 1e12, "prefix"],
    "<giga>"  :  [["G","Giga","giga"], 1e9, "prefix"],
    "<mega>"  :  [["M","Mega","mega"], 1e6, "prefix"],
    "<kilo>"  :  [["k","kilo"], 1e3, "prefix"],
    "<hecto>" :  [["h","Hecto","hecto"], 1e2, "prefix"],
    "<deca>"  :  [["da","Deca","deca","deka"], 1e1, "prefix"],
    "<deci>"  :  [["d","Deci","deci"], 1e-1, "prefix"],
    "<centi>"  : [["c","Centi","centi"], 1e-2, "prefix"],
    "<milli>" :  [["m","Milli","milli"], 1e-3, "prefix"],
    "<micro>"  : [["u","Micro","mc","micro"], 1e-6, "prefix"],
    "<nano>"  :  [["n","Nano","nano"], 1e-9, "prefix"],
    "<pico>"  :  [["p","Pico","pico"], 1e-12, "prefix"],
    "<femto>" :  [["f","Femto","femto"], 1e-15, "prefix"],
    "<atto>"  :  [["a","Atto","atto"], 1e-18, "prefix"],
    "<zepto>" :  [["z","Zepto","zepto"], 1e-21, "prefix"],
    "<yocto>" :  [["y","Yocto","yocto"], 1e-24, "prefix"],

    "<1>"     :  [["1", "<1>"], 1, ""],
    /* length units */
    "<meter>" :  [["m","meter","meters","metre","metres"], 1.0, "length", ["<meter>"] ],
    "<inch>"  :  [["in","inch","inches","\""], 0.0254, "length", ["<meter>"]],
    "<foot>"  :  [["ft","foot","feet","'"], 0.3048, "length", ["<meter>"]],
    "<yard>"  :  [["yd","yard","yards"], 0.9144, "length", ["<meter>"]],
    "<mile>"  :  [["mi","mile","miles"], 1609.344, "length", ["<meter>"]],
    "<naut-mile>" : [["nmi"], 1852, "length", ["<meter>"]],
    "<league>":  [["league","leagues"], 4828, "length", ["<meter>"]],
    "<furlong>": [["furlong","furlongs"], 201.2, "length", ["<meter>"]],
    "<rod>"   :  [["rd","rod","rods"], 5.029, "length", ["<meter>"]],
    "<mil>"   :  [["mil","mils"], 0.0000254, "length", ["<meter>"]],
    "<angstrom>"  :[["ang","angstrom","angstroms"], 1e-10, "length", ["<meter>"]],
    "<fathom>" : [["fathom","fathoms"], 1.829, "length", ["<meter>"]],
    "<pica>"  : [["pica","picas"], 0.00423333333, "length", ["<meter>"]],
    "<point>" : [["pt","point","points"], 0.000352777778, "length", ["<meter>"]],
    "<redshift>" : [["z","red-shift"], 1.302773e26, "length", ["<meter>"]],
    "<AU>"    : [["AU","astronomical-unit"], 149597900000, "length", ["<meter>"]],
    "<light-second>":[["ls","light-second"], 299792500, "length", ["<meter>"]],
    "<light-minute>":[["lmin","light-minute"], 17987550000, "length", ["<meter>"]],
    "<light-year>" : [["ly","light-year"], 9460528000000000, "length", ["<meter>"]],
    "<parsec>"  : [["pc","parsec","parsecs"], 30856780000000000, "length", ["<meter>"]],

    /* mass */
    "<kilogram>" : [["kg","kilogram","kilograms"], 1.0, "mass", ["<kilogram>"]],
    "<AMU>" : [["u","AMU","amu"], 6.0221415e26, "mass", ["<kilogram>"]],
    "<dalton>" : [["Da","Dalton","Daltons","dalton","daltons"], 6.0221415e26, "mass", ["<kilogram>"]],
    "<slug>" : [["slug","slugs"], 14.5939029, "mass", ["<kilogram>"]],
    "<short-ton>" : [["tn","ton"], 907.18474, "mass", ["<kilogram>"]],
    "<metric-ton>":[["tonne"], 1000, "mass", ["<kilogram>"]],
    "<carat>" : [["ct","carat","carats"], 0.0002, "mass", ["<kilogram>"]],
    "<pound>" : [["lbs","lb","pound","pounds","#"], 0.45359237, "mass", ["<kilogram>"]],
    "<ounce>" : [["oz","ounce","ounces"], 0.0283495231, "mass", ["<kilogram>"]],
    "<gram>"    :  [["g","gram","grams","gramme","grammes"], 1e-3, "mass", ["<kilogram>"]],
    "<grain>" : [["grain","grains","gr"], 6.479891e-5, "mass", ["<kilogram>"]],
    "<dram>"  : [["dram","drams","dr"], 0.0017718452, "mass",["<kilogram>"]],
    "<stone>" : [["stone","stones","st"],6.35029318, "mass",["<kilogram>"]],

    /* area */
    "<hectare>":[["hectare"], 10000, "area", ["<meter>","<meter>"]],
    "<acre>":[["acre","acres"], 4046.85642, "area", ["<meter>","<meter>"]],
    "<sqft>":[["sqft"], 1, "area", ["<feet>","<feet>"]],

    /* volume */
    "<liter>" : [["l","L","liter","liters","litre","litres"], 0.001, "volume", ["<meter>","<meter>","<meter>"]],
    "<gallon>":  [["gal","gallon","gallons"], 0.0037854118, "volume", ["<meter>","<meter>","<meter>"]],
    "<quart>":  [["qt","quart","quarts"], 0.00094635295, "volume", ["<meter>","<meter>","<meter>"]],
    "<pint>":  [["pt","pint","pints"], 0.000473176475, "volume", ["<meter>","<meter>","<meter>"]],
    "<cup>":  [["cu","cup","cups"], 0.000236588238, "volume", ["<meter>","<meter>","<meter>"]],
    "<fluid-ounce>":  [["floz","fluid-ounce"], 2.95735297e-5, "volume", ["<meter>","<meter>","<meter>"]],
    "<tablespoon>":  [["tbs","tablespoon","tablespoons"], 1.47867648e-5, "volume", ["<meter>","<meter>","<meter>"]],
    "<teaspoon>":  [["tsp","teaspoon","teaspoons"], 4.92892161e-6, "volume", ["<meter>","<meter>","<meter>"]],
    "<bushel>":  [["bu","bsh","bushel","bushels"], 0.035239072, "volume", ["<meter>","<meter>","<meter>"]],

    /* speed */
    "<kph>" : [["kph"], 0.277777778, "speed", ["<meter>"], ["<second>"]],
    "<mph>" : [["mph"], 0.44704, "speed", ["<meter>"], ["<second>"]],
    "<knot>" : [["kt","kn","kts","knot","knots"], 0.514444444, "speed", ["<meter>"], ["<second>"]],
    "<fps>"  : [["fps"], 0.3048, "speed", ["<meter>"], ["<second>"]],

    /* acceleration */
    "<gee>" : [["gee"], 9.80665, "acceleration", ["<meter>"], ["<second>","<second>"]],

    /* temperature_difference */
    "<kelvin>" : [["degK","kelvin"], 1.0, "temperature", ["<kelvin>"]],
    "<celsius>" : [["degC","celsius","celsius","centigrade"], 1.0, "temperature", ["<kelvin>"]],
    "<fahrenheit>" : [["degF","fahrenheit"], 5/9, "temperature", ["<kelvin>"]],
    "<rankine>" : [["degR","rankine"], 5/9, "temperature", ["<kelvin>"]],
    "<temp-K>"  : [["tempK"], 1.0, "temperature", ["<temp-K>"]],
    "<temp-C>"  : [["tempC"], 1.0, "temperature", ["<temp-K>"]],
    "<temp-F>"  : [["tempF"], 5/9, "temperature", ["<temp-K>"]],
    "<temp-R>"  : [["tempR"], 5/9, "temperature", ["<temp-K>"]],

    /* time */
    "<second>":  [["s","sec","secs","second","seconds"], 1.0, "time", ["<second>"]],
    "<minute>":  [["min","mins","minute","minutes"], 60.0, "time", ["<second>"]],
    "<hour>":  [["h","hr","hrs","hour","hours"], 3600.0, "time", ["<second>"]],
    "<day>":  [["d","day","days"], 3600*24, "time", ["<second>"]],
    "<week>":  [["wk","week","weeks"], 7*3600*24, "time", ["<second>"]],
    "<fortnight>": [["fortnight","fortnights"], 1209600, "time", ["<second>"]],
    "<year>":  [["y","yr","year","years","annum"], 31556926, "time", ["<second>"]],
    "<decade>":[["decade","decades"], 315569260, "time", ["<second>"]],
    "<century>":[["century","centuries"], 3155692600, "time", ["<second>"]],

    /* pressure */
    "<pascal>" : [["Pa","pascal","Pascal"], 1.0, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<bar>" : [["bar","bars"], 100000, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<mmHg>" : [["mmHg"], 133.322368, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<inHg>" : [["inHg"], 3386.3881472, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<torr>" : [["torr"], 133.322368, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<atm>" : [["atm","ATM","atmosphere","atmospheres"], 101325, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<psi>" : [["psi"], 6894.76, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<cmh2o>" : [["cmH2O"], 98.0638, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
    "<inh2o>" : [["inH2O"], 249.082052, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],

    /* viscosity */
    "<poise>"  : [["P","poise"], 0.1, "viscosity", ["<kilogram>"],["<meter>","<second>"] ],
    "<stokes>" : [["St","stokes"], 1e-4, "viscosity", ["<meter>","<meter>"], ["<second>"]],

    /* substance */
    "<mole>"  :  [["mol","mole"], 1.0, "substance", ["<mole>"]],

    /* concentration */
    "<molar>" : [["M","molar"], 1000, "concentration", ["<mole>"], ["<meter>","<meter>","<meter>"]],
    "<wtpercent>"  : [["wt%","wtpercent"], 10, "concentration", ["<kilogram>"], ["<meter>","<meter>","<meter>"]],

    /* activity */
    "<katal>" :  [["kat","katal","Katal"], 1.0, "activity", ["<mole>"], ["<second>"]],
    "<unit>"  :  [["U","enzUnit"], 16.667e-16, "activity", ["<mole>"], ["<second>"]],

    /* capacitance */
    "<farad>" :  [["F","farad","Farad"], 1.0, "capacitance", ["<farad>"]],

    /* charge */
    "<coulomb>" :  [["C","coulomb","Coulomb"], 1.0, "charge", ["<ampere>","<second>"]],

    /* current */
    "<ampere>"  :  [["A","Ampere","ampere","amp","amps"], 1.0, "current", ["<ampere>"]],

    /* conductance */
    "<siemens>" : [["S","Siemens","siemens"], 1.0, "conductance", ["<second>","<second>","<second>","<ampere>","<ampere>"], ["<kilogram>","<meter>","<meter>"]],

    /* inductance */
    "<henry>" :  [["H","Henry","henry"], 1.0, "inductance", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<ampere>","<ampere>"]],

    /* potential */
    "<volt>"  :  [["V","Volt","volt","volts"], 1.0, "potential", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<second>","<ampere>"]],

    /* resistance */
    "<ohm>" :  [["Ohm","ohm"], 1.0, "resistance", ["<meter>","<meter>","<kilogram>"],["<second>","<second>","<second>","<ampere>","<ampere>"]],

    /* magnetism */
    "<weber>" : [["Wb","weber","webers"], 1.0, "magnetism", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<ampere>"]],
    "<tesla>"  : [["T","tesla","teslas"], 1.0, "magnetism", ["<kilogram>"], ["<second>","<second>","<ampere>"]],
    "<gauss>" : [["G","gauss"], 1e-4, "magnetism",  ["<kilogram>"], ["<second>","<second>","<ampere>"]],
    "<maxwell>" : [["Mx","maxwell","maxwells"], 1e-8, "magnetism", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<ampere>"]],
    "<oersted>"  : [["Oe","oersted","oersteds"], 250.0/Math.PI, "magnetism", ["<ampere>"], ["<meter>"]],

    /* energy */
    "<joule>" :  [["J","joule","Joule","joules"], 1.0, "energy", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
    "<erg>"   :  [["erg","ergs"], 1e-7, "energy", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
    "<btu>"   :  [["BTU","btu","BTUs"], 1055.056, "energy", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
    "<calorie>" :  [["cal","calorie","calories"], 4.18400, "energy",["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
    "<Calorie>" :  [["Cal","Calorie","Calories"], 4184.00, "energy",["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
    "<therm-US>" : [["th","therm","therms","Therm"], 105480400, "energy",["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],

    /* force */
    "<newton>"  : [["N","Newton","newton"], 1.0, "force", ["<kilogram>","<meter>"], ["<second>","<second>"]],
    "<dyne>"  : [["dyn","dyne"], 1e-5, "force", ["<kilogram>","<meter>"], ["<second>","<second>"]],
    "<pound-force>"  : [["lbf","pound-force"], 4.448222, "force", ["<kilogram>","<meter>"], ["<second>","<second>"]],

    /* frequency */
    "<hertz>" : [["Hz","hertz","Hertz"], 1.0, "frequency", ["<1>"], ["<second>"]],

    /* angle */
    "<radian>" :[["rad","radian","radians"], 1.0, "angle", ["<radian>"]],
    "<degree>" :[["deg","degree","degrees"], Math.PI / 180.0, "angle", ["<radian>"]],
    "<gradian>"   :[["gon","grad","gradian","grads"], Math.PI / 200.0, "angle", ["<radian>"]],
    "<steradian>"  : [["sr","steradian","steradians"], 1.0, "solid_angle", ["<steradian>"]],

    /* rotation */
    "<rotation>" : [["rotation"], 2.0*Math.PI, "angle", ["<radian>"]],
    "<rpm>"   :[["rpm"], 2.0*Math.PI / 60.0, "angular_velocity", ["<radian>"], ["<second>"]],

    /* memory */
    "<byte>"  :[["B","byte"], 1.0, "memory", ["<byte>"]],
    "<bit>"  :[["b","bit"], 0.125, "memory", ["<byte>"]],

    /* currency */
    "<dollar>":[["USD","dollar"], 1.0, "currency", ["<dollar>"]],
    "<cents>" :[["cents"], 0.01, "currency", ["<dollar>"]],

    /* luminosity */
    "<candela>" : [["cd","candela"], 1.0, "luminosity", ["<candela>"]],
    "<lumen>" : [["lm","lumen"], 1.0, "luminous_power", ["<candela>","<steradian>"]],
    "<lux>" :[["lux"], 1.0, "illuminance", ["<candela>","<steradian>"], ["<meter>","<meter>"]],

    /* power */
    "<watt>"  : [["W","watt","watts"], 1.0, "power", ["<kilogram>","<meter>","<meter>"], ["<second>","<second>","<second>"]],
    "<horsepower>"  :  [["hp","horsepower"], 745.699872, "power", ["<kilogram>","<meter>","<meter>"], ["<second>","<second>","<second>"]],

    /* radiation */
    "<gray>" : [["Gy","gray","grays"], 1.0, "radiation", ["<meter>","<meter>"], ["<second>","<second>"]],
    "<roentgen>" : [["R","roentgen"], 0.009330, "radiation", ["<meter>","<meter>"], ["<second>","<second>"]],
    "<sievert>" : [["Sv","sievert","sieverts"], 1.0, "radiation", ["<meter>","<meter>"], ["<second>","<second>"]],
    "<becquerel>" : [["Bq","bequerel","bequerels"], 1.0, "radiation", ["<1>"],["<second>"]],
    "<curie>" : [["Ci","curie","curies"], 3.7e10, "radiation", ["<1>"],["<second>"]],

    /* rate */
    "<cpm>" : [["cpm"], 1.0/60.0, "rate", ["<count>"],["<second>"]],
    "<dpm>" : [["dpm"], 1.0/60.0, "rate", ["<count>"],["<second>"]],
    "<bpm>" : [["bpm"], 1.0/60.0, "rate", ["<count>"],["<second>"]],

    /* resolution / typography */
    "<dot>" : [["dot","dots"], 1, "resolution", ["<each>"]],
    "<pixel>" : [["pixel","px"], 1, "resolution", ["<each>"]],
    "<ppi>" : [["ppi"], 1, "resolution", ["<pixel>"], ["<inch>"]],
    "<dpi>" : [["dpi"], 1, "typography", ["<dot>"], ["<inch>"]],

    /* other */
    "<cell>" : [["cells","cell"], 1, "counting", ["<each>"]],
    "<each>" : [["each"], 1.0, "counting", ["<each>"]],
    "<count>" : [["count"], 1.0, "counting", ["<each>"]],
    "<base-pair>"  : [["bp"], 1.0, "counting", ["<each>"]],
    "<nucleotide>" : [["nt"], 1.0, "counting", ["<each>"]],
    "<molecule>" : [["molecule","molecules"], 1.0, "counting", ["<1>"]],
    "<dozen>" :  [["doz","dz","dozen"],12.0,"prefix_only", ["<each>"]],
    "<percent>": [["%","percent"], 0.01, "prefix_only", ["<1>"]],
    "<ppm>" :  [["ppm"],1e-6, "prefix_only", ["<1>"]],
    "<ppt>" :  [["ppt"],1e-9, "prefix_only", ["<1>"]],
    "<gross>" :  [["gr","gross"],144.0, "prefix_only", ["<dozen>","<dozen>"]],
    "<decibel>"  : [["dB","decibel","decibels"], 1.0, "logarithmic", ["<decibel>"]]
  };


  var BASE_UNITS = ["<meter>","<kilogram>","<second>","<mole>", "<farad>", "<ampere>","<radian>","<kelvin>","<temp-K>","<byte>","<dollar>","<candela>","<each>","<steradian>","<decibel>"];
  var UNITY = "<1>";
  var UNITY_ARRAY= [UNITY];
  var SIGN = "[+-]";
  var INTEGER = "\\d+";
  var SIGNED_INTEGER = SIGN + "?" + INTEGER;
  var FRACTION = "\\." + INTEGER;
  var FLOAT = "(?:" + INTEGER + "(?:" + FRACTION + ")?" + ")" +
              "|" +
              "(?:" + FRACTION + ")";
  var EXPONENT = "[Ee]" + SIGNED_INTEGER;
  var SCI_NUMBER = "(?:" + FLOAT + ")(?:" + EXPONENT + ")?";
  var SIGNED_NUMBER = SIGN + "?\\s*" + SCI_NUMBER;
  var QTY_STRING = "(" + SIGNED_NUMBER + ")?" + "\\s*([^/]*)(?:\/(.+))?";
  var QTY_STRING_REGEX = new RegExp("^" + QTY_STRING + "$");
  var POWER_OP = "\\^|\\*{2}";
  var TOP_REGEX = new RegExp ("([^ \\*]+?)(?:" + POWER_OP + ")?(-?\\d+)");
  var BOTTOM_REGEX = new RegExp("([^ \\*]+?)(?:" + POWER_OP + ")?(\\d+)");

  var SIGNATURE_VECTOR = ["length", "time", "temperature", "mass", "current", "substance", "luminosity", "currency", "memory", "angle", "capacitance"];
  var KINDS = {
    "-312058": "resistance",
    "-312038": "inductance",
    "-152040": "magnetism",
    "-152038": "magnetism",
    "-152058": "potential",
    "-39": "acceleration",
    "-38": "radiation",
    "-20": "frequency",
    "-19": "speed",
    "-18": "viscosity",
    "0": "unitless",
    "1": "length",
    "2": "area",
    "3": "volume",
    "20": "time",
    "400": "temperature",
    "7942": "power",
    "7959": "pressure",
    "7962": "energy",
    "7979": "viscosity",
    "7961": "force",
    "7997": "mass_concentration",
    "8000": "mass",
    "159999": "magnetism",
    "160000": "current",
    "160020": "charge",
    "312058": "conductance",
    "3199980": "activity",
    "3199997": "molar_concentration",
    "3200000": "substance",
    "63999998": "illuminance",
    "64000000": "luminous_power",
    "1280000000": "currency",
    "25600000000": "memory",
    "511999999980": "angular_velocity",
    "512000000000": "angle",
    "10240000000000": "capacitance"
  };

  var baseUnitCache = {};

  function Qty(initValue) {
    assertValidInitializationValueType(initValue);

    if(!(isQty(this))) {
      return new Qty(initValue);
    }

    this.scalar = null;
    this.baseScalar = null;
    this.signature = null;
    this._conversionCache = {};
    this.numerator = UNITY_ARRAY;
    this.denominator = UNITY_ARRAY;

    if (isDefinitionObject(initValue)) {
      this.scalar = initValue.scalar;
      this.numerator = (initValue.numerator && initValue.numerator.length !== 0)? initValue.numerator : UNITY_ARRAY;
      this.denominator = (initValue.denominator && initValue.denominator.length !== 0)? initValue.denominator : UNITY_ARRAY;
    }
    else {
      parse.call(this, initValue);
    }

    // math with temperatures is very limited
    if(this.denominator.join("*").indexOf("temp") >= 0) {
      throw new Error("Cannot divide with temperatures");
    }
    if(this.numerator.join("*").indexOf("temp") >= 0) {
      if(this.numerator.length > 1) {
        throw new Error("Cannot multiply by temperatures");
      }
      if(!compareArray(this.denominator, UNITY_ARRAY)) {
        throw new Error("Cannot divide with temperatures");
      }
    }

    this.initValue = initValue;
    updateBaseScalar.call(this);

    if(this.isTemperature() && this.baseScalar < 0) {
      throw new Error("Temperatures must not be less than absolute zero");
    }
  }

  /**
   * Parses a string as a quantity
   * @param {string} value - quantity as text
   * @throws if value is not a string
   * @returns {Qty|null} Parsed quantity or null if unrecognized
   */
  Qty.parse = function parse(value) {
    if(!isString(value)) {
      throw new Error("Argument should be a string");
    }

    try {
      return Qty(value);
    }
    catch(e) {
      return null;
    }
  };

  /**
   * Configures and returns a fast function to convert
   * Number values from units to others.
   * Useful to efficiently convert large array of values
   * with same units into others with iterative methods.
   * Does not take care of rounding issues.
   *
   * @param {string} srcUnits Units of values to convert
   * @param {string} dstUnits Units to convert to
   *
   * @returns {Function} Converting function accepting Number value
   *   and returning converted value
   *
   * @throws "Incompatible units" if units are incompatible
   *
   * @example
   * // Converting large array of numbers with the same units
   * // into other units
   * var converter = Qty.swiftConverter("m/h", "ft/s");
   * var convertedSerie = largeSerie.map(converter);
   *
   */
  Qty.swiftConverter = function swiftConverter(srcUnits, dstUnits) {
    var srcQty = Qty(srcUnits);
    var dstQty = Qty(dstUnits);

    if(srcQty.eq(dstQty)) {
      return identity;
    }

    var convert;
    if(!srcQty.isTemperature()) {
      convert = function(value) {
        return value * srcQty.baseScalar / dstQty.baseScalar;
      };
    }
    else {
      convert = function(value) {
        // TODO Not optimized
        return srcQty.mul(value).to(dstQty).scalar;
      };
    }

    return function converter(value) {
      var i,
          length,
          result;
      if(!Array.isArray(value)) {
        return convert(value);
      }
      else {
        length = value.length;
        result = [];
        for(i = 0; i < length; i++) {
          result.push(convert(value[i]));
        }
        return result;
      }
    };
  };

  /**
   * Default formatter
   *
   * @param {number} scalar
   * @param {string} units
   *
   * @returns {string} formatted result
   */
  function defaultFormatter(scalar, units) {
    return (scalar + " " + units).trim();
  }

  /**
   *
   * Configurable Qty default formatter
   *
   * @type {function}
   *
   * @param {number} scalar
   * @param {string} units
   *
   * @returns {string} formatted result
   */
  Qty.formatter = defaultFormatter;

  var updateBaseScalar = function () {
    if(this.baseScalar) {
      return this.baseScalar;
    }
    if(this.isBase()) {
      this.baseScalar = this.scalar;
      this.signature = unitSignature.call(this);
    }
    else {
      var base = this.toBase();
      this.baseScalar = base.scalar;
      this.signature = base.signature;
    }
  };

  /*
  calculates the unit signature id for use in comparing compatible units and simplification
  the signature is based on a simple classification of units and is based on the following publication

  Novak, G.S., Jr. "Conversion of units of measurement", IEEE Transactions on Software Engineering,
  21(8), Aug 1995, pp.651-661
  doi://10.1109/32.403789
  http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel1/32/9079/00403789.pdf?isnumber=9079&prod=JNL&arnumber=403789&arSt=651&ared=661&arAuthor=Novak%2C+G.S.%2C+Jr.
  */
  var unitSignature = function () {
    if(this.signature) {
      return this.signature;
    }
    var vector = unitSignatureVector.call(this);
    for(var i = 0; i < vector.length; i++) {
      vector[i] *= Math.pow(20, i);
    }

    return vector.reduce(function(previous, current) {return previous + current;}, 0);
  };

  // calculates the unit signature vector used by unit_signature
  var unitSignatureVector = function () {
    if(!this.isBase()) {
      return unitSignatureVector.call(this.toBase());
    }

    var vector = new Array(SIGNATURE_VECTOR.length);
    for(var i = 0; i < vector.length; i++) {
      vector[i] = 0;
    }
    var r, n;
    for(var j = 0; j < this.numerator.length; j++) {
      if((r = UNITS[this.numerator[j]])) {
        n = SIGNATURE_VECTOR.indexOf(r[2]);
        if(n >= 0) {
          vector[n] = vector[n] + 1;
        }
      }
    }

    for(var k = 0; k < this.denominator.length; k++) {
      if((r = UNITS[this.denominator[k]])) {
        n = SIGNATURE_VECTOR.indexOf(r[2]);
        if(n >= 0) {
          vector[n] = vector[n] - 1;
        }
      }
    }
    return vector;
  };

  /* parse a string into a unit object.
   * Typical formats like :
   * "5.6 kg*m/s^2"
   * "5.6 kg*m*s^-2"
   * "5.6 kilogram*meter*second^-2"
   * "2.2 kPa"
   * "37 degC"
   * "1"  -- creates a unitless constant with value 1
   * "GPa"  -- creates a unit with scalar 1 with units 'GPa'
   * 6'4"  -- recognized as 6 feet + 4 inches
   * 8 lbs 8 oz -- recognized as 8 lbs + 8 ounces
   */
  var parse = function (val) {
    if (!isString(val)) {
      val = val.toString();
    }
    val = val.trim();
    if (val.length === 0) {
      throw new Error("Unit not recognized");
    }

    var result = QTY_STRING_REGEX.exec(val);
    if(!result) {
      throw new Error(val + ": Quantity not recognized");
    }

    var scalarMatch = result[1];
    if(scalarMatch) {
      // Allow whitespaces between sign and scalar for loose parsing
      scalarMatch = scalarMatch.replace(/\s/g, "");
      this.scalar = parseFloat(scalarMatch);
    }
    else {
      this.scalar = 1;
    }
    var top = result[2];
    var bottom = result[3];

    var n, x, nx;
    // TODO DRY me
    while((result = TOP_REGEX.exec(top))) {
      n = parseFloat(result[2]);
      if(isNaN(n)) {
        // Prevents infinite loops
        throw new Error("Unit exponent is not a number");
      }
      // Disallow unrecognized unit even if exponent is 0
      if(n === 0 && !UNIT_TEST_REGEX.test(result[1])) {
        throw new Error("Unit not recognized");
      }
      x = result[1] + " ";
      nx = "";
      for(var i = 0; i < Math.abs(n) ; i++) {
        nx += x;
      }
      if(n >= 0) {
        top = top.replace(result[0], nx);
      }
      else {
        bottom = bottom ? bottom + nx : nx;
        top = top.replace(result[0], "");
      }
    }

    while((result = BOTTOM_REGEX.exec(bottom))) {
      n = parseFloat(result[2]);
      if(isNaN(n)) {
        // Prevents infinite loops
        throw new Error("Unit exponent is not a number");
      }
      // Disallow unrecognized unit even if exponent is 0
      if(n === 0 && !UNIT_TEST_REGEX.test(result[1])) {
        throw new Error("Unit not recognized");
      }
      x = result[1] + " ";
      nx = "";
      for(var j = 0; j < n ; j++) {
        nx += x;
      }

      bottom = bottom.replace(result[0], nx, "g");
    }

    if(top) {
      this.numerator = parseUnits(top.trim());
    }
    if(bottom) {
      this.denominator = parseUnits(bottom.trim());
    }

  };

  /*
   * Throws incompatible units error
   *
   * @throws "Incompatible units" error
   */
  function throwIncompatibleUnits() {
    throw new Error("Incompatible units");
  }

  Qty.prototype = {

    // Properly set up constructor
    constructor: Qty,

    // Converts the unit back to a float if it is unitless.  Otherwise raises an exception
    toFloat: function() {
      if(this.isUnitless()) {
        return this.scalar;
      }
      throw new Error("Can't convert to Float unless unitless.  Use Unit#scalar");
    },

    // returns true if no associated units
    // false, even if the units are "unitless" like 'radians, each, etc'
    isUnitless: function() {
      return compareArray(this.numerator, UNITY_ARRAY) && compareArray(this.denominator, UNITY_ARRAY);
    },

    /*
    check to see if units are compatible, but not the scalar part
    this check is done by comparing signatures for performance reasons
    if passed a string, it will create a unit object with the string and then do the comparison
    this permits a syntax like:
    unit =~ "mm"
    if you want to do a regexp on the unit string do this ...
    unit.units =~ /regexp/
    */
    isCompatible: function(other) {
      if(isString(other)) {
        return this.isCompatible(Qty(other));
      }

      if(!(isQty(other))) {
        return false;
      }

      if(other.signature !== undefined) {
        return this.signature === other.signature;
      }
      else {
        return false;
      }
    },

    /*
    check to see if units are inverse of each other, but not the scalar part
    this check is done by comparing signatures for performance reasons
    if passed a string, it will create a unit object with the string and then do the comparison
    this permits a syntax like:
    unit =~ "mm"
    if you want to do a regexp on the unit string do this ...
    unit.units =~ /regexp/
    */
    isInverse: function(other) {
      return this.inverse().isCompatible(other);
    },

    kind: function() {
      return KINDS[this.signature.toString()];
    },

    // Returns 'true' if the Unit is represented in base units
    isBase: function() {
      if(this._isBase !== undefined) {
        return this._isBase;
      }
      if(this.isDegrees() && this.numerator[0].match(/<(kelvin|temp-K)>/)) {
        this._isBase = true;
        return this._isBase;
      }

      this.numerator.concat(this.denominator).forEach(function(item) {
        if(item !== UNITY && BASE_UNITS.indexOf(item) === -1 ) {
          this._isBase = false;
        }
      }, this);
      if(this._isBase === false) {
        return this._isBase;
      }
      this._isBase = true;
      return this._isBase;
    },

    // convert to base SI units
    // results of the conversion are cached so subsequent calls to this will be fast
    toBase: function() {
      if(this.isBase()) {
        return this;
      }

      if(this.isTemperature()) {
        return toTempK(this);
      }

      var cached = baseUnitCache[this.units()];
      if(!cached) {
        cached = toBaseUnits(this.numerator,this.denominator);
        baseUnitCache[this.units()] = cached;
      }
      return cached.mul(this.scalar);
    },

    // returns the 'unit' part of the Unit object without the scalar
    units: function() {
      if(this._units !== undefined) {
        return this._units;
      }

      var numIsUnity = compareArray(this.numerator, UNITY_ARRAY),
          denIsUnity = compareArray(this.denominator, UNITY_ARRAY);
      if(numIsUnity && denIsUnity) {
        this._units = "";
        return this._units;
      }

      var numUnits = stringifyUnits(this.numerator),
          denUnits = stringifyUnits(this.denominator);
      this._units = numUnits + (denIsUnity ? "":("/" + denUnits));
      return this._units;
    },

    eq: function(other) {
      return this.compareTo(other) === 0;
    },
    lt: function(other) {
      return this.compareTo(other) === -1;
    },
    lte: function(other) {
      return this.eq(other) || this.lt(other);
    },
    gt: function(other) {
      return this.compareTo(other) === 1;
    },
    gte: function(other) {
      return this.eq(other) || this.gt(other);
    },

    /**
     * Returns the nearest multiple of quantity passed as
     * precision
     *
     * @param {(Qty|string|number)} prec-quantity - Quantity, string formated
     *   quantity or number as expected precision
     *
     * @returns {Qty} Nearest multiple of precQuantity
     *
     * @example
     * Qty('5.5 ft').toPrec('2 ft'); // returns 6 ft
     * Qty('0.8 cu').toPrec('0.25 cu'); // returns 0.75 cu
     * Qty('6.3782 m').toPrec('cm'); // returns 6.38 m
     * Qty('1.146 MPa').toPrec('0.1 bar'); // returns 1.15 MPa
     *
     */
    toPrec: function(precQuantity) {
      if(isString(precQuantity)) {
        precQuantity = Qty(precQuantity);
      }
      if(isNumber(precQuantity)) {
        precQuantity = Qty(precQuantity + " " + this.units());
      }

      if(!this.isUnitless()) {
        precQuantity = precQuantity.to(this.units());
      }
      else if(!precQuantity.isUnitless()) {
        throwIncompatibleUnits();
      }

      if(precQuantity.scalar === 0) {
        throw new Error("Divide by zero");
      }

      var precRoundedResult = mulSafe(Math.round(this.scalar/precQuantity.scalar),
                                         precQuantity.scalar);

      return Qty(precRoundedResult + this.units());
    },

    /**
     * Stringifies the quantity
     * Deprecation notice: only units parameter is supported.
     *
     * @param {(number|string|Qty)} targetUnitsOrMaxDecimalsOrPrec -
     *                              target units if string,
     *                              max number of decimals if number,
     *                              passed to #toPrec before converting if Qty
     *
     * @param {number=} maxDecimals - Maximum number of decimals of
     *                                formatted output
     *
     * @returns {string} reparseable quantity as string
     */
    toString: function(targetUnitsOrMaxDecimalsOrPrec, maxDecimals) {
      var targetUnits;
      if(isNumber(targetUnitsOrMaxDecimalsOrPrec)) {
        targetUnits = this.units();
        maxDecimals = targetUnitsOrMaxDecimalsOrPrec;
      }
      else if(isString(targetUnitsOrMaxDecimalsOrPrec)) {
        targetUnits = targetUnitsOrMaxDecimalsOrPrec;
      }
      else if(isQty(targetUnitsOrMaxDecimalsOrPrec)) {
        return this.toPrec(targetUnitsOrMaxDecimalsOrPrec).toString(maxDecimals);
      }

      var out = this.to(targetUnits);

      var outScalar = maxDecimals !== undefined ? round(out.scalar, maxDecimals) : out.scalar;
      out = (outScalar + " " + out.units()).trim();
      return out;
    },

    /**
     * Format the quantity according to optional passed target units
     * and formatter
     *
     * @param {string} [targetUnits=current units] -
     *                 optional units to convert to before formatting
     *
     * @param {function} [formatter=Qty.formatter] -
     *                   delegates formatting to formatter callback.
     *                   formatter is called back with two parameters (scalar, units)
     *                   and should return formatted result.
     *                   If unspecified, formatting is delegated to default formatter
     *                   set to Qty.formatter
     *
     * @example
     * var roundingAndLocalizingFormatter = function(scalar, units) {
     *   // localize or limit scalar to n max decimals for instance
     *   // return formatted result
     * };
     * var qty = Qty('1.1234 m');
     * qty.format(); // same units, default formatter => "1.234 m"
     * qty.format("cm"); // converted to "cm", default formatter => "123.45 cm"
     * qty.format(roundingAndLocalizingFormatter); // same units, custom formatter => "1,2 m"
     * qty.format("cm", roundingAndLocalizingFormatter); // convert to "cm", custom formatter => "123,4 cm"
     *
     * @returns {string} quantity as string
     */
    format: function(targetUnits, formatter) {
      if(arguments.length === 1) {
        if(typeof targetUnits === "function") {
          formatter = targetUnits;
          targetUnits = undefined;
        }
      }

      formatter = formatter || Qty.formatter;
      var targetQty = this.to(targetUnits);
      return formatter.call(this, targetQty.scalar, targetQty.units());
    },

    // Compare two Qty objects. Throws an exception if they are not of compatible types.
    // Comparisons are done based on the value of the quantity in base SI units.
    //
    // NOTE: We cannot compare inverses as that breaks the general compareTo contract:
    //   if a.compareTo(b) < 0 then b.compareTo(a) > 0
    //   if a.compareTo(b) == 0 then b.compareTo(a) == 0
    //
    //   Since "10S" == ".1ohm" (10 > .1) and "10ohm" == ".1S" (10 > .1)
    //     Qty("10S").inverse().compareTo("10ohm") == -1
    //     Qty("10ohm").inverse().compareTo("10S") == -1
    //
    //   If including inverses in the sort is needed, I suggest writing: Qty.sort(qtyArray,units)
    compareTo: function(other) {
      if(isString(other)) {
        return this.compareTo(Qty(other));
      }
      if(!this.isCompatible(other)) {
        throwIncompatibleUnits();
      }
      if(this.baseScalar < other.baseScalar) {
        return -1;
      }
      else if(this.baseScalar === other.baseScalar) {
        return 0;
      }
      else if(this.baseScalar > other.baseScalar) {
        return 1;
      }
    },

    // Return true if quantities and units match
    // Unit("100 cm").same(Unit("100 cm"))  # => true
    // Unit("100 cm").same(Unit("1 m"))     # => false
    same: function(other) {
      return (this.scalar === other.scalar) && (this.units() === other.units());
    },

    // Returns a Qty that is the inverse of this Qty,
    inverse: function() {
      if(this.isTemperature()) {
        throw new Error("Cannot divide with temperatures");
      }
      if(this.scalar === 0) {
        throw new Error("Divide by zero");
      }
      return Qty({"scalar": 1/this.scalar, "numerator": this.denominator, "denominator": this.numerator});
    },

    isDegrees: function() {
      // signature may not have been calculated yet
      return (this.signature === null || this.signature === 400) &&
        this.numerator.length === 1 &&
        compareArray(this.denominator, UNITY_ARRAY) &&
        (this.numerator[0].match(/<temp-[CFRK]>/) || this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/));
    },

    isTemperature: function() {
      return this.isDegrees() && this.numerator[0].match(/<temp-[CFRK]>/);
    },

    /**
     * Converts to other compatible units.
     * Instance's converted quantities are cached for faster subsequent calls.
     *
     * @param {(string|Qty)} other - Target units as string or retrieved from
     *                               other Qty instance (scalar is ignored)
     *
     * @returns {Qty} New converted Qty instance with target units
     *
     * @throws {Error} if target units are incompatible
     *
     * @example
     * var weight = Qty("25 kg");
     * weight.to("lb"); // => Qty("55.11556554621939 lbs");
     * weight.to(Qty("3 g")); // => Qty("25000 g"); // scalar of passed Qty is ignored
     */
    to: function(other) {
      var cached, target;

      if(!other) {
        return this;
      }

      if(!isString(other)) {
        return this.to(other.units());
      }

      cached = this._conversionCache[other];
      if(cached) {
        return cached;
      }

      // Instantiating target to normalize units
      target = Qty(other);
      if(target.units() === this.units()) {
        return this;
      }

      if(!this.isCompatible(target)) {
        if(this.isInverse(target)) {
          target = this.inverse().to(other);
        }
        else {
          throwIncompatibleUnits();
        }
      }
      else {
        if(target.isTemperature()) {
          target = toTemp(this,target);
        }
        else if(target.isDegrees()) {
          target = toDegrees(this,target);
        }
        else {
          var q = divSafe(this.baseScalar, target.baseScalar);
          target = Qty({"scalar": q, "numerator": target.numerator, "denominator": target.denominator});
        }
      }

      this._conversionCache[other] = target;
      return target;
    },

    // Quantity operators
    // Returns new instance with this units
    add: function(other) {
      if(isString(other)) {
        other = Qty(other);
      }

      if(!this.isCompatible(other)) {
        throwIncompatibleUnits();
      }

      if(this.isTemperature() && other.isTemperature()) {
        throw new Error("Cannot add two temperatures");
      }
      else if(this.isTemperature()) {
        return addTempDegrees(this,other);
      }
      else if(other.isTemperature()) {
        return addTempDegrees(other,this);
      }

      return Qty({"scalar": this.scalar + other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator});
    },

    sub: function(other) {
      if(isString(other)) {
        other = Qty(other);
      }

      if(!this.isCompatible(other)) {
        throwIncompatibleUnits();
      }

      if(this.isTemperature() && other.isTemperature()) {
        return subtractTemperatures(this,other);
      }
      else if(this.isTemperature()) {
        return subtractTempDegrees(this,other);
      }
      else if(other.isTemperature()) {
        throw new Error("Cannot subtract a temperature from a differential degree unit");
      }

      return Qty({"scalar": this.scalar - other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator});
    },

    mul: function(other) {
      if(isNumber(other)) {
        return Qty({"scalar": mulSafe(this.scalar, other), "numerator": this.numerator, "denominator": this.denominator});
      }
      else if(isString(other)) {
        other = Qty(other);
      }

      if((this.isTemperature()||other.isTemperature()) && !(this.isUnitless()||other.isUnitless())) {
        throw new Error("Cannot multiply by temperatures");
      }

      // Quantities should be multiplied with same units if compatible, with base units else
      var op1 = this;
      var op2 = other;

      // so as not to confuse results, multiplication and division between temperature degrees will maintain original unit info in num/den
      // multiplication and division between deg[CFRK] can never factor each other out, only themselves: "degK*degC/degC^2" == "degK/degC"
      if(op1.isCompatible(op2) && op1.signature !== 400) {
        op2 = op2.to(op1);
      }
      var numden = cleanTerms(op1.numerator.concat(op2.numerator), op1.denominator.concat(op2.denominator));

      return Qty({"scalar": mulSafe(op1.scalar, op2.scalar) , "numerator": numden[0], "denominator": numden[1]});
    },

    div: function(other) {
      if(isNumber(other)) {
        if(other === 0) {
          throw new Error("Divide by zero");
        }
        return Qty({"scalar": this.scalar / other, "numerator": this.numerator, "denominator": this.denominator});
      }
      else if(isString(other)) {
        other = Qty(other);
      }

      if(other.scalar === 0) {
        throw new Error("Divide by zero");
      }

      if(other.isTemperature()) {
        throw new Error("Cannot divide with temperatures");
      }
      else if(this.isTemperature() && !other.isUnitless()) {
        throw new Error("Cannot divide with temperatures");
      }

      // Quantities should be multiplied with same units if compatible, with base units else
      var op1 = this;
      var op2 = other;

      // so as not to confuse results, multiplication and division between temperature degrees will maintain original unit info in num/den
      // multiplication and division between deg[CFRK] can never factor each other out, only themselves: "degK*degC/degC^2" == "degK/degC"
      if(op1.isCompatible(op2) && op1.signature !== 400) {
        op2 = op2.to(op1);
      }
      var numden = cleanTerms(op1.numerator.concat(op2.denominator), op1.denominator.concat(op2.numerator));

      return Qty({"scalar": op1.scalar / op2.scalar, "numerator": numden[0], "denominator": numden[1]});
    }

  };

  function toBaseUnits (numerator,denominator) {
    var num = [];
    var den = [];
    var q = 1;
    var unit;
    for(var i = 0; i < numerator.length; i++) {
      unit = numerator[i];
      if(PREFIX_VALUES[unit]) {
        // workaround to fix
        // 0.1 * 0.1 => 0.010000000000000002
        q = mulSafe(q, PREFIX_VALUES[unit]);
      }
      else {
        if(UNIT_VALUES[unit]) {
          q *= UNIT_VALUES[unit].scalar;

          if(UNIT_VALUES[unit].numerator) {
            num.push(UNIT_VALUES[unit].numerator);
          }
          if(UNIT_VALUES[unit].denominator) {
            den.push(UNIT_VALUES[unit].denominator);
          }
        }
      }
    }
    for(var j = 0; j < denominator.length; j++) {
      unit = denominator[j];
      if(PREFIX_VALUES[unit]) {
        q /= PREFIX_VALUES[unit];
      }
      else {
        if(UNIT_VALUES[unit]) {
          q /= UNIT_VALUES[unit].scalar;

          if(UNIT_VALUES[unit].numerator) {
            den.push(UNIT_VALUES[unit].numerator);
          }
          if(UNIT_VALUES[unit].denominator) {
            num.push(UNIT_VALUES[unit].denominator);
          }
        }
      }
    }

    // Flatten
    num = num.reduce(function(a,b) {
      return a.concat(b);
    }, []);
    den = den.reduce(function(a,b) {
      return a.concat(b);
    }, []);

    return Qty({"scalar": q, "numerator": num, "denominator": den});
  }

  var parsedUnitsCache = {};
  /**
   * Parses and converts units string to normalized unit array.
   * Result is cached to speed up next calls.
   *
   * @param {string} units Units string
   * @returns {string[]} Array of normalized units
   *
   * @example
   * // Returns ["<second>", "<meter>", "<second>"]
   * parseUnits("s m s");
   *
   */
  function parseUnits(units) {
    var cached = parsedUnitsCache[units];
    if(cached) {
      return cached;
    }

    var unitMatch, normalizedUnits = [];
    // Scan
    if(!UNIT_TEST_REGEX.test(units)) {
      throw new Error("Unit not recognized");
    }

    while((unitMatch = UNIT_MATCH_REGEX.exec(units))) {
      normalizedUnits.push(unitMatch.slice(1));
    }

    normalizedUnits = normalizedUnits.map(function(item) {
      return PREFIX_MAP[item[0]] ? [PREFIX_MAP[item[0]], UNIT_MAP[item[1]]] : [UNIT_MAP[item[1]]];
    });

    // Flatten and remove null elements
    normalizedUnits = normalizedUnits.reduce(function(a,b) {
      return a.concat(b);
    }, []);
    normalizedUnits = normalizedUnits.filter(function(item) {
      return item;
    });

    parsedUnitsCache[units] = normalizedUnits;

    return normalizedUnits;
  }

  function NestedMap() {}

  NestedMap.prototype.get = function(keys) {

    // Allows to pass key1, key2, ... instead of [key1, key2, ...]
    if(arguments.length > 1) {
      // Slower with Firefox but faster with Chrome than
      // Array.prototype.slice.call(arguments)
      // See http://jsperf.com/array-apply-versus-array-prototype-slice-call
      keys = Array.apply(null, arguments);
    }

    return keys.reduce(function(map, key, index) {
      if (map) {

        var childMap = map[key];

        if (index === keys.length - 1) {
          return childMap ? childMap.data : undefined;
        }
        else {
          return childMap;
        }
      }
    },
    this);
  };

  NestedMap.prototype.set = function(keys, value) {

      if(arguments.length > 2) {
        keys = Array.prototype.slice.call(arguments, 0, -1);
        value = arguments[arguments.length - 1];
      }

      return keys.reduce(function(map, key, index) {

        var childMap = map[key];
        if (childMap === undefined) {
          childMap = map[key] = {};
        }

        if (index === keys.length - 1) {
          childMap.data = value;
          return value;
        }
        else {
          return childMap;
        }
      },
      this);
  };

  var stringifiedUnitsCache = new NestedMap();
  /**
   * Returns a string representing a normalized unit array
   *
   * @param {string[]} units Normalized unit array
   * @returns {string} String representing passed normalized unit array and
   *   suitable for output
   *
   */
  function stringifyUnits(units) {

    var stringified = stringifiedUnitsCache.get(units);
    if(stringified) {
      return stringified;
    }

    var isUnity = compareArray(units, UNITY_ARRAY);
    if(isUnity) {
      stringified = "1";
    }
    else {
      stringified = simplify(getOutputNames(units)).join("*");
    }

    // Cache result
    stringifiedUnitsCache.set(units, stringified);

    return stringified;
  }

  function getOutputNames(units) {
    var unitNames = [], token, tokenNext;
    for(var i = 0; i < units.length; i++) {
      token = units[i];
      tokenNext = units[i+1];
      if(PREFIX_VALUES[token]) {
        unitNames.push(OUTPUT_MAP[token] + OUTPUT_MAP[tokenNext]);
        i++;
      }
      else {
        unitNames.push(OUTPUT_MAP[token]);
      }
    }
    return unitNames;
  }

  function simplify (units) {
    // this turns ['s','m','s'] into ['s2','m']

    var unitCounts = units.reduce(function(acc, unit) {
      var unitCounter = acc[unit];
      if(!unitCounter) {
        acc.push(unitCounter = acc[unit] = [unit, 0]);
      }

      unitCounter[1]++;

      return acc;
    }, []);

    return unitCounts.map(function(unitCount) {
      return unitCount[0] + (unitCount[1] > 1 ? unitCount[1] : "");
    });
  }

  function compareArray(array1, array2) {
    if (array2.length !== array1.length) {
      return false;
    }
    for (var i = 0; i < array1.length; i++) {
      if (array2[i].compareArray) {
        if (!array2[i].compareArray(array1[i])) {
          return false;
        }
      }
      if (array2[i] !== array1[i]) {
        return false;
      }
    }
    return true;
  }

  function round(val, decimals) {
    return Math.round(val*Math.pow(10, decimals))/Math.pow(10, decimals);
  }

  function subtractTemperatures(lhs,rhs) {
    var lhsUnits = lhs.units();
    var rhsConverted = rhs.to(lhsUnits);
    var dstDegrees = Qty(getDegreeUnits(lhsUnits));
    return Qty({"scalar": lhs.scalar - rhsConverted.scalar, "numerator": dstDegrees.numerator, "denominator": dstDegrees.denominator});
  }

  function subtractTempDegrees(temp,deg) {
    var tempDegrees = deg.to(getDegreeUnits(temp.units()));
    return Qty({"scalar": temp.scalar - tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator});
  }

  function addTempDegrees(temp,deg) {
    var tempDegrees = deg.to(getDegreeUnits(temp.units()));
    return Qty({"scalar": temp.scalar + tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator});
  }

  function getDegreeUnits(units) {
    if(units === "tempK") {
      return "degK";
    }
    else if(units === "tempC") {
      return "degC";
    }
    else if(units === "tempF") {
      return "degF";
    }
    else if(units === "tempR") {
      return "degR";
    }
    else {
      throw new Error("Unknown type for temp conversion from: " + units);
    }
  }

  function toDegrees(src,dst) {
    var srcDegK = toDegK(src);
    var dstUnits = dst.units();
    var dstScalar;

    if(dstUnits === "degK") {
      dstScalar = srcDegK.scalar;
    }
    else if(dstUnits === "degC") {
      dstScalar = srcDegK.scalar ;
    }
    else if(dstUnits === "degF") {
      dstScalar = srcDegK.scalar * 9/5;
    }
    else if(dstUnits === "degR") {
      dstScalar = srcDegK.scalar * 9/5;
    }
    else {
      throw new Error("Unknown type for degree conversion to: " + dstUnits);
    }

    return Qty({"scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator});
  }

  function toDegK(qty) {
    var units = qty.units();
    var q;
    if(units.match(/(deg)[CFRK]/)) {
      q = qty.baseScalar;
    }
    else if(units === "tempK") {
      q = qty.scalar;
    }
    else if(units === "tempC") {
      q = qty.scalar;
    }
    else if(units === "tempF") {
      q = qty.scalar * 5/9;
    }
    else if(units === "tempR") {
      q = qty.scalar * 5/9;
    }
    else {
      throw new Error("Unknown type for temp conversion from: " + units);
    }

    return Qty({"scalar": q, "numerator": ["<kelvin>"], "denominator": UNITY_ARRAY});
  }

  function toTemp(src,dst) {
    var dstUnits = dst.units();
    var dstScalar;

    if(dstUnits === "tempK") {
      dstScalar = src.baseScalar;
    }
    else if(dstUnits === "tempC") {
      dstScalar = src.baseScalar - 273.15;
    }
    else if(dstUnits === "tempF") {
      dstScalar = (src.baseScalar * 9/5) - 459.67;
    }
    else if(dstUnits === "tempR") {
      dstScalar = src.baseScalar * 9/5;
    }
    else {
      throw new Error("Unknown type for temp conversion to: " + dstUnits);
    }

    return Qty({"scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator});
  }

  function toTempK(qty) {
    var units = qty.units();
    var q;
    if(units.match(/(deg)[CFRK]/)) {
      q = qty.baseScalar;
    }
    else if(units === "tempK") {
      q = qty.scalar;
    }
    else if(units === "tempC") {
      q = qty.scalar + 273.15;
    }
    else if(units === "tempF") {
      q = (qty.scalar + 459.67) * 5/9;
    }
    else if(units === "tempR") {
      q = qty.scalar * 5/9;
    }
    else {
      throw new Error("Unknown type for temp conversion from: " + units);
    }

    return Qty({"scalar": q, "numerator": ["<temp-K>"], "denominator": UNITY_ARRAY});
  }

  /**
   * Safely multiplies numbers while avoiding floating errors
   * like 0.1 * 0.1 => 0.010000000000000002
   *
   * @returns {number} result
   * @param {...number} number
   */
  function mulSafe() {
    var result = 1, decimals = 0;
    for(var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      decimals = decimals + getFractional(arg);
      result *= arg;
    }

    return decimals !== 0 ? round(result, decimals) : result;
  }

  /**
   * Safely divides two numbers while avoiding floating errors
   * like 0.3 / 0.05 => 5.999999999999999
   *
   * @returns {number} result
   * @param {number} num Numerator
   * @param {number} den Denominator
   */
  function divSafe(num, den) {
    if(den === 0) {
      throw new Error("Divide by zero");
    }

    var factor = Math.pow(10, getFractional(den));
    var invDen = factor/(factor*den);

    return mulSafe(num, invDen);
  }

  function getFractional(num) {
    // Check for NaNs or Infinities
    if(!isFinite(num)) {
      return 0;
    }

    // Faster than parsing strings
    // http://jsperf.com/count-decimals/2
    var count = 0;
    while(num % 1 !== 0) {
      num *= 10;
      count++;
    }
    return count;
  }

  Qty.mulSafe = mulSafe;
  Qty.divSafe = divSafe;

  function cleanTerms(num, den) {
    num = num.filter(function(val) {return val !== UNITY;});
    den = den.filter(function(val) {return val !== UNITY;});

    var combined = {};

    var k;
    for(var i = 0; i < num.length; i++) {
      if(PREFIX_VALUES[num[i]]) {
        k = [num[i], num[i+1]];
        i++;
      }
      else {
        k = num[i];
      }
      if(k && k !== UNITY) {
        if(combined[k]) {
          combined[k][0]++;
        }
        else {
          combined[k] = [1, k];
        }
      }
    }

    for(var j = 0; j < den.length; j++) {
      if(PREFIX_VALUES[den[j]]) {
        k = [den[j], den[j+1]];
        j++;
      }
      else {
        k = den[j];
      }
      if(k && k !== UNITY) {
        if(combined[k]) {
          combined[k][0]--;
        }
        else {
          combined[k] = [-1, k];
        }
      }
    }

    num = [];
    den = [];

    for(var prop in combined) {
      if(combined.hasOwnProperty(prop)) {
        var item = combined[prop];
        var n;
        if(item[0] > 0) {
          for(n = 0; n < item[0]; n++) {
            num.push(item[1]);
          }
        }
        else if(item[0] < 0) {
          for(n = 0; n < -item[0]; n++) {
            den.push(item[1]);
          }
        }
      }
    }

    if(num.length === 0) {
      num = UNITY_ARRAY;
    }
    if(den.length === 0) {
      den = UNITY_ARRAY;
    }

    // Flatten
    num = num.reduce(function(a,b) {
      return a.concat(b);
    }, []);
    den = den.reduce(function(a,b) {
      return a.concat(b);
    }, []);

    return [num, den];
  }

  /*
   * Identity function
   */
  function identity(value) {
    return value;
  }

  /**
   * Tests if a value is a string
   *
   * @param {} value - Value to test
   *
   * @returns {boolean} true if value is a string, false otherwise
   */
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }

  /**
   * Tests if a value is a number
   *
   * @param {} value - Value to test
   *
   * @returns {boolean} true if value is a number, false otherwise
   */
  function isNumber(value) {
    // Number.isFinite allows not to consider NaN or '1' as numbers
    return Number.isFinite(value);
  }

  /**
   * Tests if a value is a Qty instance
   *
   * @param {} value - Value to test
   *
   * @returns {boolean} true if value is a Qty instance, false otherwise
   */
  function isQty(value) {
    return value instanceof Qty;
  }

  /**
   * Tests if a value is a Qty definition object
   *
   * @param {} value - Value to test
   *
   * @returns {boolean} true if value is a definition object, false otherwise
   */
  function isDefinitionObject(value) {
    return value && typeof value === "object" && value.hasOwnProperty("scalar");
  }

  /**
   * Asserts initialization value type is valid
   *
   * @param {} value - Value to test
   *
   * @throws {Error} if initialization value type is not valid
   */
  function assertValidInitializationValueType(value) {
    if (!(isString(value) || isNumber(value) || isQty(value) || isDefinitionObject(value))) {
      throw new Error("Only strings, numbers or quantities " +
                         "accepted as initialization values");
    }
  }

  // Setup
  var PREFIX_VALUES = {};
  var PREFIX_MAP = {};
  var UNIT_VALUES = {};
  var UNIT_MAP = {};
  var OUTPUT_MAP = {};
  for(var unitDef in UNITS) {
    if(UNITS.hasOwnProperty(unitDef)) {
      var definition = UNITS[unitDef];
      if(definition[2] === "prefix") {
        PREFIX_VALUES[unitDef] = definition[1];
        for(var i = 0; i < definition[0].length; i++) {
          PREFIX_MAP[definition[0][i]] = unitDef;
        }
      }
      else {
        UNIT_VALUES[unitDef] = {
          scalar: definition[1],
          numerator: definition[3],
          denominator: definition[4]
        };
        for(var j = 0; j < definition[0].length; j++) {
          UNIT_MAP[definition[0][j]] = unitDef;
        }
      }
      OUTPUT_MAP[unitDef] = definition[0][0];
    }
  }
  var PREFIX_REGEX = Object.keys(PREFIX_MAP).sort(function(a, b) {
    return b.length - a.length;
  }).join("|");
  var UNIT_REGEX = Object.keys(UNIT_MAP).sort(function(a, b) {
    return b.length - a.length;
  }).join("|");
  var UNIT_MATCH = "(" + PREFIX_REGEX + ")??(" + UNIT_REGEX + ")\\b";
  var UNIT_MATCH_REGEX = new RegExp(UNIT_MATCH, "g"); // g flag for multiple occurences
  var UNIT_TEST_REGEX = new RegExp("^\\s*(" + UNIT_MATCH + "\\s*\\*?\\s*)+$");

  return Qty;
}));



MoonshadowHelpers = {};
MoonshadowHelpers.generateMD5Id = function(seeds){
	return $.md5(seeds);
};

MoonshadowHelpers.updateProgress = function(progress, status) {
	$( "#overlays .loading .progressbar").progressbar({'value': progress});
	$( "#overlays .loading .status").text(status);
};

MoonshadowHelpers.displayError = function(message) {
	$('#overlays .loading').hide();
	$('#overlays .error span').text(message);
	$('#overlays .error').show();
	$('#overlays').show();
};

MoonshadowHelpers.ErrorHandler = function() {
	this.handler = function errorHandler(error, url, line) {
		var es = (typeof error === 'string') ? error : error.message || 'Unknown error';
		// Specifically for errors that are things like browser bugs or 
		// otherwise that can occur in many different places and we want to create 
		// a more useful error message for.
		errorString = MoonshadowHelpers.getAugmentedErrorMessage(es);
		var version = (Moonshadow && Moonshadow.version) ? Moonshadow.version : 'Unknown';

		MoonshadowHelpers.displayError(errorString);
		
		var manager = Moonshadow.getManager();
		if(manager && !manager.getOption("disableErrorReporting")) {
			var obj = {
				"cVersion": version,
				"qsVersion": manager.getOption("query_version"),
				"error": errorString,
				"url": url,
				"line": line,
				"location": window.location.href,
				"server": manager.getOption('server'),
				"app": manager.getOption('app'),
				"customer": manager.getOption('customer'),
				"username": manager.getOption("user")
			};

			if(Moonshadow.server) {
				$.ajax({ 
					url: "/client/error",
					cache: false,
					type: "POST",
					contentType: 'application/json',
					data: JSON.stringify(obj),
					dataType: "json",
					success: function(data) { }
				});
			}
		}

		return false; // Dont stop the error from purculating further
	}
};
MoonshadowHelpers.getAugmentedErrorMessage = function (errorString) {
	var es = errorString;
	// #1821 For Firefox browser features disabled by the user (alerts, localStorage, etc)
	if(errorString.indexOf("NS_ERROR_NOT_AVAILABLE") > -1) {
		es = "You have disabled browser features this application requires to"
		+ " function. Please check that dialog popups are not disabled.";
	}
	return es;
};
MoonshadowHelpers.ErrorHandler.prototype.getHandler = function() {
	return this.handler;
};

MoonshadowHelpers.selectRange = function(element){
	var element = $(element).get(0);
	if (document.body.createTextRange) {
		var range = document.body.createTextRange();
		range.moveToElementText(element);
		range.select();
	} else if (window.getSelection) {
		var selection = window.getSelection();
		if(document.createRange){
			var range = document.createRange();
			range.selectNodeContents(element);
			selection.removeAllRanges();
			selection.addRange(range);
		}else if(selection.setBaseAndExtent){
			selection.setBaseAndExtent(element, 0, element, 1);
		}
	}
};

/**
*
* @class LogHandler
*/
MoonshadowHelpers.LogHandler = function(error, url, location) {
	if(!error)
		return false;
	
	var messageString = error.message || error || 'Unknown error';
	var version = (Moonshadow && Moonshadow.version) ? Moonshadow.version : 'Unknown';
	var manager = Moonshadow.getManager();
	if(manager) {
		var obj = {
			"cVersion": version,
			"qsVersion": manager.getOption("query_version"),
			"error": "LogHandler: " + messageString,
			"url": url,
			"line": location,
			"location": window.location.href,
			"server": manager.getOption('server'),
			"app": manager.getOption('app'),
			"customer": manager.getOption('customer'),
			"username": manager.getOption("user")
		};

		if(Moonshadow.server) {
			$.ajax({ 
				url: "/client/error",
				cache: false,
				type: "POST",
				contentType: 'application/json',
				data: JSON.stringify(obj),
				dataType: "json",
				success: function(data) { }
			});
		}
	}
};

/**
 * Google analytics helper
 * @class GA
 */

MoonshadowHelpers.GA = (function(id) {
   	 /**
	  *
	  * @method gaSnippit
	  * @param {} id
	  */
	 var gaSnippit = function(id) {
		/* Snippit from google */
		/* https://code.google.com/apis/analytics/docs/tracking/asyncTracking.html */
 		window._gaq = window._gaq || [];
 		window._gaq.push(['_setAccount', id]);
 		window._gaq.push(['_trackPageview']);


		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
		/* End snipped from google */
	};

	// Event specific function calls
	var eventMap = {};

	/**
	 *
	 * @method getPageviewArray
	 * @param {} event
	 * @param {} data
	 */
	var getPageviewArray = function(event, data) {
		var page = '';
		
		if(eventMap[event]) {
			page = eventMap(event, data);
		} else {
			page = '/' + event + ((data !== undefined) ? '/' + data : '');
		}

		return ['_trackPageview', page];
	}; 
	/**
	 *
	 * @method notify
	 * @param {} event
	 * @param {} data
	 */
	var notify = function(event, data) {
		// https://www.google.com/support/googleanalytics/bin/answer.py?answer=174090
		window._gaq.push(getPageviewArray(event, data));
	};

	/**
	 *
	 * @method MoonshadowGA
	 * @param {} manager
	 * @param {} id
	 */
	var MoonshadowGA = function(manager, id) {
		this.manager = manager;
		this.id = id;

		gaSnippit.call(this, id);

		manager.mapObservers.addObserver("zoom", this);
	};
	MoonshadowGA.prototype = {
		notify: notify
	};

	return MoonshadowGA;
}());

/**
 * Create color hex for string use keeps client default colors matching
 * @method rw5
 * @param {String} name Name of item to color
 */
MoonshadowHelpers.rw5 = function royColor(name) {
	var never_overflow=0xFFFFFFF;
	var h = 0x7777777; // make empty strings grey
	var nameLength=name.length;
	if(nameLength != 0) {
		for (var j = 0; j < nameLength; j++) {
			h += name.charCodeAt(j);
			h &= never_overflow;
			h += ((h&0x3FFFF) << 10 );
			h &= never_overflow;
			h ^= (h >> 6);
		}
		h += ((h & 0x1FFFFFF) << 3 );
		h &= never_overflow;
		h ^= (h >> 11);
		h += ((h & 0x1FFF) << 15 );
		h &= never_overflow;
	}
	
	h &= 0xffffff;
	
	var hex = h.toString(16);
	
	for(var n = hex.length;n < 6;n++) {
		hex = "0"+hex;			
	}
	
	return hex;
};

/*
	mercator(ilat=834342221,ilon=345799997)=geo(lat=37.20362691,lon=-122.0307582)
	mercator(ilat=834346209,ilon=345807485)=geo(lat=37.20309442,lon=-122.0295029)
	mercator(ilat=834346473,ilon=345775385)=geo(lat=37.20305917,lon=-122.0348841)
	mercator(ilat=834351095,ilon=345788507)=geo(lat=37.20244203,lon=-122.0326843)
	mercator(ilat=834351781,ilon=345801661)=geo(lat=37.20235043,lon=-122.0304792)
	mercator(ilat=834354065,ilon=345779861)=geo(lat=37.20204546,lon=-122.0341337)
	mercator(ilat=834354779,ilon=345802297)=geo(lat=37.20195012,lon=-122.0303726)
	mercator(ilat=834358037,ilon=345799475)=geo(lat=37.2015151,lon=-122.0308457)
	mercator(ilat=834361893,ilon=345799567)=geo(lat=37.20100022,lon=-122.0308303)
	mercator(ilat=834364065,ilon=345773535)=geo(lat=37.2007102,lon=-122.0351942)
	mercator(ilat=834366085,ilon=345810409)=geo(lat=37.20044047,lon=-122.0290127)
*/

/**
*
* @class demercateLat
* @param {} iLat
*/
MoonshadowHelpers.demercateLat = function demercateLat(iLat) {
	var sinh = function(x){
		return (Math.exp(x) - Math.exp(x * -1)) / 2
	};
	var magicNumber = 1 / parseInt(0x80000000, 10);
	var lat = (Math.atan(sinh((1 - (((magicNumber) * 2) * iLat))* Math.PI)) * 180) / Math.PI;
	return parseFloat(lat.toFixed(8));
};

/**
*
* @class demercateLon
* @param {} iLon
*/
MoonshadowHelpers.demercateLon = function demercateLon(iLon) {
	var magicNumber = 1 / parseInt(0x80000000, 10);
	var lon = (magicNumber * iLon - .5) * 360;
	return parseFloat(lon.toFixed(8));
};
/**
 *
 * @class demercator
 * @param {} iLat
 * @param {} iLon
 */
MoonshadowHelpers.demercator = function demercator(iLat, iLon) {
	var lat = MoonshadowHelpers.demercateLat(iLat);
	var lon = MoonshadowHelpers.demercateLon(iLon);
	return [lat, lon];
};

/**
 *
 * @class mercator
 * @param {} lat
 * @param {} lon
 */
MoonshadowHelpers.mercator = function mercator(lat, lon) {
	var magicNumber = parseInt(0x7FFFFFFE, 10);
	var rlatsin = Math.sin(Math.PI * lat / 180); 
	var iLon = (((1 * (magicNumber * (lon + 180 ))) / 360) + .5);
	var iLat = (((.5 - ((Math.log((1 + rlatsin)/(1 - rlatsin)) / 4) /Math.PI)) * magicNumber) + .5);
	
	iLon &= magicNumber;
	iLat &= magicNumber;

	// This is to avoid an edge case with polygon intersection calculations
	// Points have a high bit of 1, 0 for polygons. See Roy for details
	iLon |= 1; 
	iLat |= 1;
	
	return [iLat, iLon];
};

/**
 *
 * @class sanitizeString
 * @param {} inString
 */
MoonshadowHelpers.sanitizeString = function(inString) {
	if(!inString){
		return inString;
	}
	var nastyCharCodes = [{
			"code": 8217,
			"repl": "'"
		},{
			"code": 8216,
			"repl": "'"
		},{
			"code": 8219,
			"repl": "'"
		},{
			"code": 8220,
			"repl": '"'
		},{
			"code": 8221,
			"repl": '"'
		},{
			"code": 8222,
			"repl": '"'
		},{
			"code": 8223,
			"repl": '"'
	}];
	
	//replace bad quotes
	for(var i = 0, l = nastyCharCodes.length; i < l; ++i){
		inString = inString.replace(
			String.fromCharCode(nastyCharCodes[i].code),
			nastyCharCodes[i].repl
		);
	}
	
	// smart single quotes and apostrophe
	inString = inString.replace(/[\u2018\u2019\u201A]/g, "\'");
	// smart double quotes
	inString = inString.replace(/[\u201C\u201D\u201E]/g, "\"");
	// ellipsis
	inString = inString.replace(/\u2026/g, "...");
	// dashes
	inString = inString.replace(/[\u2013\u2014]/g, "-");
	
	//strip HTML
	var returnString = inString.replace(/(<([^>]+)>)/ig,"");
	
	return returnString;
};

/*
 *
 * http://www.mredkj.com/javascript/numberFormat.html
 * @class numberCommas
 */
MoonshadowHelpers.numberCommas = function numberCommas() {
	if(!arguments[0] ){
		return "0";
	}else{
		nStr = arguments[0];
	}
	nStr += '';
	x = nStr.split('.');
	x1 = x[0];
	x2 = x.length > 1 ? '.' + x[1] : '';
	var rgx = /(\d+)(\d{3})/;
	while (rgx.test(x1)) {
		x1 = x1.replace(rgx, '$1' + ',' + '$2');
	}
	return x1 + x2;
};

/**
 *
 * @class crumbsToObjPath
 * @param {} arr
 */
MoonshadowHelpers.crumbsToObjPath = function crumbsToObjPath(arr) {
	var arr = arr.slice();
	var obj = {};
	var position = obj;
	var crumb;
	while(crumb = arr.shift()) {
		position.values = {};
		position.values[crumb] = {};
		position = position.values[crumb];
	}

	return obj;
};

/**
 *
 * @method findBranch
 * @param {} tree
 * @param {} path
 */
MoonshadowHelpers.findBranch = function findBranch(tree, path) {
	var path = path.slice();
	var crumb = path.shift();
	var branch = tree[crumb] || null;

	if(branch) {
		if(path.length) {
			return this.findBranch(branch.values, path);
		} else {
			return $.extend({}, branch.values);
		}
	}

	return {};
};

/**
 * Shortcut for creating elements
 * @method ce
 * @param {String} type of element to return
 */
MoonshadowHelpers.ce = function(type) {
	return document.createElement(type);
}

/**
 * Shortcut for creating textNodes
 * @method tn
 * @param {String} text for node
 */
MoonshadowHelpers.tn = function(text) {
	return document.createTextNode(text);
}

/*
 *
 * http://engineeredweb.com/blog/09/12/preloading-images-jquery-and-javascript
 * @method preload
 */
MoonshadowHelpers.preload = (function() {
	var cache = [],
	preload = function() {
		var l = arguments.length;
		for (var i = l; i--;) {
			var image = document.createElement('img');
			image.src = arguments[i];
			cache.push(image);
		}
	};

	return preload;
})();

/**
 *
 * @method capitalize
 */
MoonshadowHelpers.capitalize = (function() {
	function convert() {
		return arguments[0].toUpperCase();
	}

	return function(s) {
		return s.replace(/\b[a-z]/g, convert);
	}	
})();

/**
 * Convert a date in to a rDate
 * @method rDate
 * @param {Date/String} name Name of item to color
 */
MoonshadowHelpers.rDate = function() {
	if(!arguments[0])
		throw new Error("Missing date string/object");

	var date = (typeof arguments[0] != "object" || typeof arguments[0].getFullYear != "function") ? new Date(arguments[0].toString()) : arguments[0];

	//return date.getDate()+(((date.getMonth()+(((date.getFullYear())-1875)*12))*32)); // Provided by roy
	return ((date.getFullYear()-1875)*12+date.getMonth())*32+date.getDate(); // OoO cleaned up
};

/**
 * Get a date from an rDate
 * @method rDateDecode
 * @param {rDate} rDate
 */
MoonshadowHelpers.rDateDecode = function(n) {
	if(!n)
		throw new Error("Must provide rDate encoded date number");

	var f = function(b) { // Changes 'n' and returns 'n' mod 'b'
		r = n % b; // Get the mod of divisor/break
		n = (n - r) / b; // Subtract mod and divide by divisor/break
		return r; // Return mod
	};	

	var d = f(32);
	var m = f(12);
	var y = n + 1875; // Arbitary offset

	return new Date(y,m,d); // This could use some localization later
};

MoonshadowHelpers.parseIsoTS = function(isoDateString){
	if(!isoDateString){
		return false;
	}
	
	//"2013-05-13T20:05:25.799Z"
	var isoDate = new Date(isoDateString);
	
	if(isNaN(isoDate)){
		//accommodating IE
		var datePart = isoDateString.split("T")[0];
		var datePartArray = datePart.split("-");
		var timePart = isoDateString.split("T")[1].replace("Z","");
		var timePartArray = timePart.split(":");
		isoDate = new Date(
			datePartArray[0], 
			(datePartArray[1] - 1), 
			datePartArray[2],
			timePartArray[0],
			timePartArray[1],
			timePartArray[2]
		);
	}
	return isoDate;
};


/**
 * Helper for extending objects
 * @method extend
 * @param {Object} child Item to recieve parent prototype
 * @param {Object} parent
 */
MoonshadowHelpers.extend = function(child, supertype) {
	$.extend(child.prototype, supertype.prototype);
}

/**
 *
 * @method login
 */
MoonshadowHelpers.login = (function(){
	var Const,
	loginItem = {
		"ui" : function(settings){
			
			this.settings = settings;
			
			var showAppList = true;
			var buttonTitle = "Get Application list";
			var isReauth = false;
			
			if(settings.isReauth != undefined){
				isReauth = settings.isReauth;
				if(isReauth){
					showAppList = false;
					if(!showAppList){
						buttonTitle = "Login";
					}
				}
			}
			if(settings.showAppList != undefined){
				showAppList = settings.showAppList;
				if(!showAppList){
					buttonTitle = "Login";
				}
			}
			if(settings.buttonTitle != undefined){
				buttonTitle = settings.buttonTitle;
			}
			
			var ce = MoonshadowHelpers.ce;
			
			var container = $(ce("div"))
				.addClass("login_form_container")
				.append(
					this.noticeBox(),
					$(ce("div"))
						.addClass("login_box")
						.append(
							this.workingInd(),
							isReauth ? this.placeholder(Moonshadow.user) : this.un(),
							this.ps(),
							showAppList ? this.appList() : "",
							this.button(buttonTitle),
							showAppList ? "" : this.cancelButton(),
							$(ce("div"))
								.addClass("clear")
						)
				);

			return container;
		},
		"placeholder": function(text){
			var ce = MoonshadowHelpers.ce;
			return  $(ce("div"))
				.addClass("ms_text_field_container")
				.append(
					$(ce("span"))
						.addClass("ms_text_field_small_label")
						.append("Username"),
					$(ce("div"))
						.addClass("ms_text_field_flex_container_outer")
						.append(
							$(ce("div"))
								.addClass("login_placeholder")
								.append(text)
						)
				);
		},
		"un": function(){
			var ce = MoonshadowHelpers.ce;
			var self = this;
			
			this.login_input = $(ce("input"))
				.addClass("ms_text_field_input")
				.attr({
					"type": "password",
					"autocomplete": false
				})
				.on("keyup", function(e){
					self.inputAction(e);
				});
			
			return $(ce("div"))
				.addClass("ms_text_field_container")
				.append(
					$(ce("span"))
						.addClass("ms_text_field_small_label")
						.append("Username"),
					$(ce("div"))
						.addClass("ms_text_field_flex_container_outer")
						.append(
							$(ce("div"))
								.addClass("ms_text_field_flex_container_inner")
								.append(
									this.login_input
								)
						)
				);
		},
		"ps": function(){
			var ce = MoonshadowHelpers.ce;
			var self = this;

			this.pass_input = $(ce("input"))
				.addClass("ms_text_field_input")
				.attr({
					"type": "password",
					"autocomplete": false
				})
				.capslock({
					"caps_lock_on": this.capsLockWarning
				})
				.on("keyup", function(e){
					self.inputAction(e);
				});
			
			return $(ce("div"))
				.addClass("ms_text_field_container")
				.append(
					$(ce("span"))
						.addClass("ms_text_field_small_label")
						.append("Password"),
					$(ce("div"))
						.addClass("ms_text_field_flex_container_outer")
						.append(
							$(ce("div"))
								.addClass("ms_text_field_flex_container_inner")
								.append(
									this.pass_input
								)
						)
				);
		},
		"appList": function(){
			var ce = MoonshadowHelpers.ce;
			var self = this;
			this.application_input = $(ce("select"))
				.addClass("login_select")
				.attr({
					"disabled": true
				})
				.on("keyup", function(e){
					if(e.which === 13 && this.value.length > 0) {
						self.doLogin();
					} else if(e.which >= 37 && e.which <= 40) {
						self.enableLogin(!!this.value);
					}
				})
				.on("change", function() {
					self.enableLogin(!!this.value);
				})

			return $(ce("div"))
				.addClass("list_login_box")
				.append(
					$(ce("label"))
						.addClass("login_label")
						.append("Application"),
					this.application_input
				);
		},
		"button": function(title){
			var ce = MoonshadowHelpers.ce;
			var self = this;
			this.login_button = $(ce("input"))
				.addClass("login_button")
				.attr({
					"type": "button",
					"value": title,
					"disabled": true
				})
				.on("click", function(){
					self.doLogin();
				})
				.bind("validate",function(e) {
					this.disabled = !self.canLogin();
				});
			return this.login_button;
		},
		"cancelButton": function(){
			var ce = MoonshadowHelpers.ce;
			var self = this;
			this.cancel_button = $(ce("input"))
				.addClass("cancel_button")
				.attr({
					"type": "button",
					"value": "Cancel"
				})
				.on("click", function(){
					if(self.settings.callback){
						self.settings.callback(
							Moonshadow.sessionActive
						);
					}
				});
			return this.cancel_button;
		},
		"buttonTitle": function(title){
			$(this.login_button)
				.attr({
					"value": title
				});
		},
		"enableLogin": function(onOff){
			$(this.login_button)
				.attr({
					"disabled": !onOff
				});
		},
		"enableInputs": function(onOff){
			$(this.login_input).attr({"disabled": !onOff});
			$(this.pass_input).attr({"disabled": !onOff});   
		},
		"workingInd": function(){
			var ce = MoonshadowHelpers.ce;
			this.working = $(ce("div"))
				.addClass("activeindicator hide");
			return this.working;
		},
		"noticeBox": function(){
			var ce = MoonshadowHelpers.ce;
			this.notice = $(ce("div"))
				.addClass("notice");
			return this.notice;
		},
		"capsLockWarning": function(event){
			var clwarning = $(event.target).parent().find(".clwarning");
			$(clwarning).fadeIn("fast");
			setTimeout(function(){$(clwarning).fadeOut("slow")},2000);
		},
		"canLogin": function(hiliteEmpty){
			var canlogin = true;
			$.each($([this.login_input, this.pass_input]),function(k,v) {
				if(v && !$(v).val()) {
					canlogin = false;
					if(hiliteEmpty){
						$(v).focus();
					}
					return false;
				}
			});
			return canlogin;
		},
		"inputAction": function(e){
			if(e.which === 13) {
				return this.canLogin(true) && this.doLogin();
			}
			this.resetNotice();
			$(this.login_button).trigger("validate");
		},
		"authed": function(res){
			if(res.url){
				window.location = res.url;
			} else {
				window.location = "/";
			}
		},
		"reauthed": function(res){
			var self = this;
			if(res.agreement && !this.agreed){
				return userAgreement(
					res.agreement, 
					null, 
					function(){
						self.doLogin(true);
					}
				);
			}
			if(res.token){
				Moonshadow.getManager().setOption("key", res.token);
				Moonshadow.key = res.token;
				Moonshadow.sessionActive = true;
				Moonshadow.Ajax.processReservedRequests();
			}
			if(res.version && res.version != Moonshadow.version){
				MUILayoverPanel.alert({
					"message": "The application has been updated. Please refresh your browser.",
					"modal": false
				});
			}
			if(this.settings.callback){
				this.settings.callback(
					Moonshadow.sessionActive
				);
			}
		},
		"chooseApp": function(res){
			var app = $(this.application_input).get(0);  
			app.options.length = 0; 

			if(res.apps.length !== 0) { 
				app.options[app.options.length] = new Option("Select an app","",1); 
				$.each(res.apps,function(k,v) {
					app.options[app.options.length] = new Option(v.name,v.value); 
				});
				app.disabled = false; 
				$(app).focus();

				this.buttonTitle("Login");
			} else {
				this.showNotice("No applications found"); 
				this.enableInputs(true);
				this.buttonTitle("Get app list");	
			}
		},
		"doLogin": function(agreed){
			this.enableLogin(false);
			this.enableInputs(false);
			
			var self = this;
			var manager = Moonshadow.getManager();
			var applist = $(this.application_input);
			var username = $(this.login_input).val();
			if(this.settings.isReauth){
				username = Moonshadow.user;
			}
			var password = $(this.pass_input).val();
			var url = "/user/auth";
			var complete = this.authed;
			
			var data = { 
				"_method": "post",
				"user": username,
				"pass": password,
				"agreed": agreed
			};
			
			if(this.settings.isReauth){
				url = "/user/reauth";
				complete = this.reauthed;
				data.app = manager.getOption("customer") + "|" + manager.getOption("app");
			}
			
			if(applist && !!$(applist).val()) {
				data.app = $(this.application_input).val();
			}
			
			if(!data.app){
				url = "/user/apps";
				complete = this.chooseApp;
			}
			
			var fail = function(xhr,text,error) {
				if(xhr.status == 401){
					error = "Invalid credintials."
				}
				self.enableLogin(true);
				self.enableInputs(true);
				self.showNotice(error);
				self.onComplete();
			};
			
			var done = function(res){
				self.enableLogin(true);
				if(res.result !== "ok") {
					self.enableInputs(true);
					return self.showNotice(res.error);
				}
				self.resetNotice();
				complete.call(self, res);
			}

			var ajaxObj = new Moonshadow.Ajax({
				"payload": data,
				"url": url,
				"type": "POST",
				"onFail": fail,
				"onSuccess": done,
				"bypassErrorControl": true
			});
			
			this.beforeSend();
			ajaxObj.execute(function(){
				self.onComplete();
			});
		},
		/**
		 *
		 * @method showNotice
	 	 */
		"showNotice" : function(message) {
			$(this.notice)
				.empty()
				.append(message)
				.show();			
		},
		/** 
		 *
		 * @method resetNotice
		 */
		"resetNotice" : function() {
			$(this.notice)
				.empty();
		},
		/**
		 *
		 * @method beforeSend
		 */
		"beforeSend" : function() {
			$(this.working)
				.removeClass("hide");
		},
		/**
		 *
		 * @method onComplete
		 */
		"onComplete" : function() {
			$(this.working)
				.addClass("hide");
		}
	},
	/**
	 *
	 * @method changeApp
	 * @param {} customer
	 * @param {} app
	 * @param {} caller
	 * @param {} onBeforeSEnd
	 * @param {} onFail
	 * @param {} onComplete
	 *
	 */
	changeApp = function(customer, app, caller, onBeforeSend, onFail, onComplete, agreed) {
		var self = this;
		if(!customer || !app || this.inProgress) {
			return;
		}
		
		var ajaxObj = new Moonshadow.Ajax({
			"payload": {
				"customer": customer,
				"app": app,
				"agreed": agreed
			},
			"url": "/user/app",
			"type": "PUT",
			"onFail": onFail,
			"contentType": "application/x-www-form-urlencoded",
			"stringify": false,
			"onSuccess": function(data) {
				if (data.result === "ok") {
					if(data.agreement){
						return userAgreement(
							data.agreement, null, 
							function(){
								self.changeApp(customer, app, caller, onBeforeSend, onFail, onComplete, true);
							}
						);
					}else if (data.url) {
						if(data.anonymous){
							window.location = "http://" + data.url;
							return;
						}
						window.history.replaceState(null, null, data.url);
					} 
					window.location.reload();
					
				} else if(onFail && typeof onFail == "function") {
						onFail(data);
				}
			}
		});
		
		onBeforeSend && onBeforeSend();
		ajaxObj.execute(function(){
			onComplete && onComplete();
		});
	},
	/**
	 *
	 * @method logout
	 */
	logout = function() {
		window.location = "/user/unauth";
	},
	/**
	 *
	 * @method toLogInPage
	 */
	toLogInPage = function(url){
		var manager = Moonshadow.getManager();
		return url || manager.getOption("app_urls.default", false);
	},
	/**
	 *
	 * @method loginButton
	 */
	loginButton = function(settings){
		if(!settings){
			settings = {};
		}
		
		var manager = Moonshadow.getManager();
		var url = settings.url || manager.getOption("app_urls.default", false);
		if(!url){
			return;
		}
		
		var ce = MoonshadowHelpers.ce;
		return $(ce("input"))
			.addClass(settings.className || "login_button")
			.attr({
				"type": "button",
				"value":  settings.text || "Login"
			})
			.on("click", function(){
				window.location = url;
			});
	},
	/*
	 * 
	 * @method resetForm
	 */
	resetForm = function(){
		this.form = loginItem.ui(this.loginItem.settings || {});
	};
	
	focusInput = function(settings, ui){
		setTimeout(function(){
			if(settings.isReauth){
				return $(loginItem.pass_input).focus();
			}
			$(loginItem.login_input).focus();
		}, 100);
	};
	
	Constr = {
		"form": function(){
			var ui = loginItem.ui({});
			focusInput({}, ui);
			return ui;
		},
		"formWithOptions": function(settings){
			var ui = loginItem.ui(settings);
			focusInput(settings, ui);
			return ui;
		},
		"resetForm": resetForm,
		"changeApp": changeApp,
		"logout": logout,
		"toLogInPage": toLogInPage,
		"loginButton": loginButton,
		"loginItem": loginItem
	};
	return Constr;
}());
/**
 *
 * @method sort
 * @param {} a
 */
MoonshadowHelpers.sort = function(a) {
	return a.sort(function(a,b) {
		if(typeof a == "object")
			a = a.ext_name || a.int_name;

		if(typeof b == "object")
			b = b.ext_name || b.int_name;	

		return MoonshadowHelpers.naturalSortFunc(a,b);
	});
};

/**
 *
 * @method objCount
 * @param {} a
 */
MoonshadowHelpers.objCount = function(a) {
	if (typeof a == "object"){
		if (Object.keys){
			return Object.keys(a).length;
		}else{
			var count = 0;
			for (k in a) {
				if (a.hasOwnProperty(k)) count++;
			}
			return count;
		}
	}
};

/**
 *
 * @method hrDate
 * @param dateString
 * 
 * "2/17/2015 10:29 AM"
 */
MoonshadowHelpers.hrDate = function(dateIn, excludeHour){
	var dateObj;
	
	if(typeof dateIn == "string"){
		var epochObj = Date.parse(dateIn);
		if(!epochObj || isNaN(epochObj))
			return false;
		dateObj = new Date(parseFloat(epochObj));
	}
	
	if(typeof dateIn == "number"){
		dateObj = new Date(parseFloat(dateIn));
	}
	
	if(dateIn instanceof Date){
		dateObj = dateIn;
	}

	var date = dateObj.getDate();
	var hour = dateObj.getHours();
	var ampm = " AM";
	if(hour > 12){
		hour = (hour - 12);
		ampm = " PM";
	}
	var mins = dateObj.getMinutes();
	if(mins < 10)
		mins = "0" + mins;
	
	var returnDate = (dateObj.getMonth() + 1) + "/" +
		date + "/" +
		dateObj.getFullYear();
		
	if(!excludeHour){
		returnDate += " " +
			hour + ":" +
			mins +
			ampm;
	}
	
	return returnDate;
};

/**
 *
 * @method dateFromUTC
 * @param {} utc
 */
MoonshadowHelpers.dateFromUTC = function(utc){
	return MoonshadowHelpers.mmddyyFromDateObject(new Date(utc * 1000));
}


MoonshadowHelpers.mmddyyFromString = function(dateString){
	return MoonshadowHelpers.mmddyyFromDateObject(new Date(dateString));
}
MoonshadowHelpers.mmddyyFromDateObject = function(dateObject){
	var _date = dateObject.getDate();
	var _month = dateObject.getMonth() + 1;
	var _year = dateObject.getFullYear().toString().slice(2);
	return _month + "/" + _date + "/" + _year;
}
MoonshadowHelpers.timeSinceMidnight = function(utc){
	var _fullDate = new Date(utc * 1000)
	var _extraZero = (_fullDate.getMinutes() < 10) ? '0' : '';
	return _fullDate.getHours() + ":" + _extraZero + _fullDate.getMinutes();
}
MoonshadowHelpers.timeSinceMidnightStandard = function(utc){
	var _fullDate = new Date(utc * 1000)
	var _extraZero = (_fullDate.getMinutes() < 10) ? '0' : '';
	var _hours = _fullDate.getHours();
	var _ampm = "AM";
	if(_hours > 12){
		_hours = _hours - 12;
		_ampm = "PM";
	}
	return _hours + ":" + _extraZero + _fullDate.getMinutes() + " " + _ampm;
}


/**
 *
 * @method getUTCDateISOString
 * @param {} UTCdate
 * 
 * "2015-02-18 02:40:19.000Z"
 */
MoonshadowHelpers.getUTCDateISOString = function(UTCdate){
	if(!UTCdate){
		var now = new Date();
		UTCdate = new Date(
			now.getUTCFullYear(), 
			now.getUTCMonth(), 
			now.getUTCDate(),  
			now.getUTCHours(), 
			now.getUTCMinutes(), 
			now.getUTCSeconds()
		);
	}
	if(!(new Date().toISOString)){
		//"2013-05-13T20:05:25.799Z"
		var addZ = function(n){
			return n < 10 ? '0' + n : n;
		};
		var mon = addZ(UTCdate.getMonth() + 1);
		var date = addZ(UTCdate.getDate());
		var hour = addZ(UTCdate.getHours());
		var min = addZ(UTCdate.getMinutes());
		var secs = addZ(UTCdate.getSeconds());
		return UTCdate.getFullYear() + "-" +
			mon + "-" +
			date + " " +
			hour + ":" +
			min + ":" +
			secs + ".00Z";
	}
	return UTCdate.toISOString().replace("T", " ");
};

/* http://my.opera.com/GreyWyvern/blog/show.dml/1671288 */
/**
 *
 * @method naturalSortFunc
 * @param {} a
 * @param {} b
 */
MoonshadowHelpers.naturalSortFunc = function(a, b) {
	function chunkify(t) {
		var tz = [], x = 0, y = -1, n = 0, i, j;

		while (i = (j = t.charAt(x++)).charCodeAt(0)) {
			var m = (i == 46 || (i >=48 && i <= 57));
			if (m !== n) {
				tz[++y] = "";
				n = m;
			}
			tz[y] += j;
		}
		return tz;
	}

	var aa = chunkify(a.toLowerCase());
	var bb = chunkify(b.toLowerCase());

	for (x = 0; aa[x] && bb[x]; x++) {
		if (aa[x] !== bb[x]) {
			var c = Number(aa[x]), d = Number(bb[x]);
			if (c == aa[x] && d == bb[x]) {
				return c - d;
			} else return (aa[x] > bb[x]) ? 1 : -1;
		}
	}

	return aa.length - bb.length;
};

/**
 *
 * @method rfc822validation
 * @param {String} email
 */
MoonshadowHelpers.rfc822validation = function(email){
	return /^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*$/.test(email);	
};
/**
 * Abstract map adapter
 * @class MMapAdapter
 * @module Moonshadow.MapAdapters
 * @TODO
 */
//Moonshadow.namespace("Moonshadow.Map.Adapter");
function MMapAdapter() {};

MMapAdapter.prototype = {
	manager: null,
	maxLatitude: 85.05112878,
	minLatitude: -85.05112878,
	maxLongitude: 180,
	minLongitude: -180,	
	layers: {},
	/** 
	 *
	 * @method initialize
	 * @param {} manager
	 * @param {} options
	 */
	'initialize': function(manager, options) {
		this.manager = manager;
		this.options = options || {};

		this.container;
		this.tile;
		this.controls = [];

		this.tileLayers = {};
	},
	/**
	 *
	 * @method getInitialPosition
	 */
	'getInitialPosition': function() {
		var manager = this.getManager();
		var lat = this.getManager().getOption("map.lat",39.95);
		var lng = this.getManager().getOption("map.long",-78.1);
		var z = this.getManager().getOption("map.z",4);

		return [lat, lng, z];
	},
	/**
	 *
	 * @method setupMapContainer
	 */
	'setupMapContainer': function() {
		var manager = this.getManager();

		var container = document.createElement("div");
		container.id = "mapcontainer";
		container.map = manager;

		if (this.name) {
			container.className = this.name;
		}

		// Disable rightclick contextmenu on map
		if (!container.addEventListener) {
			// This is for IE
			container.attachEvent('oncontextmenu', function() {
				event.cancelBubble = true;
				return false;
			});
		} else {
			container.addEventListener('contextmenu', function(event) {
				event.preventDefault();
			});
		}

		manager.getContainer().appendChild(container);
		return container;
	},
	/** 
	 *
	 * @method bindBasicEvents
	 */
	'bindBasicEvents': function() {
		var manager = this.getManager();
		var events = ['drag', 'zoom', 'maptype', 'resize', 'bounds', 'click', 'mousemove', 'tilesloaded'];

		for(var i = 0, l = events.length; i < l; i++) {
			var event = events[i];

			this.addMapListener(event, manager, function(event, data) {
				this.mapObservers.notify(event, data);
			});
		}
	},
	/**
	 * 
	 * @method emitMapLoaded
	 */
	'emitMapLoaded': function() {
		this.manager.mapObservers.notify("maploaded");
	},
	/**
	 *
	 * @method getMapKey
	 */
	'getMapKey': function() {
		return this.getManager().getMapKey();
	},
	getManager: function() { return this.manager; },
	getContainer: function() { return this.container; },
	addControl: function(c) { this.addControlToMap(c); },
	removeControl: function(c) { this.removeControlFromMap(c); },
	notifyOfDeltaChange: function(time) {
		$.each(tiles,function(k,v) {
			v.deltaChange(time);
		});
	},
	/**
	 *
	 * @method getLayer
	 * @param {} layerId
	 */
	getLayer: function(layerId) {
		if(typeof this.layers[layerId] == "undefined") return null;
		return this.layers[layerId];
	},
	/** 
	 *
	 * @method changeLayerSetting
	 * @param {} layerId
	 * @param {} options
	 */
	changeLayerSetting: function(layerId,options) {
		if(typeof this.layers[layerId] != "undefined")
			this.layers[layerId].changeSettings(options);
	},
	/**
	 *
	 * @method createLayer
	 * @param {} layerID
	 * @param {} settings
	 */
	createLayer: function(layerId, settings) {
		if(typeof this.layers[layerId] != "undefined") {
			throw new Error("Layer already exists");
		}
		
		this.layers[layerId] = new MTileLayer(this,layerId);
		if(settings.getUrl){
			this.layers[layerId].getUrl = settings.getUrl;
		}

		this.addMapLayer(this.layers[layerId], settings.z);
		this.layers[layerId].changeSettings(settings);
		return this.layers[layerId];
	},
	/**
 	 *
	 * @method hideLayer
	 * @param {} layerId
	 *
	 */
	hideLayer: function(layerId) {
		if(typeof this.hideMapLayer != "function") {
			throw new Error('Adapter is missing hideMapLayer()');
		}
		var layer = layerId || null;
		this.hideMapLayer(layer);
	},
	/**
	 *
	 * @method showLayer
	 * @param {} layerId
	 */
	showLayer: function(layerId) {
		if(typeof this.showMapLayer != "function") {
			throw new Error('Adapter is missing showMapLayer()');
		}
		var layer = layerId || null;
		this.showMapLayer(layer);
	},
	/**
	 *
	 * @method clip
	 * @param {} n
	 * @param {} min
	 * @param {} max
	 */
	'clip': function(n, min, max) {
		return Math.min(Math.max(n, min), max);
	},
	/**
	 *
	 * @method mapSize
	 * @param {} zoom
	 */
	'mapSize': function(zoom) {
		return 256 << zoom;
	},
	/** 
	 *
	 * @method latLngToPixelXY
	 * @param {} lat
	 * @param {} lng
	 * @param {} zoom
	 */
	'latLngToPixelXY': function(lat, lng, zoom) {
		lat = this.clip(lat, this.minLatitude, this.maxLatitude);
		lng = this.clip(lng, this.minLongitude, this.maxLongitude);

		var x = (lng + 180) / 360;		
		sinLatitude = Math.sin(lat * Math.PI / 180);
		var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);

		var size = this.mapSize(zoom);
		x = Math.floor(this.clip(x * size + 0.5, 0, size - 1));
		y = Math.floor(this.clip(y * size + 0.5, 0, size - 1));

		return [x, y];
	},
	/**
 	 *
	 * @method pixelXYToTileCord
 	 * @param {} x
	 * @param {} y
	 */
	'pixelXYToTileCord': function(x, y) {
		return [Math.floor(x / 256), Math.floor(y / 256)];
	},
	/**
 	 *
	 * @method pixelXYToSubTileCord
	 * @param {} x
	 * @param {} y
	 */
	'pixelXYToSubTileCord': function(x, y) {
		return [x % 256, y % 256];
	},
	/** 	
	 *
	 * @method latLngToTileCords
	 * @param {} lat
	 * @param {} lng
	 * @param {} zoom
	 */
	'latLngToTileCords': function(lat, lng, zoom) {
		var pixel = this.latLngToPixelXY(lat, lng, zoom);
		return this.pixelXYToTileCord(pixel[0], pixel[1]).concat(zoom);
	}
};

/** 
 * Map Adapter Class for Bing Maps 8
 * @class MapAdapterBingSeven
 * @module Moonshadow.MapAdapters
 * @extends Moonshadow.MMapAdapter
 * @constructor
 * @param {} manager
 * @param {} options
 */
function MapAdapterBingSeven(manager, options) {
	this.name = MapAdapterBingSeven.config.name;
	this.showCrosshair = false;
	this.initialize(manager, options);
}

MoonshadowHelpers.extend(MapAdapterBingSeven, MMapAdapter);

MapAdapterBingSeven.config = {
	'name': 'bing',
	'desc': "Bing Maps V7",
	'enabled': true,
	'available': true,
	'library': 'https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1',
	'adapterName': 'bseven',
	'isLibraryReady': function() { 
		if(typeof Microsoft !== 'object') {
			return false;
		}

		if(Microsoft.Maps && Microsoft.Maps.MapTypeId) {
			return true;
		}

		return false;
	},
	'factory': function(manager, mapOptions) {
		return new MapAdapterBingSeven(manager, mapOptions);
	}
};

MapAdapterBingSeven.prototype.init = function() {
	this.container = this.setupMapContainer();
	this.map = this.setupMap();
	this.createControlPositions();
	this.bindBasicEvents();
	this.emitMapLoaded();
};

/**
 *
 * @method setupMap
 */
MapAdapterBingSeven.prototype.setupMap = function() {
	var pos = this.getInitialPosition();
	var defaultKey = 'AgEcVlOoEQSBoDZoDEdqjEtpPl8FCpkHcSGwtC2hlg5jhoITwIVmeGQ5w2OpwvOz';
	var key = this.getMapKey() || defaultKey;

	var options = {
		'credentials': key,
		'mapTypeId': this.getBingMapType(this.options.mapType || 'auto'),
		'center': new Microsoft.Maps.Location(pos[0], pos[1]),
		'zoom': pos[2],
		'enableClickableLogo': false,
		'enableSearchLogo': false,
		'useInertia': false
	};

	if(this.options.disableBirdseye) {
		options.disableBirdseye = true;
	}
	
	var map = new Microsoft.Maps.Map(this.container, options);
	var MSEvents = Microsoft.Maps.Events;

	// Call the Module Loaded method
	Microsoft.Maps.moduleLoaded('CircleModule');

	// Mouse cursor hack
	var mapStyle = map.getRootElement().style;
	this.addListener(map, 'mousemove', this, function(eventName, event) {
		var targetType = event.targetType;
		if((targetType === 'map' || targetType === 'polygon') && this.showCrosshair) {
			mapStyle.cursor = 'crosshair';
		} else if(targetType !== 'map') {
			mapStyle.cursor = 'pointer';
		}
	});

	// This is in place to prevent mouse event passing from infobox to map
	MSEvents.addHandler(map, 'mousedown', (function(adapter) {
		return function(event) {
			if(adapter.focusInfobox) {
				event.handled = true;
			}
		}
	}(this)));

	// This is in place to prevent mouse events passing from infobox to map
	MSEvents.addHandler(map, 'mousewheel', (function(adapter) {
		return function(event) {
			if(adapter.focusInfobox) {
				event.handled = true;
			}
		}
	}(this)));

	return map;
};

/**
 *
 * @method createControlPositions
 */
MapAdapterBingSeven.prototype.createControlPositions = function() {
	var controls = [null, 'topLeft', 'topCenter', 'topRight', 'bottomLeft',
					'bottomCenter', 'bottomRight'];
	for(var i = 0, l = controls.length; i < l; i++) {
		var name = controls[i];
		if(!name) {
			continue;
		}

		var div = document.createElement('div');
		div.id = controls[i] + 'Controls';

		this.controls[i] = div;
		$(this.container).append(div);
		//$('.MicrosoftMap', this.container).append(div);
	}
};

/**
 *
 * @method mapTos
 */
MapAdapterBingSeven.prototype.mapTos = {
	"title": "Bing Maps TOU",
	"url": "http://www.microsoft.com/Maps/product/terms.html"
};

MapAdapterBingSeven.prototype.eventMap = {
	'drag': 'viewchangeend',
	'zoom': 'viewchangeend',
	'maptype': 'maptypechanged',
	'resize': 'resize',
	'bounds': 'viewchangeend',
	'click': 'click',
	'mousedown': 'mousedown',
	'mousemove': 'mousemove',
	'mouseup': 'mouseup',
	'mouseout': 'mouseout',
	'tilesloaded': 'tiledownloadcomplete',
	'keydown': 'keydown',
	'keyup': 'keyup'
};

MapAdapterBingSeven.prototype.getBingEvent = function(genericEvent) { 
	return this.getEventFromMap(this.bingEvents, genericEvent);
}

MapAdapterBingSeven.prototype.genericEvents = {
	'entityadded': 'added',
	'entitychanged': 'changed',
	'click': 'click',
	'doubleclick': 'dblclick',
	'dragstart': 'dragstart',
	'drag': 'drag',
	'dragend': 'dragend',
	'mousedown': 'mousedown',
	'mouseout': 'mouseout',
	'mouseover': 'mouseover',
	'mouseup': 'mouseup',
	'entityremoved': 'removed',
	'rightclick': 'rightclick'				
};

MapAdapterBingSeven.prototype.bingEvents = {
	'added': 'entityadded',
	'changed': 'entitychanged',
	'click': 'click',
	'dblclick': 'doubleclick',
	'dragstart': 'dragstart',
	'drag': 'drag',
	'dragend': 'dragend',
	'mousedown': 'mousedown',
	'mouseout': 'mouseout',
	'mouseover': 'mouseover',
	'mouseup': 'mouseup',
	'removed': 'entityremoved',
	'rightclick': 'rightclick'				
};


/**
 *	 
 * @method addMapListener
 * @param {} event
 * @param {} cbScope
 * @param {} callback
 */
MapAdapterBingSeven.prototype.addMapListener = function(event, cbScope, callback) {
	var listener = function(mmName) {
		return function(bingName, e) {
			callback.call(this, mmName, e);
		}

	}(event);

	return this.addListener(this.map, this.eventMap[event], cbScope, listener);
};

/**
 *
 * @method addListener
 * @param {} target
 * @param {} event
 * @param {} cbscope
 * @param {} callback
 */
MapAdapterBingSeven.prototype.addListener = function(target, event, cbScope, callback) {
	if(!window.bevents){
		window.bevents = {};
	}
	if(!window.bevents[event]){
		window.bevents[event] = {
			"added": 0,
			"called": 0
		};
	}
	window.bevents[event].added++;
	
	return Microsoft.Maps.Events.addHandler(target, event, (function(event, scope, callback) {
		return function(e) {
			window.bevents[event].called++;
			if (event) {
				callback.call(scope, event, e);
			}
		}
	}(event, cbScope, callback)));
};

/**
 *
 * @method removeMapListener
 * @param {} listener
 */
MapAdapterBingSeven.prototype.removeMapListener = function(listener) {
	Microsoft.Maps.Events.removeHandler(listener);
};

/**
 *
 * @method getCenter
 */
MapAdapterBingSeven.prototype.getCenter = function() {
	return (function(lat, lng) {
		return {
			lat: function() {	
				return lat;
			},
			lng: function() {
				return lng;
			}
		}
	}(this.map.getCenter().latitude, this.map.getCenter().longitude));		
};

/**
 *
 * @method setCenter
 * @param {} lat
 * @param {} lng
 * @param {} animate
 *
 */
MapAdapterBingSeven.prototype.setCenter = function(lat, lng, animate) {
	if(typeof animate === 'undefined') {
		var animate = false;
	}

	this.map.setView({
		'animate': animate,
		'center': new Microsoft.Maps.Location(lat, lng)
	});
};

/**
 *
 * @method getZoom
 */
MapAdapterBingSeven.prototype.getZoom = function() {
	return this.map.getZoom();
};

/**
 *
 * @method setZoom
 * @param {} level
 * @param {} animate
 */
MapAdapterBingSeven.prototype.setZoom = function(level, animate) { // @TODO check if this is used
	if(typeof animate === 'undefined') {
		var animate = false;
	}

	this.map.setView({
		'animate': animate,
		'zoom': level
	});
};

/**
 *
 * @method fitbounds
 * @param {} points
 */
MapAdapterBingSeven.prototype.fitBounds = function(points) {
	var locations = [];
	for (var i = 0, l = points.length; i < l; i++) {
		var xy = points[i];
		locations.push(new Microsoft.Maps.Location(xy[0], xy[1]));
	}

	this.map.setView({
		'bounds': Microsoft.Maps.LocationRect.fromLocations(locations)
	});
};

/**
 *
 * @method panTo
 * @param {} lat
 * @param {} lng
 */
MapAdapterBingSeven.prototype.panTo = function(lat, lng) {
	this.setCenter(lat, lng, true);
};

/**
 *
 * @method panToBounds
 * @param {} lat1
 * @param {} lng1
 * @param {} lat2
 * @param {} lng2
 */
MapAdapterBingSeven.prototype.panToBounds = function(lat1, lng1, lat2, lng2) {
	this.fitBounds([[lat1, lng1],[lat2, lng2]]);
};

/**
 *
 * @method getMapType
 */
MapAdapterBingSeven.prototype.getMapType = function() {
	var type = this.map.getMapTypeId();
	if(type === Microsoft.Maps.MapTypeId.road) {
		return 'roadmap';
	} else if(type === Microsoft.Maps.MapTypeId.aerial) {
		return 'satellite';
	} else if(type === Microsoft.Maps.MapTypeId.birdseye) {
		return 'birdseye';
	} else if(type === Microsoft.Maps.MapTypeId.mercator) {
		return 'mercator';
	} else if(type === Microsoft.Maps.MapTypeId.ordnanceSurvey) {
		return 'ordnanceSurvey';
	} else if(type === Microsoft.Maps.MapTypeId.auto) {
		return 'auto';
	} else { 
		return 'roadmap';
	}
};

/**
 *
 * @method getMapImagerySet
 */
MapAdapterBingSeven.prototype.getMapImagerySet = function(){
	var acceptableRESTSets = ["Road","Aerial","Birdseye"]; //lame!
	var adapterImagerySet = this.map.getImageryId();
	var imagerySet;
	for(var i = 0, l = acceptableRESTSets.length; i < l; ++i){
		if(adapterImagerySet.search(acceptableRESTSets[i]) > -1){
			imagerySet = acceptableRESTSets[i];
		}
	}
	if(!imagerySet)
		imagerySet = "Road";
	var showLabels = !this.map.getOptions().labelOverlay
	if(showLabels && (imagerySet == "Aerial" || imagerySet == "Birdseye")){
		imagerySet += "WithLabels";
	}
	return imagerySet;
};

MapAdapterBingSeven.prototype.getMaxZoom = function(){
	return this.map.getZoomRange().max;
};

/**
 *
 * @method getMapImagerySetForAPI
 * ("Birdseye" not enabled in Bing Maps API)
 */
MapAdapterBingSeven.prototype.getMapImagerySetForAPI = function(){
	var acceptableRESTSets = ["Road","Aerial"];
	var adapterImagerySet = this.map.getImageryId();
	var imagerySet;
	for(var i = 0, l = acceptableRESTSets.length; i < l; ++i){
		if(adapterImagerySet.search(acceptableRESTSets[i]) > -1){
			imagerySet = acceptableRESTSets[i];
		}
	}
	if(!imagerySet)
		imagerySet = "Road";
	var showLabels = !this.map.getOptions().labelOverlay
	if(showLabels && (imagerySet == "Aerial")){
		imagerySet += "WithLabels";
	}
	return imagerySet;
};

/**
 *
 * @method setMapType
 * @param {} maptype
 */
MapAdapterBingSeven.prototype.setMapType = function(mapType) {
	var id = this.getBingMapType(mapType);

	this.map.setView({
		'mapTypeId': id
	});
};

/**
 *
 * @method getBingMapType
 * @param {} mapType
 */
MapAdapterBingSeven.prototype.getBingMapType = function(mapType) {
	if(mapType === "roadmap") {
		return Microsoft.Maps.MapTypeId.road;
	}else if(mapType === "hybrid") {
		return Microsoft.Maps.MapTypeId.road;
	}else if (mapType === "terrain") {
		return Microsoft.Maps.MapTypeId.road;
	}else if(mapType === "satellite") {
		return Microsoft.Maps.MapTypeId.aerial;
	}else if(mapType === "auto") {
		return Microsoft.Maps.MapTypeId.auto;
	}else{
		return Microsoft.Maps.MapTypeId.road;
	}
};

/**
 *
 * @method addControlToMap
 * @parameter {} control
 */
MapAdapterBingSeven.prototype.addControlToMap = function(control, mapOverlay) {
	if (mapOverlay) {
		this.container.appendChild(control.container);
	} else {
		if(control.precedence === 1) {
			var first = this.controls[control.position].firstChild;
			!!this.controls[control.position] &&
				this.controls[control.position].insertBefore(control.container, first);
		} else {
			!!this.controls[control.position] &&
				this.controls[control.position].appendChild(control.container);
		}
	}
};

MapAdapterBingSeven.prototype.addControlInsideMap = function(control){
	$(this.map.getRootElement())
		.append(control.container);
};

/**
 *
 * @method resize
 */
MapAdapterBingSeven.prototype.resize = function(){};

/**
 *
 * @method addMapLayer
 * @param {} layer
 */
MapAdapterBingSeven.prototype.addMapLayer = function(layer, z) {
	if(this.tileLayers[layer.layerId]) {
		throw new Error('Layer has already been added to the adapter');
	}

	// @LEAFLET - disabled this
	//disabled @LEAFLET; enabled this
	layer.updateDelta();
		
	var options = {
		'uriConstructor': (function(layer, caller) { 
			return function(tile) {
				return caller.getTileLayerUrl(tile, layer);
			}
		}(layer, this))
	};
	var tileSource = new Microsoft.Maps.TileSource(options);
	var tileLayer = new Microsoft.Maps.TileLayer({
		'mercator': tileSource,
		'opacity': 1,
		'visible': false, 
		'zIndex': z == undefined ? 1 : z
	});

	tileLayer.tilesLoadedHandler = layer.tilesLoadedHandler();
	tileLayer.loadedHandlerId = Microsoft.Maps.Events.addHandler(
		tileLayer, 'tiledownloadcomplete', tileLayer.tilesLoadedHandler);

	this.tileLayers[layer.id] = tileLayer;
	this.map.entities.push(tileLayer);
};

/**
 *
 * @method getTileLayerUrl
 * @param {} tile
 * @param {} layer
 */
MapAdapterBingSeven.prototype.getTileLayerUrl = function(tile, layer) {
	var url = layer.getUrl(tile);

	if(!url) {
		return undefined;
	}

	if (Moonshadow.server) {
		var MS = Moonshadow;
		url = MS.server + url;
		url += ['&user=', MS.user, '&key=', MS.key].join('');
	}

	return [url, '&d=', layer.settings.lastChange].join('');
};

/**
 * 
 * @method reloadLayers
 * @param {} layerId
 */
MapAdapterBingSeven.prototype.reloadLayers = function(layerId) { // @CLEANUP could this be moved to the abstract?
	if(layerId) {
		this.reloadLayer(layerId);
	} else {
		$.each(this.tileLayers, function(k, v) {
			caller.reloadLayers(k);
		});
	}
};

/**
 *
 * @method reloadLayer
 * @param {}layerId
 */
MapAdapterBingSeven.prototype.reloadLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	var map = this.map;
	var tileLayers = this.tileLayers;
	var layer = tileLayers[layerId];

	// @LEAFLET - disabled
	//this.getLayer(layerId).updateDelta(); // Update delta of MTileLayer

	map.entities.remove(layer);
	map.entities.push(layer);
};

/**
 *
 * @method showMapLayer
 * @param {} layerId
 */
MapAdapterBingSeven.prototype.showMapLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	tileLayer.setOptions({'visible': true});

	if (!Microsoft.Maps.Events.hasHandler(tileLayer, 'tiledownloadcomplete')) {
		tileLayer.loadedHandlerId = Microsoft.Maps.Events.addHandler(
			tileLayer, 'tiledownloadcomplete', tileLayer.tilesLoadedHandler);
	}

	var map = this.map;
	if(map.entities.indexOf(tileLayer) === -1) {
		map.entities.push(tileLayer);
	}
};

/**
 *
 * @method hideMapLayer
 * @param {} layerId
 */
MapAdapterBingSeven.prototype.hideMapLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	Microsoft.Maps.Events.removeHandler(tileLayer.loadedHandlerId);

	tileLayer.setOptions({'visible': false});
	this.map.entities.remove(tileLayer);
};

/**
 *
 * @method get TileLayer
 * @param {} layerId
 */
MapAdapterBingSeven.prototype.getTileLayer = function(layerId) {
	return this.tileLayers[layerId] || undefined;	
};

/**
 *
 * @method getBounds
 */
MapAdapterBingSeven.prototype.getBounds = function() {
	var rect = this.map.getBounds();
	return {
		'neLat': rect.getNorth(),
		'neLon': rect.getEast(),
		'swLat': rect.getSouth(),
		'swLon': rect.getWest()
	};
};

/**
 *
 * @method getAntiBounds
 */
MapAdapterBingSeven.prototype.getAntiBounds = function(){
	var nw = this.map.getBounds().getNorthwest();
	var se = this.map.getBounds().getSoutheast();
	return {
		'nwLat': nw.latitude,
		'nwLon': nw.longitude,
		'seLat': se.latitude,
		'seLon': se.longitude
	};
};

/**
 *
 * @method enableCrosshair
 */
MapAdapterBingSeven.prototype.enableCrosshair = function() {
	this.map.getRootElement().style.cursor = 'crosshair';
	this.showCrosshair = true;
};

/**
 *
 * @method disableCrosshair
 */
MapAdapterBingSeven.prototype.disableCrosshair = function() {
	this.map.getRootElement().style.cursor = '';
	this.showCrosshair = false;
};

/**
 *
 * @method getLatLngFromXY
 * @param {} x
 * @param {} y
 */
MapAdapterBingSeven.prototype.getLatLngFromXY = function(x, y) {
	var location = this.map.tryPixelToLocation(new Microsoft.Maps.Point(x, y));
	return this.latLng(location.latitude, location.longitude);
};

/**
 *
 * @method infoWindow
 */
/* Below this line is marker stuff */
MapAdapterBingSeven.prototype.infoWindow = function() {
	var MSMaps = Microsoft.Maps;
	var MSEvents = MSMaps.Events;

	var options = { 
		'visible': false,
		'offset': new MSMaps.Point(0, 32)
	};

	var loc = new MSMaps.Location(0, 0);
	var infobox = new MSMaps.Infobox(loc, options);

	// Binding events to track mouse entering/leaving info box
	// This is needed to prevent pan/zooming when mouse in box
	if(!MSEvents.hasHandler(infobox, 'mouseenter')) {
		MSEvents.addHandler(infobox, 'mouseenter', (function(adapter) {
			return function(event) {
				adapter.focusInfobox = true;
			};
		}(this)));
	}

	if(!MSEvents.hasHandler(infobox, 'mouseleave')) {
		MSEvents.addHandler(infobox, 'mouseleave', (function(adapter) {
			return function(event) {
				adapter.focusInfobox = false;
			};
		}(this)));
	}

	if(!MSEvents.hasHandler(infobox, 'entitychanged')) {
		MSEvents.addHandler(infobox, 'entitychanged', (function(adapter) {
			return function(event) {
				if(!event.entity.getVisible()) {
					adapter.focusInfobox = false;
				}
			};
		}(this)));
	}

	return infobox;
};

MapAdapterBingSeven.prototype.getInfoWindowId = function(infobox) {
	return infobox.getId();
};

MapAdapterBingSeven.prototype.setInfoWindowId = function(infobox, id) {
	infobox.setOptions({"id": id});
};

/**
 *
 * @method closeInfoWindowListener
 * @param {} balloon
 * @param {} map
 */
MapAdapterBingSeven.prototype.closeInfoWindowListener = function(balloon, map) {
	//balloon.setOptions({'visible': false});
};

/**
 *
 * @method latLng
 * @param {} lat
 * @param {} lng
 */
MapAdapterBingSeven.prototype.latLng = function(lat, lng) {
	var MSMaps = Microsoft.Maps;
	var loc = new Microsoft.Maps.Location(lat, lng);
	loc.lat = function() {
		return this.latitude;
	};
	loc.lng = function() {
		return this.longitude;
	};
	return loc;		
};

/**
 *
 * @method setMarkerIcon
 * @param {} marker
 * @param {} url
 * @param {} anchorX
 * @param {} anchorY
 * @param {} width
 * @param {} height
 *
 */
MapAdapterBingSeven.prototype.setMarkerIcon = function(marker, url, anchorX, anchorY, width, height) {
	// Marker != Pushin, marker is an object made by MControlMarkers
	var options = {
		'icon': url,
		'anchor': new Microsoft.Maps.Point(anchorX || 0, anchorY || 0),
		'height': height || 36,
		'width': width || 22,
		'visible': true
	};

	marker.marker.setOptions(options);
};

/**
 *
 * @method addMarkerLsnr
 * @param {} marker
 * @param {} callback
 */
MapAdapterBingSeven.prototype.addMarkerLsnr = function(marker, callback) {
	return Microsoft.Maps.Events.addHandler(marker.marker, 'click', (function(marker, callback) {
		return function() {
			callback.call(marker);
		};
	}(marker.marker, callback)));
};

/**
 *
 * @method clearMarker
 * @param {} marker
 */
// @CLEANUP this function is very pooly named
// It really removes polygons/polyline/markers from the map
MapAdapterBingSeven.prototype.clearMarker = function(marker) {
	// @CLEANUP thie whole marker.marker thing is silly
	return (this.map.entities.remove(marker.marker)) ? true : false;
};

/**
 *
 * @method removeEntity
 * @param {} entity
 */
MapAdapterBingSeven.prototype.removeEntity = function(entity) {
	// the whole marker.marker thing is dumb
	this.clearMarker({'marker': entity});
};

/** 
 *
 * @method clearAllMarkers
 * @param {} markers
 */
MapAdapterBingSeven.prototype.clearAllMarkers = function(markers) {
	for(var i in markers) {
		this.clearMarker(markers[i]);
	}
};

/**
 *
 * @method getMarker
 * @param {} details
 */
MapAdapterBingSeven.prototype.getMarker = function(details) { // This is only a small part of whats in b.js
	var MSMaps = Microsoft.Maps;
	var MSEvents = MSMaps.Events;
	var position = details.position;

	var options = {
		'visible': false
	};

	if(details.draggable) {
		options.draggable = true; // As draggable
	}

	if(details.icon) {
		options.icon = details.icon;

		var dim = details.iconDim;
		if(dim) {
			options.width = dim[0];
			options.height = dim[1];
		}
		
		var anchor = details.iconAnchor;
		if(anchor) {
			options.anchor = new MSMaps.Point(anchor[0], anchor[1]);
		}
	}

	var pushpin = new MSMaps.Pushpin(position, options);
	pushpin.markerType = details.markerType;
	
	// Events for changing cursor when moving mouse over/out
	MSEvents.addHandler(pushpin, 'mouseover', (function(map) {
		return function(event) {
			event.target.previousCursor = map.getRootElement().style.cursor;
			map.getRootElement().style.cursor = 'pointer';
		}
	}(this.map)));
	MSEvents.addHandler(pushpin, 'mouseout', (function(map) {
		return function(event) {
			map.getRootElement().style.cursor = event.target.previousCursor;
		}
	}(this.map)));

	if(options.draggable) {
		// Event bindings
		this.addListener(pushpin, 'dragstart', this, this.markerStartDrag);
		this.addListener(pushpin, 'drag', this, this.markerDrag);
		this.addListener(pushpin, 'dragend', this, this.markerEndDrag);
	}

	// These properties needs cleaned up
	pushpin.Id = (details.markerId)
		? details.markerId
		: [position.latitude, position.longitude].join('');

	this.map.entities.push(pushpin);
	
	return pushpin;
};

/**
 *
 * @method openInfoWindow
 * @param {} infobox
 * @param {} map
 * @param {} marker
 * @param {} content
 *
 */
MapAdapterBingSeven.prototype.openInfoWindow = function(infobox, map, marker, content) {
	var MSEvents = Microsoft.Maps.Events;
	var location = marker.getLocation();

	var mapHeight = $(this.container).innerHeight();
	var mapWidth = $(this.container).innerWidth();
	var dim = this.getContentDim(content);
	var contentWidth = dim[0];
	var contentHeight = dim[1];

	contentHeight += 50;
	contentWidth += 90;

	if(contentWidth > mapWidth - 220) {
		contentWidth = mapWidth - 260;
	}

	if(contentHeight > mapHeight - 220) {
		contentHeight = mapHeight - 260;
	}
	
	if(contentWidth < 200){
		contentWidth = 200;
	}
	
	if(contentHeight < 200){
		contentHeight = 200;
	}
	
	// @HACK - Deal with .html() being limited and shedding container
	var wrap = document.createElement('div');
	wrap.appendChild(content);

	var options = {
		'visible': true,
		'description': $(wrap).html(),
		'width': contentWidth + 20,
		'height': contentHeight + 20,
		'zIndex': 1000
	};

	infobox.setLocation(marker.getLocation());
	infobox.setOptions(options);

	if(map.entities.indexOf(infobox) === -1) {
		map.entities.push(infobox);
	}

	//adjust normal balloon
	var infoElem = $(".infoWindow")
		.closest(".Infobox");
	if(infoElem && infoElem.length){
		var elemTop = $(infoElem)
			.offset()
			.top;
		
		var adjustedHeight = contentHeight - (elemTop * -1) - 20;
		if(adjustedHeight < 200)
			adjustedHeight = 200;
		
		if(elemTop < 0){
			infobox.setOptions({
				'height': adjustedHeight,
			});
		}
		
		var elemHeight = $(infoElem)
			.height();
	
		$(".infoWindow")
			.closest(".infobox-info")
			.css({
				'height': (elemHeight - 20) + 'px',
				'width': contentWidth + 'px',
				'overflow': 'auto',
				'right': '20px'
			});
	}
	
	//adjust canvasser balloon
	var canvElem = $("." + marker.Id)
		.closest(".Infobox")
		.parent();
	
	if(canvElem && canvElem.length){
		$(canvElem)
			.addClass("canvasser_infobox");
		marker.infoBoxContainer = canvElem;
	}
};

/** 
 *
 * @method closeImfoWindow
 * @param {} infobox
 * @param {} map
 */
MapAdapterBingSeven.prototype.closeInfoWindow = function(infobox, map) {
	infobox.setOptions({
		'visible': false
	});
	map.entities.remove(infobox);
	this.manager.mapObservers.notify("infowindowclosed");
};

/**
 *
 * @method getContentDim
 * @param {} content
 */
MapAdapterBingSeven.prototype.getContentDim = function(content) {
	var temp = document.createElement("div");
	temp.style.display = "none";
	temp.appendChild(content);

	this.container.appendChild(temp);

	var width = $(temp).innerWidth();
	var height = $(temp).innerHeight();

	$(temp).remove();
	return [width, height];
};

MapAdapterBingSeven.prototype.getLocation = function(point) {
	return new Microsoft.Maps.Location(point[0], point[1]);
};

MapAdapterBingSeven.prototype.getLocations = function(points) {
	var MSMaps = Microsoft.Maps;
	var locations = [];

	for(var i = 0, l = points.length; i < l; i++) {
		locations.push(this.getLocation(points[i]));
	}

	return locations;		
};

MapAdapterBingSeven.prototype.getGenericEvent = function(bingEvent) {
	return this.getEventFromMap(this.genericEvents, bingEvent);
};

MapAdapterBingSeven.prototype.getEventFromMap = function(map, event) {
	var event = map[event];

	if (!event) {
		throw new Error('Invalid event: ' + event);
	}

	return event;
};

MapAdapterBingSeven.prototype.getPointFromEvent = function(event) {
	return [event.pageX, event.pageY];
};

MapAdapterBingSeven.prototype.getLocationFromEvent = function(event) {
	var MSMaps = Microsoft.Maps;
	var loc = this.map.tryPixelToLocation(
		new Microsoft.Maps.Point(event.getX(), event.getY())
	);

	return this.latLng(loc.latitude, loc.longitude);
};

MapAdapterBingSeven.prototype.isRightClick = function(event) {
	return !!event.isSecondary;
};

MapAdapterBingSeven.prototype.preventDefault = function(event) {
	event.handled = true;
};

MapAdapterBingSeven.prototype.addEventListener = function(event, listener, entityHolder) {
	var MSMaps = Microsoft.Maps;
	var MSEvents = MSMaps.Events;

	var entity = entityHolder.getMapEntity();
	if (entity) {
		var wrappedListener = (function(context, callback, self) {
			return function(event) {
				var id = event.eventName;
				var details = event;

				if (typeof event.entity === 'object') {
					details = event.entity;
				}

				// Repackage the event before emitting
				callback.call(context, id, details);
			};
		}(entityHolder, listener, this));

		return MSEvents.addHandler(entity, this.getBingEvent(event),
								   wrappedListener);
	}

	return null;
};

MapAdapterBingSeven.prototype.removeEventListener = function(handler) {
	var MSMaps = Microsoft.Maps;
	var MSEvents = MSMaps.Events;
	MSEvents.removeHandler(handler);
};

MapAdapterBingSeven.prototype.panToPoints = function(points) {
	var locs = this.getLocations(points);
	if (!locs.length) {
		return;
	}		

	this.map.setView({
		'bounds': Microsoft.Maps.LocationRect.fromLocations(locs)
	});		
};

MapAdapterBingSeven.prototype.panToShape = function(shape) {
	var points = shape.getPoints();

	this.panToPoints(points);
};

MapAdapterBingSeven.prototype.createBingPolyline = function(polyline) {
	var entity = polyline.getMapEntity();
	if (!entity) {
		var locations = this.getLocations(polyline.getPoints())
		var options = this.getPolylineOptions(polyline);
		entity = new Microsoft.Maps.Polyline(locations, options);
	}

	return entity;
};

MapAdapterBingSeven.prototype.addPolyline = function(polyline) {
	var entity = this.createBingPolyline(polyline);
	this.map.entities.push(entity);

	return entity;
};

MapAdapterBingSeven.prototype.updatePolylinePoints = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		var locations = this.getLocations(polyline.getPoints())
		entity.setLocations(locations);
	}
};

MapAdapterBingSeven.prototype.updatePolylineOptions = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		var options = this.getPolylineOptions(polyline);
		entity.setOptions(options);
	}
};

MapAdapterBingSeven.prototype.removePolyline = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingSeven.prototype.getPolylineOptions = function(polyline) {
	var MSMaps = Microsoft.Maps;

	var color = MSMaps.Color.fromHex(polyline.lineColor)
	color.a = polyline.lineAlpha;

	var options = {
		'strokeColor': color,
		'strokeDashArray': polyline.lineStyle,
		'strokeThinkness': polyline.lineThickness
	};

	return options;
};

MapAdapterBingSeven.prototype.createBingPolygon = function(polygon) {
	var entity = polygon.getMapEntity();
	if (!entity) {
		var locations = this.getLocations(polygon.getPoints())
		var options = this.getPolygonOptions(polygon);
		entity = new Microsoft.Maps.Polygon(locations, options);
	}

	return entity;
};

MapAdapterBingSeven.prototype.addPolygon = function(polygon) {
	var entity = this.createBingPolygon(polygon);
	this.map.entities.push(entity);

	return entity;
};

MapAdapterBingSeven.prototype.updatePolygonPoints = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		var locations = this.getLocations(polygon.getPoints());
		entity.setLocations(locations);
	}
};

MapAdapterBingSeven.prototype.updatePolygonOptions = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		var options = this.getPolygonOptions(polygon);
		entity.setOptions(options);
	}
};

MapAdapterBingSeven.prototype.removePolygon = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingSeven.prototype.getPolygonOptions = function(polygon) {
	var MSMaps = Microsoft.Maps;

	var fillColor = MSMaps.Color.fromHex(polygon.fillColor);
	fillColor.a = polygon.fillAlpha;

	var lineColor = MSMaps.Color.fromHex(polygon.lineColor);
	lineColor.a = polygon.lineAlpha;

	var options = {
		'fillColor': fillColor,
		'strokeColor': lineColor,
		'strokeDashArray': polygon.lineStyle,
		'strikeThinkness': polygon.lineThickness
	};

	return options;
};

MapAdapterBingSeven.prototype.createBingCircle = function(circle) {
	var entity = circle.getMapEntity();
	if (!entity) {
		var center = this.getLocation(circle.getCenter())
		var distance = circle.getRadiusMeters();
		var options = this.getCircleOptions(circle);
		entity = new BM.Circle(center, distance, 'm', options);
	}

	return entity;
};

MapAdapterBingSeven.prototype.addCircle = function(circle) {
	var entity = this.createBingCircle(circle);
	this.map.entities.push(entity);

	return entity;
};

MapAdapterBingSeven.prototype.updateCirclePoints = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		var center = this.getLocation(circle.getCenter());
		var distance = circle.getRadiusMeters();
		entity.setCenter(center);
		entity.setRadius(distance);			
	}
};

MapAdapterBingSeven.prototype.updateCircleOptions = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		var options = this.getCircleOptions(circle);
		entity.setOptions(options);
	}
};

MapAdapterBingSeven.prototype.removeCircle = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingSeven.prototype.getCircleOptions = function(circle) {
	var MSMaps = Microsoft.Maps;

	var fillColor = MSMaps.Color.fromHex(circle.fillColor);
	fillColor.a = circle.fillAlpha;

	var lineColor = MSMaps.Color.fromHex(circle.lineColor);
	lineColor.a = circle.lineAlpha;

	var options = {
		'fillColor': fillColor,
		'strokeColor': lineColor,
		'strokeDashArray': circle.lineStyle,
		'strokeThinkness': circle.lineThickness
	};

	return options;
};

MapAdapterBingSeven.prototype.createBingPushpin = function(marker) {
	var entity = marker.getMapEntity();
	if (!entity) {
		var location = this.getLocation(marker.getPoint())
		var options = this.getMarkerOptions(marker);
		entity = new Microsoft.Maps.Pushpin(location, options);
	}
	return entity;			
};

MapAdapterBingSeven.prototype.addMarker = function(marker) {
	var entity = this.createBingPushpin(marker);
	this.map.entities.push(entity);

	return entity;
};

MapAdapterBingSeven.prototype.updateMarkerPoint = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		var location = this.getLocation(marker.getPoint())
		entity.setLocation(location);
	}
};

MapAdapterBingSeven.prototype.updateMarkerOptions = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		var options = this.getMarkerOptions(marker);
		entity.setOptions(options);
	}
};

MapAdapterBingSeven.prototype.hideMarker = function(marker) {
	marker.setIcon('');
	marker.addEventListener('dragend', marker.hide, marker);
};

MapAdapterBingSeven.prototype.removeMarker = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingSeven.prototype.getMarkerOptions = function(marker) {
	var MSMaps = Microsoft.Maps;
	var anchor = new MSMaps.Point(marker.anchor[0], marker.anchor[1]);
	var options = {
		'anchor': anchor,
		'draggable': marker.draggable,
		'height': marker.height,
		//'htmlContent': '',
		'icon': marker.icon,
		//'infobox': '',
		//'state': '',
		//'text': '',
		//'textOffset': '',
		//'typeName': '',
		//'visible': '',
		'width': marker.width,
		'zIndex': marker.zIndex
	};

	return options;
};

MapAdapterBingSeven.prototype.getMarkerPoint = function(markerEntity) {
	var loc = markerEntity.getLocation();
	return [loc.latitude, loc.longitude];		
};

/** 
 * Map Adapter Class for Bing Maps 8
 * @class MapAdapterBingEight
 * @module Moonshadow.MapAdapters
 * @extends Moonshadow.MMapAdapter
 * @constructor
 * @param {} manager
 * @param {} options
 */
function MapAdapterBingEight(manager, options) {
	this.name = MapAdapterBingEight.config.name;
	this.showCrosshair = false;
	
	options.displayColor = '#00FF00';
	options.displayFillAlpha = 0.27;
	options.displayLineAlpha = 0.8;

	options.activeColor = '#FF0000';
	options.activeFillAlpha = 0.5;
	options.activeLineAlpha = 0.8;
	
	this.initialize(manager, options);	
	this.generalEvents = {};
}

MoonshadowHelpers.extend(MapAdapterBingEight, MMapAdapter);

MapAdapterBingEight.config = {
	'name': 'bing8',
	'desc': "Bing Maps V8",
	'enabled': true,
	'available': true,
	'library': 'https://www.bing.com/api/maps/mapcontrol',
	'adapterName': 'BingMapsV8',
	'isLibraryReady': function() { 
		if(typeof Microsoft !== 'object') {
			return false;
		}

		if(Microsoft.Maps && Microsoft.Maps.MapTypeId) {
			return true;
		}

		return false;
	},
	'factory': function(manager, mapOptions) {
		return new MapAdapterBingEight(manager, mapOptions);
	}
};

MapAdapterBingEight.prototype.init = function() {
	this.container = this.setupMapContainer();
	this.map = this.setupMap();
	this.createControlPositions();
	this.bindBasicEvents();
	this.emitMapLoaded();
};

/**
 *
 * @method setupMap
 */
MapAdapterBingEight.prototype.setupMap = function() {
	var pos = this.getInitialPosition();
	var defaultKey = "AgEcVlOoEQSBoDZoDEdqjEtpPl8FCpkHcSGwtC2hlg5jhoITwIVmeGQ5w2OpwvOz";
	var key = this.getMapKey() || defaultKey;

	var supportedMapTypes = [
		Microsoft.Maps.MapTypeId.road,
		Microsoft.Maps.MapTypeId.aerial
	];
	
	if(!this.options.disableBirdseye) {
		supportedMapTypes.push(Microsoft.Maps.MapTypeId.birdseye);
	}
	
	var options = {
		"credentials": key,
		"mapTypeId": this.getBingMapType(this.options.mapType || "road"),
		"center": new Microsoft.Maps.Location(pos[0], pos[1]),
		"zoom": pos[2],
		"enableClickableLogo": false,
		"enableSearchLogo": false,
		"useInertia": false,
		"disableMapTypeKeyboardInput": true,
		"disableMapTypeSelectorMouseOver": false,
		"disableStreetside": true,
		"disableStreetsideAutoCoverage": true,
		"liteMode": true,
		"showLocateMeButton": false,
		"showTrafficButton": false,
		"supportedMapTypes": supportedMapTypes
	};
	
	var map = new Microsoft.Maps.Map(this.container, options);
	Microsoft.Maps.loadModule("CustomInfoboxModule");
	
	this.adjustMap();
	
	return map;
};

MapAdapterBingEight.prototype.adjustMap = function(){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var moveMapSelector = function(){
		var _sel = $("#MicrosoftNav");
		if(!_sel.length){
			return setTimeout(moveMapSelector, 100);
		}

		var hasBEinList = $("#RadialMenu .birdseye").length > 0;
		if(!hasBEinList){
			$("#RadialMenu .switchSlot")
				.before(
					$(ce("div"))
						.addClass("slot birdseye")
						.addClass(self.getMapType() == "birdseye" ? "selected" : "")
						.attr({
							"tabindex": 0,
							"role": "option"
						})
						.append(
							$(ce("div"))
								.addClass("icon"),
							$(ce("div"))
								.addClass("pie-label labelStyle")
								.append("Bird's Eye"),
							$(ce("div"))
								.addClass("pie-label-description labelStyleDescription")
								.append("An angled view from above")
						)
						.on("click", function(){
							$("#RadialMenu .selected")
								.removeClass("selected");
							$(this)
								.addClass("selected");
							self.setMapType("be");
						})
				);
		}
	};
	
	moveMapSelector();
};

/**
 *
 * @method createControlPositions
 */
MapAdapterBingEight.prototype.createControlPositions = function() {
	var controls = [null, 'topLeft', 'topCenter', 'topRight', 'bottomLeft',
					'bottomCenter', 'bottomRight'];
	for(var i = 0, l = controls.length; i < l; i++) {
		var name = controls[i];
		if(!name) {
			continue;
		}

		var div = document.createElement('div');
		div.id = controls[i] + 'Controls';

		this.controls[i] = div;
		$(this.container).append(div);
	}
};

MapAdapterBingEight.prototype.eventMap = {
	'zoom': 'viewchange',
	'maptype': 'maptypechanged',
	'bounds': 'viewchange',
	'resize': 'viewchange',
	'tilesloaded': 'viewchange'
};

MapAdapterBingEight.prototype.getBingEvent = function(event){
	return this.eventMap[event] || event;
};

/**
 *	 
 * @method addMapListener
 * @param {} event
 * @param {} cbScope
 * @param {} callback
 */
MapAdapterBingEight.prototype.addMapListener = function(event, cbScope, callback) {
	var listener = function(mmName) {
		return function(bingName, e) {
			callback.call(this, mmName, e);
		}

	}(event);

	return this.addListener(this.map, event, cbScope, listener);
};

/**
 *
 * @method addListener
 * @param {} target
 * @param {} event
 * @param {} cbscope
 * @param {} callback
 */
MapAdapterBingEight.prototype.addListener = function(target, event, cbScope, callback) {
	var listener;
	try{
		var tEvent = this.getBingEvent(event);
		listener = Microsoft.Maps.Events.addHandler(target, tEvent, (function(event, scope, callback) {
			return function(e) {
				if (event) {
					callback.call(scope, event, e);
				}
			}
		}(event, cbScope, callback)));
	}catch(e){
		if(target._rootElement){
			listener = {
				"id": $.md5(event + new Date().getTime()),
				"target": target._rootElement,
				"event": event,
				"callback": (function(event, scope, callback) {
					return function(e) {
						if (event) {
							callback.call(scope, event, e);
						}
					}
				}(event, cbScope, callback))
			};
			
			$(listener.target).on(listener.event, listener.callback);
			
			this.generalEvents[listener.id] = listener;
			return listener;
		}
		
		if(target.layer){
			//Hack to deal with Bing map 8's removal of right click events on markers
			return this.addListener(target.layer, event, cbScope, callback);
		}
		
		console && console.log("Adding map event failed: " + event, "[" + e.message + "]");
	}
	return listener;
};



MapAdapterBingEight.prototype.getTrueTarget = function(cbScope, details){
	return cbScope.getMarkerByEntityId(details.primitive.entity.id);
};

/**
 *
 * @method removeMapListener
 * @param {} listener
 */
MapAdapterBingEight.prototype.removeMapListener = function(listener) {
	if(listener && listener.id){
		$(listener.target).off(listener.event, listener.callback);
		delete this.generalEvents[listener.id];
		return;
	}
	Microsoft.Maps.Events.removeHandler(listener);
};

/**
 *
 * @method getCenter
 */
MapAdapterBingEight.prototype.getCenter = function() {
	return (function(lat, lng) {
		return {
			lat: function() {	
				return lat;
			},
			lng: function() {
				return lng;
			}
		}
	}(this.map.getCenter().latitude, this.map.getCenter().longitude));		
};

/**
 *
 * @method setCenter
 * @param {} lat
 * @param {} lng
 * @param {} animate
 *
 */
MapAdapterBingEight.prototype.setCenter = function(lat, lng, animate) {
	if(typeof animate === 'undefined') {
		var animate = false;
	}

	this.map.setView({
		'animate': animate,
		'center': new Microsoft.Maps.Location(lat, lng)
	});
};

/**
 *
 * @method getZoom
 */
MapAdapterBingEight.prototype.getZoom = function() {
	return this.map.getZoom();
};

/**
 *
 * @method setZoom
 * @param {} level
 * @param {} animate
 */
MapAdapterBingEight.prototype.setZoom = function(level, animate) { // @TODO check if this is used
	if(typeof animate === 'undefined') {
		var animate = false;
	}

	this.map.setView({
		'animate': animate,
		'zoom': level
	});
};

/**
 *
 * @method fitbounds
 * @param {} points
 */
MapAdapterBingEight.prototype.fitBounds = function(points) {
	var locations = [];
	for (var i = 0, l = points.length; i < l; i++) {
		var xy = points[i];
		locations.push(new Microsoft.Maps.Location(xy[0], xy[1]));
	}

	this.map.setView({
		'bounds': Microsoft.Maps.LocationRect.fromLocations(locations)
	});
};

/**
 *
 * @method panTo
 * @param {} lat
 * @param {} lng
 */
MapAdapterBingEight.prototype.panTo = function(lat, lng) {
	this.setCenter(lat, lng, true);
};

/**
 *
 * @method panToBounds
 * @param {} lat1
 * @param {} lng1
 * @param {} lat2
 * @param {} lng2
 */
MapAdapterBingEight.prototype.panToBounds = function(lat1, lng1, lat2, lng2) {
	this.fitBounds([[lat1, lng1],[lat2, lng2]]);
};

/**
 *
 * @method getMapType
 */
MapAdapterBingEight.prototype.getMapType = function() {
	var type = this.map.getMapTypeId();
	if(type === Microsoft.Maps.MapTypeId.road) {
		return 'roadmap';
	} else if(type === Microsoft.Maps.MapTypeId.aerial) {
		return 'aerial';
	} else if(type === Microsoft.Maps.MapTypeId.birdseye) {
		return 'birdseye';
	} else { 
		return 'roadmap';
	}
};

/**
 *
 * @method getMapImagerySet
 */
MapAdapterBingEight.prototype.getMapImagerySet = function(){
	var acceptableRESTSets = ["Road", "Aerial", "Birdseye"];
	var adapterImagerySet = this.map.getImageryId() || "";
	var imagerySet = "Road";
	for(var i = 0, l = acceptableRESTSets.length; i < l; ++i){
		if(adapterImagerySet.search(acceptableRESTSets[i]) > -1){
			imagerySet = acceptableRESTSets[i];
		}
	}
	return imagerySet;
};

MapAdapterBingEight.prototype.getMaxZoom = function(){
	return this.map.getZoomRange().max;
};

/**
 *
 * @method getMapImagerySetForAPI
 * ("Birdseye" not enabled in Bing Maps API)
 */
MapAdapterBingEight.prototype.getMapImagerySetForAPI = function(){
	var acceptableRESTSets = ["Road", "Aerial"];
	var adapterImagerySet = this.map.getImageryId() || "";
	var imagerySet = "Road";
	for(var i = 0, l = acceptableRESTSets.length; i < l; ++i){
		if(adapterImagerySet.search(acceptableRESTSets[i]) > -1){
			imagerySet = acceptableRESTSets[i];
		}
	}
	return imagerySet;
};

/**
 *
 * @method setMapType
 * @param {} maptype
 */
MapAdapterBingEight.prototype.setMapType = function(mapType) {
	var id = this.getBingMapType(mapType);
	this.map.setView({
		'mapTypeId': id
	});
};

/**
 *
 * @method getBingMapType
 * @param {} mapType
 */
MapAdapterBingEight.prototype.getBingMapType = function(mapType) {
	if(mapType === "roadmap" || mapType === "r") {
		return Microsoft.Maps.MapTypeId.road;
	}else if(mapType === "aerial" || mapType === "a") {
		return Microsoft.Maps.MapTypeId.aerial;
	}else if(mapType === "birdseye" || mapType === "be") {
		return Microsoft.Maps.MapTypeId.birdseye;
	}else{
		return Microsoft.Maps.MapTypeId.road;
	}
};

/**
 *
 * @method addControlToMap
 * @parameter {} control
 */
MapAdapterBingEight.prototype.addControlToMap = function(control, mapOverlay) {
	if (mapOverlay) {
		this.container.appendChild(control.container);
	} else {
		if(control.precedence === 1) {
			var first = this.controls[control.position].firstChild;
			!!this.controls[control.position] &&
				this.controls[control.position].insertBefore(control.container, first);
		} else {
			!!this.controls[control.position] &&
				this.controls[control.position].appendChild(control.container);
		}
	}
};

MapAdapterBingEight.prototype.addControlInsideMap = function(control){
	$(this.map.getRootElement())
		.append(control.container);
};

/**
 *
 * @method resize
 */
MapAdapterBingEight.prototype.resize = function(){};

/**
 *
 * @method addMapLayer
 * @param {} layer
 */
MapAdapterBingEight.prototype.addMapLayer = function(layer, z) {
	
	z = (z || 0) + 1000;
	
	if(this.tileLayers[layer.id]) {
		throw new Error('Layer has already been added to the adapter');
	}

	// @LEAFLET - disabled this
	//disabled @LEAFLET; enabled this
	layer.updateDelta();
		
	var options = {
		'uriConstructor': (function(layer, caller) { 
			return function(tile) {
				return caller.getTileLayerUrl(tile, layer) || "";
			}
		}(layer, this))
	};
	var tileSource = new Microsoft.Maps.TileSource(options);
	var tileLayer = new Microsoft.Maps.TileLayer({
		'mercator': tileSource,
		'opacity': 1,
		'visible': false, 
		'zIndex': z
	});

	this.tileLayers[layer.id] = tileLayer;
};

/**
 *
 * @method getTileLayerUrl
 * @param {} tile
 * @param {} layer
 */
MapAdapterBingEight.prototype.getTileLayerUrl = function(tile, layer) {
	tile.levelOfDetail = tile.zoom;
	
	var url = layer.getUrl(tile);

	if(!url) {
		return undefined;
	}

	if (Moonshadow.server) {
		var MS = Moonshadow;
		url = MS.server + url;
		url += ['&user=', MS.user, '&key=', MS.key].join('');
	}

	return [url, '&d=', layer.settings.lastChange].join('');
};

/**
 * 
 * @method reloadLayers
 * @param {} layerId
 */
MapAdapterBingEight.prototype.reloadLayers = function(layerId) { // @CLEANUP could this be moved to the abstract?
	if(layerId) {
		this.reloadLayer(layerId);
	} else {
		$.each(this.tileLayers, function(k, v) {
			caller.reloadLayers(k);
		});
	}
};

/**
 *
 * @method reloadLayer
 * @param {}layerId
 */
MapAdapterBingEight.prototype.reloadLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	var map = this.map;
	var tileLayers = this.tileLayers;
	var layer = tileLayers[layerId];
	
	map.layers.remove(layer);
	map.layers.insert(layer);
};

/**
 *
 * @method showMapLayer
 * @param {} layerId
 */
MapAdapterBingEight.prototype.showMapLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	tileLayer.setOptions({'visible': true});
	
	var map = this.map;
	if(map.entities.indexOf(tileLayer) === -1) {
		map.layers.insert(tileLayer);
	}

	this.manager.notify("tilesloaded")
};

/**
 *
 * @method hideMapLayer
 * @param {} layerId
 */
MapAdapterBingEight.prototype.hideMapLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	tileLayer.setOptions({'visible': false});	
	this.map.layers.remove(tileLayer);
};

/**
*
* @method destroyMapLayer
* @param {} layerId
*/
MapAdapterBingEight.prototype.destroyMapLayer = function(layerId) {
	var tileLayer = this.getTileLayer(layerId);
	if(!tileLayer) {
		throw new Error('Invalid layer id');
	}

	tileLayer.setOptions({'visible': false});
	this.map.layers.remove(tileLayer);
	
	delete this.tileLayers[layerId];
};

/**
 *
 * @method get TileLayer
 * @param {} layerId
 */
MapAdapterBingEight.prototype.getTileLayer = function(layerId) {
	return this.tileLayers[layerId] || undefined;	
};

/**
 *
 * @method getBounds
 */
MapAdapterBingEight.prototype.getBounds = function() {
	var rect = this.map.getBounds();
	return {
		'neLat': rect.getNorth(),
		'neLon': rect.getEast(),
		'swLat': rect.getSouth(),
		'swLon': rect.getWest()
	};
};

/**
 *
 * @method getAntiBounds
 */
MapAdapterBingEight.prototype.getAntiBounds = function(){
	var nw = this.map.getBounds().getNorthwest();
	var se = this.map.getBounds().getSoutheast();
	return {
		'nwLat': nw.latitude,
		'nwLon': nw.longitude,
		'seLat': se.latitude,
		'seLon': se.longitude
	};
};

/**
 *
 * @method enableCrosshair
 */
MapAdapterBingEight.prototype.enableCrosshair = function() {
	this.map.getRootElement().style.cursor = 'crosshair';
	this.showCrosshair = true;
};

/**
 *
 * @method disableCrosshair
 */
MapAdapterBingEight.prototype.disableCrosshair = function() {
	this.map.getRootElement().style.cursor = '';
	this.showCrosshair = false;
};

/**
 *
 * @method getLatLngFromXY
 * @param {} x
 * @param {} y
 */
MapAdapterBingEight.prototype.getLatLngFromXY = function(x, y) {
	var location = this.map.tryPixelToLocation(new Microsoft.Maps.Point(x, y));
	return this.latLng(location.latitude, location.longitude);
};

/**
 *
 * @method infoWindow
 */
/* Below this line is marker stuff */
MapAdapterBingEight.prototype.infoWindow = function() {
	var options = { 
		"offset": new Microsoft.Maps.Point(0, 25),
	    "showArrow": true,
	    "showCloseButton": true,
	    "tether": true,
	    "arrowLength": 30,
	    "arrowWidth": 20,
	    "borderColor": "#888",
	    "color": "#fff",
	    "orientation": 1
	};

	return new CustomInfobox(this.map, options);
};

/**
 *
 * @method closeInfoWindowListener
 * @param {} balloon
 * @param {} map
 */
MapAdapterBingEight.prototype.closeInfoWindowListener = function(balloon, map) {
	//balloon.setOptions({'visible': false});
};

/**
 *
 * @method latLng
 * @param {} lat
 * @param {} lng
 */
MapAdapterBingEight.prototype.latLng = function(lat, lng) {
	var loc = new Microsoft.Maps.Location(lat, lng);
	loc.lat = function() {
		return this.latitude;
	};
	loc.lng = function() {
		return this.longitude;
	};
	return loc;		
};

/**
 *
 * @method setMarkerIcon
 * @param {} marker
 * @param {} url
 * @param {} anchorX
 * @param {} anchorY
 * @param {} width
 * @param {} height
 *
 */
MapAdapterBingEight.prototype.setMarkerIcon = function(marker, url, anchorX, anchorY, width, height) {
	// Marker != Pushin, marker is an object made by MControlMarkers
	var options = {
		'icon': url,
		'anchor': new Microsoft.Maps.Point(anchorX || 0, anchorY || 0),
		'height': height || 36,
		'width': width || 22,
		'visible': true
	};

	marker.marker.setOptions(options);
};

/**
 *
 * @method addMarkerLsnr
 * @param {} marker
 * @param {} callback
 */
MapAdapterBingEight.prototype.addMarkerLsnr = function(marker, callback) {
	return Microsoft.Maps.Events.addHandler(marker.marker, 'click', (function(marker, callback) {
		return function() {
			callback.call(marker);
		};
	}(marker.marker, callback)));
};

/**
 *
 * @method clearMarker
 * @param {} marker
 */
// @CLEANUP this function is very pooly named
// It really removes polygons/polyline/markers from the map
MapAdapterBingEight.prototype.clearMarker = function(marker) {
	// @CLEANUP thie whole marker.marker thing is silly
	return (this.map.entities.remove(marker.marker)) ? true : false;
};

/**
 *
 * @method removeEntity
 * @param {} entity
 */
MapAdapterBingEight.prototype.removeEntity = function(entity) {
	// the whole marker.marker thing is dumb
	this.clearMarker({'marker': entity});
};

/** 
 *
 * @method clearAllMarkers
 * @param {} markers
 */
MapAdapterBingEight.prototype.clearAllMarkers = function(markers) {
	for(var i in markers) {
		this.clearMarker(markers[i]);
	}
};

/**
 *
 * @method getMarker
 * @param {} details
 */
MapAdapterBingEight.prototype.getMarker = function(details) {
	var MSMaps = Microsoft.Maps;
	var position = details.position;

	var options = {
		'visible': false
	};

	if(details.draggable) {
		options.draggable = true; // As draggable
	}

	if(details.icon) {
		options.icon = details.icon;

		var dim = details.iconDim;
		if(dim) {
			options.width = dim[0];
			options.height = dim[1];
		}
		
		var anchor = details.iconAnchor;
		if(anchor) {
			options.anchor = new MSMaps.Point(anchor[0], anchor[1]);
		}
	}

	var pushpin = new MSMaps.Pushpin(position, options);
	pushpin.markerType = details.markerType;

//	if(options.draggable) {
//		// Event bindings
//		this.addListener(pushpin, 'dragstart', this, this.markerStartDrag);
//		this.addListener(pushpin, 'drag', this, this.markerDrag);
//		this.addListener(pushpin, 'dragend', this, this.markerEndDrag);
//	}

	pushpin.Id = (details.markerId) ? details.markerId : [position.latitude, position.longitude].join('');

	this.map.entities.push(pushpin);
	return pushpin;
};

/**
 *
 * @method openInfoWindow
 * @param {} infobox
 * @param {} map
 * @param {} marker
 * @param {} content
 *
 */
MapAdapterBingEight.prototype.openInfoWindow = function(infobox, map, marker, content) {
	var location = marker.getLocation();

	var contentScroller = $(document.createElement('div'))
		.addClass("infowindow_scroller")
		.append(content);
		
	var options = {
		"visible": true,
		"maxWidth": 250,
		"maxHeight": 400,
		"minWidth": 250,
		"minHeight": 200,
	};
	
	infobox.setOptions(options);
	infobox.show(marker.getLocation(), $(contentScroller).get(0).outerHTML);

	//adjust canvasser balloon
//	var canvElem = $("." + marker.Id)
//		.closest(".Infobox")
//		.parent();
//	
//	if(canvElem && canvElem.length){
//		$(canvElem)
//			.addClass("canvasser_infobox");
//		marker.infoBoxContainer = canvElem;
//	}
};

/** 
 *
 * @method closeInfoWindow
 * @param {} infobox
 * @param {} map
 */
MapAdapterBingEight.prototype.closeInfoWindow = function(infobox, map) {
	infobox.hide();
	this.manager.mapObservers.notify("infowindowclosed");
};

/**
 *
 * @method getContentDim
 * @param {} content
 */
MapAdapterBingEight.prototype.getContentDim = function(content) {
	var temp = document.createElement("div");
	temp.style.display = "none";
	temp.appendChild(content);

	this.container.appendChild(temp);

	var width = $(temp).innerWidth();
	var height = $(temp).innerHeight();

	$(temp).remove();
	return [width, height];
};

MapAdapterBingEight.prototype.getLocation = function(point) {
	return new Microsoft.Maps.Location(point[0], point[1]);
};

MapAdapterBingEight.prototype.getLocations = function(points) {
	var locations = [];
	for(var i = 0, l = points.length; i < l; i++) {
		locations.push(this.getLocation(points[i]));
	}

	return locations;		
};


MapAdapterBingEight.prototype.getPointFromEvent = function(event) {
	return [event.pageX, event.pageY];
};

MapAdapterBingEight.prototype.getLocationFromEvent = function(event) {
	var loc = this.map.tryPixelToLocation(
		new Microsoft.Maps.Point(event.getX(), event.getY())
	);

	return this.latLng(loc.latitude, loc.longitude);
};

MapAdapterBingEight.prototype.isRightClick = function(event) {
	return !!event.isSecondary;
};

MapAdapterBingEight.prototype.preventDefault = function(event) {
	event.handled = true;
};

MapAdapterBingEight.prototype.addEventListener = function(event, listener, entityHolder) {
	var entity = entityHolder.getMapEntity();
	if (entity) {
		return this.addListener(entity, event, entityHolder, function(eventName, event) {
			listener.call(entityHolder, eventName, event.entity || event);
		});
	}
};

MapAdapterBingEight.prototype.removeEventListener = function(handler) {
	Microsoft.Maps.Events.removeHandler(handler);
};

MapAdapterBingEight.prototype.panToPoints = function(points) {
	var locs = this.getLocations(points);
	if (!locs.length) {
		return;
	}		

	this.map.setView({
		'bounds': Microsoft.Maps.LocationRect.fromLocations(locs)
	});		
};

MapAdapterBingEight.prototype.panToShape = function(shape) {
	var points = shape.getPoints();

	this.panToPoints(points);
};

MapAdapterBingEight.prototype.createBingPolyline = function(polyline) {
	var entity = polyline.getMapEntity();
	if (!entity) {
		var locations = this.getLocations(polyline.getPoints())
		if (!location.length){
			var center = this.map.getCenter();
			locations = [new Microsoft.Maps.Location(center.latitude, center.longitude)];
		}
		var options = this.getPolylineOptions(polyline);
		entity = new Microsoft.Maps.Polyline(locations, options);
	}

	return entity;
};

MapAdapterBingEight.prototype.addPolyline = function(polyline) {
	var entity = this.createBingPolyline(polyline);
	this.map.entities.push(entity);
	return entity;
};

MapAdapterBingEight.prototype.updatePolylinePoints = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		var locations = this.getLocations(polyline.getPoints())
		entity.setLocations(locations);
	}
};

MapAdapterBingEight.prototype.updatePolylineOptions = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		var options = this.getPolylineOptions(polyline);
		entity.setOptions(options);
	}
};

MapAdapterBingEight.prototype.removePolyline = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingEight.prototype.getPolylineOptions = function(polyline) {
	var color = Microsoft.Maps.Color.fromHex(polyline.lineColor)
	color.a = polyline.lineAlpha;

	var options = {
		'strokeColor': color,
		'strokeDashArray': polyline.lineStyle,
		'strokeThinkness': polyline.lineThickness
	};

	return options;
};

MapAdapterBingEight.prototype.createBingPolygon = function(polygon) {
	var entity = polygon.getMapEntity();
	if (!entity) {
		var locations = this.getLocations(polygon.getPoints())
		var options = this.getPolygonOptions(polygon);
		entity = new Microsoft.Maps.Polygon(locations, options);
	}

	return entity;
};

MapAdapterBingEight.prototype.addPolygon = function(polygon) {
	var entity = this.createBingPolygon(polygon);
	this.map.entities.push(entity);
	return entity;
};

MapAdapterBingEight.prototype.updatePolygonPoints = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		var locations = this.getLocations(polygon.getPoints());
		if(!locations.length){
			return;
		}
		entity.setLocations(locations);
	}
};

MapAdapterBingEight.prototype.updatePolygonOptions = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		var options = this.getPolygonOptions(polygon);
		entity.setOptions(options);
	}
};

MapAdapterBingEight.prototype.removePolygon = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingEight.prototype.getPolygonOptions = function(polygon) {
	var MSMaps = Microsoft.Maps;

	var fillColor = MSMaps.Color.fromHex(polygon.fillColor);
	fillColor.a = polygon.fillAlpha;

	var lineColor = MSMaps.Color.fromHex(polygon.lineColor);
	lineColor.a = polygon.lineAlpha;

	var options = {
		'fillColor': fillColor.toRgba(),
		'strokeColor': lineColor.toRgba(),
		'strokeDashArray': polygon.lineStyle,
		'strikeThinkness': polygon.lineThickness
	};

	return options;
};

MapAdapterBingEight.prototype.createBingCircle = function(circle) {
	var entity = circle.getMapEntity();
	if (!entity) {
		var center = this.getLocation(circle.getCenter())
		var distance = circle.getRadiusMeters();
		var options = this.getCircleOptions(circle);
		entity = new BM.Circle(center, distance, 'm', options);
	}

	return entity;
};

MapAdapterBingEight.prototype.addCircle = function(circle) {
	var entity = this.createBingCircle(circle);
	this.map.entities.push(entity);
	return entity;
};

MapAdapterBingEight.prototype.updateCirclePoints = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		var center = this.getLocation(circle.getCenter());
		var distance = circle.getRadiusMeters();
		entity.setCenter(center);
		entity.setRadius(distance);			
	}
};

MapAdapterBingEight.prototype.updateCircleOptions = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		var options = this.getCircleOptions(circle);
		entity.setOptions(options);
	}
};

MapAdapterBingEight.prototype.removeCircle = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingEight.prototype.getCircleOptions = function(circle) {
	var MSMaps = Microsoft.Maps;

	var fillColor = MSMaps.Color.fromHex(circle.fillColor);
	fillColor.a = circle.fillAlpha;

	var lineColor = MSMaps.Color.fromHex(circle.lineColor);
	lineColor.a = circle.lineAlpha;

	var options = {
		'fillColor': fillColor,
		'strokeColor': lineColor,
		'strokeDashArray': circle.lineStyle,
		'strokeThinkness': circle.lineThickness
	};

	return options;
};

MapAdapterBingEight.prototype.createBingPushpin = function(marker) {
	var entity = marker.getMapEntity();
	if (!entity) {
		var location = this.getLocation(marker.getPoint())
		var options = this.getMarkerOptions(marker);
		entity = new Microsoft.Maps.Pushpin(location, options);
	}
	return entity;			
};

MapAdapterBingEight.prototype.addMarker = function(marker) {
	var entity = this.createBingPushpin(marker);
	this.map.entities.push(entity);
	return entity;
};

MapAdapterBingEight.prototype.updateMarkerPoint = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		var location = this.getLocation(marker.getPoint())
		entity.setLocation(location);
	}
};

MapAdapterBingEight.prototype.updateMarkerOptions = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		var options = this.getMarkerOptions(marker);
		entity.setOptions(options);
	}
};

MapAdapterBingEight.prototype.hideMarker = function(marker) {
	marker.setIcon('');
	marker.addEventListener('dragend', marker.hide, marker);
};

MapAdapterBingEight.prototype.removeMarker = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		this.map.entities.remove(entity);
	}
};

MapAdapterBingEight.prototype.getMarkerOptions = function(marker) {
	var anchor = new Microsoft.Maps.Point(marker.anchor[0], marker.anchor[1]);
	var options = {
		'anchor': anchor,
		'draggable': marker.draggable,
		'height': marker.height,
		'icon': marker.icon,
		'width': marker.width,
		'zIndex': marker.zIndex
	};

	return options;
};

MapAdapterBingEight.prototype.getMarkerPoint = function(markerEntity) {
	var loc = markerEntity.location;
	return [loc.latitude, loc.longitude];
};


/*******************************************************************************
* Author: Ricky Brundritt
* Website: http://rbrundritt.wordpress.com
* Date: May 21nd, 2011
* 
* Description: 
* This JavaScript file is meant to create a infobox control that is highly 
* customizable, reusable, and easy to extend. This method takes in a map 
* reference, and a set of options. 
* 
* Example Usage:
*
* var map, customInfobox;
*
* function GetMap()
* {
*	var map = new Microsoft.Maps.Map(document.getElementById("myMap"),{ credentials: "YOUR_BING_MAPS_KEY" });
*	
*	Microsoft.Maps.registerModule("CustomInfoboxModule", "scripts/V7CustomInfobox.min.js");
*	    Microsoft.Maps.loadModule("CustomInfoboxModule", { callback: function () {
*	        customInfobox = new CustomInfobox(map);
*	    }
*	});
* }
*
* //Have data be returned from data source and added to the cluster layer
* function ClusterLayer(results)
* {
* 	clusteredLayer.SetData(results);
* }
*
* function displayInfobox() {
*	customInfobox.show(map.getCenter(), "Hello World");
*}
********************************************************************************/

var CustomInfobox = function (map, options) {
    var _map = map,
    _content,
    _anchor,
    _infoboxContainerId,
    _handlerId;

    var _options = {
        arrowColor: '#fff',     //Color of the arrow
        arrowLength: 20,        //Length of the arrow
        arrowWidth: 30,         //Width of the arrow
        borderColor: '#000',    //Color of the infobox border
        color: '#fff',          //Background color of infobox
        minHeight: 50,          //Minium height of the content area of the infobox
        minWidth: 100,          //Minimium width of the content area of the infobox
        offset: { x: 0, y: 0 }, //Offset distance of the infobox
        orientation: 0,         //Orientation of the infobox: 0 - horizontal, 1 - vertical
        showArrow: true,
        showCloseButton: true,
        tether: false
    };

    /*********************** Private Methods ****************************/

    //Inialization method
    function _init() {
        //Create an id for the infobox
        _infoboxContainerId = map.getRootElement().parentNode.id + "_infobox";

        //Create infobox container
        $('body').append("<div id='" + _infoboxContainerId + "' style='position:absolute;z-index:990;display:none;'></div>");

        //initialize default tethering 
        _enableTethering(_options.tether);

        //Set user options
        _setOptions(options);
    }

    //Method for generating the infobox arrow
    function _createArrow(direction) {
        var html = ["<div id='", _infoboxContainerId, "_arrow' style='position:relative;float:left;width:0;height:0;line-height:0;border-style:solid;"];
        var w = _options.arrowWidth * 0.5;
        switch (direction) {
            case 0: 	//Point up
                html.push("border-width:0 ", w, "px ", _options.arrowLength, "px ", w, "px;");
                html.push("border-color:transparent transparent ", _options.arrowColor, " transparent;");
                break;
            case 1: 	//Point Right
                html.push("border-width:", w, "px 0 ", w, "px ", _options.arrowLength, "px;");
                html.push("border-color:transparent transparent transparent ", _options.arrowColor, ";");
                break;
            case 2: 	//Point Down
                html.push("border-width:", _options.arrowLength, "px ", w, "px 0 ", w, "px;");
                html.push("border-color:", _options.arrowColor, " transparent transparent transparent;");
                break;
            case 3: 	//Point Left
                html.push("border-width:", w, "px ", _options.arrowLength, "px ", w, "px 0;");
                html.push("border-color:transparent ", _options.arrowColor, " transparent transparent;");
                break;
        }

        html.push("'></div>");

        return html.join('');
    }

    //method that controls is the 
    function _enableTethering(tether) {
        if (_handlerId != null) {   //Remove existing event handler
            Microsoft.Maps.Events.removeHandler(_handlerId);
        }

        if (tether) {   //update infobox when map is moving
            _handlerId = Microsoft.Maps.Events.addThrottledHandler(_map, 'viewchange', _render, 40);
        } else {        //hide infobox when map is moved
            _handlerId = Microsoft.Maps.Events.addHandler(_map, 'viewchangestart', _hide);
        }
    }

    //Hides the infobox from view
    function _hide() {
        //clear content and anchor information
        _anchor = null;
        _content = null;

        //Rerender infobox causes it to hide when there are no content or anchor
        _render();
    }

    //Generates the infobox UI
    function _render() {
        var container = $('#' + _infoboxContainerId);

        if (container != null && _anchor != null && _content != null) {
            if (!_map.getBounds().contains(_anchor)) {  //hide if anchor is anchor latlong on the map
                container.css('display', 'none');
            } else {
                container.css('display', '');
                var pinPixel = _map.tryLocationToPixel(_anchor, Microsoft.Maps.PixelReference.control),
                screenX = _map.getPageX() + pinPixel.x,
                screenY = _map.getPageY() + pinPixel.y;

                var key = (_map.getHeight() * 0.5 < pinPixel.y) ? 2 : 0; //Determine the quadrant that the pushpin is in. 
                key += (_map.getWidth() * 0.5 < pinPixel.x) ? 1 : 0;

                //Wrap contents
                var contents = ["<div id='", _infoboxContainerId, "_content' style='position:relative;float:left;border:1px solid ", _options.borderColor, ";background-color:", _options.color, ";min-width:", _options.minWidth, "px;min-height:", _options.minHeight, "px;'>", _content, "</div>"];

                var arrowX = 0, arrowY = 0, html;

                if (_options.showArrow) {
                    if (_options.orientation) { //vertical arrow
                        arrowX = _options.arrowWidth;
                        arrowY = _options.arrowLength;

                        if (key > 1) {  //down
                            html = contents.join('') + _createArrow(2);
                        } else {        //up
                            html = _createArrow(0) + contents.join('');
                        }
                    } else {
                        arrowX = _options.arrowLength;
                        arrowY = _options.arrowWidth;

                        if (key % 2) {  //right arrow
                            html = contents.join('') + _createArrow(1);
                        } else {        //left
                            html = _createArrow(3) + contents.join('');
                        }
                    }
                } else {
                    html = contents.join('');
                }

                container.html(html);

                //Get Width and Height of Contents
                var contentContainer = $('#' + _infoboxContainerId + '_content');

                //Add close button if enabled
                if (_options.showCloseButton) {
                    contentContainer.append("<span id='" + _infoboxContainerId + "_closeBtn' href='javascript:void()' style='position:absolute;right:5px;top:2px;cursor:pointer;font:bold 18px Arial;line-height:12px;'>x</span>");
                    $('#' + _infoboxContainerId + '_closeBtn').click(function () {
                        _hide();
                    });
                }

                //Get dimensions of contents
                var contentX = contentContainer.outerWidth(),
                    contentY = contentContainer.outerHeight();

                var w = 0, h = 0, arrowOffsetTop = 0, arrowOffsetLeft = 0;
                var locationClass = [];
                
                //Calculate dimensions of infobox container
                if (_options.orientation) {
                    w = contentX;
                    h = contentY + arrowY;

                    if (key % 2) {  //content left
                        arrowOffsetLeft = w - _options.arrowWidth;
                        screenX += _options.offset.x - w + _options.arrowWidth * 0.5;
                        locationClass[1] = "left";
                    } else {
                        screenX += _options.offset.x - _options.arrowWidth * 0.5;
                        locationClass[1] = "right";
                    }

                    if (key > 1) {  //bottom
                        screenY -= h + _options.offset.y;
                        locationClass[0] = "top";
                    } else {
                        screenY -= _options.offset.y;
                        locationClass[0] = "bottom";
                    }
                } else {
                    w = arrowX + contentX + 2;  //The 2 is to make up for the boarder on the contents
                    h = Math.max(contentY, arrowY);

                    if (key % 2) {  //right arrow
                        screenX += _options.offset.x - w;
                    } else {        //left
                        screenX += _options.offset.x;
                    }

                    if (key > 1) {
                        arrowOffsetTop = h - _options.arrowWidth;
                        screenY -= h - _options.arrowWidth * 0.5 + _options.offset.y;
                    } else {
                        screenY -= (_options.arrowWidth * 0.5 + _options.offset.y);
                    }
                }

                if (_options.showArrow) {
                    var arrow = $('#' + _infoboxContainerId + '_arrow');
                    arrow.css({ 'margin-left': Math.ceil(arrowOffsetLeft) + 'px', 'margin-top': Math.ceil(arrowOffsetTop) + 'px' });
                }

                container
                	.attr("class", locationClass.join("_"))
                	.css({ 'width': Math.ceil(w) + 'px', 'height': Math.ceil(h) + 'px', 'top': screenY, 'left': screenX });
                
            }
            _options.onRender && _options.onRender(container);
        } else if (container != null) {    //hide infobox
            container.html('');
            container.css('display', 'none');
        }
       
    }

    //Updates the default options with new options
    function _setOptions(options) {
        var tetherVal = _options.tether;

        for (attrname in options) {
            _options[attrname] = options[attrname];
        }

        if (tetherVal != _options.tether) {
            _enableTethering(_options.tether);
        }

        if(options.onRender){
        	_options.onRender = options.onRender;
        }
        
        _render();
    }

    /*********************** Public Methods ****************************/

    //Hide the infobox
    this.hide = function () {
        _hide();
    };

    //show infobox
    this.show = function (latlong, content) {
        _anchor = latlong;
        _content = content;
        _render();
    };

    /**
    * @returns The custom infobox options.
    */
    this.getOptions = function () {
        return _options;
    };

    /**
    * Sets the custom infobox options.
    * Example: customInfobox.SetOptions({ gridSize : 30});
    */
    this.setOptions = function (options) {
        _setOptions(options);
    };

    _init();
};

/***************************************************************
* Canvas Pushpin Module
*
* Author: Ricky Brundritt
* Website: http://rbrundritt.wordpress.com
* Date: Feb 12th, 2013
* 
* This module creates two classes called Circle and RegularPolygon 
* which are under the Namespace BM. These class wrap the Polygon 
* class in Bing Maps to provide additional shapes templates.
*
* Based on: http://rbrundritt.wordpress.com/2011/06/10/advance-shapes-in-bing-maps-v7/
* Also mostly extracted from the GeoRSS Module: 
*
* Classes:
* --------
* 
* BM.Circle
*
*   This class derives from the RegularPolygon class but has a set 
*   number of node points that makes the polygon look like a circle.
*
*   Constuctor: BM.Circle(center, radius, distanceUnits, options)
*
*   center - Center of shape as a Microsoft.Maps.Location object
*   radius - Radius of the shape as a number
*   distanceUnits - Distance units used by the radius. Takes in a string value of; 'm' (meters), 'ft' (feet), 'mi' (miles), 'km' (kilometers)
*   options - Polygon options used to render shape as a Microsoft.Maps.PolygonOptions object
*
*   Usage:
*   
*   circle = new BM.Circle(map.getCenter(), 1000, 'km', {
*            fillColor: new Microsoft.Maps.Color(100,0,0,255), 
*            strokeColor: new Microsoft.Maps.Color(200,0,255,0),
*            strokeThickness: 5
*        });
*
*   map.entities.push(circle);
*
*
* BM.RegularPolygon
*
*   This class generates regular polygons. This is useful for creating 
*   shapes like triangles, squares, pentagons or circles.
*
*   Constuctor: BM.RegularPolygon(center, radius, distanceUnits, nodeSize, offset, options)
*
*   center - Center of shape as a Microsoft.Maps.Location object
*   radius - Radius of the shape as a number
*   distanceUnits - Distance units used by the radius. Takes in a string value of; 'm' (meters), 'ft' (feet), 'mi' (miles), 'km' (kilometers)
*   nodeSize - Number of nodes (points) the shape should have.
*   offset - The angle to rotate the shape in degrees.
*   options - Polygon options used to render shape as a Microsoft.Maps.PolygonOptions object
*
*   Usage:
*
*   var poly = new BM.RegularPolygon(map.getCenter(), 1000, 'km', 3, 15, {
*        fillColor: new Microsoft.Maps.Color(100, 0, 0, 255),
*        strokeColor: new Microsoft.Maps.Color(200, 0, 255, 0),
*        strokeThickness: 5
*    });
*
*    map.entities.push(poly);
* 
*
*   Methods - In both Circle and RegularPolygon class
*     getCenter - returns the center of the shape
*     getDistanceUnits - returns the distance units used by the radius
*     getNodeSize - returns the number of points used to create shape
*     getOffset - returns the offset used to rotate the shape in degrees
*     getRadius - returns the radius of the shape
*     setCenter - changes the location of the shape. Takes in a Microsoft.Map.Location object
*     setDistanceUnits - changes the distance units used by the radius. Takes in a string value of; 'm' (meters), 'ft' (feet), 'mi' (miles), 'km' (kilometers)
*     setNodeSize - changes the number of points used to create the shape. Takes in an integer.
*     setOffset - changes the amount of offset used to rotate the shape. Takes in a number.
*     setRadius - changes the radius of the shape. Takes in a disance as a number.   
*     All methods for the Microsoft.Maps.Polygon class are also available
*
***************************************************************/

(function () {
    //Create a Namespace called BM
    if (typeof BM == 'undefined') {
        BM = {};
    }

    var _defaultNodeSize = 72, //Number node points to use to create circle.
        EARTH_RADIUS_METERS = 6378100,
        EARTH_RADIUS_KM = 6378.1,
        EARTH_RADIUS_MILES = 3963.1676,
        EARTH_RADIUS_FEET = 20925524.9;

    if (typeof BM.Circle == 'undefined') {
        BM.Circle = function(center, radius, distanceUnits, options){       
            return new BM.RegularPolygon(center, radius, distanceUnits, _defaultNodeSize, 0, options);      
        };
    }

    if (typeof BM.RegularPolygon == 'undefined') {
        BM.RegularPolygon = function(center, radius, distanceUnits, nodeSize, offset, options){   
            var points = [];
            var _basePolygon;

            var _refreshPoly = function(){
                points = generateRegularPolygonPoints(center, radius, getEarthRadius(distanceUnits), nodeSize, offset);

                if(!_basePolygon){
                    _basePolygon = new Microsoft.Maps.Polygon(points, options);
                }
            
                _basePolygon.setLocations(points);
            };

            _refreshPoly();

            _basePolygon.getCenter = function(){
                return center;
            };

            _basePolygon.getDistanceUnits = function(){
                return distanceUnits;
            };

            _basePolygon.getNodeSize = function(){
                return nodeSize;
            };

            _basePolygon.getOffset = function(){
                return offset;
            };

            _basePolygon.getRadius = function(){
                return radius;
            };
        
            _basePolygon.setCenter = function(c){
                center = c;
               _refreshPoly();
            };

            _basePolygon.setDistanceUnits = function(du){
                distanceUnits = du;
                _refreshPoly();
            };

            _basePolygon.setNodeSize = function(ns){
                nodeSize = ns;
               _refreshPoly();
            };

            _basePolygon.setOffset = function(off){
                offset = off;
               _refreshPoly();
            };

            _basePolygon.setRadius = function(r){
                radius = r;
                _refreshPoly();
            };
        
            return _basePolygon;
        };
    }

    /*
    * Private Functions
    */
    function getEarthRadius(distanceUnits){
        switch(distanceUnits.toLowerCase()){
            case 'm':
            case 'meters':
                return EARTH_RADIUS_METERS;
            case 'ft':
            case 'feet':
                return EARTH_RADIUS_FEET;
            case 'mi':
            case 'miles':
                return EARTH_RADIUS_MILES; 
            case 'km':
            case 'kilometers':
            default:
                return EARTH_RADIUS_KM;
        }
    }

    function generateRegularPolygonPoints(centerPoint, radius, earthRadius, nodeSize, offset) {
        var points = [],
            centralAngle = 360 / nodeSize;

        for (var i = 0; i <= nodeSize; i++) {
            points.push(calculateCoord(centerPoint, (i * centralAngle + offset) % 360, radius, earthRadius));
        }

        return points;
    }

    function calculateCoord(origin, brng, arcLength, earthRadius) {
        var lat1 = origin.latitude * Math.PI / 180,
            lon1 = origin.longitude * Math.PI / 180,
            centralAngle = arcLength / earthRadius;

        var lat2 = Math.asin(Math.sin(lat1) * Math.cos(centralAngle) + Math.cos(lat1) * Math.sin(centralAngle) * Math.cos(brng * Math.PI / 180));
        var lon2 = lon1 + Math.atan2(Math.sin(brng * Math.PI / 180) * Math.sin(centralAngle) * Math.cos(lat1), Math.cos(centralAngle) - Math.sin(lat1) * Math.sin(lat2));

        return new Microsoft.Maps.Location(lat2 * 180 / Math.PI, lon2 * 180 / Math.PI);
    }
})();






































/**
 * Map adapter class for leadflet (OSM)
 *
 * @class MapAdapterLeaflet
 * @extends Moonshadow.MMapAdapter
 * @constructor
 * @param {} manager
 * @param {} options
 */
function MapAdapterLeaflet(manager, options) {
	this.name = MapAdapterLeaflet.config.name;
	this.showCrosshair = false;
	this.initialize(manager, options);	
};

MoonshadowHelpers.extend(MapAdapterLeaflet, MMapAdapter);

MapAdapterLeaflet.config = {
	'name': 'leaflet',
	'desc': "Open Street Maps",
	'enabled': true,
	'available': true,
	'library': '/static/js/leaflet.js',
	'adapterName': 'leaflet',
	'isLibraryReady':  function() { 
		return typeof L === 'object';
	},
	'factory': function(manager, mapOptions) {
		return new MapAdapterLeaflet(manager, mapOptions);
	}
};

/**
 * Init function called by MMapAdapter on creation
 *
 * @method init
 */
MapAdapterLeaflet.prototype.init = function() {
	this.container = this.setupMapContainer();
	this.leafletEvents = this.reverseEventMap();
	this.map = this.setupMap();
	this.createControlPositions();
	this.bindBasicEvents();
	this.emitMapLoaded();
};

/**
 * Prepare leaflet map
 *
 * @method setupMap
 */
MapAdapterLeaflet.prototype.setupMap = function() {
	var pos = this.getInitialPosition();
	var options = {
		'center': [pos[0], pos[1]],
		'zoom': pos[2],
		'zoomAnimation': false
		//'maxZoom': 18
	};

	var map = L.map(this.container, options);
	//since this is not https, mixed content error is inevitable 
	var url = 'http://tile.openstreetmap.org/{z}/{x}/{y}.png';
	var attribution = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
	var mapLayer = L.tileLayer(url, {'maxZoom': 18, 'attribution': attribution});
	mapLayer.addTo(map);

	// Block right click
	map.on('contextmenu', function() {}, map);

	return map;
};

/**
 * Reverse event map
 *
 * We need to reverse the event map so we can lookup abstracted events
 * from leaflet events
 *
 * @method reverseEventMap
 * @return {Object} reversed eventMap
 */ 
MapAdapterLeaflet.prototype.reverseEventMap = function() {
	var map = {};
	for (var i in this.eventMap) {
		map[this.eventMap[i]] = i;
	}

	return map;
};

/**
 * Set map container style to show crosshair for cursor
 *
 * @method enableCrosshair
 */
MapAdapterLeaflet.prototype.enableCrosshair = function() {
	this.map.getContainer().style.cursor = 'crosshair';
	this.showCrosshair = true;
};

/**
 * Set map container style to show default cursor
 *
 * @method disableCrosshair
 */
MapAdapterLeaflet.prototype.disableCrosshair = function() {
	this.map.getContainer().style.cursor = '';
	this.showCrosshair = false;
};

/**
 * Prepare elements that will contain buttons, controls that overlay map
 * 
 * @method cereateControlPositions
 */
MapAdapterLeaflet.prototype.createControlPositions = function() {
	var controls = [null, 'topLeft', 'topCenter', 'topRight', 'bottomLeft',
					'bottomCenter', 'bottomRight'];

	for(var i = 0, l = controls.length; i < l; i++) {
		var name = controls[i];
		if(!name) {
			continue;
		}

		var div = document.createElement('div');
		div.id = controls[i] + 'Controls';
		this.controls[i] = div;

		L.DomEvent.disableClickPropagation(div);

		this.container.appendChild(div);
	}
};

/**
 * Registers MTileLayer with map adapter
 *
 * @method addMapLayer
 * @param 
 */
MapAdapterLeaflet.prototype.addMapLayer = function(layer, z) {
	if (this.tileLayers[layer.layerId]) {
		throw new Error('Layer has already been added to the adapter');
	}

	layer.addObserver('tilesloaded', this.onTilesLoaded, this);

	// Use special layer provided by custom module
	// https://github.com/ismyrnow/Leaflet.functionaltilelayer
	// This is needed to make a leaflet layer that behaves like 
	// Google maps and Bing
	var tileLayer = new L.TileLayer.Functional(function(layer, caller) {
		return function(tile) {
			return caller.getTileLayerUrl(layer, tile); 
		}
	}(layer, this), {zIndex: z || 0});
	tileLayer.on('load', layer.tilesLoadedHandler());

	this.tileLayers[layer.id] = tileLayer;
};

/**
 * Emites tilesloadded event
 *
 * @method onTilesLoaded
 */
MapAdapterLeaflet.prototype.onTilesLoaded = function() {
	this.manager.notify('tilesloaded');
};

/**
 * Returns url for a tile
 * 
 * @method getTileLayerUrl
 * @param {MTileLayer} layer
 * @param {Object} tile
 * @return {String} url
 */
MapAdapterLeaflet.prototype.getTileLayerUrl = function(layer, tile) {
	var url = layer.getUrl({
		x: tile.tile.column,
		y: tile.tile.row,
		levelOfDetail: tile.zoom
	});

	if (!url) {
		return '';
	}

	if (Moonshadow.server) {
		var MS = Moonshadow;
		url = MS.server + url;
		url += ['&user=', MS.user, '&key=', MS.key].join('');
	}

	return [url, '&d=', layer.settings.lastChange].join('');
};

/**
 * Display layer on map by id
 * 
 * @method showMapLayer
 * @param {String} layerId
 */
MapAdapterLeaflet.prototype.showMapLayer = function(layerId) {
	var tileLayer = this.tileLayers[layerId];
	tileLayer.addTo(this.map);
};

/**
 * Reload tile layer by id
 *
 * @method reloadLayer
 * @param {String} layerId
 */
MapAdapterLeaflet.prototype.reloadLayer = function(layerId) {
	var tileLayer = this.tileLayers[layerId];
	tileLayer.redraw();
};

MapAdapterLeaflet.prototype.getTileLayer = function(layerId) {
	// @LEAFLET
};

/**
 * Remove layer from map by id
 *
 * @method hideLayer
 * @param {String} layerId
 */
MapAdapterLeaflet.prototype.hideLayer = function(layerId) {
	var tileLayer = this.tileLayers[layerId];
	this.map.removeLayer(tileLayer);
};

/**
 * Add control to the map
 *
 * @method addControlToMap
 * @param {MControl} control
 * @param {Boolean} mapOverlay
 */
MapAdapterLeaflet.prototype.addControlToMap = function(control, mapOverlay) {
	if (mapOverlay) {
		this.container.appendChild(control.container);
	} else {
		if(control.precedence === 1) {
			var first = this.controls[control.position].firstChild;
			!!this.controls[control.position] &&
				this.controls[control.position].insertBefore(control.container, first);
		} else {
			!!this.controls[control.position] &&
				this.controls[control.position].appendChild(control.container);
		}
	}
};

MapAdapterLeaflet.prototype.addControlInsideMap = function(control){
	//hacky
	control.precedence = 1;
	control.position = 4;
	this.addControlToMap(control);
};

/**
 * Get base layer type
 *
 * @method getMapType
 * @return {String} base layer type
 */
MapAdapterLeaflet.prototype.getMapType = function() {
	return 'roadmap';
};

/**
 * Set base layer type
 *
 * @method setMapType
 * @param {MapType} mapType
 */
MapAdapterLeaflet.prototype.setMapType = function(mapType) {
	
};

MapAdapterLeaflet.prototype.getMapImagerySet = function() {
	return "Road";
};

MapAdapterLeaflet.prototype.getMapImagerySetForAPI = function() {
	return "Road";
};

/**
 * Get center of map
 *
 * @method getCenter
 * @return {Location} 
 */
MapAdapterLeaflet.prototype.getCenter = function() {
	var center = this.map.getCenter();

	return {
		latitude: center.lat,
		longitude: center.lng,
		lat: function() {	
			return this.latitude;
		},
		lng: function() {
			return this.longitude;
		}
	};
};

/**
 * Get current zoom level
 *
 * @method getZoom
 * @return {Number} zoom level
 */
MapAdapterLeaflet.prototype.getZoom = function() {
	return this.map.getZoom();
};

/**
 * Get max zoom level
 *
 * @method getMaxZoom
 * @return {Number} max zoom level
 */
MapAdapterLeaflet.prototype.getMaxZoom = function() {
	return this.map.getMaxZoom();
};

/**
 * Get current map bounds
 *
 * @method getBounds
 * @return {Bounds} map bounds
 */
MapAdapterLeaflet.prototype.getBounds = function() {
	var bounds = this.map.getBounds();
	return {
		'neLat': bounds.getNorth(),
		'neLon': bounds.getEast(),
		'swLat': bounds.getSouth(),
		'swLon': bounds.getWest()
	};
};

/**
 * Get current map "anti" bounds
 *
 * @method getAntiBounds
 * @return {AntiBounds}
 */
MapAdapterLeaflet.prototype.getAntiBounds = function() {
	var bounds = this.map.getBounds();
	return {
		'nwLat': bounds.getNorth(),
		'nwLon': bounds.getWest(),
		'seLat': bounds.getSouth(),
		'seLon': bounds.getEast()
	};
};


/**
 * Get location from lat & lng
 *
 * @method latLng
 * @param {Float} lat
 * @param {Float} lng
 * @return {Location} 
 */
MapAdapterLeaflet.prototype.latLng = function(lat, lng) {
	var loc = {
		'longitude': lng,
		'latitude': lat,
		'lat': function() {
			return this.latitude;	
		},
		'lng': function() {
			return this.longitude;
		}
	}

	return loc;
};

/**
 * Get location from layer x & y
 *
 * @method getLatLngFromXY
 * @param {Number} x
 * @param {Number} y
 * @return {Location} 
 */
MapAdapterLeaflet.prototype.getLatLngFromXY = function(x, y) {
	var point = new L.Point(x, y);
	var loc = this.map.layerPointToLatLng(point);
	return this.latLng(loc.lat, loc.lng);
};

/**
 * Leaflet doesnt provide a handle to unbind events, so we create one
 *
 * @getHandler
 * @param {Object} target
 * @param {String} event
 * @param {Function} listener
 * @param {Object} context
 * @returns {Handle}
 */
MapAdapterLeaflet.prototype.getHandler = function(target, event, listener,
												  context) {
	return {
		'target': target,
		'event': event,
		'listener': listener,
		'context': context
	}
};

/**
 * Add event listener to map entity
 *
 * @method addEventListener
 * @param {String} event
 * @param {Function} listener
 * @param {Holder} holder
 * @param {EventHandle} 
 */
MapAdapterLeaflet.prototype.addEventListener = function(event, listener,
														holder) {
	var entity = holder.getMapEntity();
	if (entity) {
		var wrappedListener = (function(context, callback, self) {
			return function(event) {
				var id = self.leafletEvents[event.type];
				var entity = event.target;

				var loc = entity.getLatLng();
				var point = self.map.latLngToContainerPoint(loc);
				
				entity.pageX = point.x;
				entity.pageY = point.y;

				// Repackage the event before emitting
				callback.call(context, id, event);
			};
		}(holder, listener, this));

		entity.on(this.eventMap[event], wrappedListener, entity);

		return this.getHandler(entity, this.eventMap[event], wrappedListener, entity);
	}

	return null;
};

/**
 * Remove event listener from map entity
 * 
 * @method removeEventListener
 * @param {EventHandle} handler
 */
MapAdapterLeaflet.prototype.removeEventListener = function(handler) {
	handler.target.off(handler.event, handler.listener, handler.context);
};

/**
 * Add event listener to map
 *
 * @method addMapListener
 * @param {String} event
 * @param {Object} context
 * @param {Function} callback
 * @return {EventHandle}
 */
MapAdapterLeaflet.prototype.addMapListener = function(event, context,
													  callback) {
	if (event === 'keydown' || event === 'keyup') {
		return this.addContainerListener(event, context, callback);
	}

	var listener = function(mmName) {
		return function(event) {
			callback.call(this, mmName, event);
		}
	}(event);

	this.addListener(this.map, this.eventMap[event], context, listener);

	return this.getHandler(this.map, this.eventMap[event], listener, context);
};

/**
 * Remove event listener from map
 *
 * @method removeMapListener
 * @param {EventHandler} handler
 */
MapAdapterLeaflet.prototype.removeMapListener = function(handler) {
	if (handler.event === 'keydown' || handler.event === 'keyup') {
		return this.removeContainerListener(handler.event, handler.context,
											handler.listener);
	}

	this.removeListener(handler.target, handler.event, handler.context,
						handler.listener);
};

/**
 * Add listener to map container
 * 
 * @method addContainerListener
 * @param {String} event
 * @param {Object} context
 * @param {Function} callback
 */
MapAdapterLeaflet.prototype.addContainerListener = function(event, context,
															callback) {
	var listener = function(mmName, callback, context) {
		return function(event) {
			callback.call(context, mmName, event);
		}
	}(event, callback, context);

	document.addEventListener(this.eventMap[event], listener);
	return this.getHandler(document, this.eventMap[event], listener,
						   context);
};

/**
 * Remove listener from a map container
 *
 * @method removeContainerListener
 * @param {EventHandler} handler
 */
MapAdapterLeaflet.prototype.removeContainerListener = function(event, context,
															   listener) {
	document.removeEventListener(event, listener);
};

/**
 * Add listener to a map entity
 *
 * @method addListener
 * @param {Entity} target
 * @param {String} event
 * @param {Object} context
 * @param {Function} callback
 */
MapAdapterLeaflet.prototype.addListener = function(target, event, context,
												   callback) {
	target.on(event, callback, context);
};

/**
 * Remove listener from a map entity
 *
 * @method removeListener
 * @param {Entity} target
 * @param {String} event
 * @param {Object} context
 * @param {Function} callback
 */
MapAdapterLeaflet.prototype.removeListener = function(target, event, context,
													  callback) {
	target.off(event, callback, context);
};

/**
 * Mark event as handled, don't proprogate futher
 *
 * @method preventDefault
 * @param {Event} details
 */ 
MapAdapterLeaflet.prototype.preventDefault = function(details) {
	if (!details.originalEvent) {
		return;
	}

	details.originalEvent.preventDefault();
};

/**
 * Check if event is mouse right click
 *
 * @method isRightClick
 * @param {Event} details
 * @return {Boolean}
 */
MapAdapterLeaflet.prototype.isRightClick = function(details) {
	return details.originalEvent.button === 2;
};

/**
 * Get location from mouse event
 *
 * @method getLocationFromEvent
 * @param {Event} event
 * @return {Location}
 */
MapAdapterLeaflet.prototype.getLocationFromEvent = function(event) {
	return this.latLng(event.latlng.lat, event.latlng.lng);
};

/** 
 * Get point from mouse event
 *
 * @method getPointFromEvent
 * @param {Event} event
 * @return {Number[]} xy
 */
MapAdapterLeaflet.prototype.getPointFromEvent = function(event) {
	return [event.layerPoint.x, event.layerPoint.y];
};

/**
 * Map of Generic events to Leaflet map
 *
 * @attribute eventMap
 */
MapAdapterLeaflet.prototype.eventMap = {
	'dragstart': 'dragstart',
	'drag': 'drag',
	'dragend': 'dragend',
	'zoom': 'zoomend',
	'maptype': 'baselayerchange',
	'resize': 'resize',
	'bounds': 'moveend',
	'click': 'click',
	'rightclick': 'contextmenu',
	'mousedown': 'mousedown',
	'mousemove': 'mousemove',
	'mouseup': 'mouseup',
	'mouseover': 'mouseover',
	'mouseout': 'mouseout',
	'tilesloaded': 'tilesloaded',
	'keydown': 'keydown',
	'keyup': 'keyup',
	'changed': 'changed'
};

/**
 * Resize event handler
 * 
 * @method resize
 */
MapAdapterLeaflet.prototype.resize = function() {
	// Check map container size and adjust center,
	// fixes several bugs related to centering
	this.map.invalidateSize(true);
};

/**
 * Pan map to bounds of points
 *
 * @method panToPoints
 * @param {Points[]} points
 */
MapAdapterLeaflet.prototype.panToPoints = function(points) {
	var bounds = L.latLngBounds(this.getLocations(points));
	this.map.fitBounds(bounds);
};

/**
 * Pan map to bounds
 *
 * @method panToBounds
 * @param lat1
 * @param lng1
 * @param lat2
 * @param lng2
 */
MapAdapterLeaflet.prototype.panToBounds = function(lat1, lng1, lat2, lng2) {
	this.pantToPoints([[lat1, lng1], [lat2, lng2]]);
};

/**
 * Pan map to bounds of points (legacy function)
 *
 * @method fitBounds
 * @param {Points[]}
 */
MapAdapterLeaflet.prototype.fitBounds = function(points) {
	this.panToPoints(points);
};

/**
 * Get Leaflet LatLng from point
 *
 * @method getLocation
 * @param {Point} point
 * @return {LatLng}
 */
MapAdapterLeaflet.prototype.getLocation = function(point) {
	return L.latLng(point[0], point[1]);
};

/**
 * Get array of locations from points
 *
 * @method getLocations
 * @param {Point[]} points
 * @return {LatLng[]}
 */
MapAdapterLeaflet.prototype.getLocations = function(points) {
	var locations = [];
	
	for (var i = 0, l = points.length; i < l; i++) {
		locations.push(this.getLocation(points[i]));
	}

	return locations;
};

/**
 * Get point from event
 * 
 * @method getMarkerPoint
 * @return {Float[]}
 */
MapAdapterLeaflet.prototype.getMarkerPoint = function(event) {
	var loc = event.target.getLatLng();
	return [loc.lat, loc.lng];
};

/**
 * Get a new polyline and add to map
 * 
 * @method addPolyline
 * @param {MMapPolyline} polyline
 * @return {Polyline}
 */
MapAdapterLeaflet.prototype.addPolyline = function(polyline) {
	var entity = this.createLeafletPolyline(polyline);
	entity.addTo(this.map);
	
	return entity;
};

/**
 * Create Leaflet polyline from generic polyline object
 *
 * @method creatLeafletPolyline
 * @param {MMapPolyline} polyline
 * @return {Polyline}
 */
MapAdapterLeaflet.prototype.createLeafletPolyline = function(polyline) {
	var entity = polyline.getMapEntity();
	if (!entity) {
		var locations = this.getLocations(polyline.getPoints());
		var options = this.getPolylineOptions(polyline);
		entity = L.polyline(locations, options);
	}

	return entity;
};

/**
 * Get polyline options
 *
 * @method getPolylineOptions
 * @param {MMapPolyline}
 * @return {Object} options
 */
MapAdapterLeaflet.prototype.getPolylineOptions = function(polyline) {
	var options = {
		'color': polyline.lineColor,
		'opacity': polyline.lineAlpha / 255,
		'dashArray': polyline.lineStyle,
		'weight': polyline.lineThickness
	};

	return options;
};

/**
 * Update polyline options
 *
 * @method updatePolylineOptions
 * @param {MMapPolyline} polyline
 */
MapAdapterLeaflet.prototype.updatePolylineOptions = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		var options = this.getPolylineOptions(polyline);
		entity.setStyle(options);
	}
};

/**
 * Update map polyline with generic polyline's points
 *
 * @method updatePolylinePoints
 * @param {MMapPolyline}
 */
MapAdapterLeaflet.prototype.updatePolylinePoints = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		var locations = this.getLocations(polyline.getPoints())
		entity.setLatLngs(locations);
	}
};

/**
 * Remove polyline from map
 *
 * @method removePolyline
 * @param {MMapPolyline}
 */
MapAdapterLeaflet.prototype.removePolyline = function(polyline) {
	var entity = polyline.getMapEntity();
	if (entity) {
		this.map.removeLayer(entity);
	}
};

/**
 * Get a new polyline and add to map
 *
 * @method addPolygon
 * @param {MMapPolygon} polygon
 * @return {Polygon}
 */
MapAdapterLeaflet.prototype.addPolygon = function(polygon) {
	var entity = this.createLeafletPolygon(polygon);
	entity.addTo(this.map);

	return entity;
};

/**
 * Create Leaflet polyline from generic polyline object
 *
 * @method createLeafletPolygon
 * @param {MMapPolygon} polygon
 * @return {Polygon}
 */
MapAdapterLeaflet.prototype.createLeafletPolygon = function(polygon) {
	var entity = polygon.getMapEntity();
	if (!entity) {
		var locations = this.getLocations(polygon.getPoints());
		var options = this.getPolygonOptions(polygon);
		entity = L.polygon(locations, options);
	}

	return entity;
};

/**
 * Get polygon options
 *
 * @method getPolygonOptions
 * @param {MMapPolygon} polygon
 * @return {Object} options
 */
MapAdapterLeaflet.prototype.getPolygonOptions = function(polygon) {
	var options = {
		'fillColor': polygon.fillColor,
		'fillOpacity': polygon.fillAlpha / 255,
		'color': polygon.lineColor,
		'opacity': polygon.lineAlpha / 255,
		'dashArray': polygon.lineStyle,
		'weight': polygon.lineThickness
	};

	return options;
};

/**
 * Update polygon options
 *
 * @method updatePolygonOptions
 * @param {MMapPolygon} polygon
 */
MapAdapterLeaflet.prototype.updatePolygonOptions = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		var options = this.getPolygonOptions(polygon);
		entity.setStyle(options);
	}
};

/**
 * Update polygon points
 *
 * @method updatePolygonPoints
 * @param {MMapPolygon} polygon
 */
MapAdapterLeaflet.prototype.updatePolygonPoints = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		var locations = this.getLocations(polygon.getPoints());
		entity.setLatLngs(locations);
	}
};

/**
 * Remove polygon from map
 *
 * @method removePolygon
 * @param {MMapPolygon} polygon
 */
MapAdapterLeaflet.prototype.removePolygon = function(polygon) {
	var entity = polygon.getMapEntity();
	if (entity) {
		this.map.removeLayer(entity);
	}
};

/**
 * Create marker from details
 *
 * @method getMarker
 * @param {Object} details
 * @return {Marker} 
 */
MapAdapterLeaflet.prototype.getMarker = function(details) {
	var position = details.position;
	var options = {};

	if (details.draggable) {
		options.draggable = true;
	}

	if (details.icon) {
		options.icon = details.icon;
		
		var dim = details.iconDim;
		if (dim) {
			options.width = dim[0];
			options.height = dim[1];
		}

		var anchor = details.iconAnchor;
		if (anchor) {
			options.anchor = anchor;
		}
	}

	var location = this.getLocation([position.lat(), position.lng()]);
	var opts = this.getMarkerOptions(options);
		
	var entity = L.marker(location, opts);
	entity.markerType = details.markerType;

	entity.Id = details.markerId ? details.markerId : 
		[position.latitude, position.longitude].join('');

	return entity;
};

/**
 * Get new marker and add to map
 *
 * @method addMarker
 * @param {MMapMarker}
 * @return {Marker}
 */
MapAdapterLeaflet.prototype.addMarker = function(marker) {
	var entity = this.createMarker(marker);
	entity.addTo(this.map);

	return entity;
};

/**
 * Create Leaflet marker from generic polyline object
 *
 * @method createMarker
 * @param {MMapMarker} marker
 * @return {Marker} 
 */
MapAdapterLeaflet.prototype.createMarker = function(marker) {
	var entity = marker.getMapEntity();
	if (!entity) {
		var location = this.getLocation(marker.getPoint());
		var options = this.getMarkerOptions(marker);
		entity = L.marker(location, options);
	}

	return entity;
};

/**
 * Set icon and details for marker
 *
 * @method setMarkerIcon
 * @param {MMapMarker} marker
 * @param {String} url Icon url
 * @param {Number} anchorX Icon point x offset
 * @param {Number} anchorY Icon point y offset
 * @param {Number} width Icon width
 * @param {Number} height Icon height
 */
MapAdapterLeaflet.prototype.setMarkerIcon = function(marker, url, anchorX, 
													 anchorY, width, height) {
	var entity = marker.marker;

	var options = {
		'iconUrl': url,
		'iconSize': [width, height],
		'iconAnchor': [anchorX, anchorY]
	};

	var icon = L.icon(options);
	entity.setIcon(icon);
	entity.addTo(this.map);
};

/**
 * Add click listener to marker
 *
 * @method addMarkerLsnr
 * @param {Object} marker
 * @param {Function} callback
 * @return {EventHandle}
 */
MapAdapterLeaflet.prototype.addMarkerLsnr = function(marker, callback) {
	marker.marker.on('click', callback, marker.marker);	
	return this.getHandler(marker.marker, 'click', callback, marker.marker);
};

/**
 * Get icon for marker
 * 
 * @method getIcon
 * @param {MMapMarker} marker
 * @return {Icon} 
 */
MapAdapterLeaflet.prototype.getIcon = function(marker) {
	return L.icon({
		'iconUrl': marker.icon,
		'iconSize': [marker.width, marker.height],
		'iconAnchor': marker.anchor
	});
};

/**
 * Get marker options
 *
 * @method getMarkerOptions
 * @param {MMapMarker} marker
 * @return {Object}
 */
MapAdapterLeaflet.prototype.getMarkerOptions = function(marker) {
	var options = {
		'icon': this.getIcon(marker),
		'draggable': marker.draggable
	};

	return options;
};

/**
 * Update marker options
 *
 * @method updateMarkerOptions
 * @param {MMapMarker} marker
 */
MapAdapterLeaflet.prototype.updateMarkerOptions = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		var options = this.getMarkerOptions(marker);
		entity.setIcon(this.getIcon(marker));
		if (marker.draggable) {
			entity.dragging.enable();
		} else {
			entity.dragging.disable();
		}
	}
};

/**
 * Update marker position
 *
 * @method updateMarkerPoint
 * @param {MMapMarker} marker
 */
MapAdapterLeaflet.prototype.updateMarkerPoint = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		var location = this.getLocation(marker.getPoint());
		entity.setLatLng(location);
	}
};

/**
 * Hide marker
 *
 * @method hideMarker
 * @param {MMapMarker} marker
 */
MapAdapterLeaflet.prototype.hideMarker = function(marker) {
	marker.hide();
};

/**
 * Remove marker from map
 *
 * @method removeMarker
 * @param {MMapMarker} marker
 */
MapAdapterLeaflet.prototype.removeMarker = function(marker) {
	var entity = marker.getMapEntity();
	if (entity) {
		this.map.removeLayer(entity);
	}
};

/**
 * Removes a collection of markers from the map
 *
 * Note: this function is portly names and needs cleaned up
 *
 * @method clearAllMarkers
 * @param {MMarker[]} markers
 */
MapAdapterLeaflet.prototype.clearAllMarkers = function(markers) {
	for (var i in markers) {
		this.clearMarker(markers[i]);
	}
};

/**
 * Removes a maker from the map
 *
 * Note: this function is portly names and needs cleaned up
 *
 * @method clearMarker
 * @param {MMarker} marker
 * @param boolean True if item was on the map
 */
MapAdapterLeaflet.prototype.clearMarker = function(marker) {
	var result = this.map.hasLayer(marker.marker);
	this.map.removeLayer(marker.marker);
	return result;
};

/**
 * Removes entity
 *
 * Note: this function is portly names and needs cleaned up
 *
 * @method removeEntity
 * @param {ILayer} entity
 */
MapAdapterLeaflet.prototype.removeEntity = function(entity) {
	this.clearMarker({'marker': entity});
};

/**
 * Get a new polyline and add to map
 *
 * @method addCircle
 * @param {MMapCircle}
 * @return {Circle}
 */
MapAdapterLeaflet.prototype.addCircle = function(circle) {
	var entity = this.createCircle(circle);
	entity.addTo(this.map);

	return entity;
};

/**
 * Create Leaflet circle from generic circle object
 * 
 * @method createCircle
 * @param {MMapCircle} circle
 * @return {Circle}
 */
MapAdapterLeaflet.prototype.createCircle = function(circle) {
	var entity = circle.getMapEntity();
	if (!entity) {
		var center = this.getLocation(circle.getCenter());
		var distance = circle.getRadiusMeters();
		var options = this.getCircleOptions(circle);
		entity = L.circle(center, distance, options);
	}

	return entity;
};

/**
 * Get circle options
 *
 * @method getCricleOptions
 * @param {MMapCircle} circle
 * @return {Object}
 */
MapAdapterLeaflet.prototype.getCircleOptions = function(circle) {
	var options = {
		'fillColor': circle.fillColor,
		'fillOpacity': circle.fillAlpha / 255,
		'color': circle.lineColor,
		'opacity': circle.lineAlpha / 255,
		'weight': circle.lineThickness
	};

	return options;
};

/**
 * Update circle options
 * 
 * @method updateCircleOptions
 * @param {MMapCircle} circle
 */
MapAdapterLeaflet.prototype.updateCircleOptions = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		var options = this.getCircleOptions(circle);
		entity.setStyle(options);
	}	
};

/**
 * Update circle location and radius
 * 
 * @method updateCirclePoints
 * @param {MMapCircle} circle
 */
MapAdapterLeaflet.prototype.updateCirclePoints = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		var center = this.getLocation(circle.getCenter());
		var distance = circle.getRadiusMeters();
		entity.setLatLng(center);
		entity.setRadius(distance);
	}
};

/**
 * Remove circle from map
 *
 * @method removeCircle
 * @param {MMapCircle} circle
 */
MapAdapterLeaflet.prototype.removeCircle = function(circle) {
	var entity = circle.getMapEntity();
	if (entity) {
		this.map.removeLayer(entity);
	}
};

/**
 * Create info window
 *
 * @method infoWindow
 * @return {Popup}
 */
MapAdapterLeaflet.prototype.infoWindow = function() {
	var mapSize = this.map.getSize();

	var options = {
		'offset': [0, -32],
		'minWidth': 150,
		'maxWidth': mapSize.x - 220,
		'maxHeight': mapSize.y - 220
	};

	var infobox = L.popup(options);

	return infobox;
};

/**
 * Get info winodow id
 *
 * @method getInfoWindowId
 * @return {String}
 */
MapAdapterLeaflet.prototype.getInfoWindowId = function(infobox) {
	return infobox.Id; // Carry over from bing maps adapter
};

/**
 * Set info window id
 *
 * @method
 * @param {Popup} infobox
 * @param {String} id
 */
MapAdapterLeaflet.prototype.setInfoWindowId = function(infobox, id) {
	infobox.Id = id;
};

/**
 * Open info window
 * 
 * @method openInfoWindow
 * @param {Popup} infobox
 * @param {Map} map
 * @param {Marker} marker
 * @param {HTMLElement} content
 */
MapAdapterLeaflet.prototype.openInfoWindow = function(infobox, map, marker, content) {
	var dim = this.getContentDim(content)

	var wrap = document.createElement('div');
	wrap.appendChild(content);
	wrap.style.width = dim[0] + 90 + 'px';
	wrap.style.height = dim[1] + 50 + 'px';

	infobox.setLatLng(marker.getLatLng());
	infobox.openOn(this.map);
	infobox.setContent(wrap);
};

/**
 * Close info window
 *
 * @method closeInfoWindow
 * @param {Popup} infobox
 * @param {map} map
 */
MapAdapterLeaflet.prototype.closeInfoWindow = function(infobox, map) {
	this.map.closePopup(infobox);
	this.manager.mapObservers.notify("infowindowclosed");
};

MapAdapterLeaflet.prototype.getContentDim = function(content) {
    var temp = document.createElement("div");
    temp.style.display = "none";
	temp.appendChild(content);

	this.container.appendChild(temp);

	var width = $(temp).innerWidth();
	var height = $(temp).innerHeight();

	$(temp).remove();
	return [width, height];
};
/**
 * Moonshadow and MManager object along with assorted helper objects definitions
 * @module Moonshadow
 * @author Ryan Olds ryan@moonshadowmobile.com
 * @copyright (c) 2010 Moonshadow Mobile - info@moonshadowmobile.com
 * @version 3.3.0
 */

/**
 * Namespace container and global var for module.
 * @class Moonshadow
 */
var Moonshadow = {
	helpers: MoonshadowHelpers,
		
	/**
	 * Client version number
	 * @property version
	 * @type String
	 * @private
	 */
		
	version: "4.4.4",

	/**
	 * Instance of manager
	 * @property __manager
	 * @type MManager
	 * @private
	 */
	__manager: null,

	/**
	 * Internal numerical id for unknown map provider
	 * @property MAP_TYPE_UNKNOWN
	 * @type Number
	 */
	MAP_TYPE_UNKNOWN: 0,

	/**
	 * Internal numerical id for Google Maps 3.x map provider
	 * @property MAP_TYPE_GOOGLE
	 * @type Number
	 */
	MAP_TYPE_BING_EIGHT: 1, 

	/**
	 * Internal numerical id for Bing Maps 7.0 map provider
	 * @property MAP_TYPE_BING
	 * @type Number
	 */
	MAP_TYPE_BING: 2,

	/**
	 * Internal numerical id for Leaflet map provider
	 * @property MAP_TYPE_LEAFLET
	 * @type Number
	 */
	MAP_TYPE_LEAFLET: 3,

	/**
	 * Collection of map provider definitions
	 * @property maps
	 * @type MapProviderDefinition[]
	 */
	maps: [
		{
			"name": "unknown",
			"desc": "Choose Map",
			"enabled": false,
			'available': true,
			"library": null,
			"adapterName": null,
			"isLibraryReady": function() {},
			"isAdapterReady": function() {}
		},
		MapAdapterBingSeven.config,
		MapAdapterBingEight.config,
		MapAdapterLeaflet.config
	],
	mapList: function(){
		return $(Moonshadow.maps)
			.filter(function(index, map){
				return map.available;
			})
			.map(function(index, map){
				return {
					"index": index,
					"desc": map.desc,
					"enabled": map.enabled
				}
			});
	},
	/**
	 * Server address
	 * @property server
	 * @type String
	 */
	server: null,
	/**
	 * Server timeout
	 * @property timeout
	 * @type Number
	 */
	timeout: 180000,
	/**
	 * Content delivery network
	 * @property cdn
	 * @type String
	 */
	cdn: "https://cdn1.moonshadowmobile.net",
	/**
	 * Protocol and domain of marker server
	 * @property markers
	 * @type String
	 */
	markers: "https://marker1.moonshadowmobile.net",
	/**
	 * Location of Ground Game Tutorials (temporary, should be app attrs)
	 * @property gg_tutorials
	 * @type String
	 */
	gg_tutorials: "http://www.moonshadowmobile.com/ground-game-votermapping-tutorials/",
	/**
	 * Username of person the client was loaded for
	 * @property user
	 * @type String
	 */
	user: null,
	/** 
	 * Key/token for the loaded users
	 * @property key
	 * @type String
	 */
	key: null,
	/**
	 * HTTP path for the route that handles queries on the
	 * the server the client is communicating with
	 * @property queryPath
	 * @type String
	 * @default "/"
	 */
	queryPath: "/",
	/**
	 * HTTP path to the scripts directory that the client files
	 * can be loaded from
	 * @property scriptPath
	 * @type String
	 * @default ""
	 */
	scriptPath: "", // Path for root mmmmap js folder
	/**
	 * Required version of jQuery, client will error if version differs
	 * @property jQueryVersion
	 * @type String
	 * @default "1.7.1"
	 */
	jQueryVersion: "1.7.1", // Supported jquery version
	/**
	 * Returns an instance of MManager
	 * @method getManager
	 * @return {MManager} Returns instance of MManager or false
	 */
	getManager: function() { 
		if(this.__manager == null) {
			return false;
		}

		return this.__manager;
	},
	/**
	 * Sets __manager to instance of MManager
	 * @method setManager
	 * @param {MManager} manager 
	 */
	setManager: function(manager) {
		this.__manager = manager;
	},
	/**
	 * Loads an external js file 
	 * @method loadScript
	 * @param {String} src Url to load js file from
	 * @param {Function} [func] Executed when loading id completed
	 * @async
	 */
	loadScript: function(src,func) {
		var onFinish = func || function() {};
		if(typeof onFinish != "function")
			onFinish = function() {};

		$.getScript(src, onFinish);
	},
	/**
	 * Logs to console in browser if exists 
	 * @method log
	 * @param {Any x n} Any number of object, strings, integers
	 */
	log: function(){
		if(console && console.log){
			console.log($(arguments).toArray().map(function(arg){
				if(!arg){
					return true;
				}
				var jsarg;
				if(typeof arg == "object"){
					try{
						jsarg = JSON.stringify(arg);
					}catch(e){}
					arg = jsarg
				}
				if(arg.toString){
					arg = arg.toString();
				}
				return arg;
			}).join(" "));
		}
	},
	/**
	 *
	 * @method LoadCachedScript
	 * @param {String} src
	 * @param {function} [func] Executed when loading completed
	 * @async
	 */
	loadCachedScript: function(src, func) {
		var onFinish = func || function() {};
		if(typeof onFinish != "function")
			onFinish = function() {};

		$.ajax({
			async: false,
			type: "GET",
			url: src,
			data: null,
			cache: true,
			dataType: 'script',
			success: onFinish,
			error: function(jqXHR, textStatus, errorThrown){
				throw new Error("Error: "+textStatus);
			}
		});
		
	},
	/**
	 * Google maps requires a function to call when loading id completed
	 * @method phaseTwo
	 */
	phaseTwo: function() {}, // Dumb stuff for google maps
	/**
	 * Creates namespaces
	 * @method namespace
	 * @param {String} ns Namespace path
	 * @returns {Object} Reference to the namespace
	 */
	namespace: function(ns) {
		var parts = ns.split("."), // Split the string up in to parts
		parent = Moonshadow, // Get a ref to parent
		i, // i for incrementing
		l; // l for parts length

		// Dump the first part of it's the leading ns
		if(parts[0] === "Moonshadow") {
			parts.shift();
		};

		for(i = 0,l = parts.length;i < l; i++) {
			if(typeof parent[parts[i]] === "undefined") { // Check if ns exists
				parent[parts[i]] = {}; // Create new ns
			}
			parent = parent[parts[i]]; // Change parent to new ns
		}
		return parent; // Return reference to new ns
	},
	/**
	 * Sets-up the client, but doesn't load the map
	 * @method init
	 * @async
	 * @param {Object} options Extra options
	 * @param {String} options.server server address
	 * @param {String} options.user user id
	 * @param {String} options.key key/token for the user id
	 * @param {HTMLElement} options.container Place to put the client on page
	 * @param {Object} [options.user_details] Details about the user
	 * @param {String} [options.queryPath] Path to query route
	 * @param {String} [options.scriptPath] Path to scripts dir
	 * @param {String} [options.customer] customerId for loaded app
	 * @param {String} [options.customerDisplay] display name for customer
	 * @param {String} [options.app] appId for loaded app
	 * @param {String} [options.appDisplay] display name for app
	 * @param {App[]} [options.app] appId for loaded app 
	 * @param {String} [options.parentOrigin] Origin of page loading embedded client
	 */
	init: function(options, callback) {
		Moonshadow.helpers.updateProgress(10, 'Configuring client...');

		var caller = this;
		if(!options.user || !options.key || !options.server || !options.container) { 
			throw new Error("Requires server, user, key, container options");
		}
		
		// Required
		this.server = options.server;
		this.timeout = options.timeout;
		this.user = options.user;
		this.user_details = options.user_details;
		this.key = options.key;
		// Optional
		this.queryPath = options.queryPath || this.queryPath;
		this.scriptPath = options.scriptPath || this.scriptPath;
		this.cdn = options.cdn || this.cdn;

		this.customer = options.customer || false;
		this.customerDisplay = options.customer_display || false;		
		this.app = options.app || false;
		this.appDisplay = options.app_display || false;
		this.apps = options.apps; // List of apps the user can login to

		// the origin of the parent of the mapping interface - used for embedded
		this.parentOrigin = options.parentOrigin;
		
		this.sessionActive = true;
		
		this.setManager(new Moonshadow.Manager(options, callback));

		this.setUpDocumentWindow();
		
		if(options.markersuri){
			Moonshadow.markers = options.markersuri;
		}
		
		// Only listen setup embedded client listener if parent origin is specified
		if (this.parentOrigin) {
			this.embedded = new MEmbedded(this.getManager(), this.parentOrigin);
		}
	},
	setUpDocumentWindow: function(){
		var self = this;
		$(document.body).on("touchmove", function(e){
			var target = $(e.target).closest(".scrollable").get(0);
			if(!target){
				return e.preventDefault();
			}
		})
		.on("click", function(){
			//removes stuck report info popups
			$(".export_descr").remove();
		})
		.on("keydown keyup", function(e){			
			self.onKey(e, e.which, e.ctrlKey, e.shiftKey, e.metaKey);
		});
		
		//@HACK to deal with selenium autoscroll in FF
		$("#maincontainer").on("scroll", function(){
			$("#maincontainer").scrollTop(0);
		});
	},
	onKey: function(event, which, ctrlKey, shiftKey, metaKey){
		var notif = [event.type];
		if(ctrlKey){
			notif.push("ctrl");
		}
		if(shiftKey){
			notif.push("shift");
		}
		if(metaKey){
			notif.push("meta");	
		}
		notif.push(which);
		var obsKey = notif.join("_");
		var obs = this.__manager.dataObservers;
		if(obs.observers[obsKey]){
			obs.notify(obsKey, event);
		}
	},
	/**
	  * Starts the map loading
	  * @method initmap
	  * @async
	  * @param {function} callback Called when map is loaded
	  */
	initMap: function() {
		this.getManager().initMap();
	},
	/**
	 * Sets-up the client and starts loading the map
	 * @method go
	 * @param {Object} options Extra options
	 * @param {function} callback Fired when everything is loaded
	 */
	go: function(options) {
		if(!this.__manager) {
			var caller = this;
			this.init(options, function() {
				caller.initMap();
			});		
		} else {
			// Manager already setup, start map
			// @TODO probably need to perform a check to prevent double loading
			this.initMap();
		}
	},
	/**
	 * Get the uri for querying data
	 * @method getDataUrl
	 * @param {String} [path] The path to use, if falsey then queryPath used
	 */
	getDataUrl: function(path) {
		return this.server + (path || this.queryPath);
	},
	/**
	 * Wrap the query for posting in www-url-form-encoded post
	 * @method wrapPost
	 * @param {Object}
	 * @deprecated Please post with application/json
	 */
	wrapPost: function(q) {
		return JSON.stringify({
			'data': q,
			'user': Moonshadow.user,
			'key': Moonshadow.key
		});
	},
	/**
	 * Sets filters and orients the map
	 * @method setSelectionAndDisplayData
	 * @async
	 * @param {} data
	 * @param {} bounds
	 * @param {function} [callback]
	 */
	setSelectionAndDisplayData: function(data, bounds, callback) {
		var caller = this;
		var manager = this.getManager(); 
		var adapter = manager.getAdapter();
		var ds = manager.getDatasource();

		var query = {
			'ds':ds.int_name
		};

		if(!data || data.length === 0) {
			query.query = 'clear_selection_and_display_data';
		} else {
			query.query = 'set_selection_and_display_data';
			query.ids = data;
		}

		var container = manager.getContainer();
		var conWidth = $(container).width();
		var conHeight = $(container).height();

		var ajax = new Moonshadow.Ajax();
		ajax.addQuery(query, function(response) {
			if(response.result === 'ok') {
				var height = (response.bottomi - response.topi) / conHeight;
				var width = (response.righti - response.lefti) / conWidth;

				// Check fixes issue with size 0 boxes
				var z = manager.getOption('map.defaultSelectionZoom', 13);
				if(height !== 0 && width !== 0) {
					z = 22 - Math.floor(Math.log(Math.max(height, width)) / Math.log(2));
				}
		
				var centerY = response.top - (response.top - response.bottom) / 2;
				var centerX = response.left - (response.left - response.right) / 2

				if(!adapter) {
					caller.updateUserMapLocation(centerY, centerX, z);
				} else {
					adapter.reloadLayer("base");
					adapter.panTo(centerY, centerX);
					adapter.setZoom(z);
				}

				if(typeof callback === 'function') {
					callback(null, response);
				}
			} else {
				if(typeof callback === 'function') {
					return callback(new Error(response.error || 'Unknown error'));
				}
			}
		});

		ajax.execute();
	},
	/**
	 * Clears filters
	 * @method clearSelectionAndDisplayData
	 * @async
	 * @param {} bounds
	 * @param {function} [callback]
	 */
	clearSelectionAndDisplayData: function(bounds, callback) {
		this.setSelectionAndDisplayData(null, null, callback);
	},
	/**
	 * 
	 * @method updateUserMapLocation
	 * @param {} lat
	 * @param {} lng
	 * @param {} zoom 
	 */
	updateUserMapLocation: function(lat, lng, zoom) {
		var manager;
		if(manager = Moonshadow.getManager()) {
			manager.setOption("map.lat", lat);
			manager.setOption("map.long", lng);
			manager.setOption("map.z", zoom);
		}
	}
};

/**
 * Handles adding/removing listeners and notifying listeners
 * @class Observer
 * @constructor
 * @namespace Moonshadow
 */
Moonshadow.namespace("Moonshadow.Observer");
Moonshadow.Observer = (function() {
	var Constr,
	/**
	 * Notify all observers
	 * @method notify
	 * @param {String} e Event name
	 * @param {Object} [data] data to be given to listeners
	 * @param {boolean} [blocking] 
	 */
	notify = function(e, data, blocking, details) {
		var d = data || null;
		var b = blocking || false;

		if (e instanceof RegExp) {
			for(var key in this.observers) {
				if (key.match(e)) {
					this.notify(key, data, blocking, details);
				}
			}
		
			return;
		}

		if(typeof this.observers[e] != "undefined") {
			$.each(this.observers[e],function(k,v) {
				// Legacy stuff. Some calls are by object and some are by specific function
				if(typeof v.o == "function") { 
					if(v.c) {
						v.o.call(v.c,e,d,b,details);
					} else {
						v.o(e,d,b,details);
					}	
				} else if(typeof v.o.notify == "function") { 
					// If v not a function, but v.notify is then call v notify
					v.o.notify(e,d,b,details);
				} else {
					Moonshadow.log("No function to notify for "+e);
				}
			});
		}
	},
	/**
	 * Checks of observer already is being watched
	 * @method isObserving
	 * @param {String} e Event name to watch
	 * @param {Function} o Item being notified of event
	 * @param {Object} c Context to use for o if function
	 */
	isObserving = function(e,o,c) {
		if(typeof this.observers[e] == "undefined") return false;

		var found = false;
		$.each(this.observers[e],function(k,v) {
			if(v.o == o && v.c == c ) {
				found = true;
				return false;
			}
		});

		return found;
	},
	/**
	 * Add an observer
	 * @method addObserver
	 * @param {String} e Event name to watch
	 * @param {Function} o Can be an object, if object then notify() calls o.notify()
	 * @param {Object} c If set and o is a function then o.call is used with c being the context
	 */
	addObserver = function(e,o,c) { 
		if ($.type(e) != "array"){
			e = [e];
		}
		for(var i = 0, l = e.length; i < l; ++i){
			// Check if object/funtion is already observing this event
			if(this.isObserving(e[i],o,c))
				return false; 

			if(this.observers[e[i]] == undefined) 
				this.observers[e[i]] = [];
			
			this.observers[e[i]].push({"o":o,"c":c});
		}
	},
	/** 
	 * Remove an observer
	 * @method removeObserver
	 * @param {String} e Event name to match
	 * @param {Function} o Function or object o match
	 * @param {Object} c Context to use for o if function
	 */
	removeObserver = function(e,o,c) {
		if ($.type(e) != "array"){
			e = [e];
		}
		for(var i = 0, l = e.length; i < l; ++i){
			if(this.observers[e[i]] == undefined) 
				return false;	
			this.observers[e[i]] = $.map(this.observers[e[i]],function(el) {
				if(!(el.o == o && el.c == c)) {
					return el;
				}
			});
			if(!this.observers[e[i]].length){
				delete this.observers[e[i]];
			}
		}
	},
	/** 
	 * Remove an context from observer
	 * @method removeContext
	 * @param {String} e Event name to match
	 * @param {Object} c Context to use for o if function
	 */
	removeContext = function(e,c) {
		if ($.type(e) != "array"){
			e = [e];
		}
		for(var i = 0, l = e.length; i < l; ++i){
			if(this.observers[e[i]] == undefined) 
				return false;
			this.observers[e[i]] = $.map(this.observers[e[i]],function(el) {
				if(!(el.c == c)) {
					return el;
				};
			});
			if(!this.observers[e[i]].length){
				delete this.observers[e[i]];
			}
		}
	},
	getObservers = function() {
		return this.observers;
	},
	getObservedEvents = function() {
		return $.map(this.observers, function(val, key) {
			return key;
		}); 
	},
	hasObservers = function(event) {
		var observers = this.observers[event] || [];
		return !!observers.length;
	},
	/**
	 * @property observers
	 * @private
	 * @type {Object} holds event listeners index by event id
	 */
	Constr = function() {
		this.observers = {};
	};
	// Public methods
	Constr.prototype = {
		notify: notify,
		addObserver: addObserver,
		removeObserver: removeObserver,
		removeContext: removeContext,
		isObserving: isObserving,
		getObservers: getObservers,
		getObservedEvents: getObservedEvents,
		hasObservers: hasObservers
	};

	return Constr;
}());

/**
 * Binds events to ajax requests. When an event happens a resulting ajax 
 * request is created. All listeners are given a chance to add queries.
 * Once all listeners have had a chance to add queries to the request it 
 * is performed. The results of the request are then distributed to interested 
 * listeners
 *
 * @class AjaxEvent
 * @namespace Moonshadow.Events
 * @constructor
 * @param {Moonshadow.Manager} man - Instance of manager
 * @param {String} event - Event name to listen for
 */
Moonshadow.namespace("Moonshadow.Events.AjaxEvent");
Moonshadow.Events.AjaxEvent = (function() {
	// Private vars
	var manager,
	Constr,
	// Private methods
	/**
	 * Add a listener. The listener must implement onAjaxEvent(event, data, ajax) 
	 * @method addListener
	 * @param {Object} Refernce to object with onAjaxEvent
	 */
	addListener = function(listener) {
		if($.inArray(listener,this.listeners) == -1)
			this.listeners.push(listener);
	},
	/** 
	 * Remove a listener - Obvious name is obvious
	 * @method removeListener
	 * @param {Object} Reference to object to remove from listeners
	 */
	removeListener = function(listener) {
		this.listeners = $.map(this.listeners,function(el) {
			if (el !== listener) {
				return el;
			}
		});
	},
	/**
	 * This function is called when the event the object is monitoring happens. 
	 * It send the ajax request to it's listeners so that they can add requests
	 * @method notify
	 * @param {String} event - Name of the event that happened
	 * @param {Object} data - Data
	 * @param {Boolean} block - If blocking, reruns the event with last blocked
	 */
	notify = function(event, data, block) {
		if(this.previousAjax) {
			var request = this.previousAjax.getRequest();
			if(request && request.readyState !== 0 && request.readyState < 4) {
				if(block) {
					this.blocked = {
						"event": event,
						"data": data,
						"blocked": block
					}
				
					return false;
				} else {
					request.abort();
				}
			}
		}	

		var ajax = new Moonshadow.Ajax();
		this.previousAjax = ajax;

		for(var i = 0,l = this.listeners.length; i < l; i++) {
			if(typeof this.listeners[i].onAjaxEvent == "function") { 
				this.listeners[i].onAjaxEvent(event, data || {}, ajax);
			}
		}

		var onComplete = (function(context, callback) {
			return function() {
				var blocked = context.blocked;
				if(blocked) {
					context.blocked = false;
					context.notify(blocked.event, blocked.data, true);
				}
			}
		})(this);

		ajax.execute(onComplete);
	};

	Constr = function(man,event) {
		manager = man;
		this.listeners = [];
		this.previousAjax = false;
		this.blocked = false;
		manager.addMapObserver(event,this);
	};
	// Public methods
	Constr.prototype = {
		constructor: Moonshadow.Events.EventsAjax,
		notify: notify,
		addListener: addListener,
		removeListener: removeListener,
		/**
		 * Listeners
		 * @property listeners
		 * @type Object[]
	 	 */
		listeners: this.listeners
	}

	return Constr;
}());

/**
 *
 * @class Manager
 * @namespace Moonshadow.Datasource
 * @constructor constr
 */
Moonshadow.namespace("Moonshadow.Datastore.Manager");
Moonshadow.Datastore.Manager = (function() {
	var datums = {},
		Constr,
		/**
		 * 
		 * @method getDatum
		 * @param {} key
		 */
		getDatum = function(key) {
			if(typeof datums[key] == "undefined")
				return setupDatum(key);
		
			return datums[key];
		},
		/**
		 * @method setupDatum
		 * @private 
		 * @param {} key
		 */
		setupDatum = function(key) {
			if(typeof Moonshadow.Datastore.Datums[key] == "undefined")
				return false;
	
			datums[key] = new Moonshadow.Datastore.Datums[key]();
	
			return datums[key];
		};

	Constr = function() {};
	Constr.prototype = {
		getDatum: getDatum,
	};

	return Constr;
}());

Moonshadow.Stats = function(manager) {
	this.manager = manager;
	this.requests = 0;
	this.requestTimes = 0;
	this.queries = 0;
	this.queryTimes = 0;
	this.clientStart = new Date().getTime();
	this.intervalTime = 1 * 60 * 1000; // 1 minute

	this.observer = new Moonshadow.Observer();

	var self = this;
	this.interval = setInterval(function() {
		self.onInterval();
	}, this.intervalTime);
};

Moonshadow.Stats.prototype.addRequestStats = function(requestTime, queries) {
	this.requests++;
	this.requestTimes += requestTime;
	this.queries += queries.length;
	
	for (var i = 0, l = queries.length; i < l; i++) {
		this.queryTimes += queries[i].time;	
	}

	this.observer.notify('stats', {
		'requestTime': requestTime,
		'queries': queries
	});
};

Moonshadow.Stats.prototype.onInterval = function() {
	// If no requests have been performed, don't send data
	if (!this.requests) {
		return;
	}

	this.send();
};

Moonshadow.Stats.prototype.send = function() {
	var self = this;
	var	requests = this.requests;
	var requestTimes = this.requestTimes;
	var queries = this.queries;
	var queryTimes = this.queryTimes;
	var clientAge = new Date().getTime() - this.clientStart;

	if (Moonshadow.server) {
		var onSuccess = function(data) {
			self.requests -= requests;
			self.requestTimes -= requestTimes;
			self.queries -= queries;
			self.queryTimes -= queryTimes;
		};
		
		var manager = Moonshadow.getManager();
		
		var onError = function(xhr, status, error) {
			// don't do anything destructive to the interval unless the session is expired
			if(xhr.status === 401) {
				clearInterval(self.interval);
				Moonshadow.getManager().onExpiredSession();
			}
		};

		var data = {
			'requests': requests,
			'request_times': (requestTimes / requests).toFixed(0) / 1,
			'queries': queries,
			'query_times': (queryTimes / queries).toFixed(0) / 1,
			'client_age': clientAge,
			'customername': manager.getOption('customer'),
			'username': manager.getOption("user"),
			'embedded': !!Moonshadow.parentOrigin
		};

		$.ajax({
			'url': "/client/stats",
			'cache': false,
			'type': "POST",
			'data': JSON.stringify(data),
			'contentType': 'application/json',
			'dataType': "json",
			'success': onSuccess,
			'error': onError
		});
	}
};

Moonshadow.Stats.prototype.addListener = function(listener, context) {
	this.observer.addObserver('stats', listener, context);
};

Moonshadow.Stats.prototype.removeListener = function(listener, context) {
	this.observer.removeObserver('stats', listener, context);
};

/**
 *
 * @method Core
 * @namespace Moonshadow.Datasource.Datums
 * @constructor constr
 */

Moonshadow.namespace("Moonshadow.Datastore.Datums.Core");
Moonshadow.Datastore.Datums.Core = (function() {
	var	constr = function() {
		this.observer = new Moonshadow.Observer();
	};
	/**
	 *
	 * @method addOverver
	 * @param {} e
	 * @param {} o
	 * @param {} c
	 *
	 * @method removeObserver
	 * @param {} e 
	 * @param {} o
	 * @param {} c
	 *
	 * @method notify
	 * @param {} e
	 * @param {} d
	 * @param {} b
	 */
	
	constr.prototype = {
		addObserver: function(e,o,c) { this.observer.addObserver(e,o,c); },
		removeObserver: function(e,o,c) { this.observer.removeObserver(e,o,c)},
		notify: function(e,d,b) { this.observer.notify(e,d,b); }
	};

	return constr;
})();

/**
 * Manager class. Acts as mediator for adapter, data and controls
 *
 * @class Manager
 * @namespace Moonshadow
 * @param {HTMLEntity} container Container for map and control
 * @param {Object literal} options Extra options -- DEPRECATED
 */
Moonshadow.namespace("Moonshadow.Manager");
Moonshadow.Manager = (function() {
	// Private vars
	var options = {}, // Options
	datasource = null, // Datasource id
	lastChange = null, // Delta
	container = null, // Reference to HTML Entity that is holding the map
	startMapLoad = false,
	windowObservers = {},
	windowMessageObservers = {},
	mapObservers = new Moonshadow.Observer(),
	dataObservers = new Moonshadow.Observer(),
	datastore = new Moonshadow.Datastore.Manager(),
	statsHandler = new Moonshadow.Stats(),
	ajaxListeners = [],
	adapter = null, // Variable for holding adapter 
	controls = {}, // Control collection
	preloadN = 0, // TODO WTF - I think is a count for load attempts
	addons = [],
	oauths = [],
	Constr, // Holds public contructor and apis
	// Private methods

	/**
	 * Setup adapter and begining control loading - this happens after all the controls have loaded
	 * @method init
	 * @private
	 */
	init = function() {
		if($().jquery != Moonshadow.jQueryVersion) { // Check jQuery version
			throw new Error("Requires "+Moonshadow.jQueryVersion+" version of jQuery - https://jquery.com/"); 
		} 
		if(typeof JSON.stringify != "function") { 
			throw new Error("JSON library requred!");
		} 
		
		updateLastChange(); // @CLEAN UP - what is this for? 1/4/12 RRO

		adapter = Moonshadow.maps[getMapProvider()].factory(this, options.map);	
		if(!adapter) {
			throw new Error("Unknown map provider");
		}

		Moonshadow.helpers.updateProgress(60, 'Setting up client UI...');

		adapter.init(); // Setup and display map
		initControls(); // Setup and display controls
				
		// Google Analytics setup
		if(typeof options.ga != "undefined") {
			Moonshadow.getManager().ga = new Moonshadow.helpers.GA(Moonshadow.getManager(),options.ga); // This is hacky, GA needs to be made a plugin/control
		} else {
			Moonshadow.getManager().ga = false;
		}

		Moonshadow.helpers.updateProgress(90, 'Loading tiles...');
		
		if (window.deprecatedAgent) {
			MUILayoverPanel.alert({
				"modal": false,
				"title": "ATTENTION",
				"message": "The support of your current browser version will end soon. " +
					"Please update your browser to assure a properly functioning product.",
				"position": {
					"top": 100,
					"left": 100
				}
			})
		}
		
	},
	/**
	 * A collection of controls to be loaded first
	 * @array initialControls
	 * @private
	 */
	initialControls = [
		"MControlDatasources"
	],
	/**
	 * A collection of controls to be part of the core system and should always be loaded
	 * @array coreControls
	 * @private
	 */
	coreControls = [
		"MControlColors",
		"MControlUniverses",
		"MControlUserSettings",
		"MControlFilters",
		"MControlColorBy",
		"MControlCounts",
		"MControlTriplets",
		"MLayerBase",
		"MLayerMask",
		"MLayerMesh",
		"MLayerRegion",
		"reportqueue",
		"rasterlayer",
		"reporttypes",
		"MControlMarkers",
		"MControlMarkerInfo"
	],
	/**
	 * A collection of controls to be optionally loaded
	 * @array optionalControls
	 * @private
	 */
	optionalControls = [
		"MControlShape",
		"MControlRouting",
		"MControlStatsUI",
		"rasterdisplay",
		"nationbuilderui",
		"MControlManagement",
		"MControlTemporal",
		"MUIColorPicker",
		"colorby"
	],
	/**
	 * A collection of controls to be loaded if specific addons are enabled
	 * @array addonControls
	 * @private
	 */
	addonControls = [],
	/**
	 * Adds cotrols to load list
	 * @method setUpControls
	 * @private
	 */
	setUpControls = function(){
		var manager = Moonshadow.getManager();

		if (manager.getOption("nologout",0) == 0) {
			optionalControls.push("MControlLogout");
		}

		if (manager.getOption("enable_management") === true &&
			manager.getOption("admin_user") == manager.getOption("user")) {
			optionalControls.push("MPanelContentManagement");
		}
		
		if (MPanelContentStateInfo.enabled()) {
			optionalControls.push("MPanelContentStateInfo");
		}
		
		if (MUIGradientPicker.enabled()){
			addonControls.push("MUIGradientPicker");
		}
		
		if($.inArray('groundgame', manager.getOption("app_addons")) > -1) {
			addonControls.push("MControlGroundGame");
			addonControls.push("MControlCanvassingMarkers");
			addonControls.push("MControlSurveys");
		}
		
		if($.inArray('ad_sales', manager.getOption("app_addons")) > -1) {
			addonControls.push("MControlAdSales");
		}
		
		if($.inArray('phonecampaigns', manager.getOption("app_addons")) > -1) {
			addonControls.push("MControlPhoneCampaigns");
			addonControls.push("MControlSurveys");
		}
		
		if($.inArray('fbpolls', manager.getOption("app_addons")) > -1) {
			addonControls.push("MControlFacebookPolls");
			addonControls.push("MControlSurveys");
		}
	},
	/**
	 * Turn in to objects and clean out dupes
	 * @method cleanControls
	 * @private
	 */
	cleanControls = function(dirty){
		var clean = [];
		var cleanList = {};

		for(var i = 0, l = dirty.length; i < l; i++) {
			var control = dirty[i];

			// Turn in to object
			if(typeof control !== 'object') {
				control = {'int_name': control};
			}

			// No longer using this control
			if(control.int_name === 'MPanelContentTile') {
				continue;
			}
			
			// No longer using this control
			if(control.int_name === 'MControlSpreadSheet') {
				continue;
			}
			
			// No longer using this control. @HACK
			if(control.int_name === 'MPanelContentSearch') {
				var manager = Moonshadow.getManager();
				manager.setOption("search", {"options": control.options});
				continue;
			}

			// Dupe
			if(cleanList[control.int_name]) {
				continue;
			}

			// Add to clean list
			cleanList[control.int_name] = true;			
			clean.push(control);
		}

		return clean; // Set cleaned up controls
	},
	/**
	 * Creates controls listed in options.controls
	 * @method initControls
	 * @private
	 */
	initControls = function() {
		var manager = Moonshadow.getManager();
		
		setUpControls.call(this);
		
		var dirty;
		if (!manager.getOption('onlyCore')) {
			dirty = [].concat(
				coreControls, 
				optionalControls, 
				options.controls, 
				addonControls
			);
		} else {
			dirty = coreControls;
		}
		
		options.controls = cleanControls.call(this, dirty);

		var controlCount = options.controls.length + initialControls.length;
		
		manager.addMapObserver("control_loaded",function(){
			var countControls = function(o) {
				var count = 0;
				for(var controlName in controls) {
					if(controls.hasOwnProperty(controlName)) {
						count++;
					}
				}
				return count; 
			};
			if(controlCount == countControls(controls)) {
				onControlsInited.call();
			}
		});
		
		for(var i = 0; i < options.controls.length; i++) {
			var v = options.controls[i];

			if(typeof v != "object") {
				v = {"int_name": v, "options": {}};
			}

			var controlType = v.int_name;
			var controlOptions = v.options || {};

			if(typeof window[controlType] != "function") { 
				var d = new Date;

				var styleUrl = Moonshadow.scriptPath + "/css/" + controlType + 
					".css?v="+d.getTime();

				$("head").append("<link>");
				css = $("head").children(":last");
				css.attr({
					rel:  "stylesheet",
					type: "text/css",
					href: styleUrl
				});
				
				var scriptUrl = Moonshadow.scriptPath + "/controls/" + controlType + 
					".js?=v"+d.getTime();
				Moonshadow.loadScript(scriptUrl, (function() { 
					var timer;

					return function(data,status) {
						if(timer == undefined && status == "success") {
							timer = setInterval(function() {
								if (typeof window[controlType] == "function") {
									clearInterval(timer);
									var success = Moonshadow.getManager().addControl(controlType,controlOptions);
									if(!success)
										--i;
								}
							}, 200);					
						}
					};
				})());
			} else {
				var success = manager.addControl(controlType,controlOptions);
				if(!success)
					--i;
			}
		};
		
	},
	/**
	 * After all controls init functions are called 
	 * @method onControlsInited
	 * @private 
	 */
	onControlsInited = function() {
		mapObservers.notify('loaded');
	},
	/**
	 * Updates the lastChange with current 
	 * @method updateLastChange
	 * @return {Date}
	 * @private 
	 */
	updateLastChange = function() { 
		var curdate = new Date;
		lastChange = curdate.getTime();
		return lastChange;
	},
	/**
	 * Get the current delta - the delta is maintained to handles caching
	 * @method getDelta
	 * @return {Date}
	 * @private
	 */
	getDelta = function() {
		if(lastChange == null) {
			updateLastChange;
		}
		return lastChange;
	},
	/**
	 * Updates the delta and sends an event to the adapter letting it know of the delta change
	 * @method updateDelta
	 * @private
	 */
	updateDelta = function() {
		adapter.notifyOfDeltaChange(updateLastChange());
		return lastChange;
	},
	/**
	 * Get the adapter
	 * @method getAdapter
	 * @return {Adapter}
	 */
	getAdapter = function() { return adapter; },
	getMap = function() { return getAdapter(); }, // DEPRECATED
	/** 
	 * Get stats handler
	 *
	 * @method getStatsHandler
 	 * @return {Moonshadow.Stats} Stats handler
	 */
	getStatsHandler = function() {
		return statsHandler;
	},
	/**
	 * Show/hide stats UI
	 *
	 * @method toggleStats
	 *
	 */
	toggleStats = function() {
		var statsUI = this.getControl('statsui');
		if (statsUI.isShown()) {
			this.getControl('statsui').hide();
		} else {
			this.getControl('statsui').show();
		}
	},
	/**
	 * Get the datasource - This is a stub for the future
	 * @method getDatasource
	 * @return {Datasource} 
	 */
	getDatasource = function(id) {
		var lookup = getDatasource.lookup;

		if (!lookup) { // Is lookup table defined
			lookup = {};
			(function(lookup,datasources) { // Build the lookup table
				var i = 0,l = datasources.length;
				for(;i < l;i++) {
					lookup[datasources[i].int_name] = datasources[i];
				}			
			}(lookup,options.datasources));
			getDatasource.lookup = lookup;
		}
		
		if (id == undefined) {
			//if no id, get current color by dsId
			var colorbycontrol = this.getControl("colorbycontrol");
			if(colorbycontrol){
				id = colorbycontrol.getActiveDsId();
			}
			if (!id) {
				//if colorby control is not yet init, determine next viable ds
				id = this.determinDefaultDatasource(options.datasource);
			}
		}
		
		/* Lookup datasource by number(**deprecated**) or int_name */
		return (typeof id === "number") ? options.datasources[id] : lookup[id];
	},
	determinDefaultDatasource = function(idInt){
		if(idInt == undefined){
			idInt = 0;
		}
		var ds = options.datasources[idInt];
		if(!ds){
			//if no ds at index of idInt, return 0
			return 0;
		}
		var dsControl = this.getControl("datasources");
		if(!dsControl){
			//if datasources control not init, return 0
			return 0;
		}
		var hasReqAddons = dsControl.hasReqAddons(ds.int_name);
		if(!hasReqAddons){
			//if addon requirements not met, get next viable ds
			return this.determinDefaultDatasource(++idInt);
		}
		return ds.int_name;
	},
	/**
	 * Set the datas - This is stub in place for future
	 * @method setDatasource
	 * @param {Datasource} pos Position in datasources
	 * @private
	 */
	setDatasource = function(dsId) {
		// @TODO This should probably be 'this.datasource'
		var prev = options.datasource; 

		if(prev != dsId) {
			options.datasource = dsId;
		}

		// Notify Google analytics
		if (this.ga) {
			this.ga.notify('datasource', dsId);
		}
	},
	/**
	 * Get the id of the current adapter
	 * @method getMapProvider
	 * @return {Number}
	 */
	getMapProvider = function() {
		return options.map.adapter || false;
	 },
	/**
	 * Get the key forthe current adapter, if it has one
	 * @method getMapKey
	 * @return {String}
	 */
	getMapKey = function() {
		return options.map.key || false;
	},
	/**
	 * Add a window observer
	 * @note This is a function to attach listeners to the window object, as
	 * 		the adapter events sometimes don't get fired (i.e., "resize" is
	 * 		not fired in Bing when window is dragged horizontally)
	 * @method addWindowObserver
	 * @param {Event} e Event to watch for
	 * @param {Callback} c Function to call
	 * @param {Object} o Object to call the callback on (optional)
	 */
	addWindowObserver = function(e, c, o, capture) {
		var cb = this.registerWindowObserver(e, c, o);
		if(window.addEventListener) {
			return window.addEventListener(e, cb, capture); 
		}
		window.attachEvent(e, cb, capture);
	},
	/**
	 * Register a window observer 
	 * @method registerWindowObserver
	 * @param {Event} e Event to watch for
	 * @param {Callback} c Function to call
	 * @param {Object} o Object to call the callback on (optional)
	 */
	registerWindowObserver = function(e, c, o){
		var wo = windowObservers;
		if(!wo[e]){
			wo[e] = {};
		}
		var key = $.md5([e, c, o]);
		wo[e][key] = function(event){
			if(o){
				return c.call(o, e, event);
			}
			c(e, event);
		};
		return wo[e][key];
	},
	/**
	 * Remove a window observer
	 * @method removeWindowObserver
	 * @param {Event} e Event to watch for
	 * @param {Callback} c Function to call
	 * @param {Object} o Object to call the callback on (optional)
	 */
	removeWindowObserver = function(e, c, o, capture) {
		var wo = windowObservers;
		var key = $.md5([e, c, o]);
		if(wo[e] && wo[e][key]){
			if(window.removeEventListener) {
				window.removeEventListener(e, wo[e][key], capture);
			}else{
				window.detachEvent(e, wo[e][key], capture);
			}
			delete wo[e][key];
		}
	},
	/**
	 * Add a map observer
	 * @method addMapObserver
	 * @param {Event} e Event to watch for
	 * @param {Callback} o Function to call, if not a function try o.notify()
	 */
	addMapObserver = function(e,o,c) {
		mapObservers.addObserver(e,o,c);
	},
	/**
	 * Removes a map observer
	 * @method removeMapObserver
	 * @param {Event} e Event being watched for
	 * @param {Callback} o Callback to remove
	 */
	removeMapObserver = function(e,o,c) {
		mapObservers.removeObserver(e,o,c);
	},
	/** 
	 * Remove an context from observer
	 * @method removeContext
	 * @param {String} e Event name to match
	 * @param {Object} c Context to use for o if function
	 */
	removeMapContext = function(e,c) {
		mapObservers.removeContext(e,c);
	},
	/**
	 * Notify event observers
	 * @method notifyMapObservers
	 * @param {Event} e Event being watched for
	 * @param {Object} o Data
	 */
	notify = function(e, o, b) {
		mapObservers.notify(e, o, b);
	},
	/**
	 * Added an ajax event listener 
	 * @method addAjaxEventListener
	 * @param {Event} e Event name to watch for
	 * @param {Callback} o Object to do callback
	 */
	addAjaxEventListener = function(e,o) {
		if(typeof ajaxListeners[e] == "undefined") {
			ajaxListeners[e] = new Moonshadow.Events.AjaxEvent(this,e);
		}

		ajaxListeners[e].addListener(o);
	},
	/**
	 * Remove an ajax event listener
	 * @method removeAjaxEventListener
	 * @param {Event} e Event name to watch for
	 * @param {Callback} o Object to do callback
	 */
	removeAjaxEventListener = function(e,o) {
		if(typeof ajaxListeners[e] == "undefined") {
			return;
		}

		ajaxListeners[e].removeListener(o);
	},
	/**
	 * Get instance of datastore
	 * @method getDatastore
	 * @returns {Moonshadow.Datastore.Manager}
	 */
	getDatastore = function() {
		return datastore;
	},
	deleteControl = function(control_name) {
		if(options && options.controls){
			for(var ii = 0, ll = options.controls.length; ii < ll; ++ii){
				var delopt = false;
				if(typeof options.controls[ii] == "object" 
						&& options.controls[ii].int_name == control_name){
					delopt = true;
				}else if(options.controls[ii] == control_name){
					delopt = true;
				}
				if(delopt){
					options.controls.splice(ii, 1);
					return true;
				}
			}
		}
		return false;
	},
	/**
	 * Add control to the application
	 * @method addControl
	 * @param {Moonshadow.Control} c Instace of a control to add to app
	 */
	addControl = function(c,o) {
		if(typeof window[c] != "function") return false;
				
		var control = new window[c](o);
//		if(control && control.restrict){
//			var user_type = this.getOption("user_details.user_type");
//			if(user_type && control.restrict[user_type]){
//				deleteControl(c);
//				return false;
//			}
//		}
		
		var parent = this;
		var pTimer = false;

		var init = function() {
			if((control.childOf == null || Moonshadow.getManager().getControl(control.childOf)) 
					&& controls[control.name] == undefined) {
				if(pTimer) { 
					clearInterval(pTimer);
					pTimer = false;
				}
				controls[control.name] = control;
				controls[control.name].init(parent);
				Moonshadow.getManager().mapObservers.notify("control_loaded");
			}
		};

		if(control.childOf && !Moonshadow.getManager().getControl(control.childOf)) {
			pTimer = setInterval(function() { init(); },20);
		} else {
			init();
		}
		
		return true;
	},
	/**
	 * Removes a control from the interface
	 * @method removeControl
	 * @param {}
	 * @TODO
	 */
	removeControl = function(c) {
		//TODO
	},
	getOptions = function() {
		return options;
	},
	/**
	 * Get an option
	 * @method getOption
	 * @param {String} p String with path to part of object string that you need
	 * @param {Anything} d Default if option not found
	 * @return {Anything} Value of the option or undefined
	 */
	getOption = function(p,d) { // (path as string, default(options) returns false if undefined)
		var a = p.split(".");
		var op = options;
		var result = true;
		for(var i = 0,l = a.length;i < l;i++) {
			if(typeof op[a[i]] == "undefined") return (typeof d != "undefined") ? d : undefined;
			op = op[a[i]];
		}

		return op;
	},
	/**
	 * Set an option
	 * @method setOption
	 * @param {String} p String with path to part of object string that you need
	 * @param {Anything} v Value to set
	 */
	setOption = function(p,v) {
		var a = p.split(".");
		var b = a.pop();
		var path = options;
		for(var i = 0,l = a.length;i < l;i++) {
			if(typeof path[a[i]] == "undefined") path[a[i]] = {};
			path = path[a[i]];
		}
		path[b] = v;
	},
	/**
	 * Get the container
	 * @method getContainer
	 * @return {HTML Entitiy} Reference to container
	 */
	getContainer = function() {
		return container;
	},
	/**
	 * Gets if the control is supposed to be loaded
	 * @method shouldControlBeLoaded
	 * @param {String} controlId String with int_name of control you want
	 * @retun {Boolean} Retuns true if contorl is supposed to loaded and false if not
	 */
	shouldControlBeLoaded = function(controlType) {
		var controls = getOption("controls");
		var toBeLoaded = false;
		$.each(controls,function(k,v) {
			if(typeof v == "string" && v == controlType) // Support less verbose scheme of loading
				toBeLoaded = true;
			if(typeof v == "object" && typeof v.int_name != "undefined" && v.int_name == controlType) // Support more verbose scheme of loading
				toBeLoaded = true;

			if(toBeLoaded) return false;
		});

		return toBeLoaded;
	},
	/**
	 * Get if a control is ready or not
	 * @method isControlReady
	 * @param {String} controlId String with int_name of control you want
	 * @retun {Boolean} Retuns true if control ready, false if not
	 */
	isControlReady = function(controlId) {
		return (typeof controls[controlId] != "undefined") ? true : false;
	},
	/**
	 * @method addControlToLoadList
	 * @param {String} controlId String with int_name of control you want
	 * @retun {Boolean} Retuns true if control ready, false if not
	 */
	addControlToLoadList = function(name) {
		var found = false;
		$.each(options.controls, function(index, item) {
			var controlName = (item && item.int_name) ? item.int_name : item ;
			if(controlName === name) {
				found = true;
				return false;
			}
		});

		if(!found) {
			options.controls.push(name);
		}
	},
	/**
	 * Get a control by int_name
	 * @method getControl
	 * @param {String} controlId String with int_name of control you want
	 * @retun {Object} Retuns the control
	 */
	getControl = function(controlId) {
		if(typeof controls[controlId] != "undefined") return controls[controlId]; 
		return undefined;
	},
	/**
	 * Get the control object
	 * @method getControls
	 * @return {Object} Object containing controls by their int_name
	 */
	getControls = function() {
		return controls;
	},
	/**
	 * Get the purchased control object
	 * @method getFilterableControl
	 * @param {String} parentName
	 * @param {String} controlName
	 * @return {Object} 
	 */
	getFilterableControl = function(parentName, controlName){
		var control = false;
		if(this.shouldControlBeLoaded("MPanelContentFilterV3")) {
			var ds = this.getControl("filters").datasources[parentName];
			if(ds && ds.filterables[controlName || parentName]) {
				control = ds.filterables[controlName || parentName];
			}
		}
		return control;
	},
	/**
	 * Get the spreadsheet control object
	 * @method getSpreadsheetControl
	 * @return {Object} 
	 */
	getSpreadsheetControl = function(){
		return this.getFilterableControl("__spreadsheets");
	},
	/**
	 * Get the universe control object
	 * @method getUniverseControl
	 * @return {Object} 
	 */
	getUniverseControl = function(){
		return this.getFilterableControl("__universes");
	},
	/**
	 *
	 * @method showErrorBox
	 * @param {} msg
	 */
	showErrorBox = function(msg) {
		if(getAdapter() == null) return;
		var errorCount = document.createElement("span");
		errorCount.appendChild(document.createTextNode(msg));
		var errorBox = document.createElement("div");
		errorBox.id = "error_box";
		errorBox.appendChild(errorCount);
		errorBox.position = 1;
		document.getElementById('maincontainer').appendChild(errorBox);
		return errorBox;
	},
	/**
	 * Loads options and builds defaults
	 * @method loadAppAttrs
	 * @param {Object literal} override Extra options - DEPRECATED
	 * @private
	 */
	loadAppAttrs = function(override) {
		var self = this;

		Moonshadow.helpers.updateProgress(20, 'Preparing data...');

		var ajax = new Moonshadow.Ajax();
		ajax.addQuery({query:"ping",qid:"ping"}, function(data) {
			if(data.result != "ok") {
				throw new  Error("Problems connecting to data server");
			} else {
				options.api_version = (data.api_version != undefined) 
					? data.api_version : 1;
				options.query_version = (data.version != undefined) 
					? data.version : "Unknown";
			}		
		},this);

		ajax.addQuery({query:"get_application_attributes",qid:"appattrs"},
					  function(data) {
			if(data.result != "ok") {
				Moonshadow.log(data);
				throw new Error(data.message || 'Unknown error');
			}
			
			options = $.extend(true,{},options,data.attributes);
			options.logout = options.logout || "/login/logout";

			if(typeof options.map !== 'object') {
				options.map = {};
			}		

			if(typeof options.map.adapter === 'undefined') {
				options.map.adapter = Moonshadow.MAP_TYPE_BING;
			}

			$.each(options.datasources,function(k,v) {
				if(typeof v.layers == "undefined") {
					v.layers = {};
				}
			});
			options.datasource = 0;
		},this);

		ajax.addQuery({'query': 'report_errors_by_app', 'qid':'reporterrors'}, 
					  function(data) {
			if (data.result === 'fail') {
				return;
			}

			if (data.errors.length > 0 && getOption('user_details.user_level') == 1) { 
				this.addMapObserver('maploaded', function() {
					if (getAdapter() == null || $('#error_box').length != 0) return;

					var errorBox = showErrorBox(data.errors.length);
					$(errorBox).click((function(errors) {
						return function() {
							Moonshadow.log(errors);
						};
					})(data.errors));

				}, this);
			}
		}, this);

		var userSettings = {
			'query':'load_stored_state',
			'qid':'usersettings',
			'name':'user_settings',
			'ds':'__app'
		};
		ajax.addQuery(userSettings, (function(data) {
			if(data.result === 'ok') {
				// If user settings loaded correctly then merge them in to the options
				options = $.extend(true,{},options,{"user_settings": data.value});
				if(options.user_settings.center == undefined){
					options.user_settings.center = {
						"lat": 0,
						"long": 0
					};
				}
				options.map.lat = options.user_settings.center.lat;
				options.map.long = options.user_settings.center.long;
				
				if(options.user_settings.z == undefined){
					options.user_settings.z = 3;
				}
				options.map.z = options.user_settings.z;
				
				if(options.user_settings.mapType != undefined){
					options.map.mapType = options.user_settings.mapType;					
				}
				
				if (options.user_settings.mapAdapter != undefined) {
					options.map.adapter = options.user_settings.mapAdapter;
				}
			}
		}),this);

		ajax.addQuery({query:"list_datasources",qid:"datasources"},(function (data) {
			if(data.result != "ok" || !data.datasources.length) {
				throw new Error("No datasources were loaded");
			}

			if(data.datasources.length != options.datasources.length) {
				throw new Error("Some datasources didn't load");
			}

			Moonshadow.helpers.updateProgress(40, 'Retrieving datasource details...');

			loadInitialControls.call(this);
			
			var self = this;
			
			var datasources = this.getControl('datasources');
			datasources.getStructure(data.datasources, function() {
				self.setupUserSettings();
				self.initCallback();
			});
			
		}),this);

		options.available_meshes = [];
		ajax.addQuery({'query': 'get_mesh_avail_list'}, function(data) {
			if(data.result === 'ok') {
				options.available_meshes = data.meshes;
			}
		}, this);

		ajax.addQuery({'query': 'load_stored_state', 'qid': 'usermesh',
					   'name': 'mesh_settings', 'ds': '__app'}, function(data) {
			if (data.result === 'ok') {
				options.user_meshes = data.value;
			}
		}, this);
		
		ajax.execute();
	},
	/**
	 *
	 * @method loadInitialControls
	 */
	loadInitialControls = function(){
		initialControls = cleanControls.call(this, initialControls);
		for(var i = 0, l = initialControls.length; i < l; ++i){
			this.addControl(initialControls[i].int_name, initialControls[i].options || {});
		}
	},
	/**
	*
	* @method prepareDatasourceLayers
	* @param {} ds
	* @param {} data
	*/
	prepareDatasourceLayers = function() {
		var options = this.getOptions();
		var colorbyControl = this.getControl("colorbycontrol");
		for(var i = 0, l = options.datasources.length;i < l;i++) { 
			options.datasources[i].layers = {
				"base": colorbyControl.getColorBy(options.datasources[i].int_name)
			};
		}
	},
	/**
	 * Load user settings
	 * @method setupUserSettings
	 * @private
	 */
	setupUserSettings = function() {
		var self = this;
		var ucbDsId = this.getOption("user_settings.ucbdsid");
		if(!ucbDsId){
			ucbDsId = this.getDatasource().int_name;
		}
		
		self.setDatasource(ucbDsId);
	},
	/**
	 * Loads the appropriate map libraries if not already loaded. Once loaded calls init();
	 * @method __loadMapLibrary
	 * @private
	 */
	loadMapLibrary = function(counter) {
		var map = Moonshadow.maps[getMapProvider()];
		if(!map) {
			throw new Error("Invalid map provider");
		}

		if(!counter){
			counter = 0;
		}
		
		var loadMapLibrary = arguments.callee;
		var check = function(data, status, jqxhr) {
			if(map.isLibraryReady()) {
				loadMapAdapter();
			} else if (counter > 50) {
				Moonshadow.log("Cant get map library", data, status, jqxhr && jqxhr.status);
				throw new Error("Cant get map library");
			} else { 
				loadMapLibrary(++counter);
			}
		};

		if(!map.isLibraryReady()) { //Check if libraries are loaded. If not then lets load them
			Moonshadow.loadScript(map.library, function(data, status, jqxhr) {
				setTimeout(function(){
					check(data, status, jqxhr);
				}, 200);
			});
		} else { // Map libary is loaded, lets do this
			loadMapAdapter();
		}
	},
	/**
	 * Get the appropriate map adapter
	 * @method loadMapAdapter
	 * @private
	 */
	loadMapAdapter = function() {
		var map = Moonshadow.maps[getMapProvider()];
		if(!map) {
			throw new Error('Invalid map provider');
		}
		try{
			init.call(Moonshadow.getManager());
		}catch(e){
			debugger;
		}
		
	},
	/**
	 *
	 * @method onServerResponding
	 */
	onServerResponding = function() {
		this.serverNotResponding = false;
	},
	 /**
	 *
	 * @method onServerNotResponding
	 */
	onServerNotResponding = function() {
		this.serverNotResponding = true;
		Moonshadow.helpers.displayError('Problem communicating with server');
	},
	/**
	 *
	 * @method onDeadSession
	 */
	onDeadSession = function() {
		Moonshadow.sessionActive = false;
		var message = 'Your session is no longer valid.';
	   	if(!this.openLoginPanel(message + " Please log in to proceed.")){
	   		var origin = this.getOption('parentOrigin');
			if (origin) {
				Moonshadow.helpers.displayError(message);
			} else {
				window.location = "/user/unauth";
			}
	   	}
	},
	/**
	*
	* @method onExpiredSession
	*/
	onExpiredSession = function() {
		Moonshadow.sessionActive = false;
		var message = 'Your session has expired, please log in again.';
	   	if(!this.openLoginPanel(message + " Please log in to proceed.")){
	   		Moonshadow.helpers.displayError(message);
	   	}
   },
   /**
   *
   * @method openLoginPanel
   */
	openLoginPanel = function(message){
		var logout = this.getControl('logout');
		if(logout){
			logout.reloginForm(message);
			return true;
		}
		return false;
   },
	/**
	 *
	 * @method throwError
	 * @param {} reason
	 */
	throwError = function(reason) {
		throw new Error(reason); // @CLEANUP This is stupid 1/5/12 RRO
	},
	/**
		*
		* @method getErrors
		* @param {} error
	*/
	getErrors = function(error) {
		// This has been stripped for the time being
	},
 	/**
		*
		* @method cvSubscriptionRequired
		* @param {} callback
	*/
	cvSubscriptionRequired = function(callback){
		var textObj = {
			"censusviewer": {
				"title": "Purchase Required",
				"header": "In order to utilize this datasource, you will need to upgrade your subscription.",
				"options": [
					{
						"title": "To upgrade your subscription to get access to the premium data, ",
						"link": {
							"text": "click here.",
							"url": "/subscription/changeplan/censusviewer"
						}
					}
				]
			},
			"censusviewer_anonymous": {
				"title": "Subscription Required",
				"header": "You need to log in before you can download data from CensusViewer.com.",
				"options": [
					{
						"title": "If you do not have a current subscription, ",
						"link": {
							"text": "register here.",
							"url": "https://login.censusviewer.com/subscription/plans/censusviewer/"
						}
					},
					{
						"title": "If you have a subscription, ",
						"link": {
							"text": "login here.",
							"url": "https://login.censusviewer.com/"
						}
					}
				]
			}
		};
		
		var apptype = this.getOption('app_details.type');
		
		if(!apptype || !textObj[apptype])
			return false;
		
		var pre_body = document.createElement("div");
		pre_body.className = "pre_text_head";
		
		var pre_text_head = document.createElement("div");
		pre_text_head.className = "pre_text_head"
		pre_text_head.appendChild(document.createTextNode(textObj[apptype].header));
		pre_body.appendChild(pre_text_head);
		
		if(textObj[apptype].options && textObj[apptype].options.length > 0){
			for(var i = 0, l = textObj[apptype].options.length; i < l; ++i){
				var link_text = document.createElement("div");
				link_text.className = "pre_text"
				link_text.appendChild(document.createTextNode(textObj[apptype].options[i].title));
				var link_anchor = document.createElement("a");
				link_anchor.className = "pre_link clickable";
				link_anchor.appendChild(document.createTextNode(textObj[apptype].options[i].link.text));
				$(link_anchor).click({"url": textObj[apptype].options[i].link.url},function(e) {
					window.location = e.data.url;
				});
				link_text.appendChild(link_anchor);
				pre_body.appendChild(link_text);
			}
		}
		
		var _subReq = new MUILayoverPanel({
			"id": "prescrip", 
			"content": pre_body, 
			"title": textObj[apptype].title,
			"animate": true
		});
		_subReq.open();
		
		callback && callback();
	},
	/**
	 *
	 * @method isAnonymous
	 */
	isAnonymous = function() {
		return !(this.getOptions().user.search(/^anon_/) === -1);
	},
	/**
	 *
	 * @method getAppType
	 */
	getAppType = function() {
		return this.getOption('app_details.type');
	},
	/**
	 *
	 * @method initMap
	 * @param {} callback
	 */
	initMap = function() {
		Moonshadow.helpers.updateProgress(50, 'Loading mapping library...');

		// If container isn't an Element throw an error
		if (!container || !container.nodeType || container.nodeType !== 1) { 
			throw new Error("Invalid map container");
		}

		loadMapLibrary();
	},
	/** 
	 *
	 * @method unicodeCheck
	 * @param {} n
	 */
	unicodeCheck = function(n) {
		var ajax = new Moonshadow.Ajax();

		var query = {
			'query': 'get_unicode_list',
			'nogzip': true,
			'count': n || 1000
		};

		ajax.addQuery(query, function(result) {
			var replaced = [];
			for(var i = 0, l = result.unicodes.length; i < l; i++) {
				if(result.unicodes.charCodeAt(i) !== i) {
					replaced.push(i);
				}
			}

			Moonshadow.log(replaced);
		}).execute();
	},
	/**
	 * Check if provider is available
	 *
	 * @method hasOAuth
	 * @param {String} provider Id of oauth provider
	 * @return {Boolean} True if provider is present
	 */
	hasOAuth = function(provider) {
		return ($.inArray(provider, oauths) !== -1);
	}
	/**
	 * Check if addon present
	 * 
	 * @method hasAddon
	 * @param {String} addon Addon id
	 * @return {Boolean} True if addon is present
	 */
	hasAddon = function(addon) {
		return ($.inArray(addon, addons) !== -1);
	};
	
	/**
	 * add oAuth provider
	 * 
	 * @method addOAuth
	 * @param {String} provider Id of oauth provider
	 */
	addOAuth = function(provider) {
		oauths.push(provider);
	}
	
	// Check subscription status. This may move elsewhere if it needs to be bigger
	subscriptionMessages = {
		"votermapping": "Your Votermapping subscription expires in %s. Please call L2 at 1.800.842.5478 to renew, or contact us at " + 
			"<a href='mailto:subscriptions@l2political.com'>subscriptions@l2political.com</a>",
		"default": "Notice: Your subscription expires in %s. "
	};
	subscriptionMessages["consumermapping"] = subscriptionMessages["votermapping"];
	subscriptionMessages["teststore"] = subscriptionMessages["votermapping"];
	subscriptionMessages["unknown"] = subscriptionMessages["votermapping"];
	
	checkSubcriptionStatus = function(self){
		var cSub = function(){
			self.mapObservers.removeObserver('maploaded', cSub);
			var sDet = self.getOption("subscriptionDetails", {});
			
			if(sDet.end){
				var _1 = 86400000; 
				var _13 = _1 * 13;
				var end = new Date(sDet.end);
				var msLeft = end - new Date();
				if(msLeft <= _13){
					var ce = Moonshadow.helpers.ce;
					var dLeft = parseInt(msLeft / _1, 10);
					
					var dString = dLeft +" day" + (dLeft == 1 ? "" : "s");
					if(dLeft == 0){
						dString = " less than a day";
					}
					
					var msgString = subscriptionMessages[sDet.subtype] || subscriptionMessages["default"];
					var msg = msgString.replace("%s", dString);
					
					setTimeout(function(){
						MUILayoverPanel.alert({
							"title": "Attention!",
							"message": $(ce("div"))
								.addClass("subscription_expiration_warning")
								.append(msg),
							"modal": false,
							"position": {
								"top": 60,
								"left": 20
							}
						});
					}, 1000);
				}
			}
		};
		self.mapObservers.addObserver('maploaded', cSub);
	};

	// Public constructor
	Constr = function(o, callback) {
		options = o;
		this.initCallback = callback;
	
		// If container is a a string we need to get a ref element by ID
		container = o.container;
		if(typeof container === 'string') {
			container = $("#" + container)[0];
		}

		// Copy addons in to local variable, bit harder to tamper with
		addons = options.app_addons.slice(0);

		// Copy addons in to local variable, bit harder to tamper with
		oauths = options.oauth.slice(0);

		// Setup error handling so we can show error bar
		this.errorHandler = new Moonshadow.helpers.ErrorHandler();
		window.onerror = this.errorHandler.getHandler();

		// Sometimes bing maps doesn't load all of it's tiles
		// we need to detect that and remove loading screen
		var tilesLoaded = false;
		this.mapObservers.addObserver('maploaded', function() {
			setTimeout(function() {
				if (tilesLoaded === false && $('#overlays').is(':visible')) {
					Moonshadow.helpers.updateProgress(100, 'Done');
		 			$('#overlays').hide();
				}
			}, 15000);
		});
		
		checkSubcriptionStatus(this);
		
		// When all layers loaded, hide the loading overlay
		this.mapObservers.addObserver('tilesloaded', function() {
			tilesLoaded = true;

			Moonshadow.helpers.updateProgress(100, 'Done');

			if ($('#overlays').is(':visible')) {
		 		$('#overlays').hide();
			}
		});

		loadAppAttrs.call(this, options); // Continue loading the client
	};
	
	// Public methods
	Constr.prototype = {
		constructor: Moonshadow.Manager,
		getAdapter: getAdapter,
		getOption: getOption,
		setOption: setOption,
		getContainer: getContainer,
		addControlToLoadList: addControlToLoadList,
		getControl: getControl,
		getControls: getControls,
		addControl: addControl,
		getStatsHandler: getStatsHandler,
		toggleStats: toggleStats,
		getMapProvider: getMapProvider,
		getMapKey: getMapKey,
		getDatastore: getDatastore,
		registerWindowObserver: registerWindowObserver,
		addWindowObserver: addWindowObserver,
		removeWindowObserver: removeWindowObserver,
		addMapObserver: addMapObserver,
		removeMapObserver: removeMapObserver,
		notify: notify,
		mapObservers: mapObservers,
		removeMapContext: removeMapContext,
		dataObservers: dataObservers,
		getDatasource: getDatasource,
		setDatasource: setDatasource,
		determinDefaultDatasource: determinDefaultDatasource,
		setupUserSettings: setupUserSettings,
		addAjaxEventListener: addAjaxEventListener,
		removeAjaxEventListener: removeAjaxEventListener,
		getOptions: getOptions,
		onServerNotResponding: onServerNotResponding,
		onDeadSession: onDeadSession,
		onExpiredSession: onExpiredSession,
		openLoginPanel: openLoginPanel,
		isControlReady: isControlReady,
		shouldControlBeLoaded: shouldControlBeLoaded,
		throwError: throwError,
		getErrors: getErrors,
		cvSubscriptionRequired: cvSubscriptionRequired,
		isAnonymous: isAnonymous,
		getAppType: getAppType,
		initMap: initMap,
		unicodeCheck: unicodeCheck,
		hasOAuth: hasOAuth,
		hasAddon: hasAddon,
		addOAuth: addOAuth,
		getUniverseControl: getUniverseControl,
		getFilterableControl: getFilterableControl,
		getSpreadsheetControl: getSpreadsheetControl
	};
	
	return Constr;
}());

/**
 * Layer
 * @class Layer
 * @namespace Moonshadow.Map
 */
Moonshadow.namespace("Moonshadow.Map.Layer");
function MTileLayer(adapter,id) {
	this.adapter = adapter;
	this.id = id;
	this.settings = $.extend({},this.settings);
	this.observers = new Moonshadow.Observer();
};
MTileLayer.prototype = {
	/**
	 *
	 * @method getAdapter
	 */
	getAdapter: function() {
		return this.adapter;
	},
	getSettings: function() {
		return this.settings;
	},
	/**
	 *
	 * @method changeSettings
	 * @param {} options
	 */
	changeSettings: function(options) {
		var settings = this.settings; // Current settings

		// Handle trying to some of the invalid cases for dataType
		if(typeof options.dataType != "undefined" && options.dataType == "") { 
			delete options.dataType;
		}
		
		var wasChange = false;
		var isShown = this.getSetting("show"); //We need to know if show changed
		$.each(options, function(k,v) {	// Change items	
			// Start of something I will finish later
			if (typeof settings[k] == "undefined" || settings[k] != v) {
				wasChange = true; 
			}

			settings[k] = v;
		});

		this.updateDelta();
		
		var howAboutNow = this.getSetting("show");
		if(isShown != howAboutNow) { // If show changed then we need show or hide the layer
			if(howAboutNow) { // To show or now to show
				this.getAdapter().showLayer(this.id);
			} else {
				this.getAdapter().hideLayer(this.id);
			}
		}
	},
	/**
	 *
	 * @method updateDelta
	 */
	updateDelta: function() {
		var curdate = new Date;
		this.settings.lastChange = curdate.getTime();
	},
	/**
	 *
	 * @method reload
	 */
	reload: function() {
		this.updateDelta();
		this.getAdapter().reloadLayer(this.id);
	},
	/**
	 *
	 * @method notifyOfDeltaChange
	 */
	notifyOfDeltaChange: function() {},
	getSetting: function(name) {
		return (typeof this.settings[name] != "undefined") 
			? this.settings[name] : null;
	},
	settings: {
		show: false,
		lastChange: null,
		dataType: "",
		tilePath: "/tiles/",
		tileName: "choropass.php",
		density: true,
		trans: 0,
		datasource: 0,
		smoothing: 0,
		contourness: 0,
		fuzziness_threshold: 32,
		intensity_mult: 10,
		intensity_sub: 80,
		levels: [256,256,256,256,256,256,256,256,256,256,256,128,128,64,64,64,32,
				 32,32,32,32,32,32,32],
		defaultLevels: [256,256,256,256,256,256,256,256,256,256,256,128,128,64,64,
						64,32,32,32,32,32,32,32,32]
	},
	addObserver: function(e,o,c) { this.observers.addObserver(e,o,c); },
	removeObserver: function(e,o,c) { this.observers.removeObserver(e,o,c)},
	removeContext: function(e,c) { this.observers.removeContext(e,o,c); },
	tilesLoadedHandler: function() {
		var self = this;
		return function() {
			self.observers.notify('tilesloaded');
		}
	}
};

// @TODO
Moonshadow.namespace("Moonshadow.Map.Balloon");
Moonshadow.Map.Balloon = (function() {
}());

// @TODO
Moonshadow.namespace("Moonshadow.Map.Polygon");
Moonshadow.Map.Polygon = (function() {
}());

/**
 *
 * @class Marker
 * @namespace Moonshadow.Map
 */
Moonshadow.namespace("Moonshadow.Map.Marker");
Moonshadow.Map.Marker = (function() {
	var Marker = function Marker(id) {
		this.id = id;
		this.lat = 0;
		this.lng = 0;
		this.type = '';
		this.draggable = false;
		this.mapMarker;
	};

	Marker.prototype = {
		/**
		 *
 		 * @method getMarker
		 */
		'getMarker': function() {
			if(!this.mapMarker) {
				var details = {

				};
				this.mapMarker = Moonshadow.getManager().getAdapter().createMarker(this.lat, this.lng);
			}

			return this.mapMarker;
		},
		/**
		 *
		 * @method isDraggable
		 */
		'isDraggable': function() {
			return this.draggable;	
		},
		/**
 		 *
		 * @method setDraggable
		 */
		'setDraggable': function() {
			this.draggable = true;
		}
	}

	return Marker;
}());

/**
 * Abstract Control Plugin
 * @class MControl
 * @namespace Moonshadow.Plugins
 */
Moonshadow.namespace("Moonshadow.Plugins.Control");
function MControl() {}
MControl.hasMethods = function(obj) {
	var i = 1;
	var name;
	while((name = arguments[i++])) {
		if (typeof obj[name] != 'function') {
			return false;
		}
	}

	return true;
};
MControl.prototype = {
	addControl: function(control) {
		if(this.childContainer == null) 
			return false;
		
		var container = this.childContainer;
		if(control.fixed){
			if(this.fixedChildContainer == null)
				return false;
			container = this.fixedChildContainer;
		}
		
		if(this.controls[control.name] == undefined) {	
			this.controls[control.name] = control;	
			
			var controls = this.controls;		
			var insertBefore = null;
			$.each(container.children,function(k,v) {
				var id = v.id;
				var pos;
				if(id){
					pos = controls[id].position;
				}else{
					pos = control.position + 1;
				}
				
				if(pos > control.position) {
					insertBefore = v;
					return false;
				}
			});  
			
			container.insertBefore(control.container,insertBefore);
			if(control.fixed){
				this.manager.mapObservers.notify("addedfixeditem");
			}
		}
	},
	/**
	 *
	 * @method removeControl
	 * @param {} control
	 */
	removeControl: function(control) {
		this.controls.removeChild(this.controls[control.name]);
		this.getManager().removeControl(this.controls[control.name]);
	},
	/**
	 *
	 * @method getParent
	 */
	getParent: function() {
		if(this.childOf == null) {
			this.getParent = function() { return this; };
			return this;
		}
		
		if(Moonshadow.getManager().getControl(this.childOf) != undefined) {
			var parent = Moonshadow.getManager().getControl(this.childOf);
			this.getParent = function() { return parent; };
			return parent;
		}

		throw new Error("Control(" + this.name + ") parent isn't loaded");
	},
	/**
	 *
	 * @method getManager
	 */
	getManager: function() {
		return this.getParent().manager;
	},
	/**
	 *
	 * @method getOptions
	 * @param {} p
	 * @param {} d
	 */
	getOption: function(p,d) {
		var a = p.split(".");
		var op = this.options;
		var result = true;
		for(var i = 0,l = a.length;i < l;i++) {
			if(typeof op[a[i]] == "undefined") return (typeof d != "undefined") ? d : undefined;
			op = op[a[i]];
		}

		return op;
	},
	/**
	 *
	 * @method createDocList
	 * @param {} docs
	 */
	createDocList: function(docs) {
		var list = document.createElement('div');
		list.className = 'doc-list';

		for(var i = 0,l = docs.length; i < l; i++) {
			var doc = docs[i]; // Get short ref to doc
			if(!doc || !doc.url){
				continue;
			}

			// Setup doc element
			var elm = document.createElement('div');
			elm.className = 'doc clickable';
			elm.title = (doc.title) ? doc.title : "Help";
		
			var sprite = "";	
			if(doc.sprite) {
				sprite = ' '+doc.sprite;
			} else {
				// TODO: eventually we won't need this check, as "sprite" will be in the 
				// app attrs and thus never require us to decompose the icon for the 
				// sprite class.
				if(doc.icon) {
					// elm.style.backgroundImage = 'url(' + doc.icon + ')';
					var last = doc.icon.split("/").pop();
					sprite = ' sprite-'+last.split(".")[0];
				} else {
					sprite = ' sprite-info_shiny info_shiny';
				}
			}
			elm.className += sprite;

			// On click open the doc's url
			$(elm).click({doc: doc},function(event) {
				window.open(event.data.doc.url,"_newTab");
			});
			
			list.appendChild(elm);
		}

		return list;
	},
	ce: function(type){
		return Moonshadow.helpers.ce(type);
	},
	/**
	 *
	 * @method defaultTransOptions
	 * @param {} defaultTrans
	 */
	'defaultTransOptions': function(defaultTrans){
		var optionObject = {'options': []};
		var allValues = [0,50,90,120,150,180,200,220,240,250,255];
		for(var i = 0, l = allValues.length; i < l; ++i){
			var valItem = {
				'text': (i * 10) + '%', 
				'value': allValues[i] + ''
			};
			if(defaultTrans === allValues[i]){
				valItem.isDefault = true;
			}
			optionObject.options.push(valItem);
		}
		return optionObject;
	},
	hasMethods: function(obj) {
		return MControl.hasMethods(obj);
	}
};
/**
 * Group of selection based logic and queries
 * @class selection 
 * @namespace Moonshadow
 */
Moonshadow.namespace("Moonshadow.selection");
Moonshadow.selection = {
	/**
	 *
	 * @method getBounds
	 * @param {} datasource
	 * @param {} selection
 	 * @param {} callback
	 */
	"getBounds": function(datasource, selection, callback) {
		if(typeof callback != "function") {
			throw new Error("Callback is not a function");
		}

		if(!(typeof datasource == "string") || datasource.length < 1) {
			return callback(new Error("Datasource isn't a string or is empty"));
		}

		var request = {
			"query": "get_bounds",
			"ds": datasource
		};

		if(selection) {
			request.filter = selection;
		}

		var ajax = new Moonshadow.Ajax();
		ajax.addQuery(request,function(data) {
			callback(null, [
				[data.top, data.left],
				[data.bottom, data.right]
			]);
		});
		ajax.execute();
	}
};

window.fidoCallback = function (status) {};






/**
 * Ajax Command, helps bundle queries and provide a single place for performing ajax requests
 * @class Ajax
 * @param {Object} settings (optional) describes various things about the request
 * 		@property {Any} payload (optional) data being sent with the request (not qs queries)
 * 		@property {String} url (defaults to flatbread (getDataUrl)) destination of request
 * 		@property {String} type (default: POST) type of request
 * 		@property {String} contentType (default: application/json) other type: application/x-www-form-urlencoded
 * 		@property {String} dataType (default: json)
 * 		@property {Boolean} wrapPost (default: false) whether to add creds and 'data' param to request (Moonshadow.wrapPost)
 * 		@property {Boolean} stringify (default: true) whether to JSON.stringify the payload
 * 		@property {Boolean} cache (default: false) whether ajax request is cached
 * 		@property {Boolean} execute (default: false) set true to execute upon instantiating
 * 		@property {Boolean} addCreds (default: false) adds username and key (same as wrapPost, but does not add data param)
 * 		@property {Boolean} bypassErrorControl (default: false) whether to bypass call to onDeadSession
 * 		@property {Function} onFail (optional) Function to call if request fails (after calling this objects own fail function)
 * 		@property {Function} onSuccess (optional) Function to call if request succeeds (after calling this objects own success function)
 * @constructor
 * @namespace Moonshadow
 */
Moonshadow.namespace("Moonshadow.Ajax");
Moonshadow.Ajax = function(settings) {
	if(!settings){
		settings = {};
	}
	
	this.manifest = {};
	this.queries = [];
	this.queryIndex = 0;
	this.unProcessed = [];
	this.request;
	this.doProcessListeners = false;
	this.startTime;
	this.preflightCount;
	this.maxQueries = 1000;
	
	this.payload = settings.payload;
	
	this.url = settings.url || Moonshadow.getDataUrl();
	this.queryString = ""; //this will be generated forGET requests from the payload
	
	this.type = (settings.type && settings.type.toUpperCase()) || "POST";
	this.contentType = settings.contentType || "application/json";
	this.dataType = settings.dataType || "json";
	
	this.wrapPost = settings.wrapPost === true ? true : false;
	this.stringify = settings.stringify === false ? false : true;
	this.addCreds = settings.addCreds === true ? true : false;
	this.cache = settings.cache === true ? true : false;
	this.bypassErrorControl = settings.bypassErrorControl === true ? true : false
	
	this.onFail = settings.onFail;
	this.onSuccess = settings.onSuccess; //callback for specific query
	this.callback; //callback after all previous queries, passed in upon call to execute
	
	var self = this;
	this.statusCode = {
		"401": function(data) {
			if(self.bypassErrorControl){
				return;
			}
			self._onDeadSession();
		},
		"410": function(data) {
			// @TODO Have this try to lookup the new server and recover
			if(self.bypassErrorControl){
				return;
			}
			self._onDeadSession();
		}
	};
	
	if(settings.execute === true){
		this.execute();
	}
};

/**
 * Place this request in reserve to be called after successful re-authentication 
 * 
 * @method _reserveRequest
 * @private
 */
Moonshadow.Ajax.prototype._reserveRequest = function(){
	var key = $.md5(JSON.stringify([this.url, this.payload, this.queries]));
	Moonshadow.Ajax._reservedRequests[key] = this;
};

/**
 * called when 401 type responses are returned 
 * 
 * @method _onDeadSession
 * @private
 */
Moonshadow.Ajax.prototype._onDeadSession = function(){
	this._reserveRequest();
	Moonshadow.getManager().onDeadSession();
};

/**
 * key/value list of backed up requests
 * 
 * @object reservedRequests
 * @private
 * @static
 */
Moonshadow.Ajax._reservedRequests = {};

/**
 * Called after successful re-authentication
 * 
 * @method processReservedRequests
 * @static
 */
Moonshadow.Ajax.processReservedRequests = function(){
	var req = Moonshadow.Ajax._reservedRequests;
	for(var i in req){
		if(!req.hasOwnProperty(i)){
			continue;
		}
		req[i].execute(req[i].callback);
	}
	Moonshadow.Ajax._reservedRequests = {};
};

/**
 * @method _isFront
 * @private
 */
Moonshadow.Ajax.prototype._isFront = function(a) { 
	if(typeof a[2] == "boolean") {
		return a[2];
	} else if(typeof a[2] == "object" && typeof a[3] == "boolean") {
		return a[3];
	}	 
	return false;
};

/**
 * @method _getContext
 * @private
 */
Moonshadow.Ajax.prototype._getContext = function(a) {
	if(typeof a[2] == "object") {
		return a[2];
	} else if(typeof a[3] == "object") {
		return a[3];			
	}	
	return false;
};

/**
 * Add a query to the list of queries headed to the QS 
 * 
 * @method addQuery
 * @returns {Moonshadow.Ajax} self
 */
Moonshadow.Ajax.prototype.addQuery = function() {
	if(typeof arguments[0] != "object" || 
			(typeof arguments[1] != "object" && 
			typeof arguments[1] != "function")) {
		throw new Error("addQuery must have a query and listener");
	}

	var query = arguments[0];
	var listener = arguments[1];
	var context = this._getContext(arguments);

	if(!query.qid){
		query.qid = this.generateQID();
	}
	this._isFront(arguments) ? this.queries.unshift(query) : this.queries.push(query);
	this.manifest[query.qid] = {"o":listener,"c":context};
	
	return this;
};

Moonshadow.Ajax.prototype.generateQID = function(){
	++this.queryIndex;
	return "_" + this.queryIndex;
};

/**
 * Return the AJAX object for this instance 
 * 
 * @method getRequest
 * @returns jQuery.ajax
 */
Moonshadow.Ajax.prototype.getRequest = function() {
	return (this.request) ? this.request : undefined;
};

/**
 * Execute the set of requests 
 * 
 * @method execute
 * @param {Function} callback (optional) Function to call after all requests are executed
 */
Moonshadow.Ajax.prototype.execute = function(callback) {
	this.callback = callback;
	this.startTime = new Date().getTime();
	var payload;
	
	if(this.queries.length){
		return this._runMultipleQueries();
	}

	this._runRequest(this._preparePayload());
};

Moonshadow.Ajax.prototype._runMultipleQueries = function(){
	
	this.preflightCount = this.queries.length;
	this.doProcessListeners = true;
	this.wrapPost = true;
	
	var queries = this.queries.slice();
	
	var numberOfRequests = 1;
	if(queries.length > this.maxQueries){
		var numberOfRequests = parseInt(queries.length / this.maxQueries, 10);
		if(queries.length % this.maxQueries > 0){
			++numberOfRequests;
		}
	}
	
	var querySlices = [];
	for(var i = 0, l = numberOfRequests; i < l; ++i){
		var payload = {
			"queries": queries.splice(0, this.maxQueries)
		};
		if(!payload.queries.length){
			break;
		}
		var ii = 0;
		while(ii < payload.queries.length){
			if(payload.queries[ii].nogzip){
				payload.nogzip = true
				break;
			}
			++ii;
		}
		querySlices.push(payload);
	}
	
	this._syncLoop(querySlices, 0);
};

Moonshadow.Ajax.prototype._syncLoop = function(querySlices, index){
	if(!querySlices[index]){
		return;
	}
	var self = this;
	this._runRequest(querySlices[index], function(){
		self._syncLoop(querySlices, ++index);
	});
};

Moonshadow.Ajax.prototype._preparePayload = function(){
	var payload;
	
	if(this.payload){
		payload = $.extend(true, {}, this.payload);			
	}
	
	if(this.addCreds){
		if(!payload){
			payload = {};
		}
		payload["user"] = Moonshadow.user;
		payload["key"] = Moonshadow.key;
	}
	
	if(this.type == "GET" || this.type == "DELETE"){
		if(payload && Moonshadow.helpers.objCount(payload) > 0){
			this.queryString = "?";
			for(var i in payload){
				if(!payload.hasOwnProperty(i))
					continue;
				this.queryString += "&" + i + "=" + payload[i];
			}
			payload = null;
		}
		this.wrapPost = false;
	}
	
	return payload;
};

Moonshadow.Ajax.prototype._runRequest = function(payload, callback){
	if(this.type == "POST" && !payload){
		return false;
	}
	
	if(payload){
		if(this.wrapPost){
			payload = Moonshadow.wrapPost(payload);
		}else if(this.stringify){
			payload = JSON.stringify(payload);
		}
	}

	var self = this;
	var ajaxObject = {
		"url": this.url + this.queryString,
		"cache": this.cache,
		"timeout": Moonshadow.timeout || 180000,
		"type": this.type,
		"contentType": this.contentType,
		"data": payload,
		"dataType": this.dataType,
		"statusCode": this.statusCode,
		"error": function(){
			self._fail.apply(self, arguments);
		},
		"fail": function(){
			self._fail.apply(self, arguments);
		},
		"success": function(data){
			self._done(data, callback);
		},
		"done": function(data){
			self._done(data, callback);
		}
	};

	this.request = $.ajax(ajaxObject);
};

Moonshadow.Ajax.prototype._done = function(data, callback) {
	if (!data) {
		throw new Error("Invalid response from server");		
	}

	if (data && typeof data.result != "undefined" && data.result != "ok") {
		if(data.error === "Query timeout") {
			Moonshadow.getManager().onServerNotResponding();
		} else if(data.error === "invalid_or_unknown_session") {
			if(this.bypassErrorControl){
				return;
			}
			this._onDeadSession();
		} else if(this.onFail != undefined){
			this.onFail(data);
		} else {
			throw new Error(
				"Unhandled ajax failure: " + 
				data.result + " - " + 
				(data.message || data.error)
			);
		}
		return;
	}
	
	
	if(this.doProcessListeners){
		var results = data.results;	
		if(!results){
			return;
		}
		
		this.unProcessed = this.unProcessed.concat(results);
		if(this.preflightCount == this.unProcessed.length){
			this._processListeners(this.unProcessed);
			return this._final(this.unProcessed);
		}
		return callback(data);
	}
	
	this._final(data);
};

Moonshadow.Ajax.prototype._final = function(data){
	this.onSuccess && this.onSuccess(data);
	this.callback && (typeof this.callback === "function") && this.callback();
	this.queries = [];
	this.queriesMap = {};
	this.unProcessed = [];
};

Moonshadow.Ajax.prototype._processListeners = function(results){
	var responseTime = new Date().getTime() - this.startTime;
	var queryStats = [];

	// Function that will handle calling the listener
	var callListener = function(listener, context, result) {
		if(typeof listener == "function") {
			if(context) {
				listener.call(context,result);
			} else {
				listener(result);
			}
			// If object has an onAjaxResponse then call it.
		} else if(typeof listener.onAjaxResponse == "function") { 
			// If object has an onAjax response then call it.
			listener.onAjaxResponse(result); 
		} else {
			if(typeof console != "undefined") {
				console.log("Not a valid listener:",listener,result);
			}
		}	
	};

	for(var i = 0, l = results.length; i < l; i++) {
		var result = results[i];
		var key = result.qid;
		
		var listeners = this.manifest[key].o;
		var contexts = this.manifest[key].c;
		
		if (result.result === "ok") {
			var time = result.time_in_usec / 1000;
			responseTime -= time; // Remove processing time for total flight time

			queryStats.push({
				"time": time,
				"type": this.queries[i].query
			});
		}

		// Check if array - Multiple object can recieve a single result
		if($.isArray(listeners)) { 
			for(var j = 0,m = listeners.length;j < m;j++) {
				// Get the listener from array
				var listener = listeners[j]; 
				// Get the context from the array or use false if undefined
				var context = contexts[j] || false; 

				callListener(listener, context, result);
			}
		} else {
			callListener(listeners, contexts, result);
		}
	}

	var statsHandler = Moonshadow.getManager().getStatsHandler();
	statsHandler.addRequestStats(responseTime, queryStats);
};

Moonshadow.Ajax.prototype._fail = function(xhr, status, error) {
	// Watch for dead sessions
	
	if(!this.bypassErrorControl){
		if (error === "Unauthorized") {
			return this._onDeadSession();
		}

		// Catch errors and CORS preflight failures
		if (status === "timeout" || status === "error" || status === "parsererror" ||
			(status === "abort" && this.type === "OPTIONS")) {
			return Moonshadow.getManager().onServerNotResponding();
		}
	}
	
	this.onFail && this.onFail(xhr, status, error);
};


function MEmbedded(manager, origin) {
	this.manager = manager;
	this.parentOrigin = origin;

	this.bindMessageHandler();

	this.manager.addMapObserver("loaded", function() {
		this.postMessage("clientReady", null);
	}, this);
}

MEmbedded.prototype.bindMessageHandler = function() {
	var self = this;
	var onMessage = function() {
		self.handleMessage.apply(self, arguments);
	};

	// < IE9 fail
	if(!window.addEventListener) {
		window.attachEvent("onmessage", onMessage, false);
	} else {
		window.addEventListener("message", onMessage, false);
	}
};

/** 
 * Posts message for cross-origin commuication, used by embedded client
 * @method postmessage
 * @private 
 * @param {String} type
 * @param {String} message
 */
MEmbedded.prototype.postMessage = function(type, message) {
	// @type - one of [sendStatChangeNotification, sendDataListenerIdentifiers]
	// @message - the message to send back to the client (identifiers/stats)
	// @origin - "*" or the window.location.origin of the inner frame
	var data = {
		type: type,
		message: message
	}
	
	if(this.parentOrigin) {
		// this.parentOrigin is falsy when the client isn't embedded
		window.parent.postMessage(JSON.stringify(data), this.parentOrigin)		
	}
};

/**
 * Recieves messages from embedded client and handles them
 * @method handleMessage 
 * @private 
 * @param {Object} event
 * @param {JSONObject} event.data JSON with event details
 * @param {String} event.data.type Event type
 * @param {String} event.data.message Event details
 */
MEmbedded.prototype.handleMessage = function (event) {
	var self = this;
	var origin = event.origin || '';
	var data = null;
	var type;
	var message;
	var manager = this.manager;
	var datasources = manager.getControl('datasources');
	var parts;
	var datasource_set_name;
	var filter_name;
	var ds;
	var details;
	var int_name;
	var dsSetName;
	var path;
	var value;
	var filtersControl;
	var dsControl;
	var parentOrigin = manager.getOption('parentOrigin');
	

	// Block messages not from the parent origin (embedded client library)
	if (origin != parentOrigin) {
		console.log('blocked, origin mismatch', parentOrigin, origin, event);
		return;
	}

	// Some chrome extensions are rude
	if (origin.indexOf('chrome-extension') === 0) {
		return;			
	}

	// Some tabs like to send bad data, don't do anything
	try {
		data = JSON.parse(event.data);
	} catch (e) {
		return; // Bad json/message
	}

	message = data.message;
	type = data.type;

	switch(type) {
	case "addDataChangeListener":
		// need to get a manager reference and attach the listener from the right
		// MDatasource object
		parts = message.split(":");
		datasource_set_name = parts[0];
		filter_name = parts[1];

		ds = datasources.getByAlias(datasource_set_name);

		var counts = manager.getControl('countsmodel');
		counts.addCounted(ds.int_name, filter_name, this.onStatsUpdate, this, true);
		break;
	case "removeDataChangeListener":
		// need to get a manager reference and remove the listener from the right
		// MDatasource object
		parts = message.split(":");
		datasource_set_name = parts[0];
		filter_name = parts[1];

		ds = datasources.getByAlias(datasource_set_name);

		var counts = manager.getControl('countsmodel');
		counts.removeCounted(ds.int_name, filter_name, this.onStatsUpdate, 
							 this, true);
		break;
	case "getDataListenerIdentifiers":
		// get a manager reference and build an object with all available
		// identifiers, keyed by datasource set_name
		this.getDataListenerIdentifiers(function (ids) {
			self.postMessage("sendDataListenerIdentifiers", JSON.stringify(ids));
		});
		break;
	case "addFilterChangeListener":
		dsSetName = message;
		ds = datasources.getByAlias(dsSetName);

		filtersControl = manager.getControl('filterscontrol');
		filtersControl.addListener(ds.id, this.onFilterChange, this);
		break;
	case "removeFilterChangeListener":
		dsSetName = message;
		ds = datasources.getByAlias(dsSetName);

		filtersControl = manager.getControl('filterscontrol');
		filtersControl.removeListener(ds.id, this.onFilterChange, this);
		break;
	case "setFilter":
		var ds = datasources.getByAlias(message.datasource);

		var filters = manager.getControl('filterscontrol');
		filters.setFilter(ds.id, message.path, message.value);
		break;
	case "clearFilter":
		var ds = datasources.getByAlias(message.datasource);

		var filters = manager.getControl('filterscontrol');
		filters.clearFilter(ds.id, message.path);
		break;
	case "clearAllFilters":
		var ds = datasources.getByAlias(message.datasource);

		var filters = manager.getControl('filterscontrol');
		filters.clearFilters(ds.id);
		break;
	case "setColorBy":
		var ds = datasources.getByAlias(message.datasource);

		var path = message.path.split('|');
		var color = path.slice().shift();

		var colorBy = manager.getControl('colorbycontrol');
		colorBy.setColorBy(ds.id, color, null, path, null);
		colorBy.setActiveColorBy(ds.id);
		break;
	case "setColors":
		var ds = datasources.getByAlias(message.datasource);

		var colors = manager.getControl('colors');
		colors.setColorsForField(ds.id, message.path, message.value);
		break;
	case "getTriplets":
		var pairs = message.pairs;

		// Convert ds aliases(set_names) to ds id (int_name)
		for (var i = 0, l = pairs.length; i < l; i++) {
			var pair = pairs[i];
			pair[0] = datasources.getByAlias(pair[0]).id;
		}	

		var triplets = manager.getControl('triplets');
		triplets.getTriplets(pairs, function(error, results) {
			if (error) {
				throw error;
			}			

			// Convert ds ids to ds alias
			for (var i = 0, l = results.length; i < l; i++) {
				var result = results[i];
				var idParts = result.id.split(':');
				
				idParts[0] = datasources.getById(idParts[0]).alias;
				result.id = idParts.join(':');
			}	

			self.onTriplets(results);
		});
		break;
 	case "removeAllDataChangeListeners": // DEPRECATED
		var dss = datasources.getAll();
		var counts = manager.getControl('countsmodel');

		for (var dsId in dss) {
			counts.removeCountedByDatasource(dsId);
		}
		break;
	case "removeAllFilterChangeListeners": // DEPRECATED
		filtersControl = manager.getControl('filterscontrol');
		filtersControl.removeAllFilterChangeListeners();
		break;
	}
};

/**
 * Retieve a datasource
 * @method getDatasourcesByName
 * @private
 * @param {String} name The int_name or set_name of the database
 * @returns {MDatasource} The datasources matching the provided name
 */
MEmbedded.prototype.getDatasourceByName = function (name) {
	var manager = this.manager;
	var ds = manager.getControl("datasources").getByAlias(name);

	if (!ds) {
		throw Error("Invalid datasource alias");
	}		

	return ds;
},

/**
 * Get all datasources and fields that can be listened to
 * @method getDataListenerIdentities
 * @private 
 * @async
 * @param {function} callback
 */
MEmbedded.prototype.getDataListenerIdentifiers = function(callback) {
	var allCodes = {};

	var manager = this.manager;
	var datasources = manager.getControl("datasources").getAll();

	// when filters loaded, iterate each datasource (ignore internal)
	for(var id in datasources) {
		var ds = datasources[id];
		if(id.slice(0, 2) != "__") {
			var codes = [];
			// crawl the tree and process the nodes (use the tacked on 
			// set_name for object keys instead of the potentially 
			// ephemeral int_name)
			_traverse(ds.alias, codes, ds.struct, _process);
		}
	}
	return callback(allCodes);

    /**
	 * called with every property and its value 
	 * @method _process
	 * @private 
	 * @param {} key
	 * @param {} value
	 * @param {} codes
	 */
	function _process(key, value, codes) {
		var whitelist = ["string", "selector", "int", "boolean"];
		var name = value.int_name;

		// if(whitelist.indexOf(value.dtype) != -1 && codes.indexOf(name) == -1) {
		// 	codes.push(name);
		// }
		if($.inArray(value.dtype, whitelist) != -1 && $.inArray(name, codes) == -1) {
			codes.push(name);
		}
	}

	/**
	 * recursive tree crawler
	 * @method _traverse
	 * @private 
	 * @param {} datasources
	 * @param {} codes
	 * @param {} struct
	 * @param {} func
	 */
	function _traverse(datasource, codes, struct, func) {
	    for (var node in struct) {
        	func.apply(this, [node, struct[node], codes]);
        	if (typeof(struct[node]) == "object") {
          		_traverse(datasource, codes, struct[node], func);
        	}
	    }
	    allCodes[datasource] = codes;
	}
};

MEmbedded.prototype.onFilterChange = function(dsId, filters) {
	var ds = this.manager.getControl('datasources').getById(dsId);
	var batch = {
		datasource: ds.id, 
		datasource_set_name: ds.alias, 
		filters: filters
	};

	this.postMessage("sendFilterChangeNotification", batch);
};

MEmbedded.prototype.onStatsUpdate = function(dsId, stats) {
	var ds = this.manager.getControl('datasources').getById(dsId);
	var batch = {
		datasource: ds.id, 
		datasource_set_name: ds.alias, 
		stats: stats
	};

	this.postMessage("sendStatChangeNotification", batch);
};

MEmbedded.prototype.onTriplets = function(results) {
	this.postMessage("sendTriplets", results);
};
/**
 * Handles storage of routes
 * 
 * MDataRoute contains a HashMap of homes keyed on kValue. Each home has a prev,
 * next home to support a doubly linked list that will make up the "route". 
 * The doubly linked list has sentinel (start, end) "homes" to simpliy the 
 * DLL implementation and help place bounds on the sequence.
 *
 * Each home is assigned/unassigned a sequence number as it's added/removed
 * from the doubly linked list. How the sequence is generated is a bit odd.
 * Due to the nature of the dynamic aux data, we want to avoid reorder, which
 * would require updating the sequence of all later homes in the route. To do
 * this an upper and lower address space is used. The upper space is for
 * "appended" points and the lower space is used for "inserted" points. The 
 * size of the address spaces is managed by the sequence mask. 
 *
 * @class MDataRoute
 * @constructor
 * @param {String} datasourceId The id of the datasource
 * @param {String} universeId The id of the universe
 * @param {String} routeId The id of the column
 */
function MDataRoute(universe) {
	this.universe = universe;
	this.datasourceId = universe.ds;
	this.universeId = universe.int_name;
	this.routeId = universe.getRouteId();
	this.creatingRoute = null;
	this.max = Math.pow(2,32) - 1;
	this.defaultSpace = 10000;
	this.sequenceMask = 0x0000FFFF;

	this.homes = {};
	this.homesCount = 0;
	this.streets = {};
	this.locations = {};

	// @TODO this should be based on datasource
	this.keyField = "LALVOTERID";

	this.houseNumberPart = 'Residence_Addresses_HouseNumber';

	this.streetParts = ['Residence_Addresses_PrefixDirection',
						'Residence_Addresses_StreetName',
						'Residence_Addresses_Designator',
						'Residence_Addresses_SuffixDirection'];

	this.shortAddressParts = ['Residence_Addresses_HouseNumber',
							  'Residence_Addresses_PrefixDirection',
							  'Residence_Addresses_StreetName',
							  'Residence_Addresses_Designator',
							  'Residence_Addresses_SuffixDirection'];

	this.addressParts = ['Residence_Addresses_HouseNumber',
						 'Residence_Addresses_PrefixDirection',
						 'Residence_Addresses_StreetName',
						 'Residence_Addresses_Designator',
						 'Residence_Addresses_SuffixDirection',
						 'Residence_Addresses_ApartmentType',
						 'Residence_Addresses_ApartmentNum'];

	this.init();
}

/** 
 * Requests route and address/door/home data
 * 
 * @method loadRoute
 * @async
 * @param {Function} callback
 */
MDataRoute.prototype.loadRoute = function(callback) {
	this.requestMarkerData(callback);
};

/** 
 * Requests route and address/door/home data
 * 
 * @method requestMarkerData
 * @async
 * @private
 * @param {Function} callback
 */
MDataRoute.prototype.requestMarkerData = function(callback) {
	var self = this;
	var req = new Moonshadow.Ajax();
	var _query = this.getMarkerQuery();
	req.addQuery(_query, function(data) {
		self.processMarkerData(data);
		callback();
	}, this);
	req.execute();
};

/**
 * Get query for getting home/route data
 *
 * @method getMarkerQuery
 * @private
 */
MDataRoute.prototype.getMarkerQuery = function() {
	var filter = {"__universes": {"values": {}}};
	filter.__universes.values[this.universeId] = {"order":1, "value":1}

	var fields = [
		{"int_name": "__latitude"},
		{"int_name": "__longitude"},
		{"int_name": this.keyField},
		{"int_name": "SEQUENCE"}, // @ALT
		{"int_name": "Residence_Addresses_HouseNumber"},
		{"int_name": "Residence_Addresses_PrefixDirection"},
		{"int_name": "Residence_Addresses_StreetName"},
		{"int_name": "Residence_Addresses_Designator"},
		{"int_name": "Residence_Addresses_SuffixDirection"},
		{"int_name": "Residence_Addresses_ApartmentType"},
		{"int_name": "Residence_Addresses_ApartmentNum"},
		{"int_name": "Residence_Addresses_AddressLine"}
	];

	if (this.routeId) {
		fields.push({"int_name": this.routeId});
	}

	return {
		"query": "get_record_info",
		"ds": this.datasourceId,
		"filter": filter,
		"tree_levels": ["point", "address_apt"],
		"limit": 2500,
		"fields": fields
	};
};

/**
 * Process the home/route data from the server
 * 
 * @method processMarkerData
 * @private
 * @param {Object} data Response from get_record_info
 */
MDataRoute.prototype.processMarkerData = function(data) {
	if(data.result != "ok"){
		throw new Error(data.message || "Unknown error");
	}
	
	var points = data.results;
	
	// Create markers
	for (var i = 0, l = points.length; i < l; i++) {
		var point = points[i];
		var pointData = this.recordArrayToObj(point.data);

		var kValue = point.k;
		var kValues = this.getVoterKValues(point);
		var keyValues = this.getVoterKeyValues(point);
		var latLng = [parseFloat(pointData.__latitude, 10),
					  parseFloat(pointData.__longitude, 10)];
		var houseNumber = this.getHouseNumber(point);
		var shortAddress = this.getShortAddress(point, pointData);
		var address = this.getAddress(point, pointData);
		var units = this.getUnits(point, pointData);
		var street = this.getStreet(pointData);
		var sequence = this.getSequence(point);

		this.addRoutableHome(kValue, kValues, keyValues, houseNumber, shortAddress,
							 address, street, units, latLng, sequence);
	}

	this.populateList(); // Build the doubly-linked list.
};

/**
 * Loop through homes and populate the doubly-linked list (route)
 *
 * @method populateList
 * @private
 */
MDataRoute.prototype.populateList = function() {
	for(var kValue in this.homes) {
		var home = this.homes[kValue];
		if (!home.sequence) {
			continue;
		}

		var before = this.getHomeAfter(home);
		this.insertBefore(before, home, false);
	}	
};

/**
 * Get next home from supplied home
 * 
 * @method getHomeAfter
 * @param {Home} home the home before
 * @return {Home} the next home
 */
MDataRoute.prototype.getHomeAfter = function(home) {
	var current = this.start;
	while (current.next) {
		if (home.sequence && current.sequence > home.sequence) {
			return current;
		}

		current = current.next;
	}

	return current;
};

/**
 * Get street name from point
 *
 * @method getStreet
 * @param {Object} data The point data for an address
 * @return {String} Street name
 */
MDataRoute.prototype.getStreet = function(data) {
	var street = [];

	for (var i = 0, l = this.streetParts.length; i < l; i++) {
		if (data[this.streetParts[i]]) {
			street.push(data[this.streetParts[i]]);
		}
	}

	return street.join(' ');
};

/**
 * Get sequence from point
 * 
 * @method getSequence
 * @param {Object} point The poind data for an address
 * @return {Number} The sequence number or null if none
 */
MDataRoute.prototype.getSequence = function(point) {
	var sequences = [];
	var columnId = this.routeId;
	//var columnId = 'SEQUENCE'; // @ALT

	if (!columnId) {
		return null;
	}

	var pointData = this.recordArrayToObj(point.data);
	if (pointData[columnId]) {
		sequences.push(parseInt(pointData[columnId], 10))
	}

	for (var i = 0, l = point.sub.length; i < l; i++) {
		var unit = point.sub[i];
		var unitData = this.recordArrayToObj(unit.data);
		
		if (unitData[columnId]) {
			sequences.push(parseInt(unitData[columnId], 10))
		}		

		for (var ii = 0, ll = unit.sub.length; ii < ll; ii++) {
			var voter = unit.sub[ii];
			var voterData = this.recordArrayToObj(voter.data);

			if (voterData[columnId]) {
				sequences.push(parseInt(voterData[columnId], 10))
			}
		}
	}

	var sequence = null;
	for (var i = 0, l = sequences.length; i < l; i++) {
		if (!sequence) {
			sequence = sequences[i];
		} else {
			if (sequence != sequences[i]) {
				// This shouldn't happen (unless it's L&L sequence)
			}
		}		
	}

	return (sequence === 0) ? null : sequence;
};

/**
 * Get kValues for all voters at a point
 *
 * @method getVoterKValues
 * @param {Object} point The point data
 * @return {Number[]} Array of voter kValues
 */
MDataRoute.prototype.getVoterKValues = function(point) {
	var kValues = [];

	for (var i = 0, l = point.sub.length; i < l; i++) {
		var unit = point.sub[i];

		for (var ii = 0, ll = unit.sub.length; ii < ll; ii++) {
			var voter = unit.sub[ii];
			kValues.push(voter.k);
		}
	}

	return kValues;
};

/**
 * Get keys for all voters at a point
 *
 * @method getVoterKeyValues
 * @param {Object} point The point data
 * @return {String[]} Array of voter keys
 */
MDataRoute.prototype.getVoterKeyValues = function(point) {
	var keyValues = [];

	for (var i = 0, l = point.sub.length; i < l; i++) {
		var unit = point.sub[i];

		for (var ii = 0, ll = unit.sub.length; ii < ll; ii++) {
			var voter = unit.sub[ii];
			var id = null;

			// Each voter has an array of key/values
			for (var iii = 0, lll = voter.data.length; iii < lll; lll++) {
				var datum = voter.data[iii];
	
				// Find the key the matches the keyField
				if (datum.n === this.keyField) {
					id = datum.v;
					break;
				}
			}

			if (!id) {
				throw new Error('Point is missing a key field');
			}

			keyValues.push(id);
		}
	}

	return keyValues;
};

/**
 * Get Address from point
 * 
 * @method getAddress
 * @param {Object} point Point data
 * @return {String} Address for home/building
 */
MDataRoute.prototype.getAddress = function(point) {
	if (!point.sub.length) {
		throw new Error('Invalid point');
	}

	var address = [];
	var unit = point.sub[0];
	var pointData = this.recordArrayToObj(point.data);
	var unitData = this.recordArrayToObj(unit.data);

	var parts = $.extend({}, pointData, unitData);

	for (var i = 0, l = this.addressParts.length; i < l; i++) {
		if (parts[this.addressParts[i]]) {
			address.push(parts[this.addressParts[i]]);
		}
	}

	return address.join(' ');
};

/**
 * Get house number from point
 * 
 * @method getHouseNumber
 * @param {Object} point Point data
 * @return {Number} House number
 */
MDataRoute.prototype.getHouseNumber = function(point) {
	if (!point.sub.length) {
		throw new Error('Invalid point');
	}

	var houseNumber = null;
	var unit = point.sub[0];
	var pointData = this.recordArrayToObj(point.data);
	var unitData = this.recordArrayToObj(unit.data);

	var parts = $.extend({}, pointData, unitData);

	return parseInt(parts[this.houseNumberPart], 10);
};

/**
 * Get the shortened address (doesn't have apt details)
 * 
 * @method getShortAddress
 * @param {Object} point Point data
 * @return {String} Short address
 */
MDataRoute.prototype.getShortAddress = function(point) {
	if (!point.sub.length) {
		throw new Error('Invalid point');
	}

	var address = [];
	var unit = point.sub[0];
	var pointData = this.recordArrayToObj(point.data);
	var unitData = this.recordArrayToObj(unit.data);

	var parts = $.extend({}, pointData, unitData);

	for (var i = 0, l = this.shortAddressParts.length; i < l; i++) {
		if (parts[this.shortAddressParts[i]]) {
			address.push(parts[this.shortAddressParts[i]]);
		}
	}

	return address.join(' ');
};

/** 
 * Get the number of units from point data
 * 
 * @method getUnits
 * @param {Object} point Point data
 * @param {Object} pointData Object of point details
 * @return {Object} Units
 */
MDataRoute.prototype.getUnits = function(point, pointData) {
	var units = {};

	for (var i = 0, l = point.sub.length; i < l; i++) {
		var unit = point.sub[i];
		var unitData = this.recordArrayToObj(unit.data);

		// Merge the two types of data and get the address
		var address = this.getAddress(point);

		for (var ii = 0, ll = unit.sub.length; ii < ll; ii++) {
			var voter = unit.sub[ii];
			var voterData = this.recordArrayToObj(voter.data);
			var address = voterData.Residence_Addresses_AddressLine;

			if (typeof units[address] === 'undefined') {
				units[address] = 0;
			}

			units[address]++;
		}
	}

	return units;
};

/**
 * Get object from array of point details
 * 
 * @method recordArrayToObj
 * @param {Array} broke Point details in array form
 * @return {Object} Object of point details
 */
MDataRoute.prototype.recordArrayToObj = function(broke) {
	var fixed = {};

	for (var i = 0, l = broke.length; i < l; i++) {
		fixed[broke[i].n] = broke[i].v;
	}

	return fixed;
};

/**
 * Add home to collection of homes
 * 
 * @method addRoutableHome
 * @private
 * @param {Number} kValue KValue of point
 * @param {Number[]} kValues KValue of voters
 * @param {String[]} keyValues Keys for voters
 * @param {String} shortAddress Home's short address
 * @param {String} fullAddress Home's address
 * @param {String} street Home's street
 * @param {Object} units Buildings units, if multi-family
 * @param {Array} latLng Latitude and longitude of home
 * @param {Number} sequence Orderable number (not sequential) in list
 */
MDataRoute.prototype.addRoutableHome = function(kValue, kValues, keyValues, 
												houseNumber,shortAddress, fullAddress, 
												street, units, latLng, sequence) {
	// YOU ARE NOW ENTERING THE DANGER ZONE!!!
	// This is deal with data issues (multiple points for the same location)
	var latLngId = latLng.toString();
	if (this.locations[latLngId]) {
		var id = this.locations[latLngId];
		var home = this.homes[id];

		var numUnits = 0;
		$.each(units, function(i, value) {
			if (home.units[i]) {
				home.units[i] += value;
			} else {
				home.units[i] = value;
			}
		});

		if (numUnits > 0) {
			home.address = shortAddress;
		}

		return;
	}
	// LEAVING THE DANGER ZONE!!!

	var numUnits = 0;
	$.each(units, function(i, value) {
		numUnits++;
	});

	this.homes[kValue] = {
		'kValue': kValue,
		'kValues': kValues,
		'keyValues': keyValues,
		'houseNumber': houseNumber,
		'address': (numUnits > 1) ? shortAddress : fullAddress,
		'street': street,
		'units': units,
		'latLng': latLng,
		'marker': null,
		'listEntry': null,
		'next': null,
		'prev': null,
		'sequence': sequence
	};
	this.homesCount++;

	if (!this.streets[street]) {
		this.streets[street] = [];
	}

	this.streets[street].push(this.homes[kValue]);
	this.locations[latLng] = kValue;
};

/**
 * Clears the route and resets it to a fresh state
 * 
 * @method clear
 * @async
 * @private
 * @param {Function} callback
 */
MDataRoute.prototype.init = function() {
	this.start = {
		'sequence': 0x00000000,
		'next': null,
		'prev': null
	};
	this.end = {
		'sequence': 0x7FFFFFFE,
		'next': null,
		'prev': null
	};
	this.end.prev = this.start;
	this.start.next = this.end;

	for (var key in this.homes) {
		this.homes[key].next = null;
		this.homes[key].prev = null;
		this.homes[key].sequence = null;
	}

	this.sendBuffer = []; // Holds modifications to send to QS
	this.reqeust = null; // Holds in flight ajaxRequest
	this.creatingRoute = null;
};

/**
 * Clears route
 *
 * @method clear
 */
MDataRoute.prototype.clear = function(callback) {
	var self = this;
	var routeId = this.routeId;
	
	// Clear sendbuffer;
	this.sendBuffer = [];
	
	// Abort any inflight requests modifying
	if (this.request) {
		this.request.abort();
	}

	this.block();
	this.unsetRouteId();
	this.init();

	if (routeId) {
		return this.deleteRouteAux(routeId, function(error) {
			if (error) {
				return callback(error);
			}

			self.unblock();
			callback();
		});
	}

	this.unblock();
	callback();
};

/**
 * Check if blocked by create/destroy aux reqeust
 *
 * @method isBlocked
 * @private
 * @return {Boolean} true if blocked
 */
MDataRoute.prototype.isBlocked = function() {
	return this.blocked;
};

/**
 * Block sends
 * 
 * @method block
 * @param {Home} home Home to add to blocked
 * @private
 */
MDataRoute.prototype.block = function(home) {
	if (!this.blocked) {
		this.blocked = [];
	}

	if (home) {
		this.blocked.push(home);
	}
};

/**
 * Unblock sends
 * 
 * @method unblock
 * @private
 */
MDataRoute.prototype.unblock = function() {
	var blocked = this.blocked;
	this.blocked = null;

	if (blocked) {
		for (var i = 0, l = blocked.length; i < l; i++) {
			this.addToSendBuffer(blocked[i]);
		}
	}
};

/**
 * Removes home from lists of blocked
 *
 * @method removeFromBlocked
 * @param {Home} home Home to remove from blocked
 * @private
 */
MDataRoute.prototype.removeFromBlocked = function(home) {
	if (!home.sequence || !this.blocked) {
		return;
	}

	for(var i = 0, l = this.blocked.length; i < l; i++) {
		if (this.blocked[i] === home) {
			this.blocked.splice(i, 1);
			// Just removed something from the array, adjust our counter and bounds
			i--;
			l--;
		}
	}
};

/**
 * Get number of homes
 * 
 * @method getNumHomes
 * @return {Number} Number of homes
 */
MDataRoute.prototype.getNumHomes = function() {
	return this.homesCount;
};

/**
 * Get number of homes in route
 *
 * @method getNumRouted
 * @return {Number} Number in route
 */
MDataRoute.prototype.getNumRouted = function() {
	var numInRoute = 0;
	var current = this.start.next;
	while (current.next) {
		numInRoute++;
		current = current.next;
	}

	return numInRoute;
};

/**
 * Check if house number is even
 *
 * @method isKValueHouseNumberEven
 * @param {Number} kValue Needle
 * @return {Boolean} True if even, false of odd
 */
MDataRoute.prototype.isKValueHouseNumberEven = function(kValue) {
	var home = this.getHome(kValue);
	return (home.houseNumber % 2) ? false : true;
};

/**
 * Get homes on a street
 * 
 * @method getHomesByStreet
 * @param {String} street Street
 * @return {Home[]} Homes on the street
 */
MDataRoute.prototype.getHomesByStreet = function(street) {
	return this.streets[street];
};

/**
 * Check if kValue is in array of home objs
 *
 * @method isKValueInHomes
 * @param {Number} kValue Needle
 * @param {Homes[]} haystack Haystack
 * @return {Boolean} True if found, false if not
 */
MDataRoute.prototype.isKValueInHomes = function(kValue, haystack) {
	for (var i = 0, l = haystack.length; i < l; i++) {
		if (haystack[i].kValue === kValue) {
			return true;
		}
	}

	return false;
};

/**
 * Get all homes 
 * 
 * @method getAllHomes
 * @return {Object} Object containing all homes key by kValue
 */ 
MDataRoute.prototype.getAllHomes = function() {
	return this.homes;	
};

/**
 * Get a home by kValue
 * 
 * @method getHome
 * @param {String} kValue
 * @return {Home} Home object
 */
MDataRoute.prototype.getHome = function(kValue) {
	return this.homes[kValue];
};


/**
 * Append home to route
 * 
 * @method append
 * @param {Home} home Home to append
 */
MDataRoute.prototype.append = function(home) {
	this.insertBefore(this.end, home);
};

/**
 * Insert home in to route before another home
 * 
 * @method insertBefore
 * @param {Home} before The home to be inserted before
 * @param {Home} home The home to insert
 * @param {Boolean} [updateSequence] If false, don't update the sequence
 */
MDataRoute.prototype.insertBefore = function(before, home, updateSequence) {
	if (typeof updateSequence === 'undefined') {
		updateSequence = true;
	}

	if (this.isHomeInRoute(home)) {
		this.remove(home);
	}

	home.prev = before.prev;
	home.prev.next = home;

	home.next = before;
	home.next.prev = home;

	if (updateSequence) {
		this.updateSequence(home);
	}

	return true;
};

/**
 * Remove home from the route
 *
 * @method remove
 * @param {Home} home to remove from route
 * @return {Boolean} If was in route
 */
MDataRoute.prototype.remove = function(home) {
	if (!this.isHomeInRoute(home)) {
		return false;
	}

	this.removeFromBlocked(home);

	home.next.prev = home.prev;
	home.prev.next = home.next;

	home.next = null;
	home.prev = null;

	if (this.getNextHome(this.getStart()) === this.getEnd()) {
		this.clear(function(error) {
			if (error) {
				throw error;
			}
		});
	} else {
		this.updateSequence(home);
	}

	return true;
};

/**
 * Get home by position in route
 * 
 * @method getHomeByIndex
 * @param {Number} index Position in route to get
 * @return {Home} The home at that position
 */
MDataRoute.prototype.getHomeByIndex = function(index) {
	var current = this.start.next;
	for (var i = 0; i < index; i++) {
		if (!current.next) {
			return -1;
		}

		current = current.next;
	}

	return current;
};

/**
 * Get index of home
 * 
 * @method getIndexByHome
 * @param {Home} home Home to get index of
 * @return {Number} The position in route, or -1 of not in route
 */
MDataRoute.prototype.getIndexByHome = function(home) {
	var current = this.start.next;
	var i = 0;
	while (current.next) {
		if (current === home) {
			return i;
		}

		current = current.next;
		i++;
	}

	return -1;
};

/**
 * Get start sentinel
 *
 * @method getStart
 * @return {Setinel} Start sentinel
 */
MDataRoute.prototype.getStart = function() {
	return this.start;
};

/**
 * Get end sentinel
 *
 * @method getEnd
 * @return {Setinel} End sentinel
 */
MDataRoute.prototype.getEnd = function() {
	return this.end;
};

/**
 * Get prev home in route 
 *
 * @method getPrevHome
 * @param {Home} home
 * @return {Home|null} Prev home in route or null, if none
 */
MDataRoute.prototype.getPrevHome = function(home) {
	if (!home.prev) {
		return null;
	}

	return home.prev;
};

/**
 * Get next home in route 
 *
 * @method getNextHome
 * @param {Home} home
 * @return {Home|null} Next home in route or null, if none
 */
MDataRoute.prototype.getNextHome = function(home) {
	if (!home.next) {
		return null;
	}

	return home.next;
};

/**
 * Check if home is first in route
 * 
 * @method isFirstHome
 * @param {Home} home The home to check
 * @return {Boolean} True if home is first in route
 */
MDataRoute.prototype.isFirstHome = function(home) {
	return this.getPrevHome(home) === this.start;
};

/**
 * Check if home is last in route
 * 
 * @method isLastHome
 * @param {Home} home The home to check
 * @return {Boolean} True if home is laslt in route
 */
MDataRoute.prototype.isLastHome = function(home) {
	return this.getNextHome(home) === this.end;
};

/**
 * Check if home is in route
 * 
 * @method isHomeInRoute
 * @param {Home} home Home to look for
 * @return {Boolean} True if in route
 */
MDataRoute.prototype.isHomeInRoute = function(home) {
	// If one is set but not the other, we have a problem
	if (!home.prev != !home.next) {
		throw new Error('Route is in an invalid state');
	}

	if (home.prev && home.next) {
		return true;
	}

	return false;
};

/**
 * Check if kValue/id is in route
 * 
 * @method isKValueInRoute
 * @param {String} kValue Id to look for
 * @return {Boolean} True if in route
 */
MDataRoute.prototype.isKValueInRoute = function(kValue) {
	return this.isHomeInRoute(this.getHome(kValue));
};

/**
 * Update the sequence on the home
 *
 * @method updateSequence
 * @private
 * @param {Home} home
 */
MDataRoute.prototype.updateSequence = function(home) {
	if (!this.isHomeInRoute(home)) {
		this.setSequence(home, null)
		return;
	}

	var seq = 0;
	var next = this.getNextHome(home);
	var prev = this.getPrevHome(home);
	
	// Check if adding to end
	if (next === this.end) {
		// Increment upper address space
		seq = prev.sequence;
		seq += this.sequenceMask + 1;
	} else {
		var lower = 0;

		// Seperate upper and lower address spaces
		var upperPrev = prev.sequence & ~this.sequenceMask;
		var upperNext = next.sequence & ~this.sequenceMask;
		var lowerPrev = prev.sequence & this.sequenceMask;		
		var lowerNext = next.sequence & this.sequenceMask;		
		
		// If the next lower is part of a primary point, then
		// set it to the size of the address space so we have
		// something to subtract from
		if (lowerNext === 0 || (upperPrev != upperNext)) {
			lowerNext = this.sequenceMask + 1;
		}

		// Figure out the amount of space and divide in two
		lower = lowerPrev + (lowerNext - lowerPrev) / 2;

		// Check if whole number
		if (lower % 1) {
			throw new Error('Sequence is not a whole number');
		}
	
		// Combine upper and lower address spaces
		seq = upperPrev | lower;
	}	

	this.setSequence(home, seq);
	this.checkSequence();
};

/**
 * Check if sequence is out of space
 *
 * @method outOfSpace
 * @param {Home} home Home to check for space
 * @return {Boolean} True if out of space
 */
MDataRoute.prototype.outOfSpace = function(home) {
	return (home.sequence & 1 ||
			home.next.sequence & 1 ||
			home.prev.sequence & 1);
};

/**
 * Update sequence on home and add to send buffer
 *
 * @method setSequence
 * @param {Home} home The home to se sequence on
 * @param {Number} sequence 
 */
MDataRoute.prototype.setSequence = function(home, sequence) {
	home.sequence = !sequence ? 0 : sequence;
	this.addToSendBuffer(home);
	return sequence;
};

/**
 * Add update to buffer
 *
 * @method addToSendBuffer
 * @private
 * @param {Home} home Home with a changed sequence
 */
MDataRoute.prototype.addToSendBuffer = function(home) {
	var self = this;

	if (!this.routeId && !this.isBlocked()) {
		this.block(home);
		return this.createRouteAux(function(error, routeId) {
			if (error) {
				throw error;
			}

			self.unblock();
		});
	}

	// If blocked, don't send right now
	if (this.isBlocked()) {
		this.block(home);
		return;
	}

	for (var i = 0, l = home.kValues.length; i < l; i++) {
		var change = {
			'k': home.kValues[i],
			'key': home.keyValues[i],
			'values': {}
		};
		change.values[this.routeId] = home.sequence.toString();

		this.sendBuffer.push(change);		
	}

	this.performSend();
};

/**
 * Send update to queryserver
 * 
 * @method performSend
 * @private
 */
MDataRoute.prototype.performSend = function() {
	if (this.ajaxRequest) {
		// Already in flight, wait
		return;
	}

	var l = this.sendBuffer.length;
	if (!l) {
		return; // nothing to send
	}

	var self = this;
	var slice = this.sendBuffer.splice(0, l);
	var query = this.buildQuery(slice);

	this.ajaxRequest = new Moonshadow.Ajax();
	this.ajaxRequest.addQuery(query, function(response) {
		if (response && response.result === 'ok') {
			var results = response.results;
			for(var i = 0, l = results.length; i < l; i++) {
				var result = results[i];
				if (result.result == 'ok') {
					slice[i] = null;
				} else {
					throw new Error('There was an error setting a sequence');
				}
			}
		} else {
			self.sendBuffer = slice.concat(this.sendBuffer);
		}

		self.ajaxRequest = null;
		if (self.sendBuffer.length) {
			self.performSend();
		}
	}, this);
	this.ajaxRequest.execute();
};

/**
 * Create query for setting sequence
 *
 * @method buildQuery
 * @private
 * @param {Update[]} slice Array of sequence updates
 * @return {Object} The query to send in the message body
 */
MDataRoute.prototype.buildQuery = function(slice) {
	return {
		"query": "set_dynamic_auxiliary_data",
		"db_sync": 1,
		"key_field": this.keyField,
		"updates": slice,
		"ds": this.datasourceId
	};

};

/**
 * Create aux column for unviese route
 * 
 * @method createRouteAux
 * @private
 * @async
 * @param {Object} universe The unverse we want the route id for
 * @param {Function} callback
 * @param {Error} callback.error The error from the callback
 * @param {String} routeId The route id for the universe
 */
MDataRoute.prototype.createRouteAux = function(callback) {
	var self = this;

	// Queue any concurrent create calls
	if (this.creatingAux) {
		this.creatingAux.push(callback);
		return;
	}

	this.creatingAux = [];

	var columnId = this.universeId + '_route';
	var query = {
		"query": "add_dynamic_auxiliary_field_universe",
		"ds": this.datasourceId,
		"key_field": this.keyField,
		"data_type": "int",
		"int_name": columnId,
		"data_attributes": {
			"max_value": 4294967295 // 2^32 -1 (JS is really 2^53, but I'm being safe
		},
		"du_type": 2, // Route type
		"du_universe_id": this.universeId
	};

	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(query, function(response) {
		if (!response) {
			return callback(new Error('Invalid response'));
		}

		if (response.result !== 'ok') {
			return callback(new Error(response.message || 'Unknown error'));
		}

		self.setRouteId(columnId);

		callback(null, columnId);

		// @TODO there could be an optimzation here,
		// original and queued ops could be bundled

		// Notify any blocked operations
		if (self.creatingAux) {
			for(var i = 0, l = self.creatingAux.length; i < l; i++) {
				self.creatingAux[i]();
			}
		}

		self.creatingAux = null;
	}, this);
	ajax.execute();
};

/**
 * Delete aux column for unviese route
 * 
 * @method deleteRouteAux
 * @private
 * @async
 * @param {Object} universe The unverse we want the route id for
 * @param {Function} callback
 * @param {Error} callback.error The error frmo the callback
 * @param {String} routeId The route id for the universe
 */
MDataRoute.prototype.deleteRouteAux = function(routeId, callback) {
	var self = this;
	var query = {
		"query": "delete_dynamic_auxiliary_field_universe",
		"ds": this.datasourceId,
		"int_name": routeId,
		"du_type": 2, // Route type
		"du_universe_id": this.universeId
	};

	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(query, function(response) {
		if (!response) {
			return callback(new Error('Invalid response'));
		}

		if (response.result !== 'ok') {
			return callback(new Error(response.message || 'Unknown error'));
		}
	
		callback();
	}, this);
	ajax.execute();

};

/**
 * Sets the route aux id
 *
 * @method setRouteId
 * @private
 * @param {String} routeId
 */
MDataRoute.prototype.setRouteId = function(routeId) {
	this.routeId = routeId;
	this.universe.setRouteId(routeId);
};


/**
 * Unsets the route aux id
 *
 * @method unsetRouteId
 * @private
 */
MDataRoute.prototype.unsetRouteId = function() {
	this.routeId = null;
	this.universe.unsetRouteId();
};

/**
 * Check route for out of order sequence numbers
 *
 * @method checkSequence
 */
MDataRoute.prototype.checkSequence = function() {
	var current = this.start.next;
	while (current.next) {
		if (current.sequence < current.prev.sequence ||
			current.sequence == current.prev.sequence) {
			console.log('There is a problem here');
			console.log(current.sequence, current.prev.sequence);
			throw new Error('Route is out of sequence');
		}

		current = current.next;
	}
};

/**
 * Print the list of sequence numbers to console
 *
 * @method dumpSequence
 */
MDataRoute.prototype.dumpSequence = function() {
	var current = this.start.next;
	while (current.next) {
		if (current.sequence < current.prev.sequence ||
			current.sequence == current.prev.sequence) {
			console.log('There is a problem here');
		}

		console.log(current.sequence);
		current = current.next;
	}
};

/**
 * Print unroutes homes to console
 *
 * @method findUnrouted
 */
MDataRoute.prototype.findUnrouted = function() {
	var keys = Object.keys(this.homes);

	for (var i = 0, l = keys.length; i < l; i++) {
		var home = this.homes[keys[i]];
		if (!this.isHomeInRoute(home)) {
			console.log(home);
		}
	}
};

/**
 *
 * @class colorby
 * @extends MControl
 * @constructor
 * @param {} options
 */
function colorby(options) {
	this.name = 'colorby';
	this.settingCache = {
		'dots': {},
		'choro': {},
		'area': {}
	};

	this.options = options;
	this.lastBoundary;
	this.boundarySettings = {};
	this.smoothingControls;
}

colorby.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	'init': function(manager) {
		this.manager = manager;
		this.container = this.buildUI();

		manager.mapObservers.addObserver('colorbyclick', function(event, element) {
			this.display(element);
		}, this);
	},
	/**
	 *
	 * @method buildUI
	 */
	'buildUI': function() {
		var container = document.createElement('div');
		container.className = 'colorby';
		container.id = 'colorby';

		var heading = document.createElement('div');
		heading.className = 'heading';

		container.appendChild(heading);
		
		var close = document.createElement('div');
		close.appendChild(document.createTextNode('X'));
		close.className = 'close clickable';

		var context = this;
		$(close).click(function() {
			context.hide();
		});

		container.appendChild(close);

		var dotLayer = this.dotLayerUI();
		container.appendChild(dotLayer);
		this.layerDisableOptions(dotLayer);

		var choroLayer = this.choroLayerUI()
		container.appendChild(choroLayer);
		this.layerDisableOptions(choroLayer);

		var areaLayer = this.areaLayerUI()
		container.appendChild(areaLayer);
		this.layerDisableOptions(areaLayer);
		
		var pointer = document.createElement('div');
		pointer.className = 'sprite-boxpointerright pointer';

		container.appendChild(pointer);

		return container;
	},
	/**
	 *
	 * @method dotLayerUI
	 */
	'dotLayerUI': function() {
		var div = document.createElement('div');
		div.className = 'layer dots';

		this.layerHeading(div, 'Dots');
		this.layerEnable(div, (function(context) {
			return function(e) {
				context.getManager().getControl('filters').changeColorBy(e.target.colorby.bucket);
				context.setDotsUIState(e.target.checked);
			}
		})(this));

		// Density
		var options = {
			'options': [
				{'text': 'Yes', 'value': 1, 'isDefault': true},
				{'text': 'No', 'value': 0}
			]
		};
		this.layerOptionSelect(div, 'Show density', 'density', options, (function(context) {
			return function(e) {
				var layer = context.getManager().getControl('layerBase');
				if(layer) {
					var value = parseInt(e.target.value, 10);
					context.settingCache.dots.density = value;
					if(value) {
						layer.showDensity();
					} else {
						layer.hideDensity();
					}
				}
			}
		})(this));

		// Dot size
		var sizeOptions = {
			'options': [
				{'text': '1', 'value': '256', 'isDefault': true},
				{'text': '2', 'value': '128'},
				{'text': '3', 'value': '64'},
				{'text': '4', 'value': '32'},
				{'text': '5', 'value': '16'},
				{'text': '6', 'value': '8'},
				{'text': '7', 'value': '4'}
			]
		};
		this.layerOptionSelect(div, 'Map dot size', 'size', sizeOptions, (function(context) {
			return function(e) {
 				var layer = context.getManager().getControl('layerBase');
				var value = parseInt(this.value, 10);
				context.settingCache.dots.size = value;
				if(layer) {
					layer.setLevels(value);
				}
			}
		})(this));

		this.layerOptionSlider(div, 'Transparency', 'trans', {
				"min": 0,
				"max": 255,
				"value": 0,
				"type": "percent"
			}, (function(context) {
				return function(val) {
		 			var layer = context.getManager().getControl('layerBase');
					var value = parseInt(val, 10);
					context.settingCache.dots.transparency = value;
					if(layer) {
						layer.setTransparency(value);
					}
				}
			})(this), null, this
		);
		
		this.smoothingControls = document.createElement('div');
		$(this.smoothingControls).css({
			"background-color": "#454545",
			"color": "white",
			"padding": "10px 0"
		}).addClass("hide");
		
		this.layerOptionSlider(this.smoothingControls, 'Smoothing', 'smoothing', {
				"min": 0,
				"max": 50,
				"value": 0,
				"type": "value"
			}, (function(context) {
				return function(val) {
		 			var layer = context.getManager().getControl('layerBase');
					var value = parseInt(val, 10);
					context.settingCache.dots.smoothing = value;
					if(layer) {
						layer.setSmoothing(value);
					}
				}
			})(this), null, this
		);
	
		/////XXX START of Roy only controls
		var controls = [{
			"name": "Contourness", "id": "contourness", "min": 0, "max": 7, "def": 0
		},{
			"name": "Fuzziness Threshold", "id": "fuzziness_threshold", "min": 0, "max": 250, "def": 32
		},{
			"name": "Intensity Multiplier", "id": "intensity_mult", "min": 1, "max": 100, "def": 10
		},{
			"name": "Intensity Subtractor", "id": "intensity_sub", "min": 0, "max": 250, "def": 80
		}];
		
		for(var i = 0, l = controls.length; i < l; ++i){
			this.layerOptionSlider(this.smoothingControls, controls[i].name, controls[i].id,
				{
					"min": controls[i].min,
					"max": controls[i].max,
					"value": controls[i].def,
					"type": "value"
				},
				(function(context) {
					return function(val, id) {
			 			var layer = context.getManager().getControl('layerBase');
						var value = parseInt(val, 10);
						context.settingCache.dots[id] = value;
						if(layer) {
							var setting = {};
							setting[id] = value;
							layer.changeSettings(setting);	
						}
					}
				})(this), null, this
			);
		}
		$(div).append(this.smoothingControls);
		/////END of Roy only controls

		
		return div;
	},
	/**
	 *
	 * @method layerEnableOptions
	 * @param {} layer
	 */
	'layerEnableOptions': function(layer) {
		$('select.option', layer).attr('disabled', false);
		$('.slider', layer)
			.slider({"disabled": false});
	},
	/**
	 *
	 * @method layerDisableOptions
	 * @param {} layer
	 */
	'layerDisableOptions': function(layer) {
		$('select.option', layer).attr('disabled', false);
		$('.slider', layer)
			.slider({"disabled": true});
	},
	/**
	 *
	 * @method choroLayerUI
	 */
	'choroLayerUI': function() {
		var div = document.createElement('div');
		div.className = 'layer zone choro';

		this.layerHeading(div, 'Choropleth');
		this.layerEnable(div, (function(context) {
			return function(e) {
				var meshes = context.getMeshLayer();
				var filterable = context.bucket.filter;
				var ds = filterable.getDatasource();
				var meshId = $('select.option.boundary', this.container).val();
				var cache = context.settingCache['choro'];
				var checked = e.target.checked;
				var choro = context.recallChoroSettings(filterable, meshId, cache, checked);

				context.setChoroUIState(choro, meshes.getSupportedChoropleths(ds.int_name));
			}
		})(this));

		var meshes = {
			'options': []
		};
		this.layerOptionSelect(div, 'Boundary', 'boundary', meshes, (function(context) {
			return function(e) {
				var meshes = context.getMeshLayer();
				var colorBy = context.bucket.filter;
				var colorById = colorBy.int_name;
				var ds = colorBy.getDatasource();
				var dsId = ds.int_name;
				var meshId = e.target.value;

				var choro = meshes.getChoropleth(dsId, colorById);
				choro.int_name = meshId;

				choro = context.restoreCachedSettings('choro', meshId, choro);
				context.settingCache.choro['__last_mesh'] = meshId;
				context.updateSettingsCache('choro', meshId, dsId, colorById);

				context.setChoroUIState(choro, meshes.getSupportedChoropleths(ds.int_name));

				if(meshes.updateChoropleth(dsId, colorById, choro)) {
					meshes.updateMesh();
				}
			};
		})(this));
	
		// Addes line color and width controls
		this.layerOptionLines(div, 'Line size', 'lines', 'choro');
		
		// Region names
		var namesOptions = {
			'options': [
				{'text': 'Show', 'value': 'all', 'isDefault': true},
				{'text': 'Hide', 'value': 'none'}
			]
		};

		this.layerOptionSelect(div, 'Region names', 'names', namesOptions, (function(context) {
			return function(e) {
				var meshes = context.getMeshLayer();
				var colorBy = context.bucket.filter;
				var colorById = colorBy.int_name;
				var dsId = colorBy.getDatasource().int_name;
				var value = e.target.value;

				context.updateSettingsItem(dsId, colorById, 'choro', 'names', value);

				if(meshes.setRegionNames(dsId, colorById, value)) {
					meshes.updateMesh();
				}
			}
		})(this));
		
		//fill trans slider
		this.layerOptionSlider(div, 'Fill Transparency', 'filltrans', 
			{
				"min": 0,
				"max": 255,
				"value": 51,
				"type": "percent"
			},
			(function(context) {
				return function(val) {
					var meshes = context.getMeshLayer();
					var colorBy = context.bucket.filter;
					var colorById = colorBy.int_name;
					var dsId = colorBy.getDatasource().int_name;
					var value = parseInt(val, 10);

					context.updateSettingsItem(dsId, colorById, 'choro', 'fill_transparency', value);

					if(meshes.setFillTransparency(dsId, colorById, value)) {
						meshes.updateMesh();
					}
				}
			})(this), null, this
		);
		
		//Line trans slider
		this.layerOptionSlider(div, 'Line Transparency', 'linetrans', 
			{
				"min": 0,
				"max": 255,
				"value": 0,
				"type": "percent"
			},
			(function(context) {
				return function(val) {
					var meshes = context.getMeshLayer();
					var colorBy = context.bucket.filter;
					var colorById = colorBy.int_name;
					var dsId = colorBy.getDatasource().int_name;
					var value = parseInt(val, 10);

					context.updateSettingsItem(dsId, colorById, 'choro', 'line_transparency', value);

					if(meshes.setLineTransparency(dsId, colorById, value)) {
						meshes.updateMesh();
					}
				}
			})(this), null, this
		);

		return div;
	},
	/**
	 *
	 * @method areaLayerUI
	 */
	'areaLayerUI': function() {
		var div = document.createElement('div');
		div.className = 'layer zone area';

		this.layerHeading(div, 'Political Map');
		this.layerEnable(div, (function(context) {
			return function(e) {
				var meshes = context.getMeshLayer();
				var filter = context.bucket.filter;
				var ds = filter.getDatasource();
				var meshId = meshes.getSupportedArea(ds.int_name, filter.int_name);
				var cache = context.settingCache['area'];
				var checked = e.target.checked;
				var choro = context.recallChoroSettings(filter, meshId, cache, checked);

				context.setAreaUIState(choro);
			}
		})(this));

		// Addes line color and width controls
		this.layerOptionLines(div, 'Line size', 'lines', 'area');
		
		// Region names
		var namesOptions = {
			'options': [
				{'text': 'Show', 'value': 'all', 'isDefault': true},
				{'text': 'Hide', 'value': 'none'}
			]
		};

		this.layerOptionSelect(div, 'Region names', 'names', namesOptions, (function(context) {
			return function(e) {
				var meshes = context.getMeshLayer();
				var colorBy = context.bucket.filter;
				var colorById = colorBy.int_name;
				var dsId = colorBy.getDatasource().int_name;
				var value = e.target.value;

				context.updateSettingsItem(dsId, colorById, 'area', 'names', value);

				if(meshes.setRegionNames(dsId, colorById, value)) {
					meshes.updateMesh();
				}
			}
		})(this));
		
		//Fill trans slider
		this.layerOptionSlider(div, 'Fill Transparency', 'filltrans', 
			{
				"min": 0,
				"max": 255,
				"value": 0,
				"type": "percent"
			},
			(function(context) {
				return function(val) {
					var meshes = context.getMeshLayer();
					var colorBy = context.bucket.filter;
					var colorById = colorBy.int_name;
					var dsId = colorBy.getDatasource().int_name;
					var value = parseInt(val, 10);

					context.updateSettingsItem(dsId, colorById, 'area', 'fill_transparency', value);

					if(meshes.setFillTransparency(dsId, colorById, value)) {
						meshes.updateMesh();
					}
				}
			})(this), null, this
		);

		//Line trans filter
		this.layerOptionSlider(div, 'Line Transparency', 'linetrans', 
			{
				"min": 0,
				"max": 255,
				"value": 0,
				"type": "percent"
			},
			(function(context) {
				return function(val) {
					var meshes = context.getMeshLayer();
					var colorBy = context.bucket.filter;
					var colorById = colorBy.int_name;
					var dsId = colorBy.getDatasource().int_name;
					var value = parseInt(val, 10);

					context.updateSettingsItem(dsId, colorById, 'area', 'line_transparency', value);

					if(meshes.setLineTransparency(dsId, colorById, value)) {
						meshes.updateMesh();
					}
				}
			})(this), null, this
		);

		return div;
	},
	/**
	 *
	 * @method getMeshLayer
	 */
	'getMeshLayer': function() {
		return this.getManager().getControl('layerMesh');
	},
	/**
	 *
	 * @method layerHeading 
	 * @param {} container
 	 * @param {} text
	 */
	'layerHeading': function(container, text) {
		var subheading = document.createElement('div');
		subheading.className = 'subheading left';
		subheading.appendChild(document.createTextNode(text));

		//@HACK
		if(text == "Dots"){
			$(subheading)
				.data({"c": 0})
				.on("click", {"control": this}, function(e){
					var c = $(this).data("c");
					$(this).data({"c": ++c});

					var smoothing = e.data.control.smoothingControls;
					if (c % 4 == 0) {
						$(smoothing).toggleClass("hide");
					}
				});
		}
		//endhack
		
		container.appendChild(subheading);
	},
	/**
	 *
	 * @method layerEnable
	 * @param {} container
	 * @param {} change
	 */
	'layerEnable': function(container, change) {
		var on = document.createElement('input');
		on.type = 'checkbox';
		on.className = 'onoff right';
		on.colorby = this;

		if(typeof change === 'function') {
			$(on).change(change);
		}

		container.appendChild(on);

		var onLabel = document.createElement('label');
		onLabel.appendChild(document.createTextNode('Turn on'));
		onLabel.className = 'right black';
		container.appendChild(onLabel);

		var clear = document.createElement('div');
		clear.className = 'clear';
		container.appendChild(clear);
	},
	/**
	 *
	 * @method layerOptionLabel
	 * @param {} container
	 * @param {} text
	 * @param {} className
	 */
	'layerOptionLabel': function(container, text, className) {
		var label = document.createElement('label');
		label.className = ['option', className].join(' ');
		label.appendChild(document.createTextNode(text));

		container.appendChild(label);
	},
	/**
	 * 
	 * @method layerOptionClear
	 * @param {} container	 
	 */
	'layerOptionClear': function(container) {
		var clear = document.createElement('div');
		clear.className = 'clear option';
		container.appendChild(clear);
	},
	/**
	 *
	 * @method layerOptionCheckbox
	 * @param {} container
	 * @param {} text
	 * @param {} className
	 * @param {} options
	 * @param {} onChange
	 */
	'layerOptionCheckbox': function(container, text, className, options, onChange) {
		var div = document.createElement('div');
		div.className = ['right', className].join(' ');

		var checkbox = document.createElement('input');
		checkbox.type = 'checkbox';
		checkbox.value = 1;
		checkbox.checked = true;
		checkbox.className = ['option', className].join(' ');

		if(options.enabled !== undefined && !options.enabled) {
			checkbox.checked = false;
		}

		if(typeof onChange === 'function') {
			$(checkbox).change(onChange);
		}

		div.appendChild(checkbox);
		
		container.appendChild(div);

		this.layerOptionLabel(container, text, className);
		this.layerOptionClear(container);
	},
	/**
	 *
	 * @method layerOptionSelect
	 * @param {} container
	 * @param {} text
	 * @param {} className
	 * @param {} options
	 * @param {} change
	 */
	'layerOptionSelect': function(container, text, className, options, change) {
		var select = document.createElement('select');
		select.className = ['option', 'right', className].join(' ');

		for(var i = 0, l = options.options.length; i < l; i++) {
			var option = options.options[i];
			var opt = document.createElement('option');

			if(option.isDefault) {
				opt.defaultSelected = true;
			}

			opt.text = option.text;
			opt.value = option.value;
			select.add(opt);
		}

		if(typeof change === 'function') {
			$(select).change({"self": this, "className": className}, function(e){
				change.apply(this, [e]);
				e.data.self.getManager().mapObservers.notify("change_" + e.data.className + "_option");
			});
		}

		container.appendChild(select);

		if(!options.noLabel) {
			this.layerOptionLabel(container, text, className);
		}

		if(!options.noClear) {
			this.layerOptionClear(container);
		}
	},
	/**
	 *
	 * @method layerOptionSlider
	 * @param {} container
	 * @param {} text
	 * @param {} className
	 * @param {} options
	 * @param {} change
	 * @param {} slide
	 */
	'layerOptionSlider': function(container, text, identifyer, options, change, slide, context, bypassNotify) {
		
		var label = document.createElement('label');
		$(label)
			.addClass('slider_option option left ' + identifyer)
			.append(text + ": ");

		var val = Math.floor(options.value);
		if(options.type == "percent")
			val = Math.floor((options.value / options.max) * 100);
		
		var valueSpan = document.createElement('span');
		$(valueSpan)
			.addClass("trans_value " + identifyer)
			.append(val + (options.type == "percent" ? "%" : ""));
		
		label.appendChild(valueSpan);
		
		var sliderOptions = {
			"value": options.value,
			"min": options.min,
			"max": options.max,
			"step": options.max / 100,
			"stop": function(event, ui) {
				$(ui.handle).blur();
				if(change){
					change.apply(this, [ui.value, identifyer]);
					if(!bypassNotify){
						$(this).data().context.getManager().mapObservers.notify("change_" + identifyer + "_option");
					}
				}
			},
			"slide": function(event, ui) {
				var val = Math.floor(ui.value);
				if(options.type == "percent")
					val = Math.round((ui.value / options.max) * 100);
				
				$(".trans_value", label)
					.empty()
					.append(val + (options.type == "percent" ? "%" : ""));
				if(slide){
					slide.apply(this, [ui.value, identifyer]);
				}
			}
		};
		
		var slider = document.createElement('div');
		$(slider)
			.addClass("slider " + identifyer)
			.data({"context": context})
			.slider(sliderOptions);

		if(!options.noLabel) {
			container.appendChild(label);
		}

		this.layerOptionClear(container);
		
		container.appendChild(slider);
		
		if(!options.noClear) {
			this.layerOptionClear(container);
		}
		
		return slider;
	},
	/**
	 *
	 * @method layerOptionColor
	 * @param {} container
	 * @param {} text
	 * @param {} className
	 * @param {} options
	 * @param {} onChange
	 */
	'layerOptionColor': function(container, text, className, type, options) {
		var colorPicker = this.getManager().getControl('colorpicker');
		var icon = colorPicker.getColorIcon(this, type);

		container.appendChild(icon);

		if (!options.noLabel) {
			this.layerOptionLabel(container, text, className);
		}

		if (!options.noClear) {
			this.layerOptionClear(container);
		}

		/* @COLORPICKER
		var color = document.createElement('div');
		color.className = ['color-picker', 'clickable', 'right', className].join(' ');
		color.selectedColor = options.color || '000000';
		color.pickerShown = false;
		color.style.backgroundColor = '#' + color.selectedColor;

		var self = this;
		
		$(color).click(function() {
			if(!color.pickerShown) {
				self.makeColorPicker(color,	null, "choroLinePicker", 
					function(){
						$("#"+$(color).data("colorpickerId")).remove();
						$(color).removeData("colorpickerId");
					},
					onChange
				);
				$(color).ColorPickerShow();
			} else {
				$(color).ColorPickerHide();
			}
		});
		*/
	},
	/**
	 * @method makeColorPicker
	 * @param {Object} target
	 * @param {String} preDefColor
	 * @param {String} eventName
	 * @param {Function} onHide
	 * @param {Function} onChange
	 * @param {Function} onBeforeShow
	 * @param {Function} onShow
	 */
	/* @COLORPICKER
	'makeColorPicker': function(target, preDefColor, eventName, onHide, onChange, onBeforeShow, onShow){
		var timeout;
		var _onChange = function(hsb, hex, rgb) {
			clearTimeout(timeout);
			timeout = setTimeout(function () {
				target.selectedColor = hex;
				target.style.background = '#' + hex;
				onChange && onChange(hsb, hex, rgb);
			}, 250);
		};
		var _onBeforeShow = function() {
			$(this).ColorPickerSetColor(target.selectedColor || preDefColor);
			onBeforeShow && onBeforeShow();
		};
		
		var _onShow = function() {
			target.pickerShown = true;
			onShow && onShow();
		};
		
		var _onHide = function() {
			target.pickerShown = false;
			_onChange(null, target.selectedColor);
			onHide && onHide();
		};
		
		$(target).ColorPicker({
			'eventName': eventName,
			'onChange': _onChange,
			'onBeforeShow': _onBeforeShow,
			'onShow': _onShow,
			'onHide': _onHide,
			'livePreview': false
		});
	},*/
	'getColor': function() {
		return this.options.color || '000000';
	},
	'setColor': function(color, type) {
		var meshes = this.getMeshLayer();
		var colorBy = this.bucket.filter;
		var colorById = colorBy.int_name
		var ds = colorBy.getDatasource();
		var dsId = ds.int_name;

		this.updateSettingsItem(dsId, colorById, type, 'color', color);

		if(meshes.setChoroplethLineColor(dsId, colorById, color)) {
			meshes.updateMesh();
		}
	},
	/**
	 *
	 * @method layerOptionLines
	 * @param {} container
	 * @param {} text
	 * @param {} className
	 * @param {} type
	 * @param {} defaultValue
	 */
	'layerOptionLines': function(container, text, className, type, defaultValue) {
		var colorOptions = {
			'noLabel': true,
			'noClear': true
		};
		this.layerOptionColor(container, null, className, type, colorOptions);

		var opts = new Array(7);
		if(!defaultValue)
			defaultValue = 1;
		for(var i = 0, l = opts.length; i < l; ++i){
			opts[i] = {};
			opts[i].text = (i === 0) ? 'No lines' : i + "";
			opts[i].value = i + "";
			opts[i].isDefault = (i === defaultValue);
		}
		var selectOptions = {
			'noLabel': true,
			'noClear': true,
			'options': opts
		};
		var selectClass = ['width', className].join(' ');
		this.layerOptionSelect(container, null, selectClass, selectOptions, (function(context) {
			return function(e) {
				var meshes = context.getMeshLayer();
				var colorBy = context.bucket.filter;
				var colorById = colorBy.int_name
				var ds = colorBy.getDatasource();
				var dsId = ds.int_name;
				var value = parseInt(e.target.value, 10);

				context.updateSettingsItem(dsId, colorById, type, 'width', value);

				if(meshes.setChoroplethLineWidth(dsId, colorById, value)) {
					meshes.updateMesh();
				}
			};
		})(this));

		this.layerOptionLabel(container, text, className);
		this.layerOptionClear(container);
	},
	/**
	 *
	 * @method hide
	 */
	'hide': function() {
		this.undisplay();
		this.getManager().removeMapObserver('zoom', this.onZoom, this);
		
	},
	/**
	 *
	 * @method display
	 * @parma {} bucket
	 */
	'display': function(bucket) {
		if(bucket.colorBy){
			//passing correct bucket when childBy is clicked
			bucket = bucket.colorBy;
		}
		
		if(bucket === this.bucket) {
			this.hide();
			return;
		}

		this.undisplay();

		this.bucket = bucket;
		var filter = bucket.filter;
		if(!filter){
			throw new Error("No filter set for bucket: " + $(bucket).html());
			return false;
		}
		
		var ds = filter.getDatasource();
		var container = this.container;

		this.getManager().addMapObserver('sidepanelscroll', this.adjustOffset, this);
		this.getManager().addMapObserver('filterabletoggle', this.adjustOffset, this);
		this.getManager().addMapObserver('panel_resize', this.adjustOffset, this);
		this.getManager().addMapObserver('before_panel_close', this.hide, this);
		
		$('.heading', this.container).empty();
		$('.heading', this.container)[0].appendChild(document.createTextNode(bucket.filter.ext_name));

		var currentColorBy = this.getManager().getControl('filters').getColorBy();

		this.setDotsUIState((bucket.filter === currentColorBy));

		// @TODO this also needs to check to see if this color by has any choros
		var meshes = this.getMeshLayer();
		if (filter.supportsChoro() && meshes && meshes.hasChoropleths(ds.int_name)) {
			var choro = meshes.getActiveChoropleth(ds.int_name, filter.int_name);
			if(choro && !this.settingCache.choro[choro.int_name]) {
				this.updateSettingsCache('choro', choro.int_name, choro.ds, choro.color_by);
			}

			this.getManager().addMapObserver('meshchange', this.onMeshChange, this);

			this.setChoroUIState(choro, meshes.getSupportedChoropleths(ds.int_name));
			$('.layer.choro', this.container).show();
			$('.layer.area', this.container).hide();
		} else if(filter.supportsArea()) {
			this.getManager().removeMapObserver('meshchange', this.onMeshChange, this);
			if(choro && !this.settingCache.area[choro.int_name]) {
				this.updateSettingsCache('area', choro.int_name, choro.ds, choro.color_by);
			}

			var choro = meshes.getActiveChoropleth(ds.int_name, filter.int_name);
			this.setAreaUIState(choro);
			$('.layer.choro', this.container).hide();
			$('.layer.area', this.container).show();
		} else {
			this.getManager().removeMapObserver('meshchange', this.onMeshChange, this);

			$('.layer.choro', this.container).hide();
			$('.layer.area', this.container).hide();
		}
		
		$('.layer.spots', this.container).hide();		

		// Need zoom to adjust zoom bound options, like dot size
		this.getManager().addMapObserver('zoom', this.onZoom, this);

		$('body').append(container);

		container.style.display = 'block';
		this.adjustOffset();
	},
	/**
	 *
	 * @method recallChoroSettings
	 * @param {} filter 
	 * @param {} mesh
	 * @param {} cache
	 * @param {} enabled
	 */
	'recallChoroSettings': function(filter, mesh, cache, enabled) {
		var meshes = this.getMeshLayer();
		var path = filter.getDataPath();
		var ds = filter.getDatasource();
		var cached = cache[mesh] || {};
		var colors = filter.getColors();

		for (var key in colors) {
			colors[key] = {'value': colors[key]};
		}

		var color;
		if(cached.color !== undefined) {
			color = cached.color;
		}
		var fc = filter.getControl();
		if(!color && fc && fc.options && fc.options.meshDefaultColor) {
			color = fc.options.meshDefaultColor;
		}

		var width;
		if(cached.width !== undefined) {
			width = cached.width;
		}

		var ltrans;
		if(cached.line_transparency !== undefined) {
			ltrans = cached.line_transparency;
		}

		var ftrans;
		if(cached.fill_transparency !== undefined) {
			ftrans = cached.fill_transparency;
		}

		var names;
		if(cached.names !== undefined) {
			names = cached.names;
		}
		
		var choro;
		if (enabled) { // Turn on layer
			// ds, colorby, path, mesh, colors, color, width, ltrans, ftrans, names
			choro = meshes.addChoropleth(ds.int_name, filter.int_name, path, mesh,
										 colors, color, width, ltrans, ftrans, names);
			filter.setChoroedBy(true);
		} else { // Turn off layer
			meshes.removeChoropleth(ds.int_name, filter.int_name, mesh);
			filter.setChoroedBy(false);
		}

		return choro;
	},
	/**
	 *
	 * @method supportsChoro
	 */ 
	'supportsChoro': function() {
		return this.bucket.filter.supportsChoro();
	},
	/**
	 *
	 * @method supportsArea
	 */
	'supportsArea': function() {
		var filter = this.bucket.filter;
		var meshLayer = this.getMeshLayer();
		return !!meshLayer.getSupportedArea(filter.int_name);
	},
	/**
	 *
	 * @method adjustOffset
	 */
	'adjustOffset': function() {
		var bucket = this.bucket;
		var container = this.container;

		if(!$(bucket).is(":visible")) {
			this.hide();
		}
		
		if(container.style.display === 'block') {
			var offset = $(bucket).offset();
			var windowHeight = $(document).height();
			var boxHeight = $(container).height();
			var boxWidth = $(container).width();
			var isLower = ((windowHeight / 2) < offset.top);

			$('.pointer', container).css('left', boxWidth + 'px');

			if(isLower) {
				$('.pointer', container).css('top', boxHeight - 20 - 17  + 'px');
			} else {
				$('.pointer', container).css('top', '');
			}

			container.style.left = offset.left - boxWidth - 15 + "px";
			container.style.top = offset.top - ((isLower) ? boxHeight - 33 : 20) +  'px';
		}
	},
	/**
	 *
	 * @method onMeshChange
	 */
	'onMeshChange': function() {
		// @TODO keep width and color in sync
	},
	/**
	 *
	 * @method onZoom
	 */
	'onZoom': function() {
		this.setDotSizeOption();
	},
	/**
	 *
	 * @method setDotSizeOption
	 */
	'setDotSizeOption': function() {
		var layer = Moonshadow.getManager().getControl('layerBase');

		var levels = layer.getLevels();
		var z = this.getManager().getAdapter().getZoom();
		$('.layer.dots .option.size', this.container).val('' + levels[z]);
	},
	/**
	 * 
	 * @method setDotsUIState
	 * @param {} isOn
	 */
	'setDotsUIState': function(isOn) {
		var layer = Moonshadow.getManager().getControl('layerBase');

		this.setLayerUIState($('.layer.dots', this.container), isOn);
		$('.layer.dots .onoff', this.container).attr('disabled', isOn);

		var density = (layer.getDensity()) ? 1 : 0;
		$('.layer.dots .option.density', this.container).val('' + density);

		this.setDotSizeOption();

		var trans = layer.getTransparency();
		
		$('.layer.dots .slider.trans', this.container).slider({
			"value": trans,
			"disabled": !isOn
		});
		$(".trans_value.trans", this.container)
			.empty()
			.append(Math.floor((trans / 255) * 100) + "%");
	},
	/**
	 *
	 * @method setChoroUIState
	 * @param {} choro
	 * @param {} meshes
	 */
	'setChoroUIState': function(choro, meshes) {
		this.setRegionUIState(choro, 'choro', meshes);
	},
	/**
	 *
	 * @method setAreaUIState
	 * @param {} choro
	 */
	'setAreaUIState': function(choro) {
		this.setRegionUIState(choro, 'area')
	},
	/**
	 *
	 * @method setRegionUIState
	 * @param {} choro
	 * @param {} className
	 * @param {} meshes
	 */
	'setRegionUIState': function(choro, className, meshes) {
		var isOn = !!choro;
		var prefix = ['.layer.', className].join('');		
		this.setLayerUIState($(prefix, this.container), isOn);

		var lastMesh;
		if(className === 'choro') {
			lastMesh = this.settingCache.choro.__last_mesh;
		}

		// @TODO emptying and repopulating this causes some odd UI behavior when 
		// disabling a choro/area
		var select = $(prefix + ' select.option.boundary', this.container)[0];
		if(select) {
			$(select).empty();
			for(var i = 0, l = meshes.length; i < l; i++) {
				var opt = document.createElement('option');
				var mesh = meshes[i];

				opt.value = mesh.int_name;
				opt.text = mesh.ext_name || mesh.int_name;

				if(choro && choro.int_name === mesh.int_name) {
					opt.selected = true;
				}

				if(!choro && lastMesh && lastMesh === mesh.int_name) {
					opt.selected = true;
				}
					
				select.add(opt);
			}
		}

		if(lastMesh && !choro) {
			choro = this.restoreCachedSettings('choro', lastMesh, {});
			choro.int_name = lastMesh;
		}			

		if(choro) {
			if(choro.width != undefined) {
				$(prefix + ' select.lines.width', this.container).val(choro.width);
			}
			if(choro.color != undefined) {
				$(prefix + ' div.lines.color-picker', this.container)
					.attr('selectedColor', choro.color)
					.css('background-color', '#' + choro.color);
			}
			if(choro.fill_transparency != undefined) {
				$(prefix + ' .slider.filltrans', this.container).slider({
					"value": choro.fill_transparency
				});
				$(".trans_value.filltrans", this.container)
					.empty()
					.append(Math.floor((choro.fill_transparency / 255) * 100) + "%");
			}
			if(choro.line_transparency != undefined) {
				$(prefix + ' .slider.linetrans', this.container).slider({
					"value": choro.line_transparency
				});
				$(".trans_value.linetrans", this.container)
					.empty()
					.append(Math.floor((choro.line_transparency / 255) * 100) + "%");
			}
			if(choro.int_name != undefined) {
				$(prefix + ' select.option.boundary', this.container).val(choro.int_name);
			}
			if(choro.names != undefined) {
				$(prefix + ' select.option.names', this.container).val(choro.names);
			}
		}

		if(!meshes) {
			meshes = [];
		}
	},
	/**
	 *
	 * @method setLayerUIState
	 * @param {} container
	 * @param {} isOn
	 */
	'setLayerUIState': function(container, isOn) {
		$(container).css('display', 'block');
		$('.onoff', container).attr('checked', isOn);
		$('.option', container).attr('disabled', !isOn);
		
		$(".slider", container).slider({
			"disabled": !isOn
		});
		
		if(isOn) {
			$(container).removeClass('disabled');
			$('label.option.disabled', container).removeClass('disabled');
		} else {
			$(container).addClass('disabled');
			$('label.option', container).addClass('disabled');
		}
	},
	/**
	 *
	 * @method undisplay
	 */
	'undisplay': function() {
		if(this.bucket) {
			$(this.container).parent()[0].removeChild(this.container);
			
			this.getManager().removeMapObserver('sidepanelscroll', this.adjustOffset, this);
			this.getManager().removeMapObserver('filterabletoggle', this.adjustOffset, this);
			this.getManager().removeMapObserver('panel_resize', this.adjustOffset, this);
			this.getManager().removeMapObserver('before_panel_close', this.hide, this);

			this.bucket = null;
		}
	},
	/**
	 *
	 * @method updateSettingsCache
	 * @param {} type
	 * @param {} newMeshId
	 * @param {} prevDSId
	 * @param {} prevColorById
	 */
	'updateSettingsCache': function(type, newMeshId, prevDSId, prevColorById) {
		// If no settings already, set them up
		if(!this.settingCache[type][newMeshId]) {
			var meshes = this.getMeshLayer();
			this.settingCache[type][newMeshId] = {};

			var choro = meshes.getChoropleth(prevDSId, prevColorById);
			if(choro) {
				this.settingCache[type][newMeshId] = {
					'color': choro.color,
					'fill_transparency': choro.fill_transparency,
					'line_transparency': choro.line_transparency,
					'names': choro.names,
					'width': choro.width
				};
			}
		}
	},
	/**
	 * 
	 * @method updateSettingsItem
	 * @param {} dsId
	 * @param {} colorId
	 * @param {} type
	 * @param {} item
	 * @param {} value
	 */
	'updateSettingsItem': function(dsId, colorId, type, item, value) {
		var meshes = this.getMeshLayer();
		var choro = meshes.getChoropleth(dsId, colorId);
		if(choro) {
			var meshId = choro.int_name;
			if(!this.settingCache[type][meshId]) {
				this.settingCache[type][meshId] = {};
			}

			this.settingCache[type][meshId][item] = value;
		}
	},
	/*
	 *
	 * @method restoreCachedSettings
	 * @param {} type
	 * @param {} meshId
	 * @param {} choro
	 */
	'restoreCachedSettings': function(type, meshId, choro) {
		return $.extend(true, {}, choro, this.settingCache[type][meshId] || {});
	}
};
Moonshadow.helpers.extend(colorby, MControl);

/**	
 *
 * @method rasterlayer
 * @extends MControl
 * @constructor
 * @param {} options
 */
function rasterlayer(options) {
	this.name = 'rasterlayer';
	this.options = options || {};
	this.region = null;
	this.dragging = false;
	this.mouseBound = false;
}

rasterlayer.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	'init': function(manager) {
		this.clearGrids();
		
		this.manager = manager;
		manager.addMapObserver('meshchange', function(event, data) {
			var maskControl = this.getManager().getControl('layerMask');
			var regionControl = this.getManager().getControl('layerRegion');
			
			var hide = true;
			
			if(data.choropleths.length && !maskControl.isSelecting) {
				regionControl.show(data.choropleths);
				hide = false;
			}else{
				regionControl.hide();
			}
			
			if(maskControl.masksEnabled) {
				maskControl.show(data.masks);
				hide = false;
			}else{
				maskControl.hide();
			}
			
			hide &&	this.hide();
			
		}, this);

		var meshControl = manager.getControl('layerMesh');
		if(meshControl.hasActiveChoropleths()) {
			var regionControl = this.getManager().getControl('layerRegion');
			regionControl.show(meshControl.getActiveChoropleths());
		}
	},
	/**
	 *
	 * @method show
	 * @param {} data
	 */
	'show': function(data, type) { // on
		this.region = null;
		this.grids[type] = data;
		this.clearCache();
		this.bindMouse();
	},
	/**
	 *
	 * @method hide
	 */
	'hide': function() { // off
		this.region = null;
		this.clearGrids();
		this.clearCache();
		this.unbindMouse();
	},
	/**
	 *
	 * @method bindMouse
	 */
	'bindMouse': function() {
		if(this.mouseBound)
			return;
		
		var manager = this.getManager();
		var adapter = manager.getAdapter();
		if(!this.onMouseDownHandler) {
	 		this.onMouseDownHandler = adapter.addMapListener('mousedown', this, this.onMouseDown);
		}
		if(!this.onMouseUpHandler) {
	 		this.onMouseUpHandler = adapter.addMapListener('mouseup', this, this.onMouseUp);
		}
		if(!this.onMouseMoveHandler) {
	 		this.onMouseMoveHandler = adapter.addMapListener('mousemove', this, this.onMouseMove);
		}
		this.mouseBound = true;
	},
	/**
	 *
	 * @method unbindMouse
	 */
	'unbindMouse': function() {
		if(!this.mouseBound)
			return;
		
		var manager = this.getManager();
		var adapter = manager.getAdapter();
		if(this.onMouseDownHandler) {
	 		adapter.removeMapListener(this.onMouseDownHandler);
	 		this.onMouseDownHandler = null;
		}
		if(this.onMouseUpHandler) {
			adapter.removeMapListener(this.onMouseUpHandler);
			this.onMouseUpHandler = null;
		}
		if(this.onMouseMoveHandler) {
			adapter.removeMapListener(this.onMouseMoveHandler);
			this.onMouseMoveHandler = null;
		}
		this.mouseBound = false;
	},
	/**
	 *
	 * @method onMouseDown
	 * @param {} event
	 * @param {} data
	 */
	'onMouseDown': function(event, data) {
		this.mouseDown = true;
		this.dragging = false;
	},
	/**
	 *
	 * @method onMouseUp
	 * @param {} event
	 * @param {} data
	 */
	'onMouseUp': function(event, data) {
		this.mouseDown = false;
		this.dragging = false;
	},
	/**
	 *
	 * @method onMouseMove
	 * @param {} event
	 * @param {} data
	 */
	'onMouseMove': function(event, data) {
		if(this.mouseDown){
			this.dragging = true;
		}
	},
	/**
	 *
	 * @method updateTile
	 * @param lat
	 * @param lng
	 * @param zoom
	 * @param type
	 * @param [] meshes
	 */
	'updateTile': function(lat, lng, zoom, type, meshes){
		
		var adapter = this.getManager().getAdapter()
		var pixel = adapter.latLngToPixelXY(lat, lng, zoom);

		var tilePixel = adapter.pixelXYToSubTileCord(pixel[0], pixel[1]);
		var tile = adapter.pixelXYToTileCord(pixel[0], pixel[1]).concat(zoom);

		var tileId = tile.join('_');

		if(!this.cache[type][tileId] && this.cache[type][tileId] !== -1) {
			var caller = this;
			caller.updateCache(type, tileId, -1);
			this.getTile(tile, meshes, function(error, data) {
				if(error) {
					throw error;
				}

				caller.updateCache(type, tileId, data);
				caller.updateData(caller.cache[type][tileId], tilePixel, type);
			});
		} else if(this.cache[type][tileId] && this.cache[type][tileId] !== -1) {
			this.updateData(this.cache[type][tileId], tilePixel, type);
		}
	},
	/**
	 *
	 * @method updateCache
	 * @param {} id
	 * @param {} grids
	 */
	'updateCache': function(type, id, grids) {
		this.cache[type][id] = grids;
	},
	/**
	 *
	 * @method clearCache
	 */
	'clearCache': function() {
		this.cache = {
			"choro": {},
			"masks": {}
		};
	},
	/**
	 *
	 * @method clearGrids
	 */
	'clearGrids': function(){
		this.grids = {
			"choro": [],
			"masks": []
		};
	},
	/**
	 *
	 * @method updateData
	 * @param {} tileData
	 * @param {} cord
	 */
	'updateData': function(tileData, cord, type) {
		if(!tileData) {
			return false;
		}		

		var pointData = [];
		var pointId = [];
		for(var i = 0, l = this.grids[type].length; i < l; i++) {
			var grid = tileData.grids[this.grids[type][i].int_name];
			var ds = this.grids[type][i].ds;
			
			var item;
			if(grid) {
				var charCode = this.getCharCodeForPoint(grid.grid, cord);
				item = grid.key[charCode - 32];

				if(item) {
					item.path = this.grids[type][i].path;
					item.ds = ds;
				}
			} else {
				// This is deal with qs crashes
				item = {
					'int_name': '__problem',
					'ext_name': 'Error! Refresh browser or reapply choropleth'
				}
			}

			if(!item || item.int_name === '') {
				item = {
					'int_name': '__unknown',
					'ext_name': 'Unknown'
				};
			};

			item.mesh = this.grids[type][i].int_name;

			pointId.push(item.int_name);
			pointData.push(item);
		}

		pointId = pointId.join('|');
		if(pointId && (!this.region || (this.region.id != pointId))) {
			this.region = this.getRegion(pointId, pointData, tileData.x, tileData.y, tileData.z);
			this.getManager().mapObservers.notify('regionchange', this.region);
		}
	},
	/**
	 *
	 * @method getRegion
	 * @param id
	 * @param data
	 * @param x
	 * @param y
	 * @param z
	 */
	'getRegion': function(id, data, x, y, z){
		return new Region(id, data, x, y, z);
	},
	/**
	 *
	 * @method getCharCodeForPoint
	 * @param gridData
	 * @param cord
	 */
	'getCharCodeForPoint': function(gridData, cord) {
		var size = 256 / gridData.length;
		var gX = Math.floor(cord[0] / size);
		var gY = Math.floor(cord[1] / size);

		return gridData[gY].charCodeAt(gX);
	},
	/**
	 *
	 * @method getTile
	 * @param {} tile
	 * @param [] meshes
	 * @param {} callback
	 */
	'getTile': function(tile, meshes, callback) {
		var query = {
			'query': 'get_utfgrid_b',
			'nogzip': true,
			'x': tile[0],
			'y': tile[1],
			'z': tile[2]
		};
		
		if(meshes && meshes.length){
			query.meshes = meshes;
			query.query = 'get_utfgrid_b_meshes';
		}

		var ajax = new Moonshadow.Ajax();
		ajax.addQuery(query, function(result) {
			if(result.result === 'ok') {
				callback(null, result);
			} else {
				callback(new Error(result.message));
			}
		}).execute();
	}
};

Moonshadow.helpers.extend(rasterlayer, MControl);

/**
 *
 * @class rasterdisplay
 * @constructor
 * @param {} options
 */
function rasterdisplay(options) {
	this.name = 'rasterdisplay';
	this.options = options || {};
	this.position = 3;
	this.precedence = 100;
	this.mouseDown = false;
	this.cards = [];
	this.currentCard;
	this.cardsCollapsed = false;
	this.cardContainers = [];
	this.cardControls;
}

rasterdisplay.prototype = {
	/** 
	 *
	 * @method init
	 * @param {} manager
	 */
	'init': function(manager) {
		this.manager = manager;

		this.container = this.buildUI();
		manager.getAdapter().addControlToMap(manager.getControl(this.name), true);

		var meshes = manager.getControl('layerMesh');
		if(meshes.hasActiveChoropleths()) {
			this.addCard(); // Create first card
			this.show();
		}

		// control on/off events
		manager.addMapObserver('choroplethon', this.onRasterOn, this);
		manager.addMapObserver('choroplethoff', this.onRasterOff, this);

		// polygon events
		manager.addMapObserver('polygonon', this.onPolygonOn, this);
		manager.addMapObserver('polygonoff', this.onPolygonOff, this);

	},
	/**
 	 *
	 * @method buildUI
	 */
	'buildUI': function() {
		var caller = this;
		var ce = Moonshadow.helpers.ce;

		this.cardControls = $(ce("div"))
			.addClass("card_controls hide single")
			.append(
				$(ce("div"))
					.append(
						$(ce("div")).addClass("adder_sprite sprite-plus"))
					.addClass("adder clickable")
					.attr({
						"title": "Add a card"
					})
					.click({"caller": caller}, function(e){
						e.data.caller.addCard();
					}),
				$(ce("div"))
					.append(
						$(ce("div")).addClass("collapse_sprite sprite-arrowRight"))
					.addClass("card_collapse clickable not_visible")
					.attr({
						"title": "Collapse cards"
					})
					.click({"caller": caller}, function(e){
						if(e.data.caller.cardsCollapsed){
							e.data.caller.unCollapseCards();
						}else{
							e.data.caller.collapseCards();
						}
					})
			);
		
		this.cardContainers.push(this.getNewContainer());
		
		return this.cardContainers[0];
		
	},
	/**
	 *	
 	 * @method redistributeCards
	 */
	'redistributeCards': function(){
		if(!this.cardsCollapsed){
			this.wrapCards();
			this.unWrapCards();
			this.adjustControls();
		}
	},
	/**
	 *	
 	 * @method adjustControls
	 */
	'adjustControls': function(turnOff){
		if(turnOff){
			$(this.cardControls).addClass('hide');
			return;
		}
		
		$(this.cardControls).removeClass('hide');
		this.hideCollapser();
		this.hideAdder();
		
		if(!this.cards.length){
			$(this.cardControls).addClass('single');
			this.showAdder();
		}
		if(this.cards.length == 1){
			$(this.cardControls).removeClass('single');
			var card = this.getCurrentCard();
			if(!card || this.cardsCollapsed) {
				this.showAdder();
			}
		}
		if(this.cards.length > 1){
			$(this.cardControls).removeClass('single');
			this.showCollapser();
			var card = this.getCurrentCard();
			if((!card && this.cardContainers.length <= 2) || this.cardsCollapsed) {
				this.showAdder();
			}
		}
	},
	/**
	 *	
 	 * @method getNewContainer
	 */
	'getNewContainer': function(){
		return $(this.ce("div"))
			.addClass("rasterdisplay right")
			.attr({
				"id": "rasterdisplay"
			})
			.css({
				"display": "block",
				"top": (this.cardContainers.length * 330) + 30
			})
			.append(this.cardControls)
			.get(0);
	},
	/**
	 *
	 * @method addContainer
	 */
	'addContainer': function() {
		var cont = this.getNewContainer();
		$(this.container).after(cont);
		this.cardContainers.push(cont);
		this.container = cont;
	},
	/**
	 *	
 	 * @method getCardCount
	 */
	'getCardCount': function() {
		return this.cards.length;
	},
	/**
	 *	
 	 * @method collapseCards
	 */
	'collapseCards': function() {
		this.cardsCollapsed = true;
		$(this.cardControls).addClass("collapsed");
		$('.card_collapse', this.cardControls).find(".collapse_sprite")
			.removeClass("sprite-arrowRight").addClass("sprite-arrowLeft");
		for(var i = 0, l = this.cardContainers.length; i < l; ++i){
			$(this.cardContainers[i])
				.removeClass("right")
				.removeAttr("style")
				.css({
					"display": "block",
					"right": 214 + (!!this.cardContainers.length ? 29 : 0)
				});
		}
		
		$(this.cardContainers[0])
			.append(this.cardControls);
		
		for(var i = 0, l = this.cards.length; i < l; ++i){
			var zindex = i * 10
			if($(this.cards[i].container).hasClass("selected")){
				zindex = (this.cards.length) * 10
			}
			this.cards[i].adjustCollapse(i, zindex);
		}
		
		this.adjustControls();
	},
	/**
	 *	
 	 * @method unCollapseCards
	 */
	'unCollapseCards': function() {
		this.cardsCollapsed = false;
		$(this.cardControls).removeClass("collapsed");
		$('.card_collapse', this.cardControls).find(".collapse_sprite")
			.removeClass("sprite-arrowLeft").addClass("sprite-arrowRight");
		for(var i = 0, l = this.cardContainers.length; i < l; ++i){
			$(this.cardContainers[i])
				.removeClass("right")
				.removeAttr("style")
				.css({
					"display": "block",
					"top": (i * 330) + 30
				});
		}
		
		$(this.cardContainers[this.cardContainers.length - 1])
			.prepend(this.cardControls);
		
		for(var i = 0, l = this.cards.length; i < l; ++i){
			$(this.cards[i].container)
				.removeAttr("style");
			if($(this.cards[i].container).hasClass("selected")){
				this.cards[i].setSelected();
			}else{
				this.cards[i].unsetSelected();
			}
		}
		this.redistributeCards();
	},
	/**
	 *	
 	 * @method wrapCards
	 */
	'wrapCards': function() {
		var self = this;
		var contIndex = 0;
		var spillInd = 0
		var getSpill = function(){
			var spill = false;
			for(var i = spillInd, l = self.cards.length; i < l; ++i){
				if(self.leftCheck(self.cards[i].container)){
					spillInd = i + 1;
					var spillArray = self.cards.slice(spillInd);
					if(spillArray.length){
						var targetCont = self.cardContainers[contIndex + 1];
						if(!targetCont){
							self.addContainer();
							targetCont = self.container;
						}
						contIndex++;
						$(targetCont).append($(spillArray).map(function(ind, card){
							return card.container;
						}));
						spill = true;
						break;
					}
				}
			}
			if(spill){
				getSpill();
			}
		};
		getSpill();
	},
	/**
	 *	
 	 * @method unWrapCards
	 */
	'unWrapCards': function() {
		var self = this;
		var getUnspill = function(){
			var unspill = false;
			if(self.cardContainers.length > 1){
				for(var i = self.cardContainers.length - 1, l = 1; i >= l; --i){
					if(!self.leftCheck(self.cardContainers[i-1])){
						unspill = true;
						$(self.cardContainers[i-1])
							.append(
								$(".card", self.cardContainers[i]).get(0)
							);
						if($(".card", self.cardContainers[i]).length == 0){
							self.removeCardContainer(self.cardContainers[i]);
						}
					}
				}
			}
			if(unspill){
				getUnspill();
			}
		};
		getUnspill();
	},
	/**
	 *
	 * @method addCard
	 */
	'addCard': function() {
		var currentCard = this.getCurrentCard();
		var card = new ChartCard(this.getManager(), this);
		card.id = this.cards.length;
		this.cards.push(card);

		
		if(currentCard) {
			card.changeChartType(currentCard.getChartType());
			card.setRegion(currentCard.lastRegion);
		}		

		if(this.leftCheck(this.container)){
			this.addContainer();
		}

		var container = this.cardContainers[this.cardContainers.length -1];
		$(container).append(card.container);
		this.setCurrentCard(card);
		this.adjustControls();

		if(this.cardsCollapsed){
			this.collapseCards();
		}
	},
	'removeCardContainer': function(container){
		for(var i = 0, l = this.cardContainers.length; i < l; ++i){
			if(container == this.cardContainers[i]){
				this.cardContainers.splice(i, 1);
				if(container == this.container){
					var newCont = this.cardContainers[this.cardContainers.length - 1];
					this.container = newCont;
					$(newCont).prepend(this.cardControls);
				}
				$(container).remove();
				break;
			}
		}
	},
	/**
	 *
	 * @method removeCard
	 * @param {} event
	 * @param {} card
	 */
	'removeCard': function(event, card) {
		var pos = $.inArray(card, this.cards);
		if(pos > -1) {
			this.cards.splice(pos, 1);
			var cardParent = $(card.container).parent().get(0);
			$(card.container).remove();
			
			if(this.getCurrentCard() == card)
				this.setCurrentCard();

			if(!$(".card", cardParent).length && this.cardContainers.length > 1){
				this.removeCardContainer(cardParent);
			}
		}
		
		this.adjustControls();
		if(!this.cardsCollapsed || this.cards.length == 0){
			this.unCollapseCards();
		}else{
			this.collapseCards();
		}
	},
	/**
	 *
	 * @method leftCheck
	 */
	'leftCheck': function(container, val) {
		if(!val)
			val = 250;
		return $(container).offset().left < val
	},
	/**
	 *
	 * @method leftCheckAll
	 */
	'leftCheckAll': function(val) {
		for(var i = 0, l = this.cardContainers.length; i < l; ++i){
			if(this.leftCheck(this.cardContainers[i], val)){
				return true;
			}
		}
	},
	/**
	 *
	 * @method showAdder
	 */
	'showAdder': function() {
		$('.adder', this.cardControls).removeClass("not_visible");
	},
	/**
	 *
	 * @method hideAdder
	 */
	'hideAdder': function() {
		$('.adder', this.cardControls).addClass("not_visible");
	},
	/**
	 *
	 * @method showCollapser
	 */
	'showCollapser': function() {
		$('.card_collapse', this.cardControls).removeClass("not_visible");
	},
	/**
	 *
	 * @method hideCollapser
	 */
	'hideCollapser': function() {
		$('.card_collapse', this.cardControls).addClass("not_visible");
	},
	/**
	 *
	 * @method getCurrentCard
	 */
	'getCurrentCard': function() {
		return this.currentCard;
	},
	/**
	 *
	 * @method setCurrentCard
	 * @param {} card
	 */
	'setCurrentCard': function(card) {
		if(this.getCurrentCard()) {
			this.getCurrentCard().unsetSelected();
		}

		this.currentCard = card;

		if(card) {
			card.setSelected();
		}
	},
	/**
	 *
	 * @method show
	 */
	'show': function() {
		var manager = this.getManager();
		manager.addMapObserver('meshchange', this.onMeshChange, this);

		this.bindMouseEvents();

		manager.addMapObserver('regionchange', this.onRegionChange, this);

		if(this.region) {
			this.onRegionChange('show', this.region);
		}

		// card management events
		manager.addMapObserver('addchartcard', this.addCard, this);
		manager.addMapObserver('removechartcard', this.removeCard, this);
		manager.addMapObserver('setchartcard', this.setCurrentCard, this);
		manager.addMapObserver(['panel_resize', 'panel_change'], this.redistributeCards, this);
		
		this.adjustControls();
	},
	/**
	 *
	 * @method hide
	 */
	'hide': function() {
		var manager = this.getManager();
		manager.removeMapObserver('meshchange', this.onMeshChange, this);

		this.unbindMouseEvents();

		manager.removeMapObserver('regionchange', this.onRegionChange, this);
		manager.removeMapObserver(['colorchange', 'filterupdated'], this.onColorChange, this);
		
		// card management events
		manager.removeMapObserver('addchartcard', this.addCard, this);
		manager.removeMapObserver('removechartcard', this.removeCard, this);
		manager.removeMapObserver('setchartcard', this.setCurrentCard, this);
		manager.removeMapObserver(['panel_resize', 'panel_change'], this.redistributeCards, this);
		
		this.adjustControls();
	},
	/**
	 *
	 * @method bindMouseEvents
	 */
	'bindMouseEvents': function() {
		var manager = this.getManager();
		var adapter = manager.getAdapter();

		if (!this.mouseDownListener) {
			this.mouseDownListener = adapter.addMapListener('mousedown', this,
															this.onMouseDown);
		}	
	},
	/**
	 * 
	 * @method unbindMouseEvents
	 */
	'unbindMouseEvents': function() {
		if(this.mouseDownListener) {
			var adapter = this.getManager().getAdapter();
			adapter.removeMapListener(this.mouseDownListener);
			this.mouseDownListener = null;	
		}
	},
	/**
	 *
	 * @method onPolygonOn
	 */
	'onPolygonOn': function() {
		this.unbindMouseEvents();
	},
	/**
	 *
	 * @method onPolygonOff
	 */
	'onPolygonOff': function() {
		this.bindMouseEvents();
	},
	/**
	 *
	 * @method setChoroStats
	 */
	'setChoroStats': function(choros) {
		var dss = this.groupChorosForStats(choros);

		var onComplete = function(data) {
			if(data.result === 'ok') {
				this.show();
				this.container.style.display = 'block';
			}
		};

		var bundle = new Moonshadow.Ajax();

		var caller = this;
		$.each(dss, function(k, v) {
			// @TODO this seems like it may be a problem. Multiple choros would cause
			// multiple refreshes?
			bundle.addQuery(caller.createSetStatsForDS(k, v), onComplete, caller);
		});

		bundle.execute();
	},
	/**
	 *
	 * @method createSetStatsForDS
	 * @param {} int_name
	 * @param {} ds
	 */
	'createSetStatsForDS': function(int_name, ds) {
		var value = {};

		$.each(ds.meshes, function(k, v) {
			if(!value[k]) {
				value[k] = [];
			}

			for(var i = 0, l = v.colorbys.length; i < l; i++) {
				var ii = v.colorbys[i];
				value[k].push({
					'filter_name': ii.int_name,
					'filter_tree': [] // @TODO this shouldn't be an empty array
				});
			}
		});

		return {
			'query': 'save_stored_state',
			'name': '__stats_choropleth',
			'value': value,
			'ds': int_name
		};
	},
	/**
	 *
	 * @method groupChorosForStats
 	 * @param {} choros
	 */
	'groupChorosForStats': function(choros) {
		var dss = {};

		for(var i = 0, l = choros.length; i < l; i++) {
			var choro = choros[i];
			if(!dss[choro.ds]) {
				dss[choro.ds] = {
					'meshes': {}
				};
			}

			if(!dss[choro.ds].meshes[choro.int_name]) {
				dss[choro.ds].meshes[choro.int_name] = {
					'colorbys': []
				};
			}

			dss[choro.ds].meshes[choro.int_name].colorbys.push({
				'int_name': choro.color_by,
				'ext_name': choro.color_by,
				'path': choro.path
			});
		}

		return dss;
	},
	/**
 	 *
	 * @method onRasterOn
	 * @param {} event
	 * @param {} data
	 */
	'onRasterOn': function(event, data) {
		var mesh = this.getManager().getControl('layerMesh');
		var active = mesh.getActiveChoropleths();
		this.setChoroStats(active);
		this.adjustControls();
	},
	/**
	 *
	 * @method onRasterOff
	 * @param {} event
	 * @param {} data
	 */
	'onRasterOff': function(event, data) {
		this.hide();
		this.container.style.display = 'none';
		this.adjustControls(true);
	},
	/**
	 *
	 * @method onColorChange
	 * @param {} event
	 * @param {} data
	 */
	'onColorChange': function(event, data) {
		if(this.region) {
			this.onRegionChange(event, this.region);
		}
	},
	/**
	 *
	 * @method onMeshChange
	 * @param {} event
	 * @param {} data
	 */
	'onMeshChange': function(event, data) {
		if (data.choropleths.length) {
			var card = this.getCurrentCard();
			if(card) {
				card.dontDisplayChart(data.choropleths[0].color_by);
			}
	
			this.setChoroStats(data.choropleths);
		}
	},
	/**
	 *
	 * @method onMouseDown
	 * @param {} event
	 * @param {} data
	 */
	'onMouseDown': function(event, data) {
		var manager = this.getManager();
		var shapeControl = manager.getControl('shape');

		if (shapeControl && shapeControl.isActive()) {
			return; // If shape is active do nothing with the event
		}

		if('pushpin' !== data.targetType &&
		   !this.getManager().getAdapter().focusInfobox) {
			this.mouseDown = true;
			this.mouseDownData = data;

			var adapter = this.getManager().getAdapter();
			this.mouseMoveListener = adapter.addMapListener('mousemove', this,
															this.onMouseMove);
			this.mouseUpListener = adapter.addMapListener('mouseup', this, 
														  this.onMouseUp);
		}
	},
	/**
	 *
	 * @method onMouseMove
	 * @param {} event
	 * @param {} data
	 */
	'onMouseMove': function(event, data) {
		if(!this.mouseDown) {
			return;
		}

		if('map' === data.targetType) {
			var start = this.mouseDownData;
			if (Math.abs(start.pageX - data.pageX) > 2 ||
					Math.abs(start.pageY - data.pageY) > 2) {
				this.mouseDownData = false;
			}
		}
	}, 
	/**
	 *
	 * @method onMouseUp
	 * @param {} event
	 * @param {} data
	 */
	'onMouseUp': function(event, data) {
		this.mouseDown = false;

		var adapter = this.getManager().getAdapter();
		if(this.mouseMoveListener) {
			adapter.removeMapListener(this.mouseMoveListener);
		}

		if(this.mouseUpListener) {
			adapter.removeMapListener(this.mouseUpListener);
		}

		if(!this.mouseDownData) {
			return;
		}

		this.onClick(event, data);
	},
	/**
	 *
	 * @method onClick
	 */
	'onClick': function() {
		if(this.getCurrentCard()) {
			if(this.getCurrentCard().noChart !== undefined && 
					this.hasData(this.getCurrentCard())){
				this.getCurrentCard().unsetSelected();
				this.currentCard = null;
				this.adjustControls();
			}
		}
	},
	/**
	 *
	 * @method hasData
	 * @param {} card
	 */
	'hasData': function(card) {
		if(card &&
			card.regionData &&
			card.regionData.data){
			for(var i in card.regionData.data){
				if(card.regionData.data.hasOwnProperty(i)){
					if(card.regionData.data[i].total){
						return true;
					}
				}
			}
		}
		return false;
	},
	/**
	 *
	 * @method onRegionChange
	 * @param {} event
	 * @param {} region
	 */
	'onRegionChange': function(event, region) {
		// Im mouse down don't emit events on drags
		if(this.mouseDown) {			
			this.mouseBlockedRegion = region;
			return;
		}

		var card = this.getCurrentCard();
		if(card) {
			card.setRegion(region);
		}
	},

};

Moonshadow.helpers.extend(rasterdisplay, MControl);
/**
 *
 * @class ChartCard
 * @param {} manager
 * @param {} parent
 */
var ChartCard = function(manager, parent) {
	this.manager = manager;
	this.parent = parent;
	this.locked = false;
	this.chartType = 'pie';
	this.container = this.buildUI();
	this.selected = false;
};

ChartCard.prototype = {
	'buildUI': function() {
		// card
		var card = document.createElement('div');
		card.className = 'card';

		// action container
		var actions = document.createElement('div');
		actions.className = 'actions';
		card.appendChild(actions);

		// Pie chart
		var pieChart = document.createElement('div');
		pieChart.className = 'pie sprite-chart_pie_sel chart-type clickable left action';
		pieChart.title = "Show Data as Pie Chart";

		$(pieChart).click((function(context) {
			return function(e) {
				context.changeChartType('pie');
			}
		})(this));

		actions.appendChild(pieChart);

		// Bar chart
		var barChart = document.createElement('div');
		barChart.className = 'bar sprite-chart_column chart-type clickable left action';
		barChart.title = "Show Data as Bar Graph";

		$(barChart).click((function(context) {
			return function(e) {
				context.changeChartType('bar');
			}
		})(this));

		actions.appendChild(barChart);

		// close action
		var close  = document.createElement('div');
		close.className = 'close sprite-close_x clickable right action';
		close.title = 'Close this card';

		$(close).click((function(context) {
			return function(e) {
				context.manager.mapObservers.notify('removechartcard', context);
			};
		})(this));

		actions.appendChild(close);

		// select action
		var focus = document.createElement('div');
		focus.className = 'focus sprite-selectedcircle_small clickable right action';

		$(focus).click((function(context) {
			return function(e) {
				if(!context.selected) {
					context.parent.setCurrentCard(context);
				}else{
					context.parent.getCurrentCard().unsetSelected();
					context.parent.currentCard = null;
					context.parent.adjustControls();
				}
			};
		})(this));

		actions.appendChild(focus);

		// card heading title
		var cardHeadingTitle = document.createElement('div');
		cardHeadingTitle.className = "card_heading_title";
		
		actions.appendChild(cardHeadingTitle);
		
		
 		var clear = document.createElement('div');
		clear.className = 'clear';

		actions.appendChild(clear);

		// data
		var data = document.createElement('div');
		data.className = 'data';
		card.appendChild(data);

		// header
		var header = document.createElement('div');
		header.className = 'header';
		data.appendChild(header);

		var title = document.createElement('div');
		title.className = 'title';
		header.appendChild(title);

		var choroby = document.createElement('div');
		choroby.className = 'choroby';
		header.appendChild(choroby);

		var total = document.createElement('div');
		total.className = 'total';
		header.appendChild(total);

		// Used when no data to display
		var noData = document.createElement('div');
		noData.className = 'no-data';
		noData.appendChild(document.createTextNode('No data'));
		data.appendChild(noData);

		// contains the chart
		var chart = document.createElement('div');
		chart.className = 'chart';
		data.appendChild(chart);

		// Used when no select yet
		var noSelect = document.createElement('div');
		noSelect.className = 'no-select';
		noSelect.appendChild(document.createTextNode('Mouse over a region'));
		noSelect.appendChild(document.createElement('br'));
		noSelect.appendChild(document.createTextNode('Click region to lock'));
		card.appendChild(noSelect);

		return card;
	},
	/**
	 *
	 * @method changeChartType
	 * @param {} type
	 */
	'changeChartType': function(type) {
		var prev = $(['.actions ', '.', this.chartType].join(''), this.container);
		var prevType = this.chartType === "bar" ? "column" : "pie";
		prev.addClass('sprite-chart_' + prevType);
		prev.removeClass('sprite-chart_' + prevType + '_sel');


		var newType = type === "bar" ? "column" : "pie";
		var next = $(['.actions ', '.', type].join(''), this.container);
		next.addClass('sprite-chart_' + newType + '_sel');
		next.addClass('sprite-chart_' + newType + '_sel');
		next.removeClass('sprite-chart_' + newType);

		this.chartType = type;
		this.setupChart();
		this.refreshChart();		
	},
	/**
	 *
	 * @method getChartType
	 */
	'getChartType': function() {
		return this.chartType;
	},
	/**
	 *
	 * @method setupChart
	 */
	'setupChart': function() {
		var container = $('.chart', this.container)[0];
		if(this.chartType === 'pie') {
			this.chart = new google.visualization.PieChart(container);
		} else if(this.chartType === 'bar') {
			this.chart = new google.visualization.BarChart(container);
		} else {
			throw new Error('Invalid chart type');
		}
	},
	/**
	 *	
 	 * @method adjustCollapse
	 * @param index
	 */
	'adjustCollapse': function(index, zindex) {
		$(this.container)
			.css({
				"position": "absolute",
				"z-index": zindex,
				"top": 10 + (index * 30),
				"left": 29,
				"margin-top": 0
			});
	},
	/**
	 *
	 * @method dontDisplayChart
	 * @param {} colorby
	 */
	'dontDisplayChart': function(colorby) {
		if(colorby === '__heatmap') {
			this.noChart = true;
			$('.actions .chart-type', this.container).hide();
			$('.chart', this.container).hide();
			$('.chart', this.container).empty();
			this.chart = null;
			return true;
		} else {
			this.noChart = false;
			$('.actions .chart-type', this.container).show();
			$('.chart', this.container).show();
			return false;
		}
	},
	/**
	 *
	 * @method setSelected
	 */
	'setSelected': function() {
		$(this.container)
			.addClass('selected')
			.css({
				"background-color": "#FFFFFF",
				"z-index": (($(".card").length - 1) * 10) + 10
			});
		var circle = $('.actions .focus', this.container);
		circle.attr('title', 'This card is selected');
		circle.addClass("sprite-selectedcircle_small");
		circle.removeClass("sprite-unselectedcircle_small");
		this.selected = true;
		this.refreshChart();
	},
	/**
	 *
	 * @method unsetSelected
	 */
	'unsetSelected': function() {
		$(this.container)
			.removeClass('selected')
			.css({
				"background-color": "#E5E5E5",
				"z-index": $($(".card").toArray()).index(this.container) * 10
			});
		var circle = $('.actions .focus', this.container);
		circle.attr('title', 'Select this card');
		circle.addClass("sprite-unselectedcircle_small");
		circle.removeClass("sprite-selectedcircle_small");
		this.selected = false;
		this.refreshChart();
	},
	/**
	 *
	 * @method removeClose
	 */
	'removeClose': function() {
		$('.actions .close', this.container).remove();
	},
	/**
	 *
	 * @method refreshChart
	 */
	'refreshChart': function() {
		if(this.regionData) {
			this.updateData(this.regionData);
		}
	},
	/**
	 *
	 * @method updateLock
	 */
	'updateLock': function() {
		if(!this.locked) {
			this.locked = true;
		} else if(this.lastRegion.id === this.region.id) {
			this.locked = false;
		} else {
			this.locked = false;
			this.setRegion(this.lastRegion);
			this.locked = true;
		}

		this.updateLockUI();
	},
	/**
	 *
	 * @method setRegion
	 * @param {} region
	 */
	'setRegion': function(region) {
		if(this.locked) {
			this.lastRegion = region;
			return;
		}

		this.lastRegion = region;

		// Block if request already in flight
		if(this.statsRequest) {
			return;
		}

		if(!region || !region.id || region.id === '__unknown') {
			return;
		}

		// This is after so we can compare the last display against the
		// last region moused over
		this.region = region;

		var geo = region.data[0];

		var query = {
			'query': 'get_choropleth_statistics',
			'id': geo.id,
			'mesh': geo.mesh,
			'ds': geo.ds
		};

		var bundle = new Moonshadow.Ajax();
		this.statsRequest = bundle;

		bundle.addQuery(query, function(data) {
			if(data.result === 'ok' && data.values) {
				this.updateData({
					'data': data.values,
					'region': region
				});

				this.statsRequest = null;

				if(this.region !== this.lastRegion) {
					this.setRegion(this.lastRegion);
				}
			} else {
				this.statsRequest = null;
			}
		}, this);
		bundle.execute();
	},
	/**
	 *
	 * @method updateData
	 * @param {} data
	 * @param {} callback
	 */
	'updateData': function(data, callback) {
		var caller = this;

		this.regionData = data;
		
		var datasourcesControl = this.manager.getControl("datasources");
		$('.no-select', this.container).hide();

		$('.title', this.container).empty();
		$('.total', this.container).empty();
		$('.choroby', this.container).empty();

		var title = document.createTextNode(data.region.data[0].ext_name);
		$('.title', this.container)[0].appendChild(title);
		
		$('.card_heading_title', this.container)
			.empty()
			.append(data.region.data[0].ext_name);

		if(!this.chart) {
			this.setupChart();
		}

		$.each(data.data, function(dsIntName, stats) {
			if(!stats.total || !stats.stats.length) {
				$('.chart', caller.container).hide();
				$('.no-data', caller.container).show();
				return true;
			} else {
				$('.no-data', caller.container).hide();
				$('.chart', caller.container).show();
			}

			var item = stats.stats[0];

			var fieldDetails = datasourcesControl.getFieldDetails(item.filter_name);
			var filterName = (fieldDetails && fieldDetails.ext_name) || item.filter_name;
			
			var dataType = document.createTextNode('Data: ' + filterName);
			$('.choroby', caller.container)[0].appendChild(dataType);

			var totalFormated = $().number_format(stats.total, {
				'numberOfDecimals': false,
				'decimalSeparator': '.',
				'thousandSeparator': ','
			});

			var total = document.createTextNode('Total: ' + totalFormated);
			$('.total', caller.container)[0].appendChild(total);

			if(caller.dontDisplayChart(item.filter_name)) {
				return;
			}

			// Get the colors
			var colors;
			var manager = caller.manager;
			var colorsControl = manager.getControl('colors');

			var path = [];
			if (data.region && data.region.data && data.region.data[0] &&
				data.region.data[0].path) {
				path = data.region.data[0].path.slice();
			}
	
			colors = colorsControl.getColorsForField(dsIntName, path.join('|'));

			var tableData = [];
			$.each(item.filter_result, function(k, v) {
				if (k === '__unknown') {
					return;
				}

				var row = {
					'label': k,
					'value': v,
				};

				if (colors[k]) {
					row.color = colors[k];
				} else {
					throw new Error('Color not found');
				}

				tableData.push(row);
			});

			var table = new google.visualization.DataTable();

			if(caller.chartType === 'pie') {
				// Reverse sort, want largest to smallest
				tableData.sort(function(a, b) {
					if(a.value < b.value) {
						return 1;
					} else if(a.value == b.value) {
						return 0;
					} else {
						return -1;
					}
				});

				table.addColumn('string', item.filter_name);
				table.addColumn('number', 'Individuals');
			} else if(caller.chartType === 'bar') {
				table.addColumn('string', null);
			}

			var rows = [];
			var colorArray = [];
			for(var i = 0, l = tableData.length; i < l; i++) {
				var row = tableData[i];

				if(caller.chartType === 'pie') {
					rows.push([row.label, row.value]);
				} else {
					if(!row.value) {
						continue;
					}

					if(!rows[0]) {
						rows[0] = [''];
					}

					table.addColumn('number', row.label);
					rows[0].push(row.value);
				}

				colorArray.push(row.color);
			}

			table.addRows(rows);

			if(caller.chartType === 'pie') {
				var options = {
					'width': 200,
					'height': 220,
					'chartArea': {
						'top': 0,
						'width': 180,
						'height': 200
					},
					'legend': {
						'position': 'bottom'
					},
					'is3D': true,
					'colors': colorArray
				};

			} else if(caller.chartType === 'bar') {
				var options = {
					'width': 200,
					'height': 220,
					'chartArea': {
						'top': 0,
						'width': 180,
						'height': 186
					},
					'legend': {
						'position': 'bottom'
					},
					'colors': colorArray
				}

				options.vAxis = [
					{
						'textPosition': 'none'
					}
				];
			}

			// Set to same color as card
			options.backgroundColor = caller.container.style.backgroundColor || '#FFFFFF'

			caller.chart.draw(table, options);
		});
	}
};

/**
 *
 * @class Region
 * @constructor
 * @param {} id
 * @param {} data
 * @param {} x
 * @param {} y
 * @param {} z
 */
function Region(id, data, x, y, z) {
	if(!data[0]) {
		throw new Error('Invalid region data');
	}

	this.id = id;
	this.data = data;
	this.x = x;
	this.y = y;
	this.z = z;

	var bounds;
	if(data[0].box) {
		bounds = data[0].box.slice();
	} else {
		bounds = [x, y, x, y];
	}
	this.bounds = bounds;
};

/**
 *
 * @method getData
 * @param {} index
 */
Region.prototype.getData = function(index) {
	return this.data[index] || undefined;
};

/**
 *
 * @method inBounds
 * @param {} x
 * @param {} y
 * @param {} z
 */
Region.prototype.inBounds = function(x, y, z) {
	var bounds = this.getBounds(z);

	if(x < bounds[0] || y < bounds[1] || x > bounds[2] || y > bounds[3]) {
		return false;
	}

	return true;
};

/**
 *
 * @method getBounds
 * @param {} z
 */
Region.prototype.getBounds = function(z) {
	if(z === this.z) {
		return this.bounds;
	} 

	var bounds = this.bounds.slice();
	var diff = z - this.z;
	if(diff > 0) {
		bounds[0] = bounds[0] << diff
		bounds[1] = bounds[1] << diff
		bounds[2] = ((bounds[2] + 1) << diff) - 1;
		bounds[3] = ((bounds[3] + 1) << diff) - 1;
	} else if(diff < 0) {
		var abs = Math.abs(diff);
		bounds[0] = bounds[0] >> abs;
		bounds[1] = bounds[1] >> abs;
		bounds[2] = bounds[2] >> abs;
		bounds[3] = bounds[3] >> abs;
	}

	return bounds;
};


/**	
 *
 * @method reportqueue
 * @extends MControl
 * @constructor
 * @param {} options
 */
function reportqueue(options) {
	this.name = "reportqueue";
	this.options = options || {};
	this.reportsJobTimer = null;
	this.reports = {};
}

Moonshadow.helpers.extend(reportqueue, MControl);

/**
 *
 * @method init
 * @param {} manager
 */
reportqueue.prototype.init = function(manager) {
	this.manager = manager;
	this.getJobDetails();
};

/**
 * Get report using report id
 * 
 * @method getReport
 * @param {String} id Report id
 * @returns {Report} Returns report, or undefined if not found
 */

reportqueue.prototype.getReport = function(id) {
	var reports = this.reports;
	for (var i in reports){
		if(!reports.hasOwnProperty(i))
			continue;
		if (reports[i].report_id === id) {
			return reports[i];
		}
	}

	return undefined;
};

/**
 *
 * @method startJobDetailsTimer
 */
reportqueue.prototype.startJobDetailsTimer = function() {
	var self = this;
	var getJobs = function() {
		var ids = [];
		$.each(self.reports, function(key, item) {
			if (item.status > 0 && item.status < 50) {
				ids.push(item.report_id);
			}
		});

		if (ids.length) {
			self.getJobDetails(ids);
		}
	};

	this.reportsJobTimer = setTimeout(getJobs, 10000);
};

/**
 *
 * @method deleteJobDetailsTimer
 */
reportqueue.prototype.deleteJobDetailsTimer = function() {
	if (this.reportsJobTimer) {
		clearTimeout(this.reportsJobTimer);
		this.reportsJobTimer = null;
	}
};

/**
 *
 * @method getJobDetails
 * @param [] ids
 * @param {Callback} callback(data)
 */
reportqueue.prototype.getJobDetails = function(ids, callback) {
	this.deleteJobDetailsTimer();

	var queryObj = {
		"interface_type": "webclient"
	};
	
	if (ids && ids.length) {
		queryObj.ids = ids;
	}

	var self = this;

	var url = Moonshadow.getDataUrl() + "reportqueue";
	
	var onSuccess = function(data){
		if (data.result !== 'ok') {
			throw new Error(data.message || data.error);
			return;
		}

		if (data && data.jobs && data.jobs.length) {
			var reports = $(data.jobs).map(function(index, job){
				job.hash = $.md5(JSON.stringify(job));
				var report = self.reports[job.report_id];
				if(!report){
					return job;
				}
				if(report.date_modified != job.date_modified){
					return $.extend(true, report, job);
				}
			})
			.filter(function(key, report){
				if(!report)
					return false;
				if(report.status <= -60) //not deleted reports
					return false;
				return true;
			})
			.toArray();

			for(var i = 0, l = reports.length; i < l; ++i){
				self.reports[reports[i].report_id] = reports[i];
			}

			self.verifyJobTimer();
		}
		self.reportDetailsUpdated();
		callback && callback(data);
	};
	
	new Moonshadow.Ajax({
		"url": url,
		"payload": queryObj,
		"addCreds": true,
		"wrapPost": false,
		"execute": true,
		"onSuccess": onSuccess
	});
};

reportqueue.prototype.reportDetailsUpdated = function(){
	this.getManager().mapObservers.notify("reportdetailsupdated");
};

/**
 *
 * @method verifyJobTimer
 * @param [] jobs
 */
reportqueue.prototype.verifyJobTimer = function() {
	var timerStarted = false;
	var self = this;
	$.each(this.reports, function(index, job) {
		if (!timerStarted && job.status >= 0 && job.status < 50) { 
			self.startJobDetailsTimer();
			timerStarted = true;
		}
	});
};

/**
 *
 * @method generateReport
 * @param {} queryObj
 * @param {Callback} callback(data)
 */
reportqueue.prototype.generateReport = function(queryObj, callback) {
	var self = this;
	self._runGenerateQuery(queryObj, function(data) {
		if(data && data.job){
			self.verifyJobTimer();
			self.reportDetailsUpdated();
		}
		callback && callback(data);
	});
};



/**
 *
 * @method _runGenerateQuery
 * @param {} queryObj
 * @param {Callback} callback(data)
 */
reportqueue.prototype._runGenerateQuery = function(queryObj, callback) {
	var self = this;
	new Moonshadow.Ajax({
		"url": Moonshadow.getDataUrl() + "reportqueue/create",
		"payload": queryObj,
		"addCreds": true,
		"wrapPost": false,
		"execute": true,
		"onSuccess": function(data) {
			if (data.result !== "ok") {
				throw new Error(data.message || data.error);
				return;
			}
			if(data && data.job){
				self.reports[data.job.report_id] = data.job;
			}
			callback && callback(data);
		}
	});
};


/**
 *
 * @method getReportsByAttribute
 * @param attribute
 * @param value
 * @param returnObject
 * returns array of report objects or object of key/value pairs
 */
reportqueue.prototype.getReportsByAttribute = function(attribute, values, returnObject) {
	if($.type(values) != "array"){
		values = [values];
	}
	var reports = $.map(this.reports, function(report, index) {
		if(!attribute && !values)
			return report;
		if($.inArray(report[attribute], values) > -1)
			return report;
	});
	
	if(returnObject){
		var retObj = {};
		for(var i = 0, l = reports.length; i < l; ++i){
			retObj[reports[i].report_id] = reports[i];
		}
		return retObj;
	}
	
	return reports;
};

/**
 *
 * @method getReportEstimates
 * @param {Callback} callback(data)
 */
reportqueue.prototype.getReportEstimates = function(callback) {
	var reports = [];
	for(i in this.reports){
		if(!this.reports.hasOwnProperty(i)){
			continue;
		}
		reports.push(this.reports[i]);
	}
	
	new Moonshadow.Ajax({
		"url": Moonshadow.getDataUrl() + "reportqueue/estimates",
		"payload": reports,
		"addCreds": true,
		"wrapPost": false,
		"execute": true,
		"onSuccess": function(data){
			if (data.result !== "ok") {
				throw new Error(data.message || data.error);
				return;
			}
			callback && callback(data);
		}
	});
};

/**
 *
 * @method batchEstimates
 * @param [] params
 * @param {Callback} callback(data)
 */
reportqueue.prototype.batchEstimates = function(params, callback){
	var obj = {
		"reports": params
	};
	new Moonshadow.Ajax({
		"url": Moonshadow.getDataUrl() + "reportqueue/estimates",
		"payload": {
			"reports": params
		},
		"wrapPost": false,
		"addCreds": true,
		"execute": true,
		"onSuccess": function(data){
			if (data.result !== "ok") {
				throw new Error(data.message || data.error);
				return;
			}
			callback && callback(data);
		}
	});
};

/**
 *
 * @method getEstimates
 * @param {} queryObj
 * @param {Callback} callback(data)
 */
reportqueue.prototype.getEstimates = function(layout, numRecords, numProcessed, callback){
	var url = Moonshadow.getDataUrl() + "reportqueue/estimate/"
		+ layout + "/" + numRecords;

	if (numProcessed != undefined) {
		url += "/" + numProcessed;
	}

	new Moonshadow.Ajax({
		"url": url,
		"type": "GET",
		"payload": {},
		"addCreds": true,
		"execute": true,
		"onSuccess": function(data){
			if (data.result !== "ok") {
				throw new Error(data.message || data.error);
				return;
			}
			callback && callback(data);
		}
	});
};

/**
 * 
 * @method deleteReport
 * @peram reportId
 * @param {Callback} callback(data)
 */
reportqueue.prototype.deleteReport = function(reportId, callback) {
	var self = this;
	
	new Moonshadow.Ajax({
		"url": Moonshadow.getDataUrl() + "reportqueue/" + reportId,
		"type": "DELETE",
		"payload": {},
		"addCreds": true,
		"execute": true,
		"onSuccess": function(data){
			if (data.result !== "ok") {
				if(data.type != 404){
					throw new Error(data.message || data.error);
					return;
				}
			}
			delete self.reports[reportId];
			self.verifyJobTimer();
			callback && callback(data);
		}
	});
};

/**
 * 
 * @method downloadReport
 * @peram reportId
 */
reportqueue.prototype.downloadReport = function(reportId) {
	var report = this.getReport(reportId);

	// Try to support depricated report_server values
	if (/^https?:\/\//.test(report.report_server) === false) {
		report.report_server = "http://" + report.report_server;
	}

	var url = report.report_server + "/reports/file/" + reportId;
	
	var reportForm = $(this.ce("form"))
		.addClass("hide")
		.attr({
			"action": url,
			"target": "_blank",
			"method": "GET"
		})
		.append(
			$(this.ce("input"))
				.attr({
					"type": "hidden",
					"name": "key",
					"value": Moonshadow.key
				}),
			$(this.ce("input"))
				.attr({
					"type": "hidden",
					"name": "user",
					"value": Moonshadow.user
				})
		);
	
	$(document.body).append(reportForm);
	reportForm.submit();
	$(reportForm).remove();

	this.getJobDetails([reportId]);
};

/**
 * 
 * @method downloadImage
 * @peram reportId
 */
reportqueue.prototype.downloadImage = function(reportId) {
	window.location.assign(Moonshadow.getDataUrl("/reports/file/" + reportId) + 
						   "?&key=" + Moonshadow.key + 
						   "&user=" + Moonshadow.user);
};
/**	
 *
 * @method reporttypes
 * @extends MControl
 * @constructor
 * @param {} options
 */
function reporttypes(options) {
	this.name = "reporttypes";
	this.options = options || {};
}

reporttypes.prototype = {
	"init": function(manager) {
		this.manager = manager;
		
		//check if the app qualifies for nationbuilder exports
		if(this.includeNationbuilder()){
			this.getTypeObj("nationbuilder_export").included = true;
		}
	},
	"getTypeObj": function(typeId){
		for(var i = 0, l = this.reportTypesInfo.length; i < l; ++i){
			if(typeId == this.reportTypesInfo[i].typeId)
				return this.reportTypesInfo[i];
		}
	},
	"getReportTypes": function(universe){
		var datasource = this.getManager().getDatasource(universe.datasource);
		if(!datasource || !datasource["export"]){
			return false;
		}
		
		var hasNBOAuthCreds = universe.getControl().getManager().hasOAuth('nationbuilder');
		
		universe.reportTypes = [];
		var isFullyPurchased = universe.isFullyPurchased();
		var self = this;

		var getTab = function(tabName){
			for(var i = 0, l = self.reportSubTabs.length; i < l; ++i){
				if(self.reportSubTabs[i].id == tabName)
					return $.extend(true, {}, self.reportSubTabs[i]);
			}
		};
		var getDefaultOptSet = function(defaultUiOpts, uiOpt){
			for(var iii = 0, lll = defaultUiOpts.length; iii < lll; ++iii){
				if(defaultUiOpts[iii].id == uiOpt.id){
					var newOpts = $.extend(true, {}, defaultUiOpts[iii]);
					for(var j in uiOpt){
						if(!uiOpt.hasOwnProperty(j))
							continue;
						if(typeof uiOpt[j] == "string" || 
								typeof uiOpt[j] == "number"){
							newOpts[j] = uiOpt[j];
						}
					}
					return newOpts;
				}
			}
		};
		var getUIOption = function(defOpt, uiOpt){
			if(defOpt.options && typeof defOpt.options == "function"){
				defOpt.options(uiOpt);
				return defOpt;
			}else if(defOpt.options && defOpt.options.length){
				defOpt.options = $(defOpt.options).map(function(key, opt){
					if($.inArray(opt.val, uiOpt.options) > -1){
						return $.extend(true, {}, opt);
					}
				})
				.filter(function(key, val){
					return !!val;
				})
				.toArray();
			}
			return defOpt;
		};

		for(var i = 0, l = this.reportTypesInfo.length; i < l; ++i) {
			var reportType = $.extend(true, {}, this.reportTypesInfo[i]);

			if (!reportType.included) {
				universe.reportTypes.push(reportType);
				continue;
			}
			
			// Check that columnset exists
			var datasource = this.getManager().getDatasource(universe.datasource);
			var columnSets = datasource['export'] || {};
			if (reportType.column_set && !columnSets[reportType.column_set]) {
				reportType.included = false;
				universe.reportTypes.push(reportType);
				continue; // column_set defined but doesn't exist in ds, don't show
			}
			
			var notExportableReason = universe.notExportableReason();
			if(notExportableReason){
				reportType.enabled = false;
				reportType.disabledReason = " (Disabled: " + notExportableReason.reason + ")";
			}

			//adds surveys tab if app qualifies
			this.checkCanvassing(reportType);
			
			if(reportType.tabs && reportType.tabs.length){
				var tabActive = -1;
				for(var ii = 0, ll = reportType.tabs.length; ii < ll; ++ii){
					var tab = getTab(reportType.tabs[ii]);
					tab.parent = reportType;
					if(hasNBOAuthCreds){
						if(tab.id == "nbauth"){
							tab.active = false;
						}
						if(tab.id == "generatenb"){
							tab.active = true;
						}
					}
					if(tab.active)
						tabActive = ii;
					if(tabActive == ii)
						tab.active = true;
					reportType.tabs.splice(ii, 1, tab);
				}
				if(tabActive < 0 && reportType.tabs.length){
					for(var ii = 0, ll = reportType.tabs.lenght; ii < ll; ++ii){
						if(reportType.tabs[ii].hidden !== true &&
								reportType.tabs[ii].disabled !== true){
							reportType.tabs[ii].active = true;
						}
					}
				}
					
			}
			if(reportType.uiOpts && reportType.uiOpts.length){
				for(var ii = 0, ll = reportType.uiOpts.length; ii < ll; ++ii){
					var uiOpt = reportType.uiOpts[ii];
					var defOpt = getDefaultOptSet(this.uiOpts, uiOpt);
					var uiOptSet = getUIOption(defOpt, uiOpt);
					reportType.uiOpts.splice(ii, 1, uiOptSet);
				}
			}
			
			reportType.getTabItem = function(tabId){
				for(var i = 0, l = this.tabs.length; i < l; ++i){
					var tab = this.tabs[i];
					if(tab.id == tabId){
						return tab;
					}
				}
			}
			
			universe.reportTypes.push(reportType);
		}
		universe.reportTypes.sort(function(a, b){
			if(!a.order)
				a.order = 0;
			if(!b.order)
				b.order = 0;
			return a.order - b.order;
		});
	},
	"includeNationbuilder": function() {
		// Don't show icon if NB export format isn't defined
		var ds = this.getManager().getDatasource(0);
		if (!ds.export || !ds.export.nationbuilder) {
			return false;
		}

		// Check supported app type, this is probably a bit redundant
		var appType = this.getManager().getAppType();
		if (!appType) {
			return false;
		}

		if (appType.indexOf('votermapping') === 0) {
			return true;
		}

		if (appType.indexOf('constituentmapping') === 0) {
			return true;
		}

		return false;
	},
	"checkCanvassing": function(reportType){
		var manager = this.getManager();
		var enabled = (manager.hasAddon("groundgame") || 
			manager.hasAddon("phonecampaigns") || 
			manager.hasAddon("fbpolls")) &&
			manager.getOption("user_details.user_type") != "read-only";
		var surveyTabIsValidForTypeIds = {"csv": true, "walking": true};
		
		if(enabled && surveyTabIsValidForTypeIds[reportType.typeId]){
			for(var i = 0, l = reportType.tabs.length; i < l; ++i){
				if(reportType.tabs[i] == "generate"){
					reportType.tabs.splice(i, 0, "surveys");
					reportType.uiOpts.splice(i, 0, {
						"id": "surveys"
					},{
						"id": "allsurveys"
					},{
						"id": "surveynames",
						"limit": reportType.typeId == "walking" ? 4 : null
					});
					break;
				}
			}
		}
	},
	"hoverDisplayOptions": {
		"standard": function(title){
			return [{			
					"title": "Report Status:",
					"bound": ["status"],
					"dataType": function(report){
						var status = report.status;
						if (status < 0){
							return "Error!";
						}
						if (status >= 0 && status < 30){
							return "In Queue";
						}
						if (status >= 30 && status < 42){
							return "Preparing Data...";
						}
						if (status >= 42 && status < 50){
							return "Generating...";
						}
						if (status == 70){
							return "Expired";
						}
						return "Ready"
					}
				},{
					"title": "Error:",
					"bound": ["error_reason"],
					"dataType": "string",
					"showAtStatus": [-50, -1],
					"forceWrap": true
				},{
					"title": "File Name:",
					"bound": ["filename"],
					"dataType": "string"
				},{
					"title": "Report Type:",
					"value": title,
					"dataType": "string"
				},{
					"title": "Source:",
					"dataType": function(report){
						if(report.source_id){
							var universe = Moonshadow.getManager().getUniverseControl().getChildById(report.source_id);
							if(universe && universe.ext_name)
								return universe.ext_name; 
						}
					},
				},{
					"title": "Column Set:",
					"bound": ["report_layout"],
					"dataType": "string"
				},{
					"title": "Compression:",
					"bound": ["compression"],
					"dataType": "string"
				},
				{
					"title": "xBase Output:",
					"bound": ["xbase_compatible"],
					"dataType": "boolean"
				},
				{
					"title": "Reports Queued Ahead of This:",
					"bound": ["place_in_queue"],
					"dataType": function(report){
						var placeInQueue = report.place_in_queue;
						var numAhead = placeInQueue - 1;
						if(numAhead < 0)
							numAhead = 0;
						return numAhead;
					},
					"hideAtStatus": 30
				},{
					"title": "Percent of Records Processed:",
					"bound": ["records_processed", "num_records"],
					"calcType": "percent",
					"dataType": "int",
					"hideAtStatus": 50
				},{
					"title": "Date Created:",
					"bound": ["date_created"],
					"dataType": "date"
				}
			]
		},
		"nationbuilder": function(title){
			return [{
				"title": "Report Status:",
				"bound": ["status"],
				"dataType": function(report){
					status = report.status;
					if (status < 0){
						return "Error!";
					}
					if (status >= 0 && status <= 10){
						return "In Queue...";
					}
					if (status > 11  && status <= 20){
						return "Processing...";
					}
					if (status > 21 && status <= 30){
						return "Getting Server...";
					}
					if (status > 31 && status <= 35){
						return "Getting CSV...";
					}
					if (status > 36 && status <= 40){
						return "Creating Batch...";
					}
					if (status > 41 && status <= 42){
						return "Authenticating...";
					}
					if (status > 43 && status <= 44){
						return "Sending Voters...";
					}
					if (status > 45 && status <= 46){
						return "Sending History...";
					}
					return "Done"
				}
			},{
				"title": "Error:",
				"bound": ["error_reason"],
				"dataType": "string",
				"showAtStatus": [-50, -1],
				"forceWrap": true
			},{
				"title": "Report Type:",
				"value": title,
				"dataType": "string"
			},{
				"title": "Source:",
				"dataType": function(report){
					if(report.source_id){
						var universe = Moonshadow.getManager().getUniverseControl().getChildById(report.source_id);
						if(universe && universe.ext_name)
							return universe.ext_name; 
					}
				},
			},{
				"title": "Reports Queued Ahead of This:",
				"bound": ["place_in_queue"],
				"dataType": function(report){
					var placeInQueue = report.place_in_queue;
					var numAhead = placeInQueue - 1;
					if(numAhead < 0)
						numAhead = 0;
					return numAhead;
				},
				"hideAtStatus": 30
			},{
				"title": "Percent of Records Processed:",
				"bound": ["records_processed", "num_records"],
				"dataType": function(report){
					var percentDone = parseInt(((report.records_processed / report.num_records) * 100 / 2), 10);
					if(report.status == 46){
						percentDone += 50;
					}
					return percentDone + "%";
				},
				"hideAtStatus": 60
			},{
				"title": "Date Created:",
				"bound": ["date_created"],
				"dataType": "date"
			}];
		}
	},
	"reportTypesInfo": [{
			"type":"CSV",			//short name for type display
			"typeId": "csv",		//id for type (for use in identifying type and display icon). Unique
			"title": "CSV Export",	//long name for type display
			"column_set":"fields",	//default feild set,
			"report_type":"simple",	//default report type, because report_type, column_set, and typeId are the same same but different
			"valid_types": ["simple", "enhanced", "id_only"], //this here for puting downloads in the right spot
			"compression":"zip",	//default compression option
			"xbase_compatible": false, //xbase output (this disables comression)
			"sort_order":"oddeven",	//default sort order
			"format":"csv",			//default format
			"order":0,				//order in which the types buttons appear in a universe
			"enabled": true,		//if the option is clickable or "gray". Enabled by default
			"disabledReason": "", //if disabled, the reason it's disabled (if determined)
			"included": true,		//if set to false, this option won't show at all
			"hoverDisplay": "standard", //what details to display when the report ui is hovered over
			"isAvailableUnpurchased": function(universe){
				return !!universe.getExportOptions("id_only");
			}, 
			"hasSpecialOptConditions": function(universe, optionControl){
				if(!!universe.getExportOptions("id_only") && !universe.isFullyPurchased() && optionControl && $(optionControl).get(0).name == "column_set"){
					$(optionControl).children().attr({
						"disabled": true
					});
					$("option[value='id_only']", optionControl).attr({
						"disabled": false,
						"selected": true
					});
				}
			},
			"hasSpecialTabConditions": function(universe, tabInfo){
				if(!!universe.getExportOptions("id_only") && !universe.isFullyPurchased()){
					if(tabInfo.id == "surveys"){
						tabInfo.disabled = true;
					}
				}
			},
			"bypassRestrictions": function(universe, gatheredOpts){
				if(gatheredOpts.report_type == "id_only"){
					gatheredOpts.num_records = universe.cardinality;
					return true;
				}
			},
			"uiOpts": [{
					"id": "column_set",
					"options":["fields","enhanced", "id_only"], //all valid field sets for this type, settable by users
					"names":["Simple", "Enhanced", "L2 ID File"]	 //the names that correlate to the options respectively
				},{
					"id": "compression",
					"options":["zip", "none"] 		//all valid compression types for this type
				},{
					"id": "xbase_compatible"
				},{
					"id": "sort_order",
					"options":["oddeven"] 			//all valid sort options (one option means it will be displayed, not choosable)
				},{
					"id": "format",
					"options":["csv"] 				//all valid formats
				},{
					"id": "report_type"
				},{
					"id": "typeId"
				}
			],
			"tabs": ["options", "generate", "download"],	//all tabs that will show when type is built
		},{
			"type":"Phone",
			"typeId": "phone",
			"title": "Phone List Export",
			"column_set":"walking_phone",
			"report_type":"phone",
			"valid_types": ["phone"],
			"compression":"zip",
			"sort_order":"oddeven",
			"format":"pdf",
			"order":1,
			"enabled": true,
			"disabledReason": "",
			"included": true,
			"hoverDisplay": "standard",
			"uiOpts": [{
					"id": "column_set",
					"options":["walking_phone"],
					"names":["Walking"]
				},{
					"id": "compression",
					"options":["zip", "none"]
				},{
					"id": "sort_order",
					"options":["zigzag"]
				},{
					"id": "format",
					"options":["pdf"]
				},{
					"id": "report_type"
				},{
					"id": "barcode",
				},{
					"id": "typeId"
				}
			],
			"tabs": ["options", "generate", "download"]
		},{
			"type":"Walking",
			"typeId": "walking",
			"title": "Walking List Export",
			"column_set":"walking_phone",
			"report_type":"walking",
			"valid_types": ["walking", "survey"],
			"compression":"zip",
			"sort_order":"oddeven",
			"format":"pdf",
			"order":2,
			"enabled": true,
			"disabledReason": "",
			"included": true,
			"hoverDisplay": "standard",
			"uiOpts": [{
					"id": "column_set",
					"options":["walking_phone"],
					"names":["Phone"]
				},{
					"id": "compression",
					"options":["zip", "none"]
				},{
					"id": "sort_order",
					"options":["zigzag", "oddeven"]
				},{
					"id": "format",
					"options":["pdf"]
				},{
					"id": "report_type"
				},{
					"id": "barcode",
				},{
					"id": "typeId"
				}
			],
			"tabs": ["options", "generate", "download"]
		},
		{
			"type":"Mailing",
			"typeId": "mailing",
			"title": "Mailing List Export",
			"column_set":"mailing",
			"report_type":"mailing",
			"valid_types": ["mailing"],
			"compression":"zip",
			"xbase_compatible": false,
			"sort_order":"oddeven",
			"format":"csv",
			"order":3,
			"enabled": true,
			"disabledReason": "",
			"included": true,
			"hoverDisplay": "standard",
			"uiOpts": [{
				"id": "column_set",
				"options":["mailing"],
				"names":["Mailing"]
			},{
				"id": "compression",
				"options":["zip", "none"]
			},{
				"id": "xbase_compatible"
			},{
				"id": "sort_order",
				"options":["zigzag"]
			},{
				"id": "format",
				"options":["csv"]
			},{
				"id": "report_type"
			},{
				"id": "typeId"
			}],
			"tabs": ["options", "generate", "download"]
		},{
			"type":"Telemarketing",
			"typeId": "household",
			"title": "Telemarketing Export",
			"column_set":"household",
			"report_type":"household",
			"valid_types": ["household"],
			"compression":"zip",
			"xbase_compatible": false,
			"sort_order":"oddeven",
			"format":"csv",
			"order":4,
			"enabled": true,
			"disabledReason": "",
			"included": true,
			"hoverDisplay": "standard",
			"uiOpts": [{
					"id": "column_set",
					"options":["household"],
					"names": ["Telemarketing"]
				},{
					"id": "compression",
					"options":["zip"]
				},{
					"id": "xbase_compatible"
				},{
					"id": "format",
					"options":["csv"]
				},{
					"id": "report_type"
				},{
					"id": "typeId"
				}
			],
			"tabs": ["options", "generate", "download"],	//all tabs that will show when type is built
		},{
			"type":"NationBuilder",
			"typeId": "nationbuilder_export",
			"title": "NationBuilder Export",
			"column_set": "nationbuilder", // not used, see sendNBReport func
			"report_type":"nationbuilder_export",
			"valid_types": ["nationbuilder_export"],
			"compression":"zip",
			"sort_order":"",
			"format":"",
			"order":5,
			"enabled": true,
			"disabledReason": "",
			"included": false,
			"hoverDisplay": "nationbuilder",
			"uiOpts": [],
			"tabs": ["nbauth", "generatenb", "nbstatus"]
		}
	],
	"reportSubTabs": [
		{
			"id": "options",
			"title": "Options",
			"description": "Options for %typeName%",
			"active": true,
			"disabled": false,
			"parent": null,
			"nextButton": {
				"title": "Next >",
				"action": "activateTab"
			},
			"ui": {
				"tab": null,
				"content": null
			}
		},{
			"id": "surveys",
			"title": "Surveys",
			"description": "Export Survey Data with %typeName%",
			"active": false,
			"disabled": false,
			"parent": null,
			"nextButton": {
				"title": "Next >",
				"action": "validateSurveyOptions"
			},
			"ui": {
				"tab": null,
				"content": null
			}
		},{
			"id": "generate",
			"title": "Generate",
			"description": "File Generation Info for %typeName%",
			"active": false,
			"registered": false,
			"disabled": false,
			"parent": null,
			"nextButton": {
				"title": "Generate Report",
				"action": "startExportGeneration"
			},
			"onload": function(universe, tabInfo){
				if(tabInfo.disabled)
					return false;
				universe.buildEstimates(universe, tabInfo, [{
					"value": Moonshadow.helpers.numberCommas(universe.numberOfRecords()),
					"title": "Number of Purchased Records:",
					"dataType": "int"
				},{
					"title": "Number of Reports Pending:",
					"bound": ["num_pending"],
					"dataType": "int"
				},{
					"title": "Estimated Wait Time:",
					"bound": ["wait_time"],
					"dataType": "time"
				},{
					"title": "Estimated Generation Time:",
					"bound": ["generate_time"],
					"dataType": "time"
				},{
					"title": "Total Estimated Time:",
					"bound": ["wait_time", "generate_time"],
					"calcType": "sum",
					"dataType": "time"
				}]);
			},
			"onunload": function(universe, tabInfo){
				universe.unRegisterEstimate();
			},
			"ui": {
				"tab": null,
				"content": null
			}
		},{
			"id": "generatenb",
			"title": "Export",
			"description": "File Generation Info for NationBuilder Export",
			"active": false,
			"disabled": false,
			"parent": null,
			"nextButton": {
				"title": "Send Report",
				"action": "sendNBReport"
			},
			"onload": function(universe, tabInfo){
				if(tabInfo.disabled)
					return false;
				universe.buildEstimates(universe, tabInfo, [{
					"value": Moonshadow.helpers.numberCommas(universe.numberOfRecords()),
					"title": "Number of Purchased Records:",
					"dataType": "int"
				},{
					"title": "Number of Reports Pending:",
					"bound": ["num_pending"],
					"dataType": "int"
				},{
					"title": "Estimated Wait Time:",
					"bound": ["wait_time"],
					"dataType": "time"
				},{
					"title": "Estimated Generation Time:",
					"bound": ["generate_time"],
					"dataType": "time"
				},{
					"title": "Total Estimated Time:",
					"bound": ["wait_time", "generate_time"],
					"calcType": "sum",
					"dataType": "time"
				}]);
			},
			"ui": {
				"tab": null,
				"content": null
			}
		},{
			"id": "download",
			"title": "Download",
			"description": "Download %typeName%",
			"active": false,
			"disabled": false,
			"parent": null,			
			"onload": function(universe, tabInfo){
				if(tabInfo.disabled)
					return false;
				universe.buildExports(universe,	tabInfo);
			},
			"ui": {
				"tab": null,
				"content": null
			}
		},
		{
			"id": "nbauth",
			"title": "Account",
			"description": "NationBuilder Account Info",
			"active": true,
			"disabled": false,
			"parent": null,
			"nextButton": {
				"title": "Next >",
				"className": "nb_account_next_button",
				"action": "activateTab"
			},
			"onload": function(universe, tabInfo){
				var hasNBOAuthCreds = universe.getControl().getManager().hasOAuth('nationbuilder');
				for(var i = 0, l = tabInfo.parent.tabs.length; i < l; ++i){
					if(tabInfo.parent.tabs[i].id != "nbauth"){
						universe.disableTab(!hasNBOAuthCreds, tabInfo.parent.tabs[i]);
					}
				}
				universe.nationBuilderAccount(tabInfo, hasNBOAuthCreds);
			},
			"ui": {
				"tab": null,
				"content": null
			}
		},
		{
			"id": "nbstatus",
			"title": "Status",
			"description": "Export Status for NationBuilder",
			"active": false,
			"disabled": false,
			"parent": null,
			"onload": function(universe, tabInfo){
				if(tabInfo.disabled)
					return false;
				universe.buildExports(universe, tabInfo);
			},
			"ui": {
				"tab": null,
				"content": null
			}
		}
	],
	"uiOpts": [{
			"id": "column_set",
			"title": "Column Set",
			"description": "",
			"tabLocation": "options",
			"inputType": "select",
			"reportsDirty": true,
			"gatherable": true,
			"uiElem": null,
			"options": function(uiOpt, universe, callback){
				if(uiOpt){
					this.columnSets = uiOpt.options || null;
					this.columnNames = uiOpt.names || null;
				}
				if(universe){
					var datasource = universe
						.getControl()
						.getManager()
						.getDatasource(universe.datasource);
					var availableFieldSets = datasource["export"];
					var options = [];

					for(var i = 0, l = this.columnSets.length; i < l; ++i){
						if(availableFieldSets[this.columnSets[i]]){
							var self = this;
							var name = this.columnNames[i];
							if(name){
								options.push({
									"name": name,
									"val": this.columnSets[i]
								});
							}
						}
					}
					callback(options);
				}
			},
			"onAction": {
				"change": function(e){
					var u = e.data.universe;
					var csvtype = u.getReportTypeObject("csv");
					if(csvtype && csvtype.getTabItem){
						var tabItem = csvtype.getTabItem("surveys");
						if(tabItem){
							if(this.value == "id_only"){
								$("input[name='surveys']", tabItem.ui.content)
									.attr({
										"checked": false
									})
									.trigger("change")
								return tabItem.ui.toggleDisableTab(false);
							}
							tabItem.ui.toggleDisableTab(true);
						}
					}
				}
			}
		},{
			"id": "compression",
			"title": "Compression",
			"description": "",
			"tabLocation": "options",
			"inputType": "select",
			"reportsDirty": true,
			"gatherable": true,
			"uiElem": null,
			"options": [
				{
					"name": "GZipped",
					"val": "gzip"
				},
				{
					"name": "Zipped",
					"val": "zip"
				},
				{
					"name": "None",
					"val": "none"
				}
			]
		},{
			"id": "xbase_compatible",
			"title": "xBase Output",
			"description": "",
			"tabLocation": "options",
			"inputType": "checkbox",
			"gatherable": true,
			"uiElem": null,
			"reportsDirty": true,
			"onAction": {
				"change": function(){
					var compression = $(this)
						.closest(".sub_holder")
						.find("select[name='compression']");
					
					if(this.checked){
						$(compression)
							.val("zip")
							.attr({"disabled": true})
					}else{
						$(compression)
							.attr({"disabled": false})
					}
				}
			}
		},{
			"id": "sort_order",
			"title": "Sort Order",
			"description": "",
			"tabLocation": "options",
			"inputType": "select",
			"reportsDirty": true,
			"gatherable": true,
			"uiElem": null,
			"options": [
				{
					"name": "Zig-Zag",
					"val": "zigzag"
				},
				{
					"name": "Odd-Even",
					"val": "oddeven"
				}
			]
		},{
			"id": "report_type",
			"tabLocation": "options",
			"gatherable": true,
			"uiElem": null
		},{
			"id": "typeId",
			"tabLocation": "options",
			"gatherable": true,
			"uiElem": null
		},{
			"id": "format",
			"title": "Format",
			"description": "",
			"tabLocation": "options",
			"inputType": "select",
			"reportsDirty": true,
			"gatherable": true,
			"uiElem": null,
			"options": [
				{
					"name": "CSV",
					"val": "csv"
				},
				{
					"name": "PDF",
					"val": "pdf"
				},
				{	
					"name": "RTF",
					"val": "rtf"
				}
			]
		},{
			"id": "barcode",
			"title": "Barcode",
			"description": "",
			"tabLocation": "options",
			"inputType": "checkbox",
			"gatherable": true,
			"uiElem": null,
			"reportsDirty": true,
		},{
			"id": "surveys",
			"title": "Include Surveys",
			"description": "",
			"tabLocation": "surveys",
			"inputType": "checkbox",
			"reportsDirty": true,
			"gatherable": true,
			"uiElem": null,
			"options": function(uiOpt, universe, callback){
				if(universe){
					//check if there are any surveys created
					var surveysControl = Moonshadow.getManager().getControl("surveys");
					if(!surveysControl.surveys.length){
						callback([{
							"val": "No surveys created"
						}], "label")
					}else{
						callback();
					}
				}
			},
			"onAction": {
				"change":"enableSurveys"
			}
		},{
			"id": "allsurveys",
			"title": "All Surveys",
			"description": "",
			"tabLocation": "surveys",
			"className": "all_surveys report_option hide",
			"inputType": "checkbox",
			"reportsDirty": true,
			"checked": true,
			"uiElem": null,
			"onAction": {
				"change": "includeAllSurveys"
			}
		},{
			"id": "surveynames",
			"title": "Include Surveys",
			"description": "",
			"tabLocation": "surveys",
			"inputType": "select",
			"reportsDirty": true,
			"disabled": true,
			"uiElem": null,
			"limit": null,
			"options": function(uiOpt, universe, callback){
				if(!universe){
					return;
				}
				var manager = Moonshadow.getManager();
				var surveyTypes = [];
				if(manager.hasAddon("groundgame")){
					surveyTypes.push("groundgame");
				}
				if(manager.hasAddon("phonecampaigns")){
					surveyTypes.push("phonecampaigns");
				}
				if(manager.hasAddon("fbpolls")){
					surveyTypes.push("facebookpoll");
				}
				
				var parent = universe.getParent();
				var surveyControl = parent.getSurveyControl();
				surveyControl.getSurveysOfTypes(true, surveyTypes, function(surveys){
					var returnSurveys = $(surveys).map(function(key, survey){
						return {
							"name": survey.ext_name,
							"val": survey.int_name
						}
					}).toArray();
					returnSurveys.unshift({
						"name": "Choose Survey"
					});
					callback(returnSurveys);
				});
			},
			"className": "all_surveys survey_names report_option hide",
			"onAction": {
				"change": "addSurveyItem"
			}
		}
	]
};

Moonshadow.helpers.extend(reporttypes, MControl);
var UIPanTo = (function() {
	var _uiDiv;
	var _pan = function(datasource, selection) { // Perform pan
		Moonshadow.selection.getBounds(datasource, selection, function(error, result) {
			if(error) {
				throw error;
			}

			Moonshadow.getManager().getAdapter().fitBounds(_scrubDupes(result));
		});
	};

	var _scrubDupes = function(points){
		var xs = {}, ys = {};
		
		var scrub = function(fl){
			var str = fl.toString();
			var last = str[str.length - 1];
			++last;
			return parseFloat(str.substring(0, str.length -1) + last);
		}
		
		for (var i = 0, l = points.length; i < l; i++) {
			var xy = points[i];
			var x = xy[0];
			var y = xy[1];
			if(xs[x]){
				x = scrub(x);
			}
			xs[x] = true;
			if(ys[y]){
				y = scrub(y);
			}
			ys[y] = true;
			points[i][0] = x;
			points[i][1] = y;
		}
		
		return points;
	};
	
	var _buildUI = function(ds, selection, name) {
		if(!_uiDiv) {
			_uiDiv = document.createElement("div");
			_uiDiv.className = "pan-to sprite-zoomCenter toggle clickable";
		}

		var div = _uiDiv.cloneNode(false);
		div.title = "Zoom to " + name;
		$(div).click({"ds":ds,"selection":selection},function(event) {
			var selection = event.data.selection;
			if(typeof event.data.selection == "function"){
				selection = event.data.selection();
			}
			_pan(event.data.ds, selection);
		});

		return div;
	}

	var panTo = function(filterable, datasource, ext_name, selection) {
		this.parent = filterable || null;
		this.datasource = datasource || null;
		this.ext_name = ext_name || null;
		this.selection = selection || null;
	}

	panTo.prototype = {
		getUI: function(){

			if(!this.container) {
				this.container = _buildUI(this.getDs(), this.getSelection(), this.getName());
			}

			return this.container;
		},
		panTo: function() {
			_pan(this.getDs(), this.getSelection());
		},
		getDs: function(){
			return this.datasource || this.parent.datasource || this.parent.getDatasource().int_name;
		},
		getName: function(){
			return this.ext_name || this.parent.parent.ext_name+": "+this.parent.ext_name;
		},
		getSelection: function() {
			if(this.selection){
				return this.selection;
			}
			var selection = {
				'value': 1
			};
			var parent = this.parent;

			while(parent && !(parent instanceof MDatasource)) {
				if(!(parent instanceof MFilterableGroup)) {
					var container = {'values': {}};
					container.values[parent.int_name] = selection;
					selection = container;
				}					

				parent = (parent.parent) ? parent.parent : null;
			}	

			return selection.values || null;
		}
	};

	return panTo;
}());
/**	
 *
 * @method nationbuilderui
 * @extends MControl
 * @constructor
 * @param {} options
 */
function nationbuilderui(options) {
	this.name = "nationbuilderui";
	this.options = options || {};
}

nationbuilderui.prototype = {
	"init": function(manager) {
		this.manager = manager;
	},
	"hasOauthCreds": function(){
		return this.manager.hasOAuth('nationbuilder');
	},
	"getStarted": function(animate, slug, cid, csecret){
		var ce = Moonshadow.helpers.ce;
		
		var openingText = "<b>Please use the following steps to set up a connection between VoterMapping and NationBuilder.</b>";
		
		if(this.hasOauthCreds){
			openingText = "<b>NationBuilder credentials already exist for this account.</b> ";
			openingText += "Continue with the following steps to reconfigure your account settings. <br>";
		}
		
		openingText += "<p class='center'><b>Please note:</b> The Nationbuilder \"auto-districting\" feature must be disabled if you'd like " +
				" your VoterMapping fields imported into Nationbuilder. Read about this feature here: " +
				"<a target='_blank' href='http://nationbuilder.com/how_does_auto_districting_work'>http://nationbuilder.com/how_does_auto_districting_work</a></p>";
		
		var pointData = [
			"First, create a NationBuilder account, if you haven't already, and log into it.",
			$(ce("a"))
				.addClass("nationbuilder_link")
				.attr({
					"href": "http://nationbuilder.com",
					"target": "_blank"
				})
				.append("http://nationbuilder.com"),
			"Once logged in, look at the page URL and find the name used in front of \".nationbuilder.com\". " +
				"(i.e., &lt;<b>yourcampaign</b>&gt;.nationbuilder.com). Provide that name in the text field below:",
			$(ce("div"))
				.addClass("nationbuilder_text_content")
				.append(
					$(ce("label"))
						.addClass("nationbuilder_text_label")
						.append("NationBuilder Slug"),
					$(ce("input"))
						.addClass("nationbuilder_text_field required")
						.attr({
							"name": "slug",
							"type": "text",
							"value": slug
						})
				),
			"Go to <b>\"Settings\"</b> and click <b>\"Developer\"</b>. Click <b>\"Register app\"</b>.<br>" + 
				"<i>NOTE: If \"Developer\" is not an option, please email <a href='mailto:api@nationbuilder.com'>api@nationbuilder.com</a>, " + 
				"and tell NationBuilder that you are using the \"L2 API\" and require developer access. Once they assign that access, " + 
				"you will be able to proceed with linking your accounts.</i></li>",
			"Provide a name for the app (suggestion: \"VoterMapping\"). ",
			"Use the following URL for the field entitled <b>\"OAuth Callback URL\"</b>. " +
				"You can right click the highlighted text below, click \"Copy\", then paste the text into " +
				"field on the NationBuilder site:",
			$(ce("input"))
				.addClass("nationbuilder_url")
				.attr({
					"value": this.getNBURL(),
					"readonly": true
				})
				.click(function(){
					this.select();
				}),
			"Click <b>\"Register\"</b>. You will then be provided with a <b>\"OAuth client ID\"</b> " +
				"and a <b>\"OAuth client secret\"</b>. Provide them in the fields below:",
			$(ce("div"))
				.addClass("nationbuilder_text_content")
				.append(
					$(ce("label"))
						.addClass("nationbuilder_text_label")
						.append("Client ID"),
					$(ce("input"))
						.addClass("nationbuilder_text_field required")
						.attr({
							"name": "clientId",
							"type": "text",
							"value": cid
						})
				),
			$(ce("div"))
				.addClass("nationbuilder_text_content")
				.append(
					$(ce("label"))
						.addClass("nationbuilder_text_label")
						.append("Client Secret"),
					$(ce("input"))
						.addClass("nationbuilder_text_field required")
						.attr({
							"name": "clientSecret",
							"type": "text",
							"value": csecret
						})
				),
			"Click \"Next\" to continue to the app authorization step."
		];
		
		this.container = $(ce("div"))
			.append(
				openingText,
				$(ce("ol"))
					.append(
						$(pointData).map(function(key, value){
							if(typeof value == "string")
								return $(ce("li"))
									.append(value)
									.get(0);
							return value
								.get(0);
						})
					),
				$(ce("input"))
					.addClass("nationbuilder_submit nationbuilder_button")
					.attr({
						"type": "button",
						"value": "Next"
					})
					.click({"self": this}, function(e){
						if(e.data.self.validateInfo()){
							e.data.self.submitNBInfo();
						}
					}),
				$(ce("span"))
					.addClass("nationbuilder_error_alert")
			)
			.get(0);
		
		var _modalWindow = new MUILayoverPanel({
			"id": "nationbuilderui_panel",
			"content": this.container,
			"title": "NationBuilder Account Setup",
			"onOpen": function(){
				$(".nationbuilder_url", this.container).focus().select();
			},
			"animate": {
				"onOpen": animate,
				"onClose": true
			}
		});
		_modalWindow.open();

	},
	"validateInfo": function(){
		$(".nationbuilder_error_alert", this.container)
			.empty();
		if($(".required", this.container)
			.removeClass("require_error")
			.each(function(key, item){
				if(!$(item).val()){
					$(item).addClass("require_error");
				}
			})
			.hasClass("require_error")){
				$(".nationbuilder_error_alert", this.container)
					.append("Please provide all required information.");
				return false;
		}
		return true;
	},
	"submitNBInfo": function(){
		var info = {
			"provider": "nationbuilder",
			"providerId": $("input[name='slug']", this.container).val(),
			"consumerKey": $("input[name='clientId']", this.container).val(),
			"consumerSecret": $("input[name='clientSecret']", this.container).val(),
			"domain": window.location.host,
			"user": Moonshadow.user,
			"key": Moonshadow.key
		};
		
		var self = this;
		MUILayoverPanel.get("nationbuilderui_panel").loadIndicator(true);
		
		new Moonshadow.Ajax({
			"url": Moonshadow.getDataUrl() + "oauth/init",
			"payload": info,
			"execute": true,
			"onFail": function(resp){
				MUILayoverPanel.get("nationbuilderui_panel").loadIndicator(false);
				if(resp.status == 404 || resp.status == 403){
					$(".nationbuilder_text_field[name='slug']", self.container)
						.addClass("require_error");
					$(".nationbuilder_error_alert", this.container)
						.append("The NationBuilder slug does not appear to be correct.");
				}
			},
			"onSuccess": function(resp){
				MUILayoverPanel.get("nationbuilderui_panel").loadIndicator(false);
				if(resp && resp.result == "ok"){
					self.openNBIFrame(info, resp.uri);
				}
			}
		});
	},
	"getNBURL": function(){
        return [
            function(){
            	return window.location.origin || 
        			window.location.protocol + "//" + 
        			window.location.hostname + 
        			(window.location.port ? ':' + 
        					window.location.port: '');
        	}(),
            "api/v1/oauth/callback/nb",
            Moonshadow.customer,
            Moonshadow.app]
        .join("/");
	},
	"openNBIFrame": function(info, url){
		MUILayoverPanel.get("nationbuilderui_panel").animate = {
			"onOpen": false,
			"onClose": false
		}
		MUILayoverPanel.close("nationbuilderui_panel");
		
		var ce = Moonshadow.helpers.ce;
		var self = this;
		var onClose = function(callback){
			new Moonshadow.Ajax({
				"url": Moonshadow.getDataUrl() + "oauth/nationbuilder",
				"type": "GET",
				"execute": true,
				"addCreds": true,
				"onSuccess": function(resp){
					if(resp && resp.result == "ok" && resp.valid){
						self.getManager().addOAuth('nationbuilder');
					}
					self.getManager().mapObservers.notify('nationbuilder_access');
					callback();
				}
			});
		};
		
		var iframeContent = $(ce("div"))
			.append(
				$(ce("input"))
					.addClass("nationbuilder_submit nationbuilder_button")
					.attr({
						"type": "button",
						"value": "Close"
					})
					.click(function(e){
						onClose(function(){
							MUILayoverPanel.close("nationbuilderui_iframe_panel");
						});
					}),
				$(ce("input"))
					.addClass("nationbuilder_back nationbuilder_button")
					.attr({
						"type": "button",
						"value": "Back"
					})
					.click({"self": self, "info": info}, function(e){
						MUILayoverPanel.get("nationbuilderui_iframe_panel").animate = {
							"onOpen": false,
							"onClose": false
						}
						MUILayoverPanel.close("nationbuilderui_iframe_panel");
						e.data.self.getStarted(
							false,
							e.data.info.providerId,
							e.data.info.consumerKey,
							e.data.info.consumerSecret
						);
					}),
				$(ce("iframe"))
					.addClass("nationbuilder_iframe")
					.attr({
						"src": url,
						"seamless": true,
						"name": "nationbuilder_iframe"
					})
			).get(0);
	
		var _iframeWindow = new MUILayoverPanel({
			"id": "nationbuilderui_iframe_panel",
			"content": iframeContent,
			"title": "NationBuilder Account Setup", 
			"onClose": onClose,
			"context": this,
			"fixed": false,
			"animate": {
				"onOpen": false,
				"onClose": true
			}
		});
		_iframeWindow.open();

	}
};

Moonshadow.helpers.extend(nationbuilderui, MControl);
/**
 * Datasource
 * @class MDatasource
 * @constructor
 * @param {Object} branch Tree of fields in the datasource
 * @param {MPanelContentFilterV3} parent Instance of MPanelContentFiltersV3 that
 *  holds this datasources
 */
function MDatasource(branch,parent) {
	if(typeof branch.dsIndex == "undefined") throw "Datasource missing dsIndex";

	this.int_name = branch.int_name;
	this.ext_name = branch.ext_name || this.int_name;

	this.isDS = true;
	this.dsIndex = branch.dsIndex;

	this.parent = parent;
	this.struct = branch.struct || [];

	this.filters = {};
	this.filters.values = branch.filters || {};

	this.dataPath = [];
	this.treePath = [];

	this.filterables = {};
	this.children = this.filterables;

	this.filterListeners = 0;

	this.selectedSSRow = null;
	
	this.hasFilters = this.countFilters([], this.struct);

	this.container;
	this.childContainer;

	this.ui = {};
	
	this.openBranches = {};

	this.purchUniv = null;
	this.unpurchUniv = null;

	this.openSS = null;

	this.currentTotal;

	this.requiredAddons = [];
	this.viewOnly = branch.viewOnly || false;
	this.hideBuy = branch.hideBuy || false;
	this.hidden = branch.hidden || false;
	
	this.sensitivityWarnings = this.getSensitivityWarnings(this.int_name);

	var defaultSort = {
		"column": "label",
		"sortOrder": 1
	};
	
	if(branch.defaultSort){
		if(typeof branch.defaultSort == "string"){
			defaultSort.column = branch.defaultSort;
		}else if(typeof branch.defaultSort == "object"){
			defaultSort = branch.defaultSort;
		}
	}
		
	this.defaultSort = defaultSort;

	var firstSelector;
	var caller = this;
	$.each(this.struct,function(k,v) {
		if(v.dtype == "string" || typeof v != "object") {
			return;
		}

		if(!firstSelector && v.dtype == "selector") {
			firstSelector = v;
			firstSelector.filterDocs = true;
		}

		try {
			if(typeof caller.filterables[v.int_name] == "undefined") {
				v.sensitivityWarnings = caller.getSensitivityWarnings(v.int_name);
				caller.filterables[v.int_name] = parent.getFilterable(v,caller);
			} else {
				throw("Duplicate filter id: "+v.int_name);
			}
		} catch (e) {
			if(typeof console != "undefined") {
				console.log("DS Struct: ",v.int_name,e);
			}
		}
	});

	
	this.show();
}
MDatasource.prototype = {
	buildUI: function() {
		var ce = this.getControl().ce;
		var control = this.getControl();
		var manager = control.getManager();
		var self = this;

		if(this.int_name == "__search") {
			var searchoptions = manager.getOption("search.options");
			if(!searchoptions){
				return false;
			}
		}

		var container = document.createElement("div");
		container.className = "datasource";
		container.id = this.int_name + "_datasource";

		var countsControl = control.getManager().getControl('countsmodel');
		var mode = countsControl.getCountsMode(this.int_name)
		if (mode) {
			if (mode === 'row') {
				container.className += " mode-row";
			} else if (mode === 'total') {
				container.className += " mode-total";
			}
		}

		var datasourcesControl = control.getManager().getControl('datasources');
		if (!datasourcesControl.hasReqAddons(this.int_name)) {
			this.viewOnly = true;
		}
		
		if (this.viewOnly) {
			$(container).addClass('view-only');
		}

		// Check for filterables
		var count = 0;
		for (k in this.filterables) {
			if (this.filterables.hasOwnProperty(k)) {
				count++;
			}
		}

		// If no filterables then hide the datasource
		if(count == 0 && this.int_name != "__divider" && this.int_name != "__clearselections") { 
			container.style.display = "none";
		} 

		var clear = document.createElement("div");
		clear.className = "clear";

		var header = document.createElement("div");
		header.className = "header";

		if(this.dsIndex >= 0) {
			header.style.border = "0px";
		}

		var handle = document.createElement("div");
		handle.className = "handle clickable";

		// If this is the current DS then make it selected
		if(control.getManager().getDatasource().int_name == this.int_name) {
			handle.className += " selected";
		}

		handle.filter = this;
		handle.control = this.control;
		$(handle).click({"self": this}, function(e) { 
			e.data.self.toggle(); 
			manager.mapObservers.notify('filterabletoggle', e.data.self);
		});

		if(count > 0) {
			var expander = document.createElement("div");
			expander.className = "expander expanded";
			this.expander = expander;
			handle.appendChild(expander);
		}

		this.placeDocumentationIcons(header);

		if(this.viewOnly && !this.hideBuy) {
			header.appendChild(this.getBuyButton(this.ext_name));
		}
		
		var label = document.createElement("div");
		label.className = "label";
		label.appendChild(document.createTextNode(this.ext_name));
		handle.appendChild(label);
			
		if (this.dsIndex >= 0) {
			var utilitiesHolder = document.createElement('div');
			utilitiesHolder.className = "utility";

			//open spreadsheet button
			var ssControl = control.getManager().getSpreadsheetControl();
			this.openSS = ssControl.getSSOpener(this.int_name);

			utilitiesHolder.appendChild(this.openSS);
				
			//collapse branches button
			var ce = control.ce;
			var collapseBranches = $(ce("div"))
				.addClass("collapse_branches sprite-collapse_all clickable")
				.attr({
					"title": "Collapse All Branches"
				})
				.click({"self": this}, function(e){
					e.data.self.collapseOpenBranches();
				})
				.get(0);
			
			utilitiesHolder.appendChild(collapseBranches);
			
			//counts mode button
			var countsModeAllowed = manager.getOption('count_mode', true);
			if (countsModeAllowed) {
				var countsMode = document.createElement("div");
				countsMode.className = "counts-mode clickable";
				countsMode.title = "Change counts mode";
	
				$(countsMode).click($.proxy(function() {
					this.changeCountsMode();
				}, this));
			
				utilitiesHolder.appendChild(countsMode);

				manager.addMapObserver('countsmodechange', this.onCountsModeChange, this);
			}
			
			
			var filterControl = manager.getControl('filterscontrol');
			zoomToFiltersControl = new UIPanTo(this, this.int_name, "Selected", function(){
				var filterControl = manager.getControl('filterscontrol');
				return filterControl.filtersToJSON(self.int_name);
			});
			var zoomToFilters = zoomToFiltersControl.getUI();
			$(zoomToFilters)
				.removeClass("pan-to toggle")
				.addClass("zoom_to_selected")
			utilitiesHolder.appendChild(zoomToFilters);

			header.appendChild(utilitiesHolder);

			this.makeSectionClearer($(".utility", header), this.onClearFilters);
			this.checkFilterCount();
		}

		if(this.int_name == "__universes") {
			this.makeSectionClearer(header, this.onClearUniverseFilters);
			control.getManager().addMapObserver(
				['checkUniverseFilterCount', 'filtersloaded'],
				this.checkUniverseFilterCount,
				this
			);
		}
		
		if(this.int_name == "__divider") {
			this.makeSectionClearer(header, this.onClearDatasourceFilters);
			control.getManager().addMapObserver(
				['checkDatasourceFilterCount', 'filtersloaded'],
				this.checkDatasourceFilterCount, 
				this
			);
		}
		
		header.appendChild(handle);
		header.appendChild(clear);

		var children = document.createElement("div");
		children.className = "children";

		if(this.int_name == "__clearselections") {
			var reset = document.createElement("div");
			reset.title = "Clear All Current Selections";
			reset.className = "reset-button sprite-clearAllSelections clickable";
			children.appendChild(reset);
			$(reset).click({filter:control},function(event) {
				event.data.filter.onClearFilters();
			});

			var resetColors = document.createElement("div");
			resetColors.title = "Reset Colors";
			resetColors.className = "reset-button colors sprite-resetColors clickable";
			children.appendChild(resetColors);
			$(resetColors).click({filter:control},function(event) {
				 event.data.filter.resetColors();
			});
		}
		
		//closed by default
		var defaultClosed = ["__spreadsheets", "__reports"];
		if(this.viewOnly || $.inArray(this.int_name, defaultClosed) > -1){
			$(children).hide();
			$(this.expander).removeClass('expanded');
		}

		if(this.int_name == "__search" && !this.searchHasValues()){
			$(children).hide();
			$(this.expander).removeClass('expanded');
		}
		
		if(this.int_name != "__clearselections"){
			container.appendChild(header);
		}
		container.appendChild(children);

		this.ui.handle = handle;
		this.container = container;
		this.childContainer = children;

		this.parent.childContainer.appendChild(container);
		
		if (this.sensitivityWarnings) {
			$(this.childContainer)
				.prepend(
					control.buildSensitivityWarning(
						this.sensitivityWarnings
					)
				);
		}
	},
	getSensitivityWarnings: function(fieldName){
		var sensitivityWarnings = [];
		var manager = this.getControl().getManager();
		var ds = manager.getDatasource(this.int_name);
		var warnings = ds && ds.sensitivity_warnings;
		
		if(warnings){
			
			var warningNames;
			if(warnings.datasource &&  warnings.datasource[fieldName]){
				warningNames = warnings.datasource[fieldName];
			}
			
			if(warnings.fields && warnings.fields[fieldName]){
				warningNames = warnings.fields[fieldName];
			}
			
			if(warningNames && warningNames.length && warnings.types){
				var control = this.getControl();
				var manager = control.getManager();
				var closedDialogs = manager.getOption('user_settings.warningDialogsClosed', {});
				
				for(var i = 0, l = warningNames.length; i < l; ++i){
					if(closedDialogs[fieldName] && closedDialogs[fieldName][warningNames[i]]){
						continue;
					}
					if(warnings.types[warningNames[i]]){
						var infoObject = $.extend({}, warnings.types[warningNames[i]]);
						infoObject.fieldName = fieldName;
						infoObject.warningName = warningNames[i];
						sensitivityWarnings.push(infoObject);
					}
				}
			}
			
		}
		return sensitivityWarnings;
	},
	placeDocumentationIcons: function(header){
		var control = this.getControl();
		var manager = control.getManager();
		
		if(this.int_name == "__divider") {
			if(control.options.docs) {
				header.appendChild(
					control.createDocList(
						control.options.docs
					)
				);
			}
		}
		
		if(this.int_name == "__spreadsheets") {
			if(control.options.spreadsheet_docs) {
				header.appendChild(
					control.createDocList(
						control.options.spreadsheet_docs
					)
				);
			}
		}
		
		if(this.int_name == "__search") {
			var searchoptions = manager.getOption("search.options");
			if(searchoptions && searchoptions.docs){
				header.appendChild(
					control.createDocList(
						searchoptions.docs
					)
				);
			}
		}
		
		if(this.int_name == "__reports") {
			if(control.options.reports_docs) {
				header.appendChild(
					control.createDocList(
						control.options.reports_docs
					)
				);
			}
		}
	},
	changeCountsMode: function() {
		var mode = this.getCountsMode();
		if (mode === 'row') {
			this.setCountsMode('total');
		} else {
			this.setCountsMode('row');
		}
	},
	getCountsMode: function() {
		var countsControl = this.getControl().getManager().getControl('countsmodel');
		return countsControl.getCountsMode(this.int_name);
	},
	setCountsMode: function(mode) {
		var countsControl = this.getControl().getManager().getControl('countsmodel');
		countsControl.setCountsMode(this.int_name, mode);
	},
	onCountsModeChange: function() {
		var mode = this.getCountsMode();
		
		if (mode === 'row') {
			$(this.container).addClass('mode-row');
			$(this.container).removeClass('mode-total');
		} else {
			$(this.container).addClass('mode-total');
			$(this.container).removeClass('mode-row');
		}
	},
	makeSectionClearer: function(container, callback){
		$(container)
			.append(
				this.makeSectionClearerInst(callback)
			);
	},
	makeSectionClearerInst: function(callback){
		var ce = Moonshadow.helpers.ce;
		this.clear_selection = $(ce("div"))
			.addClass("sprite-clearSelections clear_selection clickable hide")
			.attr({
				"title": "Clear " + this.ext_name + " Selections"
			})
			.click({"self": this, "callback": callback},function(e){
				e.data.callback.apply(e.data.self);
			});
		
		return this.clear_selection;
	},
	checkFilterCount: function(){
		var manager = this.getControl().getManager();
		
		if(this.int_name == "__universes"){
			manager.mapObservers.notify('checkUniverseFilterCount');
		}else{
			var hasFilters = this.countFilters([],this.struct);
			this.showHideClear(hasFilters);
			if(this.parent && this.parent.checkFilterCount){
				this.parent.checkFilterCount();
			}else{
				manager.mapObservers.notify('checkDatasourceFilterCount');
			}
		}
	},
	onClearDatasourceFilters: function(){
		var datasources = this.getControl().getManager().getControl("filters").datasourceLookup;
		for(var i = 0, l = datasources.length; i < l; ++i){
			datasources[i].onClearFilters && datasources[i].onClearFilters();
		}
		this.showHideClear(false);
	},
	onClearUniverseFilters: function(){
		var filterables = this
			.getControl()
			.getManager()
			.getControl("filters")
			.datasources["__universes"]
			.filterables;
		
		for(var i in filterables){
			filterables[i].onClearFilters && filterables[i].onClearFilters();
		}
		this.showHideClear(false);
	},
	checkDatasourceFilterCount: function(){
		var datasources = this.getControl().getManager().getControl("filters").datasourceLookup;
		var filterCount = 0;
		for(var i = 0, l = datasources.length; i < l; ++i){
			filterCount += datasources[i].countFilters([],datasources[i].struct);
		}
		this.showHideClear(filterCount);
	},
	checkUniverseFilterCount: function(){
		var filterables = this
			.getControl()
			.getManager()
			.getControl("filters")
			.datasources["__universes"]
			.filterables;
		
		var filterCount = 0;
		for(var i in filterables){
			filterCount += filterables[i].countFilters();
		}
		this.showHideClear(filterCount);
	},
	searchHasValues: function(){
		return this.filterables &&
			this.filterables["__search"] && 
			this.filterables["__search"].hasValues();
	},
	showHideClear: function(showHide){
		if(this.clear_selection){
			if(showHide){
				$(this.clear_selection).removeClass("hide");
			}else{
				$(this.clear_selection).addClass("hide");
			}
		}
	},
	trackBranches: function(openClose, filterable){
		if(filterable){
			var filterableDS = filterable.getDatasource();
			if(filterableDS.dsIndex < 0)
				return;
			if(openClose){
				this.openBranches[filterable.int_name] = filterable;
			}else{
				delete this.openBranches[filterable.int_name];
			}
		}
	},
	collapseOpenBranches: function(){
		for(var i in this.openBranches){
			if(this.openBranches.hasOwnProperty(i))
				this.openBranches[i].toggle();
		}
		this.openBranches = {};
	},
	setSelected: function() {
		$.each(this.getControl().datasources,function(k,v) {
			$(this.ui.handle).removeClass("selected");
		});

		$(this.ui.handle).addClass("selected");
	},
	toggle: function() {
		if($(this.expander).hasClass("expanded")) {
			this.childContainer.style.display = "none";
			$(this.expander).removeClass("expanded");
		} else {
			this.childContainer.style.display = "block";
			$(this.expander).addClass("expanded");
		}

		//this.getControl().getManager().mapObservers.notify('filterabletoggle', this);
	},
	getControl: function() {
		var parent = this;
		while(typeof parent.parent != "undefined") {
			parent = parent.parent;
		}

		this.getControl = function() { return parent; };
		return parent;
	},
	findStruct: function(arr, path) {
		var crumb = path.shift();

		var pos = null;
		for(var i = 0, l = arr.length; i < l; i++) {
			if(arr[i].int_name === crumb) {
				pos = i;
				break;
			}
		}

		if(pos === null) {
			return {};
		}

		var branch = arr[pos] || null;
		if(branch) {
			if(path.length) {
				if(branch.filters) {
					return this.findStruct(branch.filters, path);
				}
			} else if(branch) {
				return branch;
			}
		}

		return {};
	},
	resetColors: function() {
		if (Moonshadow.getManager().getOption("neutered") == 1) {
			return false;
		}

		if ($.inArray(this.int_name, [
			'__top', '__universes', 
			'__divider', '__spreadsheets',
			'__search',	'__clearselections',
			'__reports']) > -1) {
			return;
		}

		var colors = this.getControl().getManager().getControl('colors');
		colors.resetDatasource(this.int_name);
	},
	onClearFilters: function(){
		var pattern = /^((?!__universes)(?!__polygon)(?!circle_filter).)*$/g; //all but universes and polygons
		var filters = this.getControl().getManager().getControl('filterscontrol');
		filters.clearFiltersRegEx(this.int_name, pattern);
		this.clearFilters();
	},
	clearFilters: function() {
		var manager = this.getControl().getManager();

		$.each(this.filterables, function(k,v) {
			v.clearFilters();
		});

		this.hasFilters = 0;
		this.updateFilterCount();
		this.perculateChange();
		this.showHideClear(false);
	},
	isIntNameInArray: function(arr, key) {
		var found = false;
		$.each(arr, function(k, v) {
			if(typeof v === 'string' && v === key) {
				found = true;
			}

			if(typeof v === 'object' && v.int_name && v.int_name === key) {
				found = true;
			}
	
			if(found) {
				return false;;
			}
		});
		return found;
	},
	countFilters: function(path, branch) {
		var count = 0;
		var self = this;
		var dsId = this.int_name;
		var filters = this.getControl().getManager().getControl('filterscontrol');

		for (var i = 0, l = branch.length; i < l; i++) {			
			var subBranch = branch[i];

			if (subBranch.dtype === 'collection') {
				count += this.countFilters(path, subBranch.filters);
			} else if (subBranch.dtype === 'filter_group') {
				count += filters.countDeclaration(dsId, 'select_elections');

				var requiredPath = path.concat('required_elections').join('|');
				count += filters.countFilters(dsId, requiredPath);

				var excludedPath = path.concat('excluded_elections').join('|');
				count += filters.countFilters(dsId, excludedPath);
			} else {
				subPath = path.concat(subBranch.int_name);
				count += filters.countFilters(dsId, subPath.join('|'));
			}
		}

		return count;
	},
	countLeaves: function(branch, visitChildren) {
		// Default visit children to true
		if(typeof visitChildren === 'undefined') {
			visitChildren = true;
		}

		var total = 0;

		var caller = this;
		var toFromAlreadyCounted = false;
		$.each(branch, function(k,v) {
			if(typeof v == 'object') {
				if(visitChildren && k !== '__universes') {
					total += caller.countLeaves(v);
				}
			} else {
				// Order is used by universes, we don't need to count it.
				if(k === 'suffix' || k === 'order') {
					return true;
				}

				if(k === 'to' || k === 'from') {
					if(toFromAlreadyCounted) {
						return true;
					}

					toFromAlreadyCounted = true;
				}

				total++;
			}
		});

		return total;
	},
	onAjaxEvent: function(event, data, ajax) {},
	onAjaxResponse: function(data) {},
	getSelectedScenario: function() {
		var manager = this.getControl().getManager();
		if(manager.getControl("scenarios") == null)
			return false;

		var scenarioControl = manager.getControl("scenarios");
		return (scenarioControl.currentScenario != "") ? {"name":scenarioControl.currentScenario,"stype":scenarioControl.currentStype} : false;

	},
	isScenarioChosen: function() {
		return (this.getSelectedScenario() == false) ? false : true;
	},
	getCurrentTotal: function(callback){
		if(!this.currentTotal){
			var query = {
				"query": "get_data_statistics",
				"qid": "getTotal",
				"ds": this.int_name
			};
			this.getControl().getScopeBounds(query);
			var ajax = new Moonshadow.Ajax();
			var control = this;
			ajax.addQuery(query, function(data){
				if(data && data && data.result == "ok"){
					callback(data.total);
				}
			});
			ajax.execute();
		}else{
			callback(this.currentTotal);
		}
	},
	getBuyButton: function(ext_name) {
		var buy = document.createElement('div');
		buy.className = "buy_ds clickable sprite-cart_in";
		var itemName = "";
		if(ext_name)
			itemName = ext_name;
		buy.title = "Purchase " + itemName + " datasource";
		$(buy).click(function(e){
			Moonshadow.getManager().cvSubscriptionRequired();
		});
		return buy;
	},
	notify: function(force,meta) {
		// This shouldn't be called anymore RRO 11/14/13
	},
	perculateChange: function() {
		this.hasFilters = this.countFilters([], this.struct);

		if(this.hasFilters <= 0) {
			$(this.ui.handle).removeClass("has-filters");
		} else {
			$(this.ui.handle).addClass("has-filters");
		}
		
		if (this.parent == null || typeof this.parent.perculateChange != "function") {
			return;
		}

		this.parent.perculateChange();
	},
	updateFilterCount: function(handle) {
		if(handle === undefined) {
			handle = this.container;
		}
		
		this.hasFilters = this.countFilters([], this.struct);
		
		if(this.hasFilters <= 0) {
			$(".filter-count", handle).empty();
			$(handle).removeClass('has-filters');
		} else {
			var has = this.hasFilters;
			$.each($(".filter-count", handle), function(k,v) {
				$(v).empty();
				v.appendChild(document.createTextNode("(" + has + ")"));
			});
			$(handle).addClass('has-filters');
		}
		this.checkFilterCount();
	},
	show: function() {
		var manager = this.getControl().getManager();
		manager.addAjaxEventListener('filterchange',this);
		manager.addAjaxEventListener('colorreset',this);
		manager.addAjaxEventListener('bounds',this);
		manager.addAjaxEventListener('scenario_change',this);
	},
	hide: function() {
		this.getControl().getManager().removeAjaxEventListener('filterchange',this);
		this.getControl().getManager().removeAjaxEventListener('colorreset',this);
		this.getControl().getManager().removeAjaxEventListener('bounds',this);
		this.getControl().getManager().removeAjaxEventListener('scenario_change',this);
	}
};

function MReportsVisual(parent) {
	this.parent = parent;
	this.manager = parent.manager;
	this.container = parent.container;
	this._uiFunc = parent._uiFunc;
	
	this._gt = 1;
	this.id = MReportsVisual.meta.id;
	this.name = MReportsVisual.meta.name;
	this.order = 1;
	this.defaultTab = true;
	this.description = "Create a PDF report with graphs and tables filtered by chosen selections.";
	this.buttonTitle = "Generate Report";
	this.defaultSort = "report_datecreated";
	this.format = "advanced_pdf";
	this.icon = "sprite-piechart";
	this.childrenTitle = "Your Reports";
	this.comparableDatasources = {};
	this.options = {
		"layouts": [
			{
				"id": "standard",
				"name": "Standard"
			}
		],
		"styles": [
			{
				"id": "default",
				"name": "Default"
			}
		]
	};
	this.fields = {
		"visual_report_error_reason": {
			"id": "error_reason",
			"name": "Error",
			"format": function(value){
				return Moonshadow.helpers.capitalize(value);
			}
		},
		"visual_report_title": {
			"id": "title",
			"name": "Title",
			"type": function(field){
				return new String($(field).val());
			},
			"format": function(value){
				return Moonshadow.helpers.capitalize(value);
			},
			"path": "data"
		},
		"visual_report_datasources": {
			"id": "datasources",
			"name": "Data Source",
			"type": function(field){
				var value = $(field).val();
				if(value instanceof Array){
					return value;
				}
				return new Array(value);
			},
			"format": function(values){
				var dsControl = Moonshadow.getManager().getControl("datasources");
				return $(values).map(function(index, ds){
					return dsControl.getDatasourceAttribute(ds, "ext_name");
				})
				.toArray()
				.join(", ");
			}
		},
		"visual_report_layout": {
			"id": "layout",
			"name": "Layout",
			"type": function(field){
				return new String($(field).val());
			},
			"format": function(value){
				return Moonshadow.helpers.capitalize(value);
			}
		},
		"visual_report_style": {
			"id": "style",
			"name": "Style",
			"type": function(field){
				return new String($(field).val());
			},
			"format": function(value){
				return Moonshadow.helpers.capitalize(value);
			}
		},
		"visual_report_toc": {
			"id": "display_toc",
			"name": "Display Table of Contents",
			"type": function(field){
				return new Boolean($(field).get(0).checked);
			},
			"format": function(value){
				return value === true ? "Yes": "No";
			}
		},
		"visual_report_cover": {
			"id": "display_cover",
			"name": "Display Cover Page",
			"type": function(field){
				return new Boolean($(field).get(0).checked);
			},
			"format": function(value){
				return value === true ? "Yes": "No";
			}
		},
		"visual_report_compare": {
			"special": function(options, field){
				if(field.checked && options.datasources){
					options.datasources.push(field.value);
				}
			}
		}
	};
};

MReportsVisual.meta = {
	"id": "visual",
	"name": "Reports",
	"class": "MReportsVisual"
};

MReportsVisual.enabled = function(){
	var enabled = false;
	var appTypesForReports = ["censusviewer", "votermapping", "votermapping_private", "ncc", "experian", "ground_game", "constituentmapping"];
	
	var customerApiAccess = Moonshadow.getManager().getOption("customer_details.apiAccess");
	var appType = Moonshadow.getManager().getOption("app_details.type");
	
	//if($.inArray(appType, appTypesForReports) > -1 && customerApiAccess){ //api access no longer determines eligibility
	if($.inArray(appType, appTypesForReports) > -1){
		enabled =  true;
	}
	
	return enabled;
};

MReportsVisual.prototype._explainFilters = function(dsSetName){
	var dsId;
	var ce = Moonshadow.helpers.ce;
	var datasources = this.manager.getOptions().datasources;
	var dsControl = this.manager.getControl("datasources");
	var filtersControl = this.manager.getControl("filterscontrol");
	
	if(!dsSetName){
		dsId = datasources[0].int_name;
	}else{
		dsId = dsControl.getIdByAlias(dsSetName);
	}
	
	var filters = filtersControl.filtersToJSON(dsId);
	if(Moonshadow.helpers.objCount(filters) > 0){
		var explainedFilters = filtersControl.explainFilters(
			dsId, filters
		)
		if(explainedFilters.length){
			return $(explainedFilters)
				.filter(function(index, filterItem){
					return filterItem.val.length;
				})
				.map(function(index, filterItem){
					return $(ce("ul"))
						.addClass("reports_filters")
						.append(
							$(ce("li"))
								.addClass("reports_filters_fields")
								.append(filterItem.ext, ": "),
							$(ce("ul"))
								.addClass("reports_filters_values_list")
								.append(
									$(filterItem.val).map(function(i, v){
										return $(ce("li"))
											.addClass("reports_filters_values")
											.append(v)
											.get(0);
									})
								)
						)
						.get(0);
				})
		}
	}
	return $(ce("span"))
		.addClass("no_selections italic")
		.append("None")
};

MReportsVisual.prototype.refreshControls = function(){
	this._showComparableParam($(".visual_report_datasources").val());
	$(".visual_report_title")
		.val(this._getNextName());
};

MReportsVisual.prototype._updateExplain = function(){
	var chosenDs = $(".visual_report_datasources", this.container).val();
	$(".reports_chosen_selections_container", this.container)
		.empty()
		.append(
			this._explainFilters(chosenDs)
		);
};

MReportsVisual.prototype._colorByChanged = function(){
	var currentColorBy = this.manager.getDatasource().int_name;
	var dsSelector = $(".visual_report_datasources", this.container);
	$("option", dsSelector).each(function(index, opt){
		if(opt.value == currentColorBy){
			dsSelector.get(0).selectedIndex = index;
			return false;
		}
	});
	$(dsSelector).trigger("change");
	this.refreshControls();
	this._updateExplain();
};

MReportsVisual.prototype.generateReport = function(callback){
	var filtersControl = this.manager.getControl("filterscontrol");
	var reportqueue = this.manager.getControl("reportqueue");
	var dsControl = this.manager.getControl("datasources");
	
	var optionFields = $(".visual_reports_control input, .visual_reports_control select", this.container);
	var query_params = {};
	for(var i = 0, l = optionFields.length; i < l; ++i){
		var f = optionFields[i];
		var typeOpts;
		for(var ii in this.fields){
			if(!this.fields.hasOwnProperty(ii)){
				continue;
			}
			if(f.className.search(ii) > -1){
				typeOpts = this.fields[ii];
			}
		}
		if(!typeOpts){
			return false;
		}
		var path;
		var pathTrail = query_params;
		if(typeOpts.path){
			path = typeOpts.path.split(".");
			for(var ii = 0, ll = path.length; ii < ll; ++ii){
				if(!pathTrail[path[ii]]){
					pathTrail[path[ii]] = {};
				}
				pathTrail = pathTrail[path[ii]];
			}
		}
		if(typeOpts && typeOpts.type && typeOpts.id && !(typeOpts.id instanceof Array)){
			pathTrail[typeOpts.id] = typeOpts.type(f).valueOf();
		}
		if(typeOpts.special){
			typeOpts.special(query_params, f);
		}
	}

	var primaryDs = $(".visual_report_datasources", this.container).val();
	var primaryDsId = dsControl.getIdByAlias(primaryDs);
	var filters = filtersControl.filtersToJSON(primaryDsId);

	var query = {
		"report_type": "visual",
		"format": this.format,
		"filter": filters,
		"query_params": query_params
	};

	var self = this;
	reportqueue.generateReport(query, callback);
};

MReportsVisual.prototype.addListeners = function(){
	var self = this;
	this.manager.addMapObserver("colorbychange", this._colorByChanged, this);
	this.manager.addMapObserver(["filterchange", "shapechanged"], function(){
		self.refreshControls();
		self._updateExplain();
	}, this);
};

MReportsVisual.prototype.removeListeners = function(){
	this.manager.removeMapContext([
		"colorbychange",
		"filterchange",
		"shapechanged"
	], this);
};

MReportsVisual.prototype._getNextName = function() {
	var self = this, x = 0;
	var reg = new RegExp(this.name + " " + "([0-9]+)", "i");
	var values = this.parent._getReportsOfType("visual");
	for(var i in values){
		var title = (values[i].query_params && 
			values[i].query_params.data && 
			values[i].query_params.data.title) || 
			values[i].report_id;
		
		if(!values.hasOwnProperty(i)){
			continue;
		}
		var matches = title.match(reg);
		var match = (matches && matches[1]) ? matches[1] : 0;
		match = parseInt(match, 10);
		if(typeof match === "number" && match > x)	{
			x = match;
		}
	}
	return this.name + " "  + (x + 1);
};

MReportsVisual.prototype._showComparableParam = function(dsId){
	var dsControl = this.manager.getControl('datasources');
	var comparable = this.comparableDatasources[dsId];
	var showHide = !!comparable;
	var extName = "";
	
	if(comparable){
		extName = dsControl.getDatasourceAttribute(comparable, "ext_name");
	}
	
	$(".comparable", this.container)
		.removeClass(showHide && "hide")
		.addClass(!showHide && "hide")
		.find("label")
		.empty()
		.append("Compare to " + extName);
	
	$(".comparable input", this.container)
		.val(comparable || "")
		.attr({"checked": showHide});
};

MReportsVisual.prototype._buildComparableDatasources = function(){
	
	var dsControl = this.manager.getControl('datasources');
	var datasources = dsControl.getAll();
	
	for(var i in datasources){
		if(!datasources.hasOwnProperty(i)){
			continue;
		}
		var md1 = datasources[i].metadata;
		var ds1 = datasources[i].set_name;
		if(!md1){
			continue;
		}
		for(var ii in datasources){
			if(!datasources.hasOwnProperty(ii)){
				continue;
			}
			var md2 = datasources[ii].metadata;
			var ds2 = datasources[ii].set_name;
			if(!md2 || ds1 == ds2){
				continue;
			}
			if(md1.type == md2.type && md1.summary_file == md2.summary_file){
				this.comparableDatasources[ds1] = ds2;
			}
		}
	}
};

MReportsVisual.prototype.reportControl = function(){
	this._buildComparableDatasources();
	
	var ce = Moonshadow.helpers.ce;

	var currentColorBy = this.manager.getDatasource().int_name;
	var self = this;
	
	var dsControl = this.manager.getControl('datasources');
	var datasourcesObj = dsControl.getAll();
	var datasources = [];

	for (var dsObj in datasourcesObj) {
		if(!dsControl.hasReqAddons(dsObj)) {
			continue;
		}

		datasources.push(datasourcesObj[dsObj]);
	}

	var dsSelector;
	return $(ce("div"))
		.addClass("visual_reports_control")
		.append(
			this._uiFunc.controlContainer(
				"Report name",
				$(ce("input"))
					.addClass("visual_report_title")
					.attr({
						"type": "text",
						"value": this._getNextName()
					})
			),
			function(){
				if(datasources.length > self._gt){
					dsSelector = $(ce("select"))
						.addClass("visual_report_datasources")
						.append(
							$(datasources).map(function(index, ds){
								return $(ce("option"))
									.attr({
										"value": ds.set_name,
										"selected": ds.set_name == currentColorBy
									})
									.append(ds.ext_name)
									.get(0);
							})
						)
						.on("change", function(){
							self.refreshControls();
							self._updateExplain();
						});
					
					return self._uiFunc.controlContainer(
						"Data source",
						dsSelector
					);
				}
				return $(ce("input"))
					.addClass("visual_report_datasources")
					.attr({
						"type": "hidden",
						"value": datasources[0].set_name
					});
			}(),
			this._uiFunc.controlContainer(
				"",
				$(ce("input"))
					.addClass("visual_report_compare")
					.attr({
						"type": "checkbox",
						"id": "visual_report_compare"
					}),
				"hide comparable"
			),
			function(){
				if(!self.options || !self.options.layouts)
					return "";
				if(self.options.layouts.length > self._gt){
					return self._uiFunc.controlContainer(
						"Layout",
						$(ce("select"))
							.addClass("visual_report_layout")
							.append(
								$(self.options.layouts).map(function(index, layout){
									return $(ce("option"))
										.attr({
											"value": layout.id
										})
										.append(layout.name)
										.get(0);
								})
							)
					);
				}
				return $(ce("input"))
					.addClass("visual_report_layout")
					.attr({
						"type": "hidden",
						"value": self.options.layouts[0].id
					})
			}(),
			function(){
				if(!self.options || !self.options.styles)
					return "";
				if(self.options.styles.length > self._gt){
					return self._uiFunc.controlContainer(
						"Style",
						$(ce("select"))
							.addClass("visual_report_style")
							.append(
								$(self.options.styles).map(function(index, style){
									return $(ce("option"))
										.attr({
											"value": style.id
										})
										.append(style.name)
										.get(0);
								})
							)
					);
				}
				return $(ce("input"))
					.addClass("visual_report_style")
					.attr({
						"type": "hidden",
						"value": self.options.styles[0].id
					})
			}(),
			this._uiFunc.controlContainer(
				"Include Table of Contents",
				$(ce("input"))
					.addClass("visual_report_toc")
					.attr({
						"type": "checkbox",
						"id": "visual_report_toc",
						"checked": true
					})
			),
			this._uiFunc.controlContainer(
				"Include Cover Page",
				$(ce("input"))
					.addClass("visual_report_cover")
					.attr({
						"type": "checkbox",
						"id": "visual_report_cover",
						"checked": true
					})
			),
			$(ce("div"))
				.addClass("reports_option_selector reports_chosen_selections selectable")
				.append(
					$(ce("label"))
						.append(
							"Selections:",
							$(ce("div"))
								.addClass("expander clickable")
								.on("click", function(){
									$(this)
										.toggleClass("expanded");
									$(".reports_chosen_selections_container", self.container)
										.toggleClass("closed");
								})
						),
					$(ce("div"))
						.addClass("reports_chosen_selections_container closed")
						.append(
							this._explainFilters()
						)
				),
			this._uiFunc.generateButton("visual")
		);
};
function MReportsImage(parent) {
	this.manager = parent.manager;
	this.container = parent.container;
	this._uiFunc = parent._uiFunc;
	
	this._gt = 1;
	this.transpSlider;
	this.id = MReportsImage.meta.id;
	this.name = MReportsImage.meta.name;
	this.order = 2;
	this.defaultTab = false;
	this.description = "Create an image file from the current map viewport.";
	this.buttonTitle = "Generate Image";
	this.defaultSort = "report_datecreated";
	this.format = "image";
	this.icon = "sprite-screenshot";
	this.childrenTitle = "Your Images";
	this.options = {};
	
	var defaultTransOptions = this.manager.getControl("filters").defaultTransOptions(0).options;
	var self = this;
	this.fields = {
		"image_report_axis_type": {
			"id": ["max_width", "max_height"],
			"name": "Maximum Type",
			"type": function(field){
				var value = $(field).val();
				if(value instanceof Array){
					return value;
				}
				return new Array(value);
			},
			"format": function(value, field){
				if(field == "max_width"){
					return "Max Width";
				}
				if(field == "max_height"){
					return "Max Heigh";
				}
			},
			"special": function(options, field){
				var overRidden = $(".override_image_size", self.container).attr("checked");
				if(!overRidden){
					return;
				}
				var axisval = $(".image_report_axis", self.container).val();
				if(axisval){
					var valType = $(field).val();
					options[valType] = parseInt(axisval, 10);
				}
			}
		},
		"image_report_axis": {
			"id": ["max_width", "max_height"],
			"name": "Maximum Value (px)",
			"type": function(field){
				var value = parseInt($(field).val(), 10);
				if(isNaN(value)){
					value = 0;
				}
				return value;
			},
			"format": function(value){
				return value;
			},
			"special": function(){
				//do nothing here
			}
		},
		"image_report_density": {
			"id": "displayDensity",
			"name": "Show Density",
			"type": function(field){
				return $(field).get(0).checked ? 1 : 0
			},
			"format": function(value){
				return value === 1 ? "Yes": "No";
			},
			"path": "choropassData"
		},
		"image_report_dot_size": {
			"id": "geoDivisions",
			"name": "Map Dot Size",
			"type": function(field){
				return parseInt($(field).val(), 10);
			},
			"format": function(value){
				return Math.abs((Math.log(value)/Math.log(2)) - 10) -1
			},
			"path": "choropassData"
		},
		"image_report_transparency": {
			"id": "transparency",
			"name": "Transparency",
			"type": function(field){
				var value = $(field).val();
				if(!value){
					value = 0;
				}
				return parseInt(value, 10);
			},
			"format": function(value){
				if(defaultTransOptions){
					for(var i = 0, l = defaultTransOptions.length; i < l; ++i){
						if(defaultTransOptions[i].value == value.toString()){
							return defaultTransOptions[i].text;
						}
					}
				}
				return "0%";
			},
			"path": "choropassData"
		}
	};
};

MReportsImage.meta = {
	"id": "image",
	"name": "Images",
	"class": "MReportsImage"
};

MReportsImage.enabled = function(){
	var addons = Moonshadow.getManager().getOption("app_addons");
	return $.inArray('image_composer', addons) > -1
};

MReportsImage.prototype.addListeners = function(){
	this.manager.addMapObserver(["zoom", "change_size_option"], this._adjustZoomDotSizeEvent, this);
	this.manager.addMapObserver("change_trans_option", this._adjustTranspEvent, this);
	this.manager.addMapObserver("change_density_option", this._adjustDensity, this);
};

MReportsImage.prototype.removeListeners = function(){
	this.manager.removeMapContext([
		"zoom",
		"change_trans_option",
		"change_size_option",
		"change_density_option"
	], this);
};

MReportsImage.prototype._getAdjustedZoom = function(){
	var manager = this.manager;
	var adapter = manager.getAdapter();
	var zoom = adapter.getZoom();
	
	var axisval = $(".image_report_axis", this.container).val();
	var axistype = $(".image_report_axis_type", this.container).val();
	
	if(isNaN(parseInt(axisval, 10))){
		if(axistype == "max_width")
			axisval = $("#mapcontainer").width();
		if(axistype == "max_height")
			axisval = $("#mapcontainer").height();
	}
	
	var ppi = this._calculatePPI(axisval, axistype);
	var newZoom = Math.floor((ppi / 72) + zoom);
	if(newZoom > adapter.getMaxZoom()){
		newZoom = adapter.getMaxZoom();
	}

	return newZoom;
};

MReportsImage.prototype.refreshControls = function(){
	this._adjustZoomDotSizeEvent();
	this._adjustTranspEvent();
	this._adjustDensity();
	this._adjustDots();
};

MReportsImage.prototype._calculatePPI = function(axisval, axistype){
	this.maxPPIHard = 300;
	this.maxAxisHard = 1920;
	if(axistype == "max_width"){
		var mapWidth = $("#mapcontainer").width();
		var ppiX = axisval / Math.ceil(mapWidth / 72);
		if(ppiX > this.maxPPIHard)
			ppiX = this.maxPPIHard;
		if(isNaN(ppiX))
			ppiX = 72;
		return Math.ceil(ppiX) || 72;
	}
	if(axistype == "max_height"){
		var mapHeight = $("#mapcontainer").height();
		var ppiY = axisval / Math.ceil(mapHeight / 72);
		if(ppiY > this.maxPPIHard)
			ppiY = this.maxPPIHard;
		if(isNaN(ppiY))
			ppiY = 72;
		return Math.ceil(ppiY) || 72;
	}
	return 72;
};

MReportsImage.prototype._validateInput = function(axisField){
	if(axisField.value == ""){
		return false;
	}
	
	var value = parseInt(axisField.value.replace(/\D/g, ""), 10);
	if(isNaN(value)){
		axisField.value = "";
		return false;
	}
	if(value > this.maxAxisHard)
		value = this.maxAxisHard;
	
	if(value < 1){
		value = 1;
	}
	axisField.value = value;
};

MReportsImage.prototype._adjustDensity = function(){
	var density = this._getDensityValue();
	$(".image_report_density", this.container)
		.attr({
			"checked": !!density
		});
};

MReportsImage.prototype._adjustTranspEvent = function(){
	var overRidden = $(".override_transparency", this.container).attr("checked");
	if(!overRidden){
		this._adjustTransp();
	}
}

MReportsImage.prototype._adjustTransp = function(transpVal){
	if(!transpVal){
		transpVal = this._getTranspValue();
	}
	var value = this._getTransp(transpVal);
	$(".image_reports_adjusted_transparency_feedback", this.container)
		.empty(value)
		.append(value + "%");
	$(".image_report_transparency", this.container)
		.val(transpVal);
};

MReportsImage.prototype._adjustedZoom = function(){
	var newZoom = this._getAdjustedZoom();
	$(".image_reports_adjusted_zoom_feedback", this.container)
		.empty()
		.append(newZoom);
};

MReportsImage.prototype._adjustZoomDotSizeEvent = function(){
	this._adjustedZoom();
	var overRidden = $(".override_dot_size", this.container).attr("checked");
	if(!overRidden){
		this._adjustDots();
	}
};

MReportsImage.prototype._adjustDots = function(value){
	if(!value){
		value = this._getSuggestedDotValue();
	}
	$(".image_reports_adjusted_dot_size_feedback", this.container)
		.empty()
		.append(this._getDotSizeFromValue(value));
	$(".image_report_dot_size", this.container)
		.val(value);
};

MReportsImage.prototype._getDotValueFromSize = function(value){
	return Math.pow(2, Math.abs((value + 1) - 10));
};

MReportsImage.prototype._getDotSizeFromValue = function(value){
	return Math.abs((Math.log(value)/Math.log(2)) - 10) -1
};

MReportsImage.prototype._getTransp = function(transpVal){
	if(!transpVal){
		transpVal = this._getTranspValue();
	}
	return (Math.round(transpVal/(255/100)));
};

MReportsImage.prototype._getTranspValue = function(){
	var layerBaseControl = this.manager.getControl("layerBase");
	return layerBaseControl.getTransparency();
};

MReportsImage.prototype._getDensityValue = function(){
	var layerBaseControl = this.manager.getControl("layerBase");
	return layerBaseControl.getDensity();
};

MReportsImage.prototype._getSuggestedDotValue = function(){
	var layerBaseControl = this.manager.getControl("layerBase");
	var adapter = this.manager.getAdapter();
	var zoom = adapter.getZoom();
	return layerBaseControl.getDefaultLevels()[zoom];
};

MReportsImage.prototype.reportControl = function(){
	var ce = Moonshadow.helpers.ce;
	var typeDetails = this.typeDetails;
	
	var self = this;
	return $(ce("div"))
		.addClass("image_reports_control")
		.append(
			this._uiFunc.controlContainer(
				"Adjusted zoom level for image size",
				 $(ce("span"))
				 	.addClass("image_reports_adjusted_zoom_feedback report_feedback")
				 	.append(this._getAdjustedZoom())
				 	.get(0)
			),
			this._uiFunc.controlContainer(
				"Adjusted map dot size",
				[$(ce("span"))
				 	.addClass("image_reports_adjusted_dot_size_feedback report_feedback")
				 	.append(this._getDotSizeFromValue(this._getSuggestedDotValue()))
				 	.get(0),
				 $(ce("input"))
				 	.addClass("image_report_dot_size")
				 	.attr({
				 		"type": "hidden",
				 		"value": this._getSuggestedDotValue(),
				 		"id": "image_report_dot_size"
				 	})
				 	.get(0)
				 ]
			),
			this._uiFunc.controlContainer(
				"Dot Transparency",
				[$(ce("span"))
				 	.addClass("image_reports_adjusted_transparency_feedback report_feedback")
				 	.append(this._getTransp() + "%")
				 	.get(0),
				 $(ce("input"))
				 	.addClass("image_report_transparency")
				 	.attr({
				 		"type": "hidden",
				 		"value": self._getTranspValue(),
				 		"id": "image_report_transparency"
				 	})
				 	.get(0)
				 ]
			),
			this._uiFunc.controlContainer(
				"Show Density",
				$(ce("input"))
					.addClass("image_report_density")
					.attr({
						"type": "checkbox",
						"id": "image_report_density",
						"checked": !!this._getDensityValue()
					})
			),
			this._uiFunc.controlContainer(
				"Set Maximum Size", 
				$(ce("input"))
					.addClass("override_image_size override")
					.attr({
						"type": "checkbox",
						"id": "override_image_size",
					})
					.on("change", function(){
						var parent = $(this)
							.closest(".image_reports_control");
						var atc = $(".image_report_axis_type_container", parent);
						var ac = $(".image_report_axis_container", parent);
						
						var at = $(".image_report_axis_type", atc);
						var a = $(".image_report_axis", ac);
						
						$([atc.get(0), ac.get(0)]).addClass(this.checked ? "" : "hide")
							.removeClass(this.checked ? "hide" : "");
						$([at.get(0), a.get(0)]).attr({
							"disabled": !this.checked
						});
						if(!this.checked){
							$(a).val("");
						}
					})
			),
			this._uiFunc.controlContainer(
				"Maximum Type",
				$(ce("select"))
					.addClass("image_report_axis_type")
					.attr({
						"disabled": true,
						"id": "image_report_axis_type"
					})
					.append(
						$(ce("option"))
							.attr({
								"value": "max_width"
							})
							.append("Max Width"),
						$(ce("option"))
							.attr({
								"value": "max_height"
							})
							.append("Max Height")
					),
				"image_report_axis_type_container hide report_override"
			),
			this._uiFunc.controlContainer(
				"Maximum Value (px)",
				$(ce("input"))
					.addClass("image_report_axis")
					.attr({
						"type": "text",
						"disabled": true,
						"id": "image_report_axis"
					})
					.on("blur", {"self":self}, function(e){
						e.data.self._validateInput(this);
						e.data.self._adjustZoomDotSizeEvent();
					}),
				"image_report_axis_container hide report_override"
			),
			this._uiFunc.controlContainer(
				"Override Dot Size",
				$(ce("input"))
					.addClass("override_dot_size override")
					.attr({
						"type": "checkbox",
						"id": "override_dot_size"
					})
					.on("change", function(){
						var parent = $(this).closest(".image_reports_control");
						var ads = $(".image_report_dot_size_container", parent);
						var ds = $(".image_report_dot_size_control", ads);
						$(ads).addClass(this.checked ? "" : "hide")
							.removeClass(this.checked ? "hide" : "");
						$(ds).attr({
							"disabled": !this.checked
						})
						var dotSize;
						if(this.checked){
							dotSize = $(".image_report_dot_size_control").val();
						}
						self._adjustDots(dotSize);
					})
			),
			this._uiFunc.controlContainer(
				"New Dot Size",
				$(ce("select"))
					.addClass("image_report_dot_size_control override")
					.attr({
						"disabled": true,
						"id": "image_report_dot_size_control"
					})
					.append(
						function(){
							var len = 8, options = [];
							while(--len){
								var value = self._getDotValueFromSize(len);
								options.push($(ce("option"))
									.attr({
										"value": value
									})
									.append(len)
									.get(0)
								);
							}
							return options.reverse();
						}()
					)
					.on("change", function(){
						self._adjustDots(this.value);
					}),
				"image_report_dot_size_container hide report_override"
			),
			this._uiFunc.controlContainer(
				"Override Transparency", 
				$(ce("input"))
					.addClass("override_transparency override")
					.attr({
						"type": "checkbox",
						"id": "override_transparency"
					})
					.on("change", function(){
						var parent = $(this).closest(".image_reports_control");
						var itc = $(".image_report_transparency_container", parent);
						$(itc).addClass(this.checked ? "" : "hide")
							.removeClass(this.checked ? "hide" : "");

						var trans;
						if(this.checked && self.transpSlider){
							trans = $(self.transpSlider).slider("value")
						}
						self._adjustTransp(trans);
					})
			),
			function(){
				var container = $(ce("div"))
					.addClass("image_report_transparency_container hide report_override report_slider");
				self._transpSlider(container.get(0));
				return container;
			}(),
			this._uiFunc.generateButton("image")
		);
};

MReportsImage.prototype._getColorInfo = function(dsId, callback){
	var ajax = new Moonshadow.Ajax();
	var query = {
		"query": "load_stored_state",
		"qid": "usercolorby",
		"name": "color_by__set_color",
		"ds": dsId
	};
	var self = this;
	ajax.addQuery(query, function(data){
		var color_settings = {};
		if(data.result = "ok" && data.value){
			color_settings = {
	            "color": data.value.color,
	            "colors": data.value.colors
	        };
		}else{
			var manager = self.getManager();
			var filterControl = manager.getControl("filters");
			var colorBy = filterControl.getColorBy();
			var filterableDS = filterControl.getDatasource(dsId);
			var colors = filterableDS.layers.base.colors;
			var colorName = filterableDS.layers.base.color;
			color_settings = {
	            "color": colorName,
	            "colors": colors
	        };
		}
		callback(color_settings);
	}, this);
	ajax.execute();
};

MReportsImage.prototype._transpSlider = function(container){
	var colorby = this.manager.getControl("colorby");
	var self = this;
	var initalValue = this._getTranspValue();
	this.transpSlider = colorby.layerOptionSlider(
		container, 
		"New Dot Transparency",
		"image_report_transparency_slider", {
			"min": 0,
			"max": 255,
			"value": initalValue,
			"type": "percent"
		}, (function(context) {
			return function(val) {
				self._adjustTransp(val);
			}
		})(this), null, this, true
	);
};

MReportsImage.prototype._gatherImageDetails = function(callback){
	this._validateInput($(".image_report_axis", this.container).get(0));
	
	var manager = this.manager;
	var datasource = manager.getDatasource();
	var dsId = datasource.int_name;
	var adapter = manager.getAdapter();
	var bounds = adapter.getAntiBounds();
	var imagerySet = adapter.getMapImagerySetForAPI();
	
	var query_params = {
		"preserve_aspect_ratio": true,
		"units": "px",
		"zoom": adapter.getZoom(),
		"imagerySet": imagerySet,
		"topLeftPoint": {
            "lat": bounds.nwLat,
            "lon": bounds.nwLon
        },
        "bottomRightPoint": {
            "lat": bounds.seLat,
            "lon": bounds.seLon
        },
        "choropassData": {
        	"datasource": dsId
        }
	};
	
	var optionFields = $(".image_reports_control input, .image_reports_control select", this.container).not(".override");
	for(var i = 0, l = optionFields.length; i < l; ++i){
		var f = optionFields[i];
		var typeOpts = this.fields[f.id];
		var path;
		var pathTrail = query_params;
		if(typeOpts.path){
			path = typeOpts.path.split(".");
			for(var ii = 0, ll = path.length; ii < ll; ++ii){
				if(!pathTrail[path[ii]]){
					pathTrail[path[ii]] = {};
				}
				pathTrail = pathTrail[path[ii]];
			}
		}
		if(typeOpts && typeOpts.id && !(typeOpts.id instanceof Array)){
			pathTrail[typeOpts.id] = typeOpts.type(f).valueOf();
		}
		if(typeOpts.special){
			typeOpts.special(query_params, f);
		}
	}
	
	var layerMeshControl = manager.getControl("layerMesh");
	var mask = layerMeshControl.getActiveMask();
	if(mask){
		query_params.mask = mask;
	}
	var meshes = layerMeshControl.getActiveMeshes();
	if(meshes && meshes.length){
		if(!query_params.mesh_settings){
			query_params.mesh_settings = {};
		}
		query_params.mesh_settings.meshes = meshes;
	}
	var choropleths = layerMeshControl.getActiveChoropleths();
	if(choropleths.length){
		if(!query_params.mesh_settings){
			query_params.mesh_settings = {};
		}
		query_params.mesh_settings.choropleths = choropleths;
	}
	
	var axisval = $(".image_report_axis", this.container).val();
	var axistype = $(".image_report_axis_type", this.container).val();
	query_params.ppi = this._calculatePPI(axisval, axistype);
	
	this._getColorInfo(dsId, function(color_settings){
		query_params.color_settings = color_settings;
		callback(query_params);
	});
};

MReportsImage.prototype.generateReport = function(callback){
	var manager = this.manager;
	var datasource = manager.getDatasource();
	var dsId = datasource.int_name;
	var reportqueue = manager.getControl("reportqueue");
	var filtersControl = manager.getControl('filterscontrol');
	var filters = filtersControl.filtersToJSON(dsId);

	var self = this;
	this._gatherImageDetails(function(query_params){
		var query = {
		    "query_params": query_params,
		    "user": Moonshadow.user,
			"key": Moonshadow.key,
			"customer": Moonshadow.customer,
			"app": Moonshadow.app,
		    "ds": dsId,
		    "report_type": "image",
		    "format": "png",
		    "filter": filters
		};

		reportqueue.generateReport(query, callback);
	});
};


/**
 * Editable polyline class
 *
 * This class represents a polyline and contains the options and operations we 
 * expose. Calling show(), hide() handles all the adapter work to show it on the
 * the map.
 *
 * @class MMapPolyline
 * @constructor
 * @param {MManager} manager Ref to manager object
 * @param {Object} options Polygon options
 */
function MMapPolyline(manager, options) {
	if (!options) {
		options = {};
	}

	this.points = [];
	this.markers = [];
	this.midMarkers = [];
	this.midPolyline = null;
    
	this.lineColor = '#FF0000';
	this.lineAlpha = 204;
	this.lineStyle = options.lineStyle || '';
	this.lineThickness = 3;
	this.isEditable = false;

	this.minLineColor = '#FF0000';
	this.midLineAlpha = 204;
	this.midLineStyle = options.lineStyle || '4 4';
	this.midLineThickness = 3;

	this.pointMarkerUri = undefined;
	this.midMarkerUri = undefined;

	this.showPointMarkers = true;
	this.showMidMarkers = true;

	this.overrideMidInsert = null;	
	this.overrideMidContext = null;	

	this.manager;
	this.adapter;
	this.mapEntity; // Ref to map polyline
	this.mapEventHandlers = {};
	this.observers = new Moonshadow.Observer();
	this.metadata = {};

	this.init(manager, options);
};

/**
 * Sets up the polyline object
 * @method init
 */
MMapPolyline.prototype.init = function(manager, options) {
	this.manager = manager;
	this.adapter = manager.getAdapter();
};

/**
 * Get the current line color
 *
 * @method getLineColor
 * @return {#RGB} Returns the line color in hex (RGB) format
 */
MMapPolyline.prototype.getLineColor = function() {
	return this.lineColor;
};

/**
 * Set the current line color
 *
 * @method setLineColor
 * @param {#RGB} lineColor Line color
 */
MMapPolyline.prototype.setLineColor = function(lineColor) {
	this.lineColor = lineColor;
	this.updateMapOptions();
};

/**
 * Get the current line alpha
 *
 * @method getLineAlpha
 * @return {Number} Integer between 0 (invisible) and 255 (opace) 
 */
MMapPolyline.prototype.getLineAlpha = function() {
	return this.lineAlpha;
};

/**
 * Set the current line alpha
 *
 * @method setLineAlpha
 * @param {Number} lineAlpha
 */
MMapPolyline.prototype.setLineAlpha = function(lineAlpha) {
	this.lineAlpha = lineAlpha;
	this.updateMapOptions();
};

/**
 * Get the current line style
 *
 * @method getLineStyle
 * @return {String} Line style (dashes)
 */
MMapPolyline.prototype.getLineStyle = function() {
	return this.lineStyle;
};

/**
 * Set the current line style
 *
 * @method setLineStyle
 * @param {String} lineStyle Style definition
 */
MMapPolyline.prototype.setLineStyle = function(lineStyle) {
	this.lineStyle = lineStyle;
	this.updateMapOptions();
};

/**
 * Get the current line thickness
 *
 * @method getLineThickness
 * @reutrn {Number} Line thickness in pixels
 */
MMapPolyline.prototype.getLineThickness = function() {
	return this.lineThickness;
};

/**
 * Set the current line thickness
 *
 * @method setLineThickness
 * @param {Number} lineThickness Thickness in pixels 
 */
MMapPolyline.prototype.setLineThickness = function(lineThickness) {
	this.lineThickness = lineThickness;
	this.updateMapOptions();
};

/**
 * Get the mid line color
 *
 * @method getMidLineColor
 * @return {#RGB} Returns the line color in hex (RGB) format
 */
MMapPolyline.prototype.getMidLineColor = function() {
	return this.midLineColor;
};

/**
 * Set the mid line color
 *
 * @method setMidLineColor
 * @param {#RGB} lineColor Line color
 */
MMapPolyline.prototype.setMidLineColor = function(lineColor) {
	this.midLineColor = lineColor;
};

/**
 * Get the mid line alpha
 *
 * @method getMidLineAlpha
 * @return {Number} Integer between 0 (invisible) and 255 (opace) 
 */
MMapPolyline.prototype.getMidLineAlpha = function() {
	return this.midLineAlpha;
};

/**
 * Set the mid line alpha
 *
 * @method setMidLineAlpha
 * @param {Number} lineAlpha
 */
MMapPolyline.prototype.setMidLineAlpha = function(lineAlpha) {
	this.midLineAlpha = lineAlpha;
};

/**
 * Get the mid line style
 *
 * @method getMidLineStyle
 * @return {String} Line style (dashes)
 */
MMapPolyline.prototype.getMidLineStyle = function() {
	return this.midLineStyle;
};

/**
 * Set the mid line style
 *
 * @method setMidLineStyle
 * @param {String} lineStyle Style definition
 */
MMapPolyline.prototype.setMidLineStyle = function(lineStyle) {
	this.midLineStyle = lineStyle;
};

/**
 * Get the mid point line thickness
 *
 * @method getMidLineThickness
 * @reutrn {Number} Line thickness in pixels
 */
MMapPolyline.prototype.getMidLineThickness = function() {
	return this.midLineThickness;
};

/**
 * Set the mid point line thickness
 *
 * @method setMidLineThickness
 * @param {Number} lineThickness Thickness in pixels 
 */
MMapPolyline.prototype.setMidLineThickness = function(lineThickness) {
	this.midLineThickness = lineThickness;
};

/**
 * Get metadata 
 *
 * @method getMetadata
 * @param {String} id Id of metadata item
 * @return The value or undefined
 */
MMapPolyline.prototype.getMetadata = function(id) {
	return this.metadata[id];
};

/**
 * Set metadata 
 *
 * @method setMetadata
 * @param {String} id Id of metadata item
 * @param The value or undefined
 */
MMapPolyline.prototype.setMetadata = function(id, value) {
	this.metadata[id] = value;
};

MMapPolyline.prototype.getPointMarkerUrl = function() {
	var cdn = this.manager.getOption("cdn");
	if (this.pointMarkerUri) {
		return cdn + this.pointMarkerUri;
	}

	return cdn + '/images/point_red.png';
};

MMapPolyline.prototype.setPointMarkerUri = function(uri) {
	this.pointMarkerUri = uri;
};


MMapPolyline.prototype.getMidMarkerUrl = function() {
	var cdn = this.manager.getOption("cdn");
	if (this.midMarkerUri) {
		return cdn + this.midMarkerUri;
	}

	return cdn + '/images/midpoint_red.png';
};

MMapPolyline.prototype.getMidMarkerUri = function() {
	return this.midMarkerUri;
};

MMapPolyline.prototype.setMidMarkerUri = function(uri) {
	this.midMarkerUri = uri;
};

MMapPolyline.prototype.showPointMarkers = function() {
	this.showPointMarkers = true;
};

MMapPolyline.prototype.hidePointMarkers = function() {
	this.showPointMarkers = false;
	this.removePointMarkers();	
};

MMapPolyline.prototype.showMidMarkers = function() {
	this.showMidMarkers = false;
};

MMapPolyline.prototype.hideMidMarkers = function() {
	this.showMidMarkers = false;
	this.removeMidMarkers();
};

MMapPolyline.prototype.overrideMidPointInsertion = function(func, context) {
	if (typeof func != "function") {
		throw new Error('Supplied override is not a function');
	}

	this.overrideMidInsert = func;
	this.overrideMidContext = context;
};

MMapPolyline.prototype.clearMidPointInsertion = function() {
	this.overrideMidInsert = null;
	this.overrideMidContext = null;	
};

/**
 * Get index of a point, or -1 if not in polyline
 *
 * @method getFirstIndex
 * @param {LatLng} point The point to get index of
 * @return {Number} index of provided point or -1
 */
MMapPolyline.prototype.getFirstIndex = function(point) {
	var pointString = point.toString();

	for(var i = 0, l = this.points.length; i < l; i++) {
		if (pointString === this.points[i].toString()) {
			return i;
		}
	}

	return -1;
};

/**
 * Get lines points (lat,lng)
 *
 * @method getPoints
 * @return {LatLng[]} Array of [lat, lng] pairs
 */
MMapPolyline.prototype.getPoints = function() {
	return this.points.slice(0);
};

/**
 * Set the points and update map if shown
 *
 * @method setPoints
 * @param {LatLng[]} Array of [lat, lng] pairs
 */
MMapPolyline.prototype.setPoints = function(points) {
	this.points = points.slice(0);

	this.updateAllMarkers();
	this.pointsChanged();
};

/**
 * Add point to polyline
 *
 * @method addPoint
 * @param {LatLng} point New [lat,lng] for point
 */
MMapPolyline.prototype.addPoint = function(point) {
	var numPoints = this.points.length;
	var index = numPoints;

	this.points.push(point);

	this.adjustMarkers(index);
	this.pointsChanged();
};

/**
 * Set lat lng of specific point in line and if shown, update map
 *
 * @method setPoint
 * @param {Number} index Index of point in polyline, starts at 0
 * @param {LatLng} point LatLng pair ([lat, lng])
 */
MMapPolyline.prototype.setPoint = function(index, point) {
	this.points[index] = point;

	this.adjustMidMarker(index, -1);
	this.adjustMidMarker(index, 1);

	this.pointsChanged();
};

/**
 * Insert a point at index and if shown, update map
 *
 * @method insertPoint
 * @param {Number} index Index to insert point in polyline
 * @param {LatLng} point LatLng pair ([lat, lng])
 */
MMapPolyline.prototype.insertPoint = function(index, point) {
	var numPoints = this.points.length;
	this.points.splice(index, 0, point);

	this.adjustMarkers(index, true);
	this.pointsChanged();
};

/**
 * Remove a point from the polyline and if shown, update map
 *
 * @method removePoint
 * @param {Number} index Index of point to remove
 */
MMapPolyline.prototype.removePoint = function(index) {
	this.points.splice(index, 1);

	this.removeMarkers(index);
	this.pointsChanged();
};


/**
 * Sets polyline as editable (adds point and midpoint markers)
 *
 * @method setEditable
 */
MMapPolyline.prototype.setEditable = function() {
	if (!this.isEditable && this.mapEntity) {
		this.addPointMarkers();
		this.addMidMarkers();
	}

	this.isEditable = true;
};

/**
 * Sets polyline as uneditable (removes point and midpoint markers)
 *
 * @method setUneditable
 */
MMapPolyline.prototype.setUneditable = function() {
	this.removePointMarkers();
	this.removeMidMarkers();
	this.isEditable = false;
};

/**
 * Bind an event listner
 * 
 * @method addEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MMapPolyline.prototype.addEventListener = function(event, listener, context) {
	var adapter = this.adapter;
	if (!this.mapEventHandlers[event]) {
		var handler = adapter.addEventListener(event, this.mapEventHandler,
											   this);
		this.mapEventHandlers[event] = handler;
	}

	this.observers.addObserver(event, listener, context);
};

/**
 * Unbind an event listener
 *
 * @method removeEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MMapPolyline.prototype.removeEventListener = function(event, listener, 
													  context) {
	this.observers.removeObserver(event, listener, context);

	if (!this.observers.hasObservers(event) && this.mapEventHandlers[event]) {
		this.adapter.removeEventListener(this.mapEventHandlers[event]);
		this.mapEventHandlers[event] = null;
	}
};

/**
 * Show polyline on map
 *
 * @method show
 */
MMapPolyline.prototype.show = function() {
	if (!this.mapEntity) {
		var mapEntity = this.adapter.addPolyline(this);
		this.mapEntity = mapEntity;
	}

	if (this.isEditable) {
		this.addPointMarkers();
		this.addMidMarkers();
	}

	// @TODO Bind any lower-level events that are being observed
};

/**
 * Remove polyline from map
 *
 * @method hide
 */
MMapPolyline.prototype.hide = function() {
	this.adapter.removePolyline(this);
	this.mapEntity = null;

	// Remove markers
	this.removePointMarkers();
	this.removeMidMarkers();

	// @TODO Unbind any lower-level events being observed
};

/**
 * When points change update map and notify any listeners
 *
 * @method pointsChanged
 */
MMapPolyline.prototype.pointsChanged = function() {
	if (this.getMapEntity()) {
		this.adapter.updatePolylinePoints(this);
	}

	this.observers.notify('changed', this);
};

/**
 * Adjusts point and mid markers
 *
 * @private
 * @method pointsChanged
 * @param {Number} index Index of point that changed
 * @Param {Boolean} [newPoint] If true, it's a new point (add midmarker)
 */
MMapPolyline.prototype.adjustMarkers = function(index, newPoint) {
	if (this.isEditable && this.getMapEntity()) {
		// Add marker
		var point = this.points[index];

		if (this.showPointMarkers) {
			this.markers.splice(index, 0, this.getPointMarker(point));
		}

		// If more then one points, create/update midpoint markers
		if (this.points.length > 1) {
			this.adjustMidMarker(index, -1);
			// If new point, don't adjust - create a new mid marker
			this.adjustMidMarker(index, 1, newPoint);
		}
	}
};

/**
 * Loop through all points and update markers and midmarkers
 *
 * @private
 * @method updateAllMarkers
 */
MMapPolyline.prototype.updateAllMarkers = function() {
	// @TODO
};

/**
 * Remove markers related to a point
 * 
 * @private
 * @method removeMarkers
 * @param {Number} index Index of point that has been removed
 */
MMapPolyline.prototype.removeMarkers = function(index) {
	var numPoints = this.points.length;

	if (this.markers[index]) {
		this.markers[index].hide();
		this.markers.splice(index, 1);
	}

	// If first point
	if (index === 0) {
		if (this.midMarkers[index]) {
			this.midMarkers[index].hide();
			this.midMarkers.splice(index, 1);
		}
	} else {
		if (this.midMarkers[index - 1]) {
			this.midMarkers[index - 1].hide();
			this.midMarkers.splice(index - 1, 1);
		}

		if (this.midMarkers[index - 1]) {		
			this.adjustMidMarker(index, -1);
		}
	}
};

/**
 * If shown, passes polyline options to adapter for map update
 *
 * @method updateMapOptions
 */
MMapPolyline.prototype.updateMapOptions = function() {
	if (this.getMapEntity()) {
		this.adapter.updatePolylineOptions(this);
	}
};

/**
 * Create an instance of MMapMarker that is styled to be a point marker
 *
 * @private
 * @method getPointMarker
 * @param {LatLng} point LatLng ([lat, lng]) for new marker
 * @return {MMapMarker} Instance of MMapMarker for a point
 */
MMapPolyline.prototype.getPointMarker = function(point) {
	var options = {
		'icon': this.getPointMarkerUrl(),
		'anchor': [6 ,6],
		'height': 13,
		'width': 13,
		'draggable': true,
		'zIndex': 7000
	};

	// Create marker
	var marker = new MMapMarker(this.manager, point, options);

	// Bind events
    marker.addEventListener('dragstart', this.onMarkerDrag, this);
    marker.addEventListener('drag', this.onMarkerDrag, this);
    marker.addEventListener('dragend', this.onMarkerDrag, this);
    marker.addEventListener('rightclick', this.markerRemove, this);

	// Show it on map
	marker.show();
		
	return marker;
};

/**
 * Sets up point markers
 *
 * @private
 * @method addPointMarkers
 */
MMapPolyline.prototype.addPointMarkers = function() {
	if (!this.showPointMarkers) {
		return;
	}

	for (var i = 0, l = this.points.length; i < l; i++) {
		var marker = this.getPointMarker(this.points[i]);
		this.markers.push(marker);
	}
};

/**
 * Delete point markers
 *
 * @private
 * @method removePointMarkers
 */
MMapPolyline.prototype.removePointMarkers = function() {
	// Loop through markers and hide, then clear array
	for (var i = 0, l = this.markers.length; i < l; i++) {
		// @TODO unbind event listeners
		this.markers[i].hide();
	}
	this.markers = [];
};

/**
 * Create an instance of MMapMarker that is styled to be a mid-point marker
 *
 * @private
 * @method getMidMarker
 * @param {LatLng} point LatLng ([lat, lng]) for new mid-point marker
 * @return {MMapMarker} Instance of MMapMarker for a mid-point
 */
MMapPolyline.prototype.getMidMarker = function(point) {
	var options = {
		'icon': this.getMidMarkerUrl(),
		'anchor': [6 ,6],
		'height': 11,
		'width': 11,
		'draggable': true,
		'zIndex': 6000
	};

	var marker = new MMapMarker(this.manager, point, options);
	var dragstart = marker.addEventListener('dragstart', this.midMarkerDrag, this);
	var drag = marker.addEventListener('drag', this.midMarkerDrag, this);
	var dragend = marker.addEventListener('dragend', this.midMarkerDrag, this);

	marker.setMetadata('dragstarthandle', dragstart);
	marker.setMetadata('draghandle', drag);
	marker.setMetadata('dragendhandle', dragend);

	marker.show();
		
	return marker;
};

/**
 * Sets up mid-point markers
 *
 * @private
 * @method addMidMarkers
 */
MMapPolyline.prototype.addMidMarkers = function() {
	if (this.showMidMarkers) {
		return;
	}

	for (var i = 0, l = this.points.length; i < l; i++) {
		var point1 = this.points[i];
		var point2 = this.points[i+1];

		if (point1 && point2) { 
			var marker = this.getMidMarker(this.getMidPoint(point1, point2));
			this.midMarkers.push(marker);
		}
	}
};

/**
 * Delete mid-point markers
 *
 * @private
 * @method removeMidMarkers
 */
MMapPolyline.prototype.removeMidMarkers = function() {
	// Loop through mid-markers and hide, then clear array
	for (var i = 0, l = this.midMarkers.length; i < l; i++) {
		// @TODO unbind event listeners
		this.midMarkers[i].hide();
	}
	this.midMarkers = [];
};

/**
 * Get point in between two points
 *
 * @private
 * @method getMidPoint
 * @param {LatLng} point1 
 * @param {LatLng} point2
 * @return {LatLng} Point between point1 and point2
 */
MMapPolyline.prototype.getMidPoint = function(point1, point2) {
	return [
		point2[0] - (0.5 * (point2[0] - point1[0])),
		point2[1] - (0.5 * (point2[1] - point1[1]))
	];
};

/**
 * Get ref to entity used by map system
 *
 * This is mostly used to tell if the line is shown on the map
 *
 * @private
 * @method getMapEntity
 * @return {Object} Map system specific object the represents the line
 */
MMapPolyline.prototype.getMapEntity = function() {
	return this.mapEntity;
};

/**
 * Redispatches events to listeners
 *
 * @private
 * @method mapEventHandler
 */
MMapPolyline.prototype.mapEventHandler = function(event, details) {
	this.observers.notify(event, this);
};

/**
 * Get index for a marker in the marker array
 *
 * @private
 * @method getMarkerPos
 * @return {Number} Index of marker in marker array
 */
MMapPolyline.prototype.getMarkerPos = function(marker) {
	var pos = null;

	for(var i = 0, l = this.markers.length; i < l; i++) {
		if (this.markers[i] === marker) {
			pos = i;
			break;
		}		
	}

	if (pos === null) {
		return -1;
	}

	return pos;
};

/**
 * Get index of marker in mid-marker array
 *
 * @private 
 * @method getMidMarkerPos
 * @return {Number} Index of marker in mid-marker array
 */
MMapPolyline.prototype.getMidMarkerPos = function(marker) {
	var pos = null;

	for(var i = 0, l = this.midMarkers.length; i < l; i++) {
		if (this.midMarkers[i] === marker) {
			pos = i;
			break;
		}		
	}

	if (pos === null) {
		return -1;
	}

	return pos;
};

/**
 * Remove point from line using marker 
 *
 * This is used to remove a point when marker is righ-clicked on
 * 
 * @private
 * @method markerRemove
 * @param {String} event Event id
 * @param {MMapMarker} marker Marker the event was fired on
 */
MMapPolyline.prototype.markerRemove = function(event, marker) {
	var pos = this.getMarkerPos(marker);

	if (pos !== -1) {
		this.removePoint(pos);
	}
};

/**
 * Update point using dragged marker
 *
 * @private
 * @method onMarkerDrag
 * @param {String} event Event id
 * @param {MMapMarker} marker Marker the event was fired on
 */
MMapPolyline.prototype.onMarkerDrag = function(event, marker) {
	// Update polyline
	var pos = this.getMarkerPos(marker);

	if (pos !== -1) {
		this.setPoint(pos, marker.getPoint());

		this.observers.notify('point' + event, marker);
	}
};

/**
 * Calculate mid point for mid-marker and update latlng
 *
 * @private
 * @method adjustMidMarker
 * @param {Number} index Index of point that changed
 * @param {Number} direction 1 or -1
 */
MMapPolyline.prototype.adjustMidMarker = function(index, direction, isNew) {
	var point = this.points[index];
 	var adjacentPoint = this.points[index + direction];

	if (point && adjacentPoint && this.showMidMarkers) {
 		var midPoint = this.getMidPoint(point, adjacentPoint);
		var midIndex = index - 1;
		if (direction > 0) {
			midIndex++;
		}

		if (this.midMarkers[midIndex] && !isNew) {
			this.midMarkers[midIndex].setPoint(midPoint);

			if (!this.midMarkers[midIndex].isShown()) {
				this.midMarkers[midIndex].show()
			}
		} else {
			this.midMarkers.splice(midIndex, 0, this.getMidMarker(midPoint));
		}
	}	
};

/**
 * Handle the dragging of a mid-marker. This creates a new point when done
 *
 * @private
 * @method midMarkerDrag
 * @param {String} event Event id
 * @param {MMapMarker} marker Mid-arker the event was fired on
 */
MMapPolyline.prototype.midMarkerDrag = function(event, marker) {
	var pos = this.getMidMarkerPos(marker);
	if (pos === -1) {
		return;
	}

	var point = marker.getPoint();

	if (event === 'dragstart') { // 
		var midPolyline = new MMapPolyline(this.manager);
		// line points
		midPolyline.addPoint(this.points[pos]);
		midPolyline.addPoint(point);
		midPolyline.addPoint(this.points[pos + 1]);
		// line styling
		midPolyline.setLineColor(this.midLineColor);
		midPolyline.setLineAlpha(this.midLineAlpha);
		midPolyline.setLineStyle(this.midLineStyle);
		midPolyline.setLineThickness(this.mindLineThickness);
		midPolyline.setMidMarkerUri(this.getMidMarkerUri());

		this.midPolyline = midPolyline;
		this.midPolyline.show();
	}

	if (event === 'drag') {
		if (this.midPolyline) {
			this.midPolyline.setPoint(1, point);	
		}
	}

	if (event === 'dragend') {
		if (!this.overrideMidInsert) {
			// Adding one to pos so that it's spliced in after the point
			// already in pos
			this.insertPoint(pos + 1, point);
		} else {
			this.overrideMidInsert.call(this.overrideMidContext, marker);
		}

		// Remove polyline
		this.abortMidDrag(pos);
	}

	this.observers.notify('mid' + event, marker);
};

MMapPolyline.prototype.abortMidDrag = function(index) {
	if (this.midPolyline) {
		this.midPolyline.hide();
		this.midPolyline = null;
	}

	// Create new marker
	var prevMarker = this.midMarkers[index];
	var point1 = this.points[index];
	var point2 = this.points[index + 1];
	this.midMarkers[index] = this.getMidMarker(this.getMidPoint(point1, point2));

	this.adapter.hideMarker(prevMarker);
};

MMapPolyline.prototype.hideMidMarker = function(index) {
	if (this.midMarkers[index]) {
		this.midMarkers[index].hide();
	}
};

MMapPolyline.prototype.showMidMarker = function(index) {
	if (this.midMarkers[index]) {
		this.midMarkers[index].show();
	}
};

/**
 * Adds some points to the polyline and sets editable
 *
 * @private
 * @method testPolyline
 */
MMapPolyline.prototype.testPolyline = function() {
    this.setEditable();
    this.show();
    this.addPoint([44.04, -123.0742]);
    this.addPoint([44.0375, -123.0743]);
    this.addPoint([44.0376, -123.0696]);
    this.addPoint([44.05, -123.0697]);
};
/**
 * Editable polygone class
 *
 * This class is very similar to the MMapPolyline. It has some additional fill
 * related options and it's a closed shape. Once the poylgon has at least 3 
 * points a point at the end of the points array is added to close the shape.
 * This point will be the same location as the first point. Many of the
 * functions related to editing the points array have deviated from MMapPolyline
 * to support this additional point.
 *
 * @class MMapPolygon
 * @constructor
 * @param {MManager} manager Ref to manager object
 * @param {Object} options Polygon options
 */
function MMapPolygon(manager, options) {
	if (!options) {
		options = {};
	}

	this.polygon;
	this.points = [];
	this.markers = [];
	this.midMarkers = [];
	this.midPolyline = null;

	this.lineColor = '#FF0000';
	this.lineAlpha = 204;
	this.lineStyle = options.lineStyle || '';
	this.lineThickness = 3;
	this.fillColor = '#FF0000';
	this.fillAlpha = 127;
	this.isEditable = false;

	this.manager;	
	this.adapter
	this.mapEntity; // Ref to map polygon
	this.mapEventHandlers = {};
	this.observers = new Moonshadow.Observer();

	this.filterFlag = "__polygon";
	
	this.init(manager, options);
};

/**
 * Sets up the polygon object
 *
 * @private
 * @method init
 */
MMapPolygon.prototype.init = function(manager, options) {
	this.manager = manager;
	this.adapter = manager.getAdapter();
};

/**
 *
 */
MMapPolygon.prototype.isReady  = function() {
	return (this.points && this.points.length > 2);
};

/**
 * Get the current line color
 *
 * @method getLineColor
 * @return {#RGB} Returns the line color in hex (RGB) format
 */
MMapPolygon.prototype.getLineColor = function() {
	return this.lineColor;
};

/**
 * Set the current line color
 *
 * @method setLineColor
 * @param {#RGB} lineColor Line color
 */
MMapPolygon.prototype.setLineColor = function(lineColor) {
	this.lineColor = lineColor;
	this.updateMapOptions();
};

/**
 * Get the current line alpha
 *
 * @method getLineAlpha
 * @return {Number} Integer between 0 (invisible) and 255 (opace) 
 */
MMapPolygon.prototype.getLineAlpha = function() {
	return this.lineAlpha;
};

/**
 * Set the current line alpha
 *
 * @method setLineAlpha
 * @param {Number} lineAlpha
 */
MMapPolygon.prototype.setLineAlpha = function(lineAlpha) {
	this.lineAlpha = lineAlpha;
	this.updateMapOptions();
};

/**
 * Get the current line style
 *
 * @method getLineStyle
 * @return {String} Line style (dashes)
 */
MMapPolygon.prototype.getLineStyle = function() {
	return this.lineStyle;
};

/**
 * Set the current line style
 *
 * @method setLineStyle
 * @param {String} lineStyle Style definition
 */
MMapPolygon.prototype.setLineStyle = function(lineStyle) {
	this.lineStyle = lineStyle;
	this.updateMapOptions();
};

/**
 * Get the current line thickness
 *
 * @method getLineThickness
 * @reutrn {Number} Line thickness in pixels
 */
MMapPolygon.prototype.getLineThickness = function() {
	return this.lineThickness;
};

/**
 * Set the current line thickness
 *
 * @method setLineThickness
 * @param {Number} lineThickness Thickness in pixels 
 */
MMapPolygon.prototype.setLineThickness = function(lineThickness) {
	this.lineThickness = lineThickness;
	this.updateMapOptions();
};

/**
 * Get polygon fill color
 *
 * @method getFillColor
 * @return {#RGB} Fill color
 */
MMapPolygon.prototype.getFillColor = function() {
	return this.fillColor;
};

/**
 * Set area fill color
 *
 * @method setFillColor
 * @param {#RGB} fillColor Fill color
 */
MMapPolygon.prototype.setFillColor = function(fillColor) {
	this.fillColor = fillColor;
	this.updateMapOptions();
};

/**
 * Get fill alpha
 *
 * @method getFillAlpha
 * @return {#RGB} Fill alpha
 */
MMapPolygon.prototype.getFillAlpha = function() {
	return this.fillAlpha;
};

/**
 * Set the current line thickness
 *
 * @method setLineThickness
 * @param {Number} fillAlpha Fill alpha
 */
MMapPolygon.prototype.setFillAlpha = function(fillAlpha) {
	this.fillAlpha = fillAlpha;
	this.updateMapOptions();
};

/**
 * Get metadata 
 *
 * @method getMetadata
 * @param {String} id Id of metadata item
 * @return The value or undefined
 */
MMapPolygon.prototype.getMetadata = function(id) {
	return this.metadata[id];
};

/**
 * Set metadata 
 *
 * @method setMetadata
 * @param {String} id Id of metadata item
 * @param The value or undefined
 */
MMapPolygon.prototype.setMetadata = function(id, value) {
	this.metadata[id] = value;
};

MMapPolygon.prototype.getFilter = function() {
	if (!this.isReady()) {
		return null;
	}

	var filter = [];
	var points  = this.getPoints();
	if (points && points.length > 0) {
		for(var i = 0, l = points.length; i < l; i++) {
			var point = points[i];
			// Points is an array of lat,lng arrays
			filter.push({'lat': point[0], 'long': point[1]});
		}
	}

	return filter;
};

MMapPolygon.prototype.getFilterQuery = function() {
	return {
		'query': 'save_stored_state',
		'qid': 'polygonselect',
		'name': '__polygon',
		'value': this.getFilter()
	}
};

MMapPolygon.prototype.getStatsQuery = function(dsId, shapeId, poly) {
	return {
		'query': 'get_total_count',
		'ds': dsId,
		'int_name': shapeId,
		'points': this.getFilter()
	};
};

/**
 * Get lines points (lat,lng)
 *
 * @method getPoints
 * @param {Boolean} removeClosing If true, remove closing point
 * @return {LatLng[]} Array of [lat, lng] pairs
 */
MMapPolygon.prototype.getPoints = function(noClosing) {
	var points = this.points.slice(0);

	if (!points.length) {
		return points;
	}

	var pointString = points[0].toString();

	if (noClosing && pointString == points[this.points.length - 1].toString()) {
		points.splice(-1, 1);
	}

	return points;
};

/**
 * Set the points and update map if shown
 *
 * @method getPoints
 * @param {LatLng[]} Array of [lat, lng] pairs
 */
MMapPolygon.prototype.setPoints = function(points) {
	this.points = points.slice(0);

	// Add "closing" point if not present
	var numPoints = this.points.length;
	if (numPoints > 2 && this.points[0] != this.points[numPoints -1]) {
		this.points.push(this.points[0]);
	}

	this.updateAllMarkers();
	this.pointsChanged();
};

/**
 * Add point to polygon
 *
 * @method addPoint
 * @param {LatLng} point New [lat,lng] for point
 */
MMapPolygon.prototype.addPoint = function(point) {
	var numPoints = this.points.length;
	var index = numPoints;

	if (numPoints < 2) { // If first or 2nd point, just push
		this.points.push(point);
	} else if (numPoints === 2) { // If 3rd point, then add "closing" point
		this.points.push(point);
		this.points.push(this.points[0]);		
	} else { // Otherwise, splice between 2nd to last and "closing" point
		this.points.splice(-1, 0, point);
		index = numPoints - 1;
	}

	// If shape isn't shown, show it
	if (!this.getMapEntity() && this.showable()) {
		this.show();
	}	

	this.adjustMarkers(index);
	this.pointsChanged();
};

/**
 * Set lat lng of specific point in line and if shown, update map
 *
 * @method setPoint
 * @param {Number} inde Index of point in polygon, starts at 0
 * @param {LatLng} point LatLng pair ([lat, lng])
 */
MMapPolygon.prototype.setPoint = function(index, point) {	
	var numPoints = this.points.length;

	// Handle the "closing" point
	if (numPoints > 2) {
		if (index === 0) { // If first point, update last point
			this.points[numPoints - 1] = point;
		} else if (index === numPoints - 1) {
			this.points[0] = point; // If last, update first
		}
	}

	this.points[index] = point;
	
	this.adjustMidMarker(index, -1);
	this.adjustMidMarker(index, 1);

	this.pointsChanged();
};

/**
 * Insert a point at index and if shown, update map
 *
 * @method insertPoint
 * @param {Number} index Index to insert point in polygon
 * @param {LatLng} point LatLng pair ([lat, lng])
 */
MMapPolygon.prototype.insertPoint = function(index, point) {
	var numPoints = this.points.length;

	if (numPoints === 2) { // If 3rd point, then add "closing" point
		this.points.splice(index, 0, point);
		this.points.push(this.points[0]);
	} else { // Otherwise, splice as normal
		this.points.splice(index, 0, point);
	}

	this.adjustMarkers(index, true);
	this.pointsChanged();
};

/**
 * Remove a point from the polygon and if shown, update map
 *
 * @method removePoint
 * @param {Number} index Index of point to remove
 */
MMapPolygon.prototype.removePoint = function(index) {
	var numPoints = this.points.length;
	this.points.splice(index, 1);
	this.removeMarkers(index);

	if (this.points.length === 3 && this.points[0] == this.points[2]) {
		this.points.splice(2, 1);
		this.removeMarkers(2);
	}

	this.pointsChanged();
};

MMapPolygon.prototype.getBounds = function() {
	return this.getPoints();
};

/**
 * Sets polygon as editable (adds point and midpoint markers)
 *
 * @method setEditable
 */
MMapPolygon.prototype.setEditable = function() {
	if (!this.isEditable && this.mapEntity) {
		this.addPointMarkers();
		this.addMidMarkers();
	}

	this.isEditable = true;
};

/**
 * Sets polygon as uneditable (removes point and midpoint markers)
 *
 * @method setUneditable
 */
MMapPolygon.prototype.setUneditable = function() {
	this.removePointMarkers();
	this.removeMidMarkers();
	this.isEditable = false;
};

/**
 * Bind an event listner
 * 
 * @method addEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MMapPolygon.prototype.addEventListener = function(event, listener, context) {
	if (!this.mapEventHandlers[event]) {
		var handler = this.adapter.addEventListener(event, this.mapEventHandler, this);
		this.mapEventHandlers[event] = handler;
	}

	this.observers.addObserver(event, listener, context);
};

/**
 * Unbind an event listener
 *
 * @method removeEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MMapPolygon.prototype.removeEventListener = function(event, listener, 
													  context) {
	this.observers.removeObserver(event, listener, context);

	if (!this.observers.hasObservers(event) && this.mapEventHandlers[event]) {
		this.adapter.removeEventListener(this.mapEventHandlers[event]);
		this.mapEventHandlers[event] = null;
	}
};

/**
 * Check if shape is showable
 *
 * @method showable
 * @return {Boolean} True if showable
 */
MMapPolygon.prototype.showable = function() {
	return this.points.length > 0;
};

/**
 * Show polygon on map
 *
 * @method show
 */
MMapPolygon.prototype.show = function() {
	if (!this.mapEntity && this.showable()) {
		var mapEntity = this.adapter.addPolygon(this);
		this.mapEntity = mapEntity;
	}

	if (this.isEditable && this.points.length && !this.markers.length &&
		!this.midMarkers.length) {
		this.addPointMarkers();
		this.addMidMarkers();
	}

	// @TODO Bind any lower-level events that are being observed
};

/**
 * Remove polygon from map
 *
 * @method hide
 */
MMapPolygon.prototype.hide = function() {
	this.adapter.removePolygon(this);
	this.mapEntity = null;

	// Remove markers
	this.removePointMarkers();
	this.removeMidMarkers();

	// @TODO Unbind any lower-level events being observed
};

/**
 * When points change update map and notify any listeners
 *
 * @prviate
 * @method pointsChanged
 */
MMapPolygon.prototype.pointsChanged = function() {
	if (this.getMapEntity()) {
		this.adapter.updatePolygonPoints(this);
	}

	this.observers.notify('changed', this);
};

/**
 * Adjusts point and mid markers
 *
 * @private
 * @method pointsChanged
 * @param {Number} index Index of point that changed
 * @Param {Boolean} [newPoint] If true, it's a new point (add midmarker)
 */
MMapPolygon.prototype.adjustMarkers = function(index, newPoint) {
	if (this.isEditable && this.getMapEntity()) {
		// Add marker
		var point = this.points[index];
		this.markers.splice(index, 0, this.getPointMarker(point));

		// If more then one points, create/update midpoint markers
		if (this.points.length > 1) {
			this.adjustMidMarker(index, -1);
			// If new point, don't adjust - create a new mid marker
			this.adjustMidMarker(index, 1, newPoint);
		}

		// If 4 points (was 3 + closing point) and it's a new point
		if (this.points.length === 4 && newPoint) {
			this.adjustMidMarker(index + 1, 1);
		}
	}
};

/**
 * Loop through all points and update markers and midmarkers
 *
 * @private
 * @method updateAllMarkers
 */
MMapPolygon.prototype.updateAllMarkers = function() {
	// @TODO
};

/**
 * Remove markers related to a point
 * 
 * @private
 * @method removeMarkers
 * @param {Number} index Index of point that has been removed
 */
MMapPolygon.prototype.removeMarkers = function(index) {
	var numPoints = this.points.length;

	if (this.markers[index]) {
		this.markers[index].hide();
		this.markers.splice(index, 1);
	}

	// If first point
	if (index === 0) {
		if (this.midMarkers[index]) {
			this.midMarkers[index].hide();
			this.midMarkers.splice(index, 1);
		}

		if (numPoints > 2) {
			this.points[numPoints - 1] = this.points[0];
			this.adjustMidMarker(this.midMarkers.length - 1, 1);
		}
	} else {
		if (this.midMarkers[index - 1]) {
			this.midMarkers[index - 1].hide();
			this.midMarkers.splice(index - 1, 1);
		}

		if (index <= this.markers.length) {
			if (this.midMarkers[index - 1]) {		
				this.adjustMidMarker(index, -1);
			}
		}
	}
};

/**
 * If shown, passes polygon options to adapter for map update
 *
 * @private
 * @method updateMapOptions
 */
MMapPolygon.prototype.updateMapOptions = function() {
	if (this.getMapEntity()) {
		this.adapter.updatePolygonOptions(this);
	}
};

/**
 * Sets up point markers
 *
 * @private
 * @method addPointMarkers
 */
MMapPolygon.prototype.addPointMarkers = function() {
	for (var i = 0, l = this.points.length; i < l; i++) {
		if (i === l - 1 && this.points[0] === this.points[l - 1]) {
			continue;
		}

		var marker = this.getPointMarker(this.points[i]);
		this.markers.push(marker);
	}
};

/**
 * Create an instance of MMapMarker that is styled to be a point marker
 *
 * @private
 * @method getPointMarker
 * @param {LatLng} point LatLng ([lat, lng]) for new marker
 * @return {MMapMarker} Instance of MMapMarker for a point
 */
MMapPolygon.prototype.getPointMarker = function(point) {
	var cdn = this.manager.getOption("cdn");
	var options = {
		'icon': cdn + '/images/point_red.png',
		'anchor': [6 ,6],
		'height': 13,
		'width': 13,
		'draggable': true	
	};

	var marker = new MMapMarker(this.manager, point, options);
    marker.addEventListener('dragstart', this.onMarkerDrag, this);
    marker.addEventListener('drag', this.onMarkerDrag, this);
    marker.addEventListener('dragend', this.onMarkerDrag, this);
    marker.addEventListener('rightclick', this.markerRemove, this);
	marker.show();
		
	return marker;
};

/**
 * Delete point markers
 *
 * @private
 * @method removePointMarkers
 */
MMapPolygon.prototype.removePointMarkers = function() {
	// Loop through markers and hide, then clear array
	for (var i = 0, l = this.markers.length; i < l; i++) {
		// @TODO unbind event listeners
		this.markers[i].hide();
	}
	this.markers = [];
};

/**
 * Sets up mid-point markers
 *
 * @private
 * @method addMidMarkers
 */
MMapPolygon.prototype.addMidMarkers = function() {
	for (var i = 0, l = this.points.length; i < l; i++) {
		var point1 = this.points[i];
		var point2 = this.points[i+1];

		if (point1 && point2) { 
			var marker = this.getMidMarker(this.getMidPoint(point1, point2));
			this.midMarkers.push(marker);
		}
	}
};

/**
 * Create an instance of MMapMarker that is styled to be a mid-point marker
 *
 * @private
 * @method getMidMarker
 * @param {LatLng} point LatLng ([lat, lng]) for new mid-point marker
 * @return {MMapMarker} Instance of MMapMarker for a mid-point
 */
MMapPolygon.prototype.getMidMarker = function(point) {
	var cdn = this.manager.getOption("cdn");
	var options = {
		'icon': cdn + '/images/midpoint_red.png',
		'anchor': [6 ,6],
		'height': 11,
		'width': 11,
		'draggable': true	
	};

	var marker = new MMapMarker(this.manager, point, options);
	marker.addEventListener('dragstart', this.midMarkerDrag, this);
	marker.addEventListener('drag', this.midMarkerDrag, this);
	marker.addEventListener('dragend', this.midMarkerDrag, this);
	marker.show();
		
	return marker;
};

/**
 * Delete mid-point markers
 *
 * @private
 * @method removeMidMarkers
 */
MMapPolygon.prototype.removeMidMarkers = function() {
	// Loop through mid-markers and hide, then clear array
	for (var i = 0, l = this.midMarkers.length; i < l; i++) {
		// @TODO unbind event listeners
		this.midMarkers[i].hide();
	}
	this.midMarkers = [];
};

/**
 * Get point in between two points
 *
 * @private
 * @method getMidPoint
 * @param {LatLng} point1 
 * @param {LatLng} point2
 * @return {LatLng} Point between point1 and point2
 */
MMapPolygon.prototype.getMidPoint = function(point1, point2) {
	return [
		point2[0] - (0.5 * (point2[0] - point1[0])),
		point2[1] - (0.5 * (point2[1] - point1[1]))
	];
};

/**
 * Get ref to entity used by map system
 *
 * This is mostly used to tell if the line is shown on the map
 *
 * @private
 * @method getMapEntity
 * @return {Object} Map system specific object the represents the line
 */
MMapPolygon.prototype.getMapEntity = function() {
	return this.mapEntity;
};

/**
 * Redispatches events to listeners
 *
 * @private
 * @method mapEventHandler
 */
MMapPolygon.prototype.mapEventHandler = function(event, details) {
	this.observers.notify(event, this);
};

/**
 * Get index for a marker in the marker array
 *
 * @private
 * @method getMarkerPos
 * @return {Number} Index of marker in marker array
 */
MMapPolygon.prototype.getMarkerPos = function(marker) {
	var pos = null;

	for(var i = 0, l = this.markers.length; i < l; i++) {
		if (this.markers[i] === marker) {
			pos = i;
			break;
		}		
	}

	if (pos === null) {
		throw new Error('Polygon does not contain this marker');
	}

	return pos;
};

MMapPolygon.prototype.getMarkerByEntityId = function(id){
	for(var i = 0, l = this.markers.length; i < l; i++) {
		var ent = this.markers[i].mapEntity.entity;
		if (ent.id === id) {
			return this.markers[i];
		}		
	}
};

/**
 * Get index of marker in mid-marker array
 *
 * @private 
 * @method getMidMarkerPos
 * @return {Number} Index of marker in mid-marker array
 */
MMapPolygon.prototype.getMidMarkerPos = function(marker) {
	var pos = null;

	for(var i = 0, l = this.midMarkers.length; i < l; i++) {
		if (this.midMarkers[i] === marker) {
			pos = i;
			break;
		}		
	}

	if (pos === null) {
		throw new Error('Polygon does not contain this mid marker');
	}

	return pos;
};

/**
 * Remove point from line using marker 
 *
 * This is used to remove a point when marker is righ-clicked on
 * 
 * @private
 * @method markerRemove
 * @param {String} event Event id
 * @param {MMapMarker} marker Marker the event was fired on
 */
MMapPolygon.prototype.markerRemove = function(event, marker, blocking, details) {
	//only for certain adapters (Bing 8)
	var trueTarget = this.adapter.getTrueTarget == undefined ? marker : this.adapter.getTrueTarget(this, details);
	if(trueTarget === marker){
		var pos = this.getMarkerPos(trueTarget);
		this.removePoint(pos);
	}
};

/**
 * Update point using dragged marker
 *
 * @private
 * @method onMarkerDrag
 * @param {String} event Event id
 * @param {MMapMarker} marker Marker the event was fired on
 */
MMapPolygon.prototype.onMarkerDrag = function(event, marker) {
	// Update polygon
	var pos = this.getMarkerPos(marker);
	this.setPoint(pos, marker.getPoint());
};

/**
 * Calculate mid point for mid-marker and update latlng
 *
 * @private
 * @method adjustMidMarker
 * @param {Number} index Index of point that changed
 * @param {Number} direction 1 or -1
 */
MMapPolygon.prototype.adjustMidMarker = function(index, direction, isNew) {
	// literally an edge case
	var lastPoint = this.points.length - 1
	if (index === 0 && direction < 0) {
		index = lastPoint;
	} else if (index === lastPoint && direction > 0) {
		index = 0;
	}

	var point = this.points[index];
 	var adjacentPoint = this.points[index + direction];

	if (point && adjacentPoint) {
 		var midPoint = this.getMidPoint(point, adjacentPoint);
		var midIndex = index - 1;
		if (direction > 0) {
			midIndex++;
		}

		if (this.midMarkers[midIndex] && !isNew) {
			this.midMarkers[midIndex].setPoint(midPoint);
		} else {
			this.midMarkers.splice(midIndex, 0, this.getMidMarker(midPoint));
		}
	}	
};

/**
 * Handle the dragging of a mid-marker. This creates a new point when done
 *
 * @private
 * @method midMarkerDrag
 * @param {String} event Event id
 * @param {MMapMarker} marker Mid-arker the event was fired on
 */
MMapPolygon.prototype.midMarkerDrag = function(event, marker) {
	var pos = this.getMidMarkerPos(marker);
	var point = marker.getPoint();

	if (event === 'dragstart') { // 
		var options = {
			'lineStyle': '4 4'			
		};
		var midPolyline = new MMapPolyline(this.manager, options);
		midPolyline.addPoint(this.points[pos]);
		midPolyline.addPoint(point);
		midPolyline.addPoint(this.points[pos + 1]);

		this.midPolyline = midPolyline;
		midPolyline.show();
	}

	if (event === 'drag') {
		this.midPolyline.setPoint(1, point);	
	}

	if (event === 'dragend') {
		// Adding one to pos so that it's spliced in after the point
		// already in pos
		this.insertPoint(pos + 1, point);

		// Remove polyline
		this.midPolyline.hide();
		this.midPolyline = null;
	}
};

/**
 * Adds some points to the polygon and sets editable
 *
 * @private
 * @method testPolygon
 */
MMapPolygon.prototype.testPolygon = function() {
    this.setEditable();
    this.show();
    this.addPoint([44.04, -123.0742]);
    this.addPoint([44.0375, -123.0743]);
    this.addPoint([44.0376, -123.0696]);
    this.addPoint([44.05, -123.0697]);
};

/**
 * Editable circle class
 *
 */
function MMapCircle(manager, options) {
	if (!options) {
		options = {};
	}

	this.circle;
	this.center = null;
	this.radius = null;
	this.oneKMiles = 1609340; // meters
	this.fiftyFt = 15.24; // meters

	this.markers = [];

	this.lineColor = '#FF0000';
	this.lineAlpha = 204;
	this.lineStyle = options.lineStyle || '';
	this.lineThickness = 3;
	this.fillColor = '#FF0000';
	this.fillAlpha = 127;
	this.isEditable = false;

	this.manager;	
	this.adapter;
	this.mapEntity;
	this.mapEventHandlers = {};
	this.observers = new Moonshadow.Observer();
	
	this.filterFlag = "circle_filter";

	this.init(manager, options);
}

/**
 * Sets up the circle object
 *
 * @private
 * @method init
 */
MMapCircle.prototype.init = function(manager, options) {
	this.manager = manager;
	this.adapter = manager.getAdapter();
};

MMapCircle.prototype.isReady  = function() {
	return (this.center && this.radius);
};

/**
 * Get the current line color
 *
 * @method getLineColor
 * @return {#RGB} Returns the line color in hex (RGB) format
 */
MMapCircle.prototype.getLineColor = function() {
	this.init(manager, options);	
};

/**
 * Get the current line color
 *
 * @method getLineColor
 * @return {#RGB} Returns the line color in hex (RGB) format
 */
MMapCircle.prototype.getLineColor = function() {
	return this.lineColor;
};

/**
 * Set the current line color
 *
 * @method setLineColor
 * @param {#RGB} lineColor Line color
 */
MMapCircle.prototype.setLineColor = function(lineColor) {
	this.lineColor = lineColor;
	this.updateMapOptions();
};

/**
 * Get the current line alpha
 *
 * @method getLineAlpha
 * @return {Number} Integer between 0 (invisible) and 255 (opace) 
 */
MMapCircle.prototype.getLineAlpha = function() {
	return this.lineAlpha;
};

/**
 * Set the current line alpha
 *
 * @method setLineAlpha
 * @param {Number} lineAlpha
 */
MMapCircle.prototype.setLineAlpha = function(lineAlpha) {
	this.lineAlpha = lineAlpha;
	this.updateMapOptions();
};

/**
 * Get the current line style
 *
 * @method getLineStyle
 * @return {String} Line style (dashes)
 */
MMapCircle.prototype.getLineStyle = function() {
	return this.lineStyle;
};

/**
 * Set the current line style
 *
 * @method setLineStyle
 * @param {String} lineStyle Style definition
 */
MMapCircle.prototype.setLineStyle = function(lineStyle) {
	this.lineStyle = lineStyle;
	this.updateMapOptions();
};

/**
 * Get the current line thickness
 *
 * @method getLineThickness
 * @reutrn {Number} Line thickness in pixels
 */
MMapCircle.prototype.getLineThickness = function() {
	return this.lineThickness;
};

/**
 * Set the current line thickness
 *
 * @method setLineThickness
 * @param {Number} lineThickness Thickness in pixels 
 */
MMapCircle.prototype.setLineThickness = function(lineThickness) {
	this.lineThickness = lineThickness;
	this.updateMapOptions();
};

/**
 * Get fill color
 *
 * @method getFillColor
 * @return {#RGB} Fill color
 */
MMapCircle.prototype.getFillColor = function() {
	return this.fillColor;
};

/**
 * Set area fill color
 *
 * @method setFillColor
 * @param {#RGB} fillColor Fill color
 */
MMapCircle.prototype.setFillColor = function(fillColor) {
	this.fillColor = fillColor;
	this.updateMapOptions();
};

/**
 * Get fill alpha
 *
 * @method getFillAlpha
 * @return {#RGB} Fill alpha
 */
MMapCircle.prototype.getFillAlpha = function() {
	return this.fillAlpha;
};

/**
 * Set the current line thickness
 *
 * @method setLineThickness
 * @param {Number} fillAlpha Fill alpha
 */
MMapCircle.prototype.setFillAlpha = function(fillAlpha) {
	this.fillAlpha = fillAlpha;
	this.updateMapOptions();
};

/**
 * Get metadata 
 *
 * @method getMetadata
 * @param {String} id Id of metadata item
 * @return The value or undefined
 */
MMapCircle.prototype.getMetadata = function(id) {
	return this.metadata[id];
};

/**
 * Set metadata 
 *
 * @method setMetadata
 * @param {String} id Id of metadata item
 * @param The value or undefined
 */
MMapCircle.prototype.setMetadata = function(id, value) {
	this.metadata[id] = value;
};

MMapCircle.prototype.getFilter = function() {
	if (!this.isReady()) {
		return null;
	}

	var point = this.getCenter();
	var dist = this.getRadiusMeters();

	return {"lat": point[0], "long": point[1], "radius": dist} 
};

MMapCircle.prototype.getFilterQuery = function() {
	return {
		'query': 'save_stored_state',
		'qid': 'polygonselect',
		'name': 'circle_filter',
		'value': this.getFilter()
	};
};

MMapCircle.prototype.getStatsQuery = function(dsId, shapeId, circle) {
	return {
		'query': 'get_total_count',
		'ds': dsId,
		'int_name': shapeId,
		"circle_filter": this.getFilter()
	};
};

/**
 * Get lines points (lat,lng)
 *
 * @method getPoints
 * @param {Boolean} removeClosing If true, remove closing point
 * @return {LatLng[]} Array of [lat, lng] pairs
 */
MMapCircle.prototype.getPoints = function(removeClosing) {
	if (!this.getCenter() || !this.getRadius()) {
		return null;
	}

	return [this.center, this.radius];
};

/**
 * Set the points and update map if shown
 *
 * @method setPoints
 * @param {LatLng[]} Array of [lat, lng] pairs
 */
MMapCircle.prototype.setPoints = function(points) {
	if (points && points.length > 2) {
		throw new Error('Too many points for circle');
	}

	if (points && points[0]) {
		this.center = points[0];
	}

	if (points && points[0] && points[1]) {
		this.radius = points[1];
	}

	this.pointsChanged();
};

MMapCircle.prototype.addPoint = function(point) {
	if (this.center) {
		return;
	}

	this.center = point;

	if (!this.radius) {
		if (this.radiusDistance) {
			dist = this.radiusDistance;	
		} else {
			var zoom = this.adapter.getZoom();
			var dist = 5 * Math.pow(2, (22 - zoom));		
		}


		if (dist > this.oneKMiles) {
			dist = this.oneKMiles;
		}

		this.radius = this.getUpdatedRadius(point, dist, 90);
	}

	this.show();
	this.pointsChanged();
};

MMapCircle.prototype.getCenter = function() {
	if (!this.center) {
		return null;
	}

	return this.center.slice(0);
};

MMapCircle.prototype.setCenter = function(point) {
	this.center = point;
	this.pointsChanged();
};

MMapCircle.prototype.getRadius = function() {
	if (!this.radius) {
		return null;
	}

	return this.radius.slice(0);
};

MMapCircle.prototype.getRadiusMeters = function() {
	if (!this.center || !this.radius) {
		return 0;
	}

	var p1 = {'coordinates': [this.center[1], this.center[0]]};
	var p2 = {'coordinates': [this.radius[1], this.radius[0]]};
	return gju.pointDistance(p1, p2);
};

MMapCircle.prototype.getRadiusBearing = function() {
    var φ1 = gju.numberToRadius(this.center[0]);
	var λ1 = gju.numberToRadius(this.center[1]);
    var φ2 = gju.numberToRadius(this.radius[0]);
	var λ2 = gju.numberToRadius(this.radius[1]);

	// http://www.movable-type.co.uk/scripts/latlong.html
	var y = Math.sin(λ2-λ1) * Math.cos(φ2);
	var x = Math.cos(φ1)*Math.sin(φ2) -Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
	return Math.atan2(y, x) * 180 / Math.PI;;
};

MMapCircle.prototype.setRadius = function(point) {
	this.radius = point;
	this.pointsChanged();
};

MMapCircle.prototype.getBounds = function() {
	if (!this.getCenter() || !this.getRadius()) {
		return null;
	}

	var bounds = [];
	var center = this.getCenter();
	var dist = this.getRadiusMeters();

	for (var i = 0, l = 360; i < l; i += 90) {
		bounds.push(this.getUpdatedRadius(center, dist, i));
	}

	return bounds;
};

/**
 * Sets editable (adds point markers)
 *
 * @method setEditable
 */
MMapCircle.prototype.setEditable = function() {
	if (!this.isEditable && this.mapEntity) {
		this.addMarkers();
	}

	this.isEditable = true;
};

/**
 * Sets uneditable (removes point markers)
 *
 * @method setUneditable
 */
MMapCircle.prototype.setUneditable = function() {
	this.removePointMarkers();
	this.isEditable = false;
};

/**
 * Bind an event listner
 * 
 * @method addEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MMapCircle.prototype.addEventListener = function(event, listener, context) {
	if (!this.mapEventHandlers[event]) {
		var handler = this.adapter.addEventListener(event, this.mapEventHandler,
													this);
		this.mapEventHandlers[event] = handler;
	}

	this.observers.addObserver(event, listener, context);
};

/**
 * Unbind an event listener
 *
 * @method removeEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MMapCircle.prototype.removeEventListener = function(event, listener, 
													  context) {
	this.observers.removeObserver(event, listener, context);

	if (!this.observers.hasObservers(event) && this.mapEventHandlers[event]) {
		this.adapter.removeEventListener(this.mapEventHandlers[event]);
		this.mapEventHandlers[event] = null;
	}
};

/**
 * Check if shape is showable
 *
 * @method showable
 * @return {Boolean} True if showable
 */
MMapCircle.prototype.showable = function() {
	if (this.getCenter()) {
		return true;
	}

	return false;
};

/**
 * Show on map
 *
 * @method show
 */
MMapCircle.prototype.show = function() {
	if (!this.mapEntity && this.showable()) {
		this.mapEntity = this.adapter.addCircle(this);
	}

	if (this.isEditable && this.mapEntity && !this.centerMarker &&
		!this.radiusMarker) {
		this.addMarkers();
	}

	// @TODO Bind any lower-level events that are being observed
};

/**
 * Remove circle from map
 *
 * @method hide
 */
MMapCircle.prototype.hide = function() {
	this.adapter.removeCircle(this);
	this.mapEntity = null;

	// Remove markers
	this.removePointMarkers();

	// @TODO Unbind any lower-level events being observed
};

/**
 * When points change update map and notify any listeners
 *
 * @prviate
 * @method pointsChanged
 */
MMapCircle.prototype.pointsChanged = function() {
	if (this.getMapEntity()) {
		this.adapter.updateCirclePoints(this);
	}

	this.observers.notify('changed', this);
};

/**
 * Update position of radius marker using radius point
 *
 * @private
 * @method adjustRadiusMarker
 */
MMapCircle.prototype.adjustRadiusMarker = function() {
	if (!this.radiusMarker) {
		return;
	}

	this.radiusMarker.setPoint(this.radius);
};

/**
 * Remove markers related to a point
 * 
 * @private
 * @method removeMarkers
 * @param {Number} index Index of point that has been removed
 */
MMapCircle.prototype.removeMarkers = function(index) {
	var numPoints = this.points.length;

	if (this.markers[index]) {
		this.markers[index].hide();
		this.markers.splice(index, 1);
	}
};

/**
 * If shown, passes circle options to adapter for map update
 *
 * @private
 * @method updateMapOptions
 */
MMapCircle.prototype.updateMapOptions = function() {
	if (this.getMapEntity()) {
		this.adapter.updateCircleOptions(this);
	}
};

/**
 * Sets up markers
 *
 * @private
 * @method addMarkers
 */
MMapCircle.prototype.addMarkers = function() {
	this.centerMarker = this.getPointMarker(this.center);
	this.radiusMarker = this.getPointMarker(this.radius);
};

/**
 * Create an instance of MMapMarker that is styled to be a point marker
 *
 * @private
 * @method getPointMarker
 * @param {LatLng} point LatLng ([lat, lng]) for new marker
 * @return {MMapMarker} Instance of MMapMarker for a point
 */
MMapCircle.prototype.getPointMarker = function(point) {
	var cdn = this.manager.getOption("cdn");
	var options = {
		'icon': cdn + '/images/point_red.png',
		'anchor': [6 ,6],
		'height': 13,
		'width': 13,
		'draggable': true
	};

	var marker = new MMapMarker(this.manager, point, options);
	marker.addEventListener('dragstart', this.onMarkerDrag, this);
	marker.addEventListener('drag', this.onMarkerDrag, this);
	marker.addEventListener('dragend', this.onMarkerDrag, this);
	//marker.addEventListener('rightclick', this.markerRemove, this);
	marker.show();

	return marker;
};

/**
 * Delete point markers
 *
 * @private
 * @method removePointMarkers
 */
MMapCircle.prototype.removePointMarkers = function() {
	if (this.centerMarker) {
		this.centerMarker.hide();
		this.centerMarker = null;
	}

	if (this.radiusMarker) {
		this.radiusMarker.hide();
		this.radiusMarker = null;
	}
};

MMapCircle.prototype.getMapEntity = function() {
	return this.mapEntity;
};

/**
 * Redispatches events to listeners
 *
 * @private
 * @method mapEventHandler
 */
MMapCircle.prototype.mapEventHandler = function(event, details) {
	this.observers.notify(event, this);
};

/**
 * Update point using dragged marker
 *
 * @private
 * @method onMarkerDrag
 * @param {String} event Event id
 * @param {MMapMarker} marker Marker the event was fired on
 */
MMapCircle.prototype.onMarkerDrag = function(event, marker) {
	if (marker === this.centerMarker) {
		var point = marker.getPoint();
		var dist = this.getRadiusMeters();
		var bearing = this.getRadiusBearing();	
		this.radius = this.getUpdatedRadius(point, dist, bearing);
		this.adjustRadiusMarker();

		this.center = marker.getPoint();
	} else if (marker === this.radiusMarker) {
		this.radius = marker.getPoint();

		var bearing = this.getRadiusBearing();	
		var dist = this.getRadiusMeters();
		if (dist > this.oneKMiles || dist < this.fiftyFt) {
			dist = (dist > this.oneKMiles) ? this.oneKMiles : this.fiftyFt;
			this.radius = this.getUpdatedRadius(this.getCenter(), dist, bearing);
			this.adjustRadiusMarker();
		}
	} else {
		return;
	}

	this.pointsChanged();
};

MMapCircle.prototype.setRadiusDistance = function(dist) {
	this.radiusDistance = dist;
	var point = this.getCenter();
	if (!point) {
		return;
	}

	var bearing = this.getRadiusBearing();
	this.radius = this.getUpdatedRadius(point, this.radiusDistance, bearing);
	this.adjustRadiusMarker();
	this.pointsChanged();
};

MMapCircle.prototype.getUpdatedRadius = function(point, dist, bearing) {
	var coord = {'coordinates': [point[1], point[0]]};
	var radius = gju.destinationPoint(coord, bearing, dist / 1000);
	return [radius.coordinates[1], radius.coordinates[0]];
};

/**
 * Draggable Marker class
 *
 * @class MMapMarker
 * @constructor
 * @param {MManager} manager Ref to manager object
 * @param {Object} options Polygon options
 */
function MMapMarker(manager, point, options) {
	if (typeof options === 'undefined') {
		options = {};
	}

	this.setPoint(point);

	this.anchor = options.anchor || [10, 34];
	this.height = options.height || 34;
	this.width = options.width || 20;
	this.zIndex = options.zIndex || 500;
	this.defaultIcon = 'https://lnprodmarker1.moonshadowmobile.net/marker/__default/a8a8a8/0';
	this.icon = options.icon || this.defaultIcon;
	this.type;
	this.content;
	this.text;
	this.textOffset;
	this.state; // hightlighted, selected - bing stuff
	this.draggable = options.draggable || false;

	this.manager;
	this.adapter;
	this.mapEntity;
	this.mapEventHandlers = {};
	this.observers = new Moonshadow.Observer();
	this.metadata = {};

	this.init(manager, options);
};

/**
 * Sets up the marker object
 * @methode init
 */
MMapMarker.prototype.init = function(manager, options) {
	this.mangaer = manager;
	this.adapter = manager.getAdapter();
};

MMapMarker.prototype.getIcon = function() {
	return this.icon;
};

MMapMarker.prototype.setIcon = function(url) {
	this.icon = url;
	this.updateMapOptions();
};

MMapMarker.prototype.getZIndex = function() {
	return this.zIndex;
};

MMapMarker.prototype.setZIndex = function(zIndex) {
	this.zIndex = zIndex;
	this.updateMapOptions();
};

MMapMarker.prototype.getPoint = function() {
	if (!this.point) {
		return null;
	}

	return this.point.slice(0);
};
	
MMapMarker.prototype.setPoint = function(point) {
	if (!point) {
		this.point = null;
		return;
	}

	this.point = point;

	if (this.getMapEntity()) {
		this.adapter.updateMarkerPoint(this);
	}
};

/**
 * Get metadata 
 *
 * @method getMetadata
 * @param {String} id Id of metadata item
 * @return The value or undefined
 */
MMapMarker.prototype.getMetadata = function(id) {
	return this.metadata[id];
};

/**
 * Set metadata 
 *
 * @method setMetadata
 * @param {String} id Id of metadata item
 * @param The value or undefined
 */
MMapMarker.prototype.setMetadata = function(id, value) {
	this.metadata[id] = value;
};

MMapMarker.prototype.getMapEntity = function() {
	return this.mapEntity;
};

MMapMarker.prototype.mapEventHandler = function(eventName, eventDetails) {
	var adapter = this.adapter;

	switch(eventName) {
	case 'mousedown':
		this.mouseDownXY = [eventDetails.pageX, eventDetails.pageY];

		break;
	case 'mouseup':
		// Emit the mouse up event before the click event
		this.observers.notify(eventName, this);

		// Check distance moved between down and up
		// If a small distance, then emit a click event
		if (this.mouseMoveXY && this.proximityCheck(this.mouseDownXY,
													[eventDetails.pageX, eventDetails.pageY])) {
			this.observers.notify('click', this);
		}
		this.mouseDownXY = null;

		return; // Don't this the nromal notify call
		break;
	case 'click':
		return; // This is eaten because the Bing Maps API sucks
		break;
	case 'dragstart':
	case 'drag':
	case 'dragend':
		this.setPoint(adapter.getMarkerPoint(eventDetails));
		break;		
	}

	this.adapter.preventDefault(eventDetails);
	this.observers.notify(eventName, this, false, eventDetails);
};

MMapMarker.prototype.proximityCheck = function(before, after) {
	var xDiff = Math.abs(before[0] - after[0]);
	var yDiff = Math.abs(before[1] - after[1]);
	return xDiff <= 2 && yDiff <= 2;
};

MMapMarker.prototype.addEventListener = function(event, listener, context) {
	var adapter = this.adapter;
	if (!this.mapEventHandlers[event]) {
		var handler = adapter.addEventListener(event, this.mapEventHandler, this);
		this.mapEventHandlers[event] = handler;
	}

    // Now setup this objects event handler
	this.observers.addObserver(event, listener, context);
};

MMapMarker.prototype.removeEventListener = function(event, listener, context) {
	this.observers.removeObserver(event, listener, context);

	if (!this.observers.hasObservers(event)) {
		this.removeMapEventListener(event);
	}
};

MMapMarker.prototype.bindObservedEvents = function() {
	var eventIds = this.observers.getObservedEvents();
	for(var i = 0, l = eventIds.length; i < l; i++) {
		var event = eventIds[i];

	    this.addMapEventListener(event);
	}
};

MMapMarker.prototype.unbindObservedEvents = function() {
	var eventIds = this.observers.getObservedEvents();
	for(var i = 0, l = eventIds.length; i < l; i++) {
		var event = eventIds[i];

		// We are ignoring Microsoft's click event in favor one that
		// doesnt suck (MS's fires on drag....)
		if (event === 'click') {
			// There is now mouse move in Bing, so we piggy back on drag
			eventIds.push('mousedown', 'mouseup');
			continue;
		}

	    this.removeMapEventListener(event);
	}
};

MMapMarker.prototype.addMapEventListener = function(event) {
	// If this object isn't already listening for the map event, then 
	// bind to the map event
	if (!this.mapEventHandlers[event]) {
		var adapter = this.adapter;

		// We are ignoring Microsoft's click event in favor one that
		// doesnt suck (MS's fires on drag....)
		if (event === 'click') {
			this.addMapEventListener('mousedown');
			this.addMapEventListener('mouseup');
			return;
		}

		var handler = adapter.addEventListener(event, this.mapEventHandler,
											   this);
		this.mapEventHandlers[event] = handler;
	}
};

MMapMarker.prototype.removeMapEventListener = function(event) {
	// We are ignoring Microsoft's click event in favor one that
	// doesnt suck (MS's fires on drag....)
	if (event === 'click') {
 		this.removeMapEventListener('mousedown');
		this.removeMapEventListener('mouseup');
		return;
	}

	if (this.mapEventHandlers[event]) {
		var adapter = this.adapter;
		var handle = this.mapEventHandlers[event];
		adapter.removeEventListener(handle);
		delete this.mapEventHandlers[event];
	}
};

MMapMarker.prototype.hasEventListeners = function(event) {
	return this.observers.hasObservers[event];
};

MMapMarker.prototype.updateMapOptions = function() {
	if (this.getMapEntity()) {
		this.adapter.updateMarkerOptions(this);
	}
};

MMapMarker.prototype.isShown = function() {
	return !!this.mapEntity;
};

/**
 * Show marker on map
 * @methode show
 */
MMapMarker.prototype.show = function() {
	if (!this.mapEntity) {
	  	var mapEntity = this.adapter.addMarker(this);
		this.mapEntity = mapEntity;

		this.bindObservedEvents();
	}
};

/**
 * Remove marker from map
 * @methode hide
 */
MMapMarker.prototype.hide = function() {
	this.adapter.removeMarker(this);
	this.mapEntity = null;

	this.unbindObservedEvents();
};

Moonshadow.helpers.extend(MMapMarker, MControl);


function MControlSurveys(options) {
	this.name = "surveys";
	this.manager = null;
	this.surveys = [];
	this.options = options || {};
};

Moonshadow.helpers.extend(MControlSurveys, MControl);

MControlSurveys.prototype.init = function(manager) {
	this.manager = manager;
};

MControlSurveys.prototype.getSurveys = function(liveOnly, callback){
	var self = this;
	var returnSurveys = function(surveys){
		if(liveOnly){
			return callback(self.getFilteredSurveys("final"));
		}
		if(callback){
			return callback(surveys);
		}
		return surveys;
	};
	if(!this.surveys.length){
		this.requestSurveys(returnSurveys);
	}else{
		returnSurveys(this.surveys);
	}
};

MControlSurveys.prototype.getSurveysOfTypes = function(liveOnly, types, callback){
	var self = this;
	var returnSurveys = function(surveys){
		if(liveOnly){
			return callback(self.getFilteredSurveys("final", types));
		}
		if(callback){
			return callback(surveys);
		}
		return surveys;
	};
	if(!this.surveys.length){
		this.requestSurveys(returnSurveys);
	}else{
		returnSurveys(this.surveys);
	}
};

MControlSurveys.prototype.getSurveysOfType = function(type, refresh, callback){
	var self = this;
	if(refresh){
		this.surveys = [];
	}
	this.getSurveys(false, function(surveys){
		var ofTypeSurveys = [];
		for(var i = 0, l = surveys.length; i < l; ++i){
			if(surveys[i].survey_type == type){
				ofTypeSurveys.push(surveys[i]);
			}
		}
		callback(ofTypeSurveys);
	});
}

MControlSurveys.prototype.getAllSurveyIds = function(callback){
	var self = this;
	this.getSurveys(true, function(surveys){
		var surveyIds = [];
		for(var i = 0, l = surveys.length; i < l; ++i){
			surveyIds.push(surveys[i].int_name);
		}
		callback(surveyIds);
	});
};

MControlSurveys.prototype.getSurveyByPropertyName = function(propery, value){
	for(var i = 0,  l = this.surveys.length; i < l; ++i){
		if(this.surveys[i][propery] && this.surveys[i][propery] == value){
			return this.surveys[i];
		}
	}
};

MControlSurveys.prototype.getSurveysByProperties = function(properties){
	var _returnItems = [];
	for(var i = 0,  l = this.surveys.length; i < l; ++i){
		var add = false;
		for(var ii in properties){
			if(!properties.hasOwnProperty(ii)){
				continue;
			}
			if(this.surveys[i][ii] != undefined && this.surveys[i][ii] === properties[ii]){
				add = true;
			}else{
				add = false;
			}
			if(!add){
				break;
			}
		}
		add && _returnItems.push(this.surveys[i]);
	}
	
	return _returnItems;
};

MControlSurveys.prototype.getSurveysFields = function(surveyIds, abbriviate, callback){
	if(surveyIds && (!(surveyIds instanceof Array))){
		surveyIds = [surveyIds];
	}
	var self = this;
	this.getSurveys(true, function(surveys){
		var fieldList = [];
		for(var i = 0, l = surveys.length; i < l; ++i){
			if(surveyIds != undefined && $.inArray(surveys[i].int_name, surveyIds) == -1){
				continue;
			}
			fieldList = fieldList.concat(
				self._extractSurveyFields(surveys[i], abbriviate)
			);
		}
		callback(fieldList);
	});
};

MControlSurveys.prototype.getSurveyFields = function(surveyId){
	return this._extractSurveyFields(
		this.getSurveyByPropertyName("int_name", surveyId)
	);
};

MControlSurveys.prototype.getSurveyQuestionFields = function(surveyId){
	return this._extractSurveyQuestionsFields(
		this.getSurveyByPropertyName("int_name", surveyId)
	);
};

MControlSurveys.prototype.getSurveyMetadataFields = function(surveyId){
	return this._extractSurveyMetadataFields(
		this.getSurveyByPropertyName("int_name", surveyId)
	);
};

MControlSurveys.prototype.getMetaFieldsByType = function(type, surveyId){
	var metafields = this.getSurveyMetadataFields(surveyId);
	var fields = [];
	for(var i = 0, l = metafields.length; i < l; ++i){
		if(metafields[i].metadata_type == type){
			fields.push(metafields[i]);
		}
	}
	return fields;
};

MControlSurveys.prototype.getLiveSurveys = function(){
	return this.getFilteredSurveys("final");
};

MControlSurveys.prototype.getSurveyNames = function(){
	return $(this.surveys).map(function(k, s){
		return $.trim(s.ext_name);
	}).toArray();
};

MControlSurveys.prototype.getSurveyAbbrNames = function(){
	return $(this.surveys).map(function(k, s){
		return $.trim(s.ext_name_abbr);
	}).toArray();
};

MControlSurveys.prototype.questionCount = function(surveyId){
	var survey = this.getSurveyByPropertyName(
		"int_name", surveyId
	);
	if(survey && survey.questions){
		return survey.questions.length;
	}
};

MControlSurveys.prototype.finalizeSurvey = function(surveyId, callback){
	var self = this;
	
	var survey = this.getSurveyByPropertyName(
		"int_name", surveyId
	);
	
	new Moonshadow.Ajax({
		"url": "/surveys/finalize/" + surveyId,
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			if(data.result != "ok"){
				throw new Error(data.error || data.message);
			}else{
				self.reBuildCollections(survey.setName, callback);
			}
			self.manager.dataObservers.notify("surveyfinalized", surveyId);
		}
	});
};

MControlSurveys.prototype.getSurveyStatus = function(surveyId){
	var survey = this.getSurveyByPropertyName(
		"int_name", surveyId
	);
	if(!survey){
		return false;
	}
	if(!survey.deleted && survey.live){
		return "final";
	}
	if(!survey.deleted && survey.status == "draft"){
		return "draft";
	}
	if(survey.deleted){
		return "hidden";
	}
	return false;
};

MControlSurveys.prototype.getFilteredSurveys = function(filterType, surveyTypes){
	var surveys = this.surveys;
	if(surveyTypes){
		surveys = this.getFilteredByType(surveyTypes);
	}
	return $(surveys).filter(function(index, item){
		switch(filterType){
			case "final":
				return !item.deleted && item.live;
			case "draft":
				return !item.deleted && item.status == "draft";
			case "hidden":
				return item.deleted;
			case "surveys":
			default:
				return true;
		}
	})
	.toArray();
};

MControlSurveys.prototype.getFilteredByType = function(surveyTypes){
	if(surveyTypes == undefined){
		surveyTypes = ["groundgame"];
	}
	if(!(surveyTypes instanceof Array)){
		surveyTypes = [surveyTypes];
	}
	return $(this.surveys).filter(function(index, item){
		if($.inArray(item.survey_type, surveyTypes) > -1){
			return true;
		}
		return false;
	})
	.toArray();
};

MControlSurveys.prototype.reBuildCollections = function(setName, callback){
	var manager = this.manager;
	var dsCont = manager.getControl("datasources");
	var dsId = dsCont.getIdByAlias(setName);
	
	dsCont.rebuildStruct([dsId], function () {
		var filtersCont = manager.getControl("filters");
		filtersCont.reBuildCollections(dsId);
		callback && callback();
	});
};

MControlSurveys.prototype.recoverSurvey = function(surveyId, callback){
	var self = this;
	var survey = this.getSurveyByPropertyName(
		"int_name", surveyId
	);
	
	new Moonshadow.Ajax({
		"url": "/surveys/recover/" + surveyId,
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			if(data.result != "ok"){
				throw new Error(data.error || data.message);
			}else{
				self.reBuildCollections(survey.setName, callback);
			}
			self.manager.dataObservers.notify("surveyrecovered", surveyId);
		}
	});
};

MControlSurveys.prototype._extractSurveyFields = function(survey, abbriviate){
	return this._extractSurveyQuestionsFields(survey, abbriviate).concat(this._extractSurveyMetadataFields(survey, abbriviate));
};

MControlSurveys.prototype._extractSurveyQuestionsFields = function(survey, abbriviate){
	return this._extractFields(survey, survey.questions, abbriviate);
};

MControlSurveys.prototype._extractSurveyMetadataFields = function(survey, abbriviate){
	return this._extractFields(survey, survey.metadata, abbriviate);
};

MControlSurveys.prototype._extractFields = function(survey, list, abbriviate){
	var ss = Moonshadow.helpers.sanitizeString;
	
	var pad = function (value) {
	    return value < 10 ? '0' + value : value;
	};
	
	var createOffset = function (date) {
	    var sign = (date.getTimezoneOffset() > 0) ? "-" : "+";
	    var offset = Math.abs(date.getTimezoneOffset());
	    var hours = pad(Math.floor(offset / 60));
	    var minutes = pad(offset % 60);
	    return sign + "" + hours + "" + minutes;
	};
	
	var nameText = ss(survey.ext_name);
	if(abbriviate && survey.ext_name_abbr && survey.ext_name_abbr.length){
		nameText = ss(survey.ext_name_abbr);
	}
	return $(list).map(function(index, field){
		if(field.type != "remark"){
			var fieldName = ss(field.ext_name);
			if(field.ext_name_abbr && field.ext_name_abbr.length){
				fieldName = ss(field.ext_name_abbr);
			}
			var fInfo = {};
			var ext_field_name;
			if(fieldName == "ilat"){
				fInfo.format = "latitude";
				ext_field_name = "latitude";
			}
			if(fieldName == "ilon"){
				fInfo.format = "longitude";
				ext_field_name = "longitude";
			}
			fInfo.int_name = field.int_name;
			fInfo.ext_name = Moonshadow.helpers.capitalize(nameText + ": " + (ext_field_name || fieldName));
			fInfo.type = field.type;
			if(field.metadata_type){
				fInfo.metadata_type = field.metadata_type;					
			}
			if(fieldName == "timestamp" || fieldName == "visited"){
				fInfo.unix_timestamp_as_date = 1;
				fInfo.timezone_offset = createOffset(new Date());
			}
			return fInfo;
		}
	})
	.filter(function(key, val){
		return !!val;
	})
	.toArray();
};



MControlSurveys.prototype.requestSurveys = function(callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/surveys",
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			if(data.result != "ok"){
				throw new Error(data.error || data.message);
			}
			
			if(data.surveys){
				self.surveys = data.surveys;
				callback(data.surveys);
			}
		}
	});
};

MControlSurveys.prototype.createSurvey = function(survey, callback){
	if(!survey.setName){
		survey.setName = this.manager.getDatasource().set_name;
	}
	this.sendSurvey(survey, callback);
};

MControlSurveys.prototype.sendSurvey = function(survey, callback){
	var self = this;
	var onSuccess = function(data){
		$(".survey_save_button").attr("disabled", false);
		if(data.result != "ok"){
			$(".survey_save_button").attr("disabled", false);
			throw new Error(data.error || data.message);
		}else{
			var id;
			if(!survey.int_name){
				id = data.survey.int_name;
				data.survey && self.surveys.push(data.survey);
			}else{
				id = survey.int_name;
			}
			self.manager.dataObservers.notify("surveyadded", id);
			callback && callback(data);
		}
	};
	var onError = function(xhr, text, error){
		$(".survey_save_button").attr("disabled", false);
	};
	
	var ajax = {
		"url": "/surveys",
		"type": "PUT",
		"wrapPost": true,
		"execute": true,
		"payload": survey,
		"onFail": onError,
		"onSuccess": onSuccess
	};
	
	if(survey.int_name){
		ajax.url = "/surveys/" + survey.int_name;
		ajax.type = "POST";
	}
	
	new Moonshadow.Ajax(ajax);
};

MControlSurveys.prototype.disableSurvey = function(surveyId, hidedata, callback){
	var self = this;
	var url ="/surveys/" + surveyId + "/" + (hidedata ? "1" : "0");
	
	var survey = this.getSurveyByPropertyName(
		"int_name", surveyId
	);
	
	new Moonshadow.Ajax({
		"url": url,
		"type": "DELETE",
		"execute": true,
		"onSuccess": function(data){
			if(data.result != "ok"){
				throw new Error(data.error || data.message);
			}else{
				self.manager.dataObservers.notify("surveyremoved", surveyId);
				if(hidedata){
					return self.reBuildCollections(survey.setName, callback);
				}
			}
			callback && callback();
		}
	});
};

/**
 * Control for managing currently active shape
 * 
 * This handles maps events related to manipulating the shape and exposes a
 * place to interograte shape interaction
 * 
 * @class MControlShape
 * @constructor
 * @param {Object} options Control options
 */
function MControlShape(options) {
    this.options = options || {};

    this.name = "shape";
    this.manager = null;
    this.adapter = null;

	this.shape = null;
	this.mouseEvent = null;
	this.shiftKey = false;
	this.observers = new Moonshadow.Observer();

	this.keyDownHandle = null;
	this.mouseDownHandle = null;

	this.disabled = false;
};

/**
 * General control init function
 *
 * @method init
 * @private
 * @param {MManager} manager Instance of MManager
 */
MControlShape.prototype.init = function(manager) {
    this.manager = manager;
    this.adapter = manager.getAdapter();
};

/**
 * Enables shape control after it was disabled
 *
 * @method enable
 */
MControlShape.prototype.enable = function() {
	this.disabled = false;

	if (this.shape) {
		this.bindShape(this.shape);
	}

	this.manager.mapObservers.notify('shapeenabled');
};

/**
 * Disabled shape control
 *
 * @method disable
 */
MControlShape.prototype.disable = function() {
	this.disabled = true;

	if (this.shape) {
		var shape = this.shape;
		this.unbindShape();
		this.shape = shape;
	}

	// Notify listeners that shape control is diabled
	this.manager.mapObservers.notify('shapedisabled');
};

/**
 * Makes a shape the active (interacted with) shape
 * 
 * @method bindShape
 * @param {Shape} shape Shape to bind
 */
MControlShape.prototype.bindShape = function(shape) {
	if (this.shape) {
		if (this.shape === shape) {
			// If same shape do nothing
			return;
		} else {
			// Remove event handlers
			this.adapter.removeMapListener(this.keyDownHandle);
			this.keyDownHandle = null;
			this.adapter.removeMapListener(this.mouseDownHandle);
			this.mouseDownHandle = null;

			this.shape.removeEventListener('changed', this.onShapeChange, this);
			this.shape.setUneditable();
		}		
	}

	this.shape = shape;

	if (this.disabled) {
		return;
	}

	shape.setEditable();

	// Setup event handlers
	this.shape.addEventListener('changed', this.onShapeChange, this);

	// Bind map listeners
	this.keyDownHandle = this.adapter.addMapListener('keydown', this, this.onKeyDown);
	this.mouseDownHandle = this.adapter.addMapListener('mousedown', this, this.onMouseDown);

	this.adapter.enableCrosshair();
	this.shape.show();

	// Listen for shapechanged even so we can update filters
	this.manager.addAjaxEventListener('shapechanged', this);

	// Update filters and counts
	this.notifyShapechanged();
};

/**
 * Unbind currently active shape
 *
 * @method unbindShape
 */
MControlShape.prototype.unbindShape = function() {
	if (this.shape) {
		// Remove event handlers
		this.shape.removeEventListener('changed', this.onShapeChange, this);
		this.shape.setUneditable();
		this.shape = null;
		this.mouseEvent = null;
	}

	this.adapter.removeMapListener(this.keyDownHandle);
	this.keyDownHandle = null;
	this.adapter.removeMapListener(this.mouseDownHandle);
	this.mouseDownHandle = null;

	this.adapter.disableCrosshair();

	// Update filters and counts
	this.notifyShapechanged();
};

/**
 * Notify shapechanged listeners
 * 
 * @method notifyShapechanged
 * @private
 */
MControlShape.prototype.notifyShapechanged = function() {

	var datasources = this.manager.getControl('datasources').getAll();
	var dsIds = [];
	for (var id in datasources) {
		this.setDatasourceFilter(id)
		dsIds.push(id);
	}

	this.manager.mapObservers.notify('shapechanged', dsIds, true);
};

MControlShape.prototype.setDatasourceFilter = function(dsId){
	var active = this.isActive();
	var shape = this.getShape();
	
	var filtersControl = this.manager.getControl("filterscontrol");
	
	filtersControl.clearFilterValue(dsId, "circle_filter");
	filtersControl.clearFilterValue(dsId, "__polygon");
	
	if(active && shape){
		filtersControl.setFilterValue(dsId, shape.filterFlag, shape.getFilter());
	}
};

MControlShape.prototype.getFilterValues = function(dsId){
	var filtersControl = this.manager.getControl("filterscontrol");
	var filters = filtersControl.filtersToJSON(dsId);
	delete filters["circle_filter"];
	delete filters["__polygon"];
	return filters;
}

/**
 * Add polygon def to query bundle
 * 
 * @method addFilterQuery
 * @private
 * @param {Ajax} ajax Bundle to hold query
 */
MControlShape.prototype.addFilterQuery = function(ajax) {
	// Get points, except "closing" points
	if(!this.shape) {
		throw new Error('Cannot add a filter query for a null shape.');
	}

	ajax.addQuery(this.shape.getFilterQuery(), this, true);
};

/**
 * AjaxEvent listener
 * 
 * Used to listen for shapechanges and add polygon filter too
 *
 * @method onAjaxEvent
 * @private
 * @param {String} event Event Id
 * @param {Object} data EVent details
 * @param {Ajax} ajx Ajax bundle to add queries to
 */
MControlShape.prototype.onAjaxEvent = function(event, data, ajax) {
	if (event === 'shapechanged' && this.shape) {
		this.addFilterQuery(ajax);
	}	
};

/**
 * Required response listener
 *
 * @method onAjaxResponse
 * @private
 */
MControlShape.prototype.onAjaxResponse = function() {};

/**
 * Do we have an active (bound) shape
 * 
 * @method isActive
 * @return {Boolean} true if we have an active shape, false if not
 */
MControlShape.prototype.isActive = function() {
	return !!this.shape;
};

MControlShape.prototype.getShape = function() {
	return this.shape;
};

MControlShape.prototype.getFilter = function() {
	if (!this.shape) {
		return null;
	}

	return this.shape.getFilter();
};

MControlShape.prototype.getType = function() {
	if (!this.isActive()) {
		return null;
	}

	if (this.shape instanceof MMapPolygon) {
		return 'polygon';
	} 

	if (this.shape instanceof MMapCircle) {
		return 'circle'
	}

	throw new Error('Unknown shape type');
};

/**
 * Event listener for onShapeChange event
 *
 * @method onShapeChange
 * @private
 * @param {String} event event id
 * @param {Shape} shape Shape that emitted the event
 */
MControlShape.prototype.onShapeChange = function(event, shape) {
	this.notifyShapechanged();
};

MControlShape.prototype.onKeyDown = function(event, details) {
	if (details.shiftKey) {
		this.shiftKey = true;
	}

	if (!this.keyUpHandle) {
		this.keyUpHandle = this.adapter.addMapListener('keyup', this, this.onKeyUp);
	}
};

MControlShape.prototype.onKeyUp = function(event, details) {
	if (!details.shiftKey) {
		this.shiftKey = false;
	}

	if (this.keyUpHandle) {
		this.adapter.removeMapListener(this.keyUpHandle);
		this.keyUpHandle = null;
	}	
};

/**
 * onMouseDown event listener
 *
 *
 * @method onMouseDown
 * @private
 * @param {String} event event id
 * @param {Event} details Event details
 */
MControlShape.prototype.onMouseDown = function(event, details) {
	if (event !== 'mousedown') {
		return;
	}

	// Secondary is for removing points, not adding them
	if (this.adapter.isRightClick(details)) {
		this.adapter.preventDefault(details);
		return;
	}

	// Don't add points when clicking markers
	if (details.targetType === 'pushpin') {
		return;
	}

	// If shift key is down, don't add point
	if (this.shiftKey) {
		return;
	}

	this.mouseEvent = details;

	this.mouseMoveHandle = this.adapter.addMapListener('mousemove', this, this.onMouseMove);
	this.mouseUpHandle = this.adapter.addMapListener('mouseup', this, this.onMouseUp);
};

/**
 * onMouseMove event listener
 *
 *
 * @method onMouseMove
 * @private
 * @param {String} event event id
 * @param {Event} details Event details
 */
MControlShape.prototype.onMouseMove = function(event, details) {
	if (event === 'mousemove' && this.mouseEvent) {
		var startPos = this.adapter.getPointFromEvent(this.mouseEvent);
		var curPos = this.adapter.getPointFromEvent(details);

		if (Math.abs(startPos[0] - curPos[0]) > 2 ||
			Math.abs(startPos[1] - curPos[1]) > 2) {
			this.doneListeningForMovement();
		}
	}
};

/**
 * onMouseUp event listener
 *
 *
 * @method onMouseUp
 * @private
 * @param {String} event event id
 * @param {Event} details Event details
 */
MControlShape.prototype.onMouseUp = function(event, details) {
	if (event === 'mouseup' && this.mouseEvent && !this.mouseEvent.handled) {
		var location = this.adapter.getLocationFromEvent(this.mouseEvent);
		if(!this.shape) {
			throw new Error('Cannot handle mouseup event for shape: '+this.shape);
		}

		this.shape.addPoint([location.latitude, location.longitude]);
	}

	this.doneListeningForMovement();
};

/**
 * Call when no longer insterested in tracking mouse events after a mousedown
 *
 * @method doneListenerForMovement
 * @private
 */
MControlShape.prototype.doneListeningForMovement = function() {
	if (this.mouseMoveHandle) {
		this.adapter.removeMapListener(this.mouseMoveHandle);
	}

	if (this.mouseUpHandle) {
		this.adapter.removeMapListener(this.mouseUpHandle);
	}

	this.mouseEvent = null;
	this.mouseMoveHandle = null;
	this.mouseUpHandle = null;
};

/**
 * Bind an event listner
 * 
 * @method addEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MControlShape.prototype.addEventListener = function(event, listener, context) {
	this.observers.addObserver(event, listener, context);
};

/**
 * Unbind an event listener
 *
 * @method removeEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MControlShape.prototype.removeEventListener = function(event, listener, 
													  context) {
	this.observers.removeObserver(event, listener, context);
};

Moonshadow.helpers.extend(MControlShape, MControl);
/**
 *
 * @class MControlAdSales
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlAdSales(options) {
	this.name = "adsales";
	this.manager = null;
	this.options = options || {};
	this.container = null;
};

MControlAdSales.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	init: function(manager) {
		this.manager = manager;
		this.container = document.createElement("div");
		this.buildAdSalesUI();
		this.manager.addMapObserver("filtersloaded", this.showAdSalesPopup, this);
	},
	/**
	 *
	 * @methodbuildAdSalesUI
	 */
	buildAdSalesUI: function(){
		var control = this;
		this.asui = {
			"universe": null,
			"customerInfo": {},
			"selectedFirms": [],
			"allFirms": [],
			"allFirmTypes": [],
			"sendInfo": true,
			"emailInfo": true,
			"fetched": false,
			"extraErrorInfo": "",
			"allContactFields": ["first_name","last_name","email","street1","street2","city","state","zip","country","phone1","phone2","fax"],
			"requiredContactFields": ["first_name","last_name","email","street1","city","state","zip","country"],
			"descriptionHeader": "You selected the voters. Now let's contact them with QuickConnect!",
			"descriptionText": "QuickConnect can help you reach the voters in universes you create. " +
				"Start by selecting that universe from the list " +
				"on the right and we'll then help connect you to the firms that can " +
				"fulfill your mail plan, conduct a telemarketing campaign, place a cable " +
				"television 'buy', initiate a poll or deploy online ads. You'll be able " +
				"to learn about each firm and then contact it through " +
				"QuickConnect, sending it either an inquiry or the actual " +
				"data that firm will need to fulfill your campaign plans. Pick " +
				"and choose from multiple mail houses, telemarketing firms and " +
				"pollsters with no obligation on your part.",
			"descriptionText2": "After creating a universe, you'll find a new \"Contact These Voters\" icon " +
				"<img src='https://cdn1.moonshadowmobile.net/images/adSales.png'> under your universe name. Click " +
				"on that icon and follow the instructions to share your data with a chosen vendor or initiate an inquiry.",
			"sendInfoText":"Please send my selected voter universe directly to the firms I choose in the following screens. ",
			"sendInfoDescription":"This option will send an email to your chosen firms with your contact " +
				"information, comments and the actual records of the voters in the universe you have selected.",
			"doNotSendInfoText":"Please send my inquiry to the firms I choose but do not send my data. ",
			"doNotSendInfoDescription":"This option will send an email with your contact information and comments only.",
			"reqPurch":"You are attempting to send a universe to a firm but you have not yet purchased all records in that universe. " +
				"Please return to VoterMapping.com and purchase the records in this universe so that they will be available for export. " +
				"You may still send an inquiry to this firm without purchasing or delivering your universe.  To do so, close this box by " +
				"clicking \"OK\" then click the \"Back\" button and change your selection to an inquiry without sending data.",
			"finalMessage1": "You're one click away from sending your inquiry and universe to the companies shown below. " + 
				"If you already have a relationship with any one of these firms, be sure to include instructions for how you would " +
				"like them to handle your universe.  The firms will receive your message directly from VoterMapping.com and will be able to " +
				"access the universe you've chosen. They'll get right back in touch with you to confirm receipt or answer your questions.",
			"finalMessage2": "You're one click away from sending your inquiry to the companies shown below. These " +
				"firms will receive your message directly from VoterMapping.com and will get right back in touch with you to answer " +
				"your questions.  Because you have chosen only to initiate an inquiry, the firms receiving your message will not " +
				"have access to this universe.",
			/**
			 *
			 * @method learnMore
			 * @param {} universeControl
			 */
			"learnMore": function(universeControl, animate){
				var adsalepanel = document.createElement("div");
				adsalepanel.className = "learn_more_panel";
				control.asui.adSalesPages.learnMorePage(adsalepanel, universeControl, function(adsalepanel){
					var _learnMore = new MUILayoverPanel({
						"id": "adsales", 
						"content": adsalepanel, 
						"title": "Contact Your Voters",
						"animate": {
							"onClose": true,
							"onOpen": animate
						}
					});
					_learnMore.open();
				});
			},
			/**
			 *
			 * @method adSalesPanel
		 	 * @param {} universe
			 */
			"adSalesPanel": function(universe, animate){
				this.universe = universe;
				var adsalepanel = document.createElement("div");
				control.asui.selectedFirms = [];
				control.asui.adSalesPages.page1(adsalepanel, function(adsalepanel){
					var prev = MUILayoverPanel.get("adsales");
					if(prev){
						prev.animate = false;
						prev.close();
					}
					var _adSalesPanel = new MUILayoverPanel({
						"id": "adsales", 
						"content": adsalepanel, 
						"title": "Contact Your Voters",
						"animate": {
							"onClose": true,
							"onOpen": animate
						}
					});
					_adSalesPanel.open();
				});
			},
			/**
			 *
			 * @method showSelectedFirms
			 * @param {} universe
			 */
			"showSelectedFirms": function(universe){
				this.universe = universe;
				var adsalepanel = document.createElement("div");
				adsalepanel.className = "show_selected_firms";
				var firmsListObj = {};
				for(var i = 0, l = control.asui.allFirms.length; i < l; ++i){
					firmsListObj[control.asui.allFirms[i].customername] = control.asui.allFirms[i];
				}
				for(var i = 0, l = universe.firms.length; i < l; ++i){
					if(firmsListObj[universe.firms[i].customername])
						universe.firms[i] = firmsListObj[universe.firms[i].customername];
				}
				control.asui.adSalesPages.selectedFirmsPage(adsalepanel, universe.firms, function(adsalepanel){
					var _selectedFirms = new MUILayoverPanel({
						"id": "adsales", 
						"content": adsalepanel, 
						"title": "View Firms",
						"animate": true
					});
					_selectedFirms.open();
				});
			},
			/**
			 *
			 * @method clearPanel
			 * @param {} adsalepanel
			 */
			"clearPanel": function(adsalepanel){
				MUILayoverPanel.feedback("adsales");
				$(adsalepanel).empty();
			},
			/**
			 *
			 * @method existingContactInfo
			 * @param {} callback
			 */
			"existingContactInfo": function(callback){
				if(!control.asui.customerInfo.email){
					new Moonshadow.Ajax({
						"url": "/customer/get/contactinfo/billing",
						"type": "GET",
						"execute": true,
						"onSuccess": function(data){
							new Moonshadow.Ajax({
								"url": "/user/details",
								"type": "GET",
								"execute": true,
								"onSuccess": function(details){
									control.asui.customerInfo = data.addressInfo[0];
									control.asui.customerInfo.email = details.user.email;
									callback(control.asui.customerInfo);
								}
							});
						}
					});
				}else{
					callback(control.asui.customerInfo);
				}
			},
			/**
			 *
			 * @method getFirms
			 * @param {} callback
			 */
			"getFirms": function(callback){
				if(!control.asui.fetched){
					new Moonshadow.Ajax({
						"url": "/firms/getallforapp",
						"type": "GET",
						"execute": true,
						"onSuccess": function(data){
							control.asui.fetched = true;
							if(data.result == "ok"){
								control.asui.allFirms = data.firms;
								return callback(data.firms);
							}
							
							callback([]);
						},
						"onFail": function(data){
							if(data.status != 404){
								throw new Error("Unhandled ajax failure: " + data.result
										+ " - " + (data.message || data.error));
							}
							
							callback([]);
						}
					});
				}else{
					callback(control.asui.allFirms);
				}
			},
			/**
			 *
			 * @method getPartisanships
			 * @param {} callback
			 */
			"getPartisanships": function(callback){
				var getFirmPart = function(allFirms){
					var partisanships = [];
					for(var i = 0, l = allFirms.length; i < l; ++i){
						if($.inArray(allFirms[i].partisanship, partisanships) == -1)
							partisanships.push(allFirms[i].partisanship);
					}
					callback(partisanships);
				}
				if(!control.asui.fetched){
					control.asui.getFirms(getFirmPart)
				}else{
					getFirmPart(control.asui.allFirms);
				}
			},
			/**
			 * 
	 		 * @method getFirmTypes
			 * @param {} callback
			 */
			"getFirmTypes": function(callback){
				if(!control.asui.allFirmTypes.length){
					new Moonshadow.Ajax({
						"url": "/firms/typesforapp",
						"type": "GET",
						"execute": true,
						"onSuccess": function(data){
							if(data.result == "ok"){
								control.asui.allFirmTypes = data.types;
								return callback(data.types);
							}
							
							callback([]);
						}
					});
				}else{
					callback(control.asui.allFirmTypes);
				}
			},
			/**
			 *
			 * @method submitRequest
			 */
			"submitRequest": function(){
				var self = this;
				var submit = function(){
					$(self).removeClass("clickable").addClass("wait");
					var obj = control.asui.gatherFormInfo();
					new Moonshadow.Ajax({
						"url": "/exportal/queue",
						"payload": obj,
						"execute": true,
						"wrapPost": true,
						"onSuccess": function(data){
							$(self).removeClass("wait");
							if(data.result == "ok"){
								var firmsListObj = {};
								for(var i = 0, l = control.asui.allFirms.length; i < l; ++i){
									firmsListObj[control.asui.allFirms[i].customername] = control.asui.allFirms[i];
								}
								for(var i = 0, l = control.asui.selectedFirms.length; i < l; ++i){
									control.asui.universe.firms.push(firmsListObj[control.asui.selectedFirms[i]]);
								}
								control.asui.refreshUniverse();
								MUILayoverPanel.alert({
									"message": "Success!",
									"callback": function(res, id, hide){
										MUILayoverPanel.close("adsales");
										hide();
									}
								});
							}else{
								throw new Error(data.error || data.message);
							}
						}
					});
				};
				
				MUILayoverPanel.confirm({
					"message": "Are you sure you want to send information to these firms?",
					"callback": function(res, id, hide){
						if(res){
							submit();
						}
						hide();
					}
				});
			},
			/**
			 *
			 * @cancelRequest
			 * @param firm
			 */
			"cancelRequest": function(firm){
				var obj = {
					"firm": firm,
					"universe": control.asui.universe.int_name,
					"status": "canceled"
				};
				
				for(var i = 0, l = control.asui.universe.firms.length; i < l; ++i){
					if(control.asui.universe.firms[i].customername == firm){
						$(control.asui.universe.firms[i].firmItem).remove();
						control.asui.universe.firms.splice(i, 1);
						break;
					}
				}
				
				var showSelectedFirms = $(".show_selected_firms");
				
				new Moonshadow.Ajax({
					"url": "/exportal/status",
					"payload": obj,
					"execute": true,
					"wrapPost": true,
					"onSuccess": function(data){
						if(data.result != "ok"){
							throw new Error(data.error || data.message);
						}
					}
				});
				
				control.asui.refreshUniverse();
				if($(".firms_panel .firm_container_link").length){
					showSelectedFirms.empty();
					return control
						.asui
						.adSalesPages
						.selectedFirmsPage(
							showSelectedFirms,
							control
								.asui
								.universe
								.firms,
							function(){}
						);
				}
				MUILayoverPanel.close("adsales");
				
			},
			/**
	 		 *
			 * @method refreshUniverse
			 */
			"refreshUniverse": function(){
				control.asui.universe.refreshUi();
			},
			/**
			 *
			 * @param holdCustomerInfo
			 */
			"holdCustomerInfo": function(){
				MUILayoverPanel.feedback("adsales");
				if(control.asui.validateFields()){
					$(".asf").each(function(key, item){
						item.value && (control.asui.customerInfo[item.name] = item.value);
					});
					control.asui.sendInfo = $("input[name='allowAccess']:checked").val() == "true" ? true : false;
					return true;
				}else{
					$(this).removeClass("wait");
					MUILayoverPanel.feedback("adsales", "Please supply missing information.", "adsales_error",  control.asui.extraErrorInfo);
					return false;
				}
			},
			/**
			 *
			 * @method holdAgencies
			 */
			"holdAgencies": function(suppressWarning){
				if(suppressWarning){
					control.asui.selectedFirms = $("input[name='firm']:checked").map(function(){
					    return this.value;
					}).toArray();
					return true;
				}
				MUILayoverPanel.feedback("adsales");
				if(control.asui.validateFields()){
					control.asui.selectedFirms = $("input[name='firm']:checked").map(function(){
					    return this.value;
					}).toArray();
					return true;
				}else{
					$(this).removeClass("wait");
					MUILayoverPanel.feedback("adsales", "Please supply missing information.", "adsales_error", control.asui.extraErrorInfo);
					return false;
				}
			},
			/**
			 *
			 * @method gatherFormInfo
			 */
			"gatherFormInfo": function(){
				var emailInfo = $.map($("input[name='emailInfo']"), function(elem){
					return $(elem).val()
				});
				
				var obj = {
					"sendInfo": control.asui.sendInfo,
					"emailInfo": emailInfo,
					"firms": control.asui.selectedFirms,
					"universe": {
						"filter_comp": control.asui.universe.explainFilters(),
						"int_name": control.asui.universe.int_name,
						"ext_name": control.asui.universe.ext_name,
					},
					"customer": control.asui.customerInfo
				}
				if(control.asui.universe.description.length){
					obj.universe.description = control.asui.universe.description;
				}
				if($(".asl_comments").val().length > 0){
					obj.customer.comments = $(".asl_comments").val();
				}
				return obj;
			},
			/**
			 *
			 * @method validateFields
			 */
			"validateFields": function(){
				var isValid = true;
				control.asui.extraErrorInfo = "";
				$(".agent_title").removeClass("missing");
				$(".required").each(function(){
					$(this).removeClass("missing");
					if(!this.value.length){
						$(this).addClass("missing");
						isValid = false;
					}
				});
				
				if($("input[name='firm']").length){
					if(!$("input[name='firm']:checked").length){
						$(".agent_title").addClass("missing");
						control.asui.extraErrorInfo += " Please select one of the firms shown below by clicking the checkbox next to its name. ";
						isValid = false;
					}
				}
				
				return isValid;
			},
			/**
			 *
		 	 * @method addField
			 * @param {} name
			 * @param {} value
			 */
			"addField": function(name, value){

				var l = document.createElement("label");
				l.className = name + "_asl asl";
				
				var f = document.createElement("input");
				f.name = name;
				f.className = name + "_asf asf";
				f.type = "text";
				if(value)
					f.value = value;
				
				var req;
				for(var i = 0, ll = control.asui.requiredContactFields.length; i < ll; ++i){
					if(control.asui.requiredContactFields[i] == name){
						req = document.createElement("p");
						req.appendChild(document.createTextNode("*"));
						f.className += " required";
						break;
					}
				}
				
				$(l).append(Moonshadow.helpers.capitalize(name.replace("_"," ")) + ": ", !!req && req, f);

				return l;
			},
			"buildFirmsList": function(includeChecks, includeCancels, firms, callback){
				
				var ce = control.ce;

				var processFirms = function(firms){
					control.asui.getFirmTypes(function(types){
						if(firms.length){
							types.sort(function(a, b){
								return a.type > b.type ? 1 : (a.type < b.type ? -1 : 0);
							});
						
							var firmTypeHeaders = {};
							for(var i = 0, l = types.length; i < l; ++i){
								firmTypeHeaders[types[i].type] = { 
									"elem": $(ce("div"))
										.addClass("firmtype_heading bigger")
										.append(types[i].description),
									"purchaseRequired": types[i].purchase_required 
								};
							}
	
							var firmsByType = {};
							for(var i = 0, l = firms.length; i < l; ++i){
								if(!firms[i].firmLogoAnchor)
									firms[i].firmLogoAnchor = $(ce("a"))
										.addClass("firm_link")
										.attr({
											"target": "_blank",
											"href": firms[i].url,
											"title": firms[i].description,
											"src": firms[i].logoUrl
										});
								
								if(!firmsByType[firms[i].firmType])
									firmsByType[firms[i].firmType] = [];
								
								if(!firms[i].firmItem){
									firms[i].firmItem = $(ce("div"))
										.addClass("firm_container_link partisanship_" + firms[i].partisanship)
										.append(
											$(ce("div"))
												.addClass("firm_title")
												.append(
													$(ce("input"))
														.addClass("firm_check")
														.attr({
															"type": "checkbox",
															"name": "firm",
															"value": firms[i].customername,
															"checked": (firms.length == 1)
														}),
													$(ce("input"))
														.addClass("firm_cancel hide")
														.attr({
															"type": "button",
															"value": "Cancel request",
														}),
													firms[i].name
												),
											$(ce("div"))
												.addClass("firm_label")
												.append(
													firms[i].firmLogoAnchor,
													function(){
														if(firms[i].logoUrl){
															return $(ce("div"))
																.addClass("loading_firm_wait");
														}else{
															return "";
														}
													}()
												),
											$(ce("div"))
												.addClass("firm_description")
												.append(firms[i].description),
											$(ce("div"))
												.addClass("clear")
										);
								}else{
									$(firms[i].firmItem).removeClass("hide");
									if(!firmTypeHeaders[firms[i].firmType].purchaseRequired && 
											!includeCancels && 
											control.asui.sendInfo){
										$(firmListItemCont)
										.append(
											$(ce("div"))
												.addClass("no_purchase_required")
												.append(
													"(Full universe purchase not required for contacting online ad-firms.)"
												)
										);
								}
								}
								firmsByType[firms[i].firmType].push(firms[i].firmItem);
							}
							
							var firmListElems = [];
							for(var i in firmTypeHeaders){
								if(firmTypeHeaders.hasOwnProperty(i)){
									if(firmsByType[i] && firmsByType[i].length){
										
										var firmListItemCont = $(ce("div"))
											.addClass("firm_type_item type_" + i.replace(" ", ""))
											.append(firmTypeHeaders[i].elem);
										
										if(!firmTypeHeaders[i].purchaseRequired && 
												!includeCancels && 
												control.asui.sendInfo){
											$(firmListItemCont)
												.append(
													$(ce("div"))
														.addClass("no_purchase_required")
														.append(
															"(Full universe purchase not required for contacting online ad-firms.)"
														)
												);
										}
										
										for(var j = 0, l = firmsByType[i].length; j < l; ++j){
											var firmCheck = $(".firm_check", firmsByType[i][j]).removeClass("hide").get(0);
											var firmTitle = $(".firm_title", firmsByType[i][j]);
											if(includeChecks){
												$(".firm_cancel", firmsByType[i][j]).addClass("hide");
												if($.inArray(firmCheck.value, control.asui.selectedFirms) > -1){
													firmCheck.checked = true;
												}else{
													firmCheck.checked = false;
												}
												if(firmTypeHeaders[i].purchaseRequired && 
														!control.asui.universe.allRecordsPurchased() &&
														control.asui.sendInfo){
													firmCheck.checked = false;
													$(firmCheck).addClass("disabled");
												}else{
													$(firmCheck).removeClass("disabled");
												}
												$(firmCheck)
													.unbind("click")
													.click({"reqPurch":control.asui.reqPurch}, function(e){
														this.checked = !this.checked;
													});
												$(firmTitle)
													.unbind("click")
													.click({"reqPurch":control.asui.reqPurch, "firmCheck": firmCheck}, function(e){
														if($(e.data.firmCheck).hasClass("disabled") && !e.data.firmCheck.checked){
															e.data.firmCheck.checked = false;
															MUILayoverPanel.alert(e.data.reqPurch);
														}else{
															e.data.firmCheck.checked = !e.data.firmCheck.checked;
														}
													});
											}
											
											firmListItemCont.append(firmsByType[i][j]);
											
											if(includeCancels){
												$(firmTitle).unbind("click");
												$(".firm_cancel", firmsByType[i][j])
													.unbind("click")
													.click({
															"firm": firmCheck.value,
															"control": control
														}, function(e){
															var cancel = e.data.control.asui.cancelRequest
															MUILayoverPanel.confirm({
																"message": "Cancel the request to this firm?",
																"callback": function(res, id, hide){
																	if(res){
																		cancel(e.data.firm);
																	}
																	hide();
																}
															});
														}
													)
													.removeClass("hide");
												$(".purchase_required", firmsByType[i][j]).addClass("hide");
												$(".firm_check", firmsByType[i][j]).addClass("hide");
											}

											if(j < l - 1)
												firmListItemCont.append($(ce("div"))
													.addClass("divider"));
										}
										firmListElems.push(firmListItemCont);
									}
								}
							}
	
							callback($(firmListElems).map(function(key, item){
								return $(item).toArray();
							}));
							
							for(var i = 0, l = firms.length; i < l; ++i){
								var firm = firms[i];
								if(firm.logoUrl){
									$(".loading_firm_wait", firm.firmItem).remove();
									firm.logoUrl = firm.logoUrl;
									firm.firmLogoAnchor.className = "firm_logo";
									firm.firmItem.className = "firm_container_img";
									
									$(firm.firmLogoAnchor).empty().append(
										$(ce("img"))
											.attr({
												"src": firm.logoUrl,
												"title": firm.description
											})
									);
									$(".full_purch_text.hide").removeClass("hide");
								}
							}
						}else{
							callback($(ce("div"))
								.addClass("contact_option missing")
								.append("No Firms!"));
						}
					});
				}
				
				if(firms){
					processFirms(firms);
				}else{
					control.asui.getFirms(processFirms);
				}
			},
			"adSalesPages" : {
				/**
				 *
				 * @method learnMorePage
				 * @param {} adsalepanel
				 * @param {} universControl
				 * @param {} callback
				 */
				"learnMorePage": function(adsalepanel, universeControl, callback){
					var ce = control.ce;
					$(adsalepanel).append(
						$(ce("div"))
							.addClass("as_content left")
							.append(
								$(ce("h4"))
									.addClass("as_universe_title agent_title")
									.append(control.asui.descriptionHeader),
								$(ce("span"))
									.addClass("as_description")
									.append(control.asui.descriptionText)
							),
						$(ce("div"))
							.addClass("as_content left constricted")
							.append(
								function(){
									if(universeControl.getNumChildren() > 0)
										return [
										    $(ce("h4"))
										        .addClass("as_universe_title agent_title")
										        .append("Start by selecting one of your universes.")
										        .get(0),
											$(ce("div"))
												.addClass("adsalepanel_universe_selection")
												.append(
													function(){
														var returnArray = [];
														for(var i in universeControl.children){
															var item = universeControl.children[i];
															if(universeControl.children.hasOwnProperty(i)){
																returnArray.push($(ce("span"))
																	.addClass("clickable universe_list")
																	.append(item.ext_name)
																	.click({
																			"control": control, 
																			"universe": item
																		}, function(e){
																			control.asui.adSalesPanel(e.data.universe);
																	})
																	.get(0));
															}
														}
														return returnArray;
													}()
												)
												.get(0)
											];
									
										var returnElems = [$(ce("h4"))
											.addClass("as_universe_title agent_title")
											.append("Start by creating a universe.")
											.get(0)];
	
										if(universeControl.getControl().options.universe_docs && 
												universeControl.getControl().options.universe_docs.length) {
											var docs = universeControl.getControl().options.universe_docs;
											
											var docElems = $(docs).map(function(key, item){
												return $(ce("a"))
													.addClass("adsalepanel_universe_selection_button")
													.attr({
														"target": "_blank",
														"href": item.url
													})
													.append(item.title)
													.get(0)
											}).toArray();

											if(docElems.length)
												returnElems = returnElems.concat(docElems);
											
											returnElems.push(
												$(ce("span"))
													.addClass("as_description")
													.append(control.asui.descriptionText2)
													.get(0)
											);
										}
									
										
										return returnElems;
									}()
							)
					);
					callback && callback(adsalepanel);
				},
				/**
				 *
				 * @method selectedFirmsPage
				 * @param {} adsalepanel
				 * @param {} firms
				 * @param {} callback
				 */
				"selectedFirmsPage": function(adsalepanel, firms, callback){
					var ce = control.ce;
					control.asui.buildFirmsList(false, true, firms, function(firmsList){
						$(adsalepanel)
							.append(
								$(ce("div"))
									.addClass("as_content_wide")
									.append(
										$(ce("div"))
											.addClass("firms_panel")
											.append(
												$(ce("h5"))
													.addClass("agent_subtitle")
													.append('You have already contacted the following firms '+
														'in regard to this universe. If you wish to contact '+
														'additional firms, close this box and click "Contact another firm".'),
												firmsList
											)
									)
							);
						callback(adsalepanel);
					});
				},
				/**
				 *
				 * @method page1
				 * @param adsalepanel
				 * @param callback
				 */
				"page1" : function(adsalepanel, callback){
					
					control.asui.existingContactInfo(function(addressInfo){
					
						var fieldLoop = function(){
							var returnElems = []; 
							for(var i = 0, l = control.asui.allContactFields.length; i < l; ++i){
								returnElems.push(
									control.asui.addField(
										control.asui.allContactFields[i], 
										addressInfo[control.asui.allContactFields[i]]
									)
								);
							}
							return returnElems;
						}
						
						var ce = control.ce;
						
						var uni = control.asui.universe;
						
						$(adsalepanel)
							.addClass("adsales_page")
							.append(
								$(ce("div"))
									.addClass("page1")
									.append(
										$(ce("div"))
											.addClass("as_content left")
											.append(fieldLoop()),
										$(ce("div"))
											.addClass("as_content left wide")
											.append(
												$(ce("h5"))
													.addClass("as_universe_title")
													.append("Universe Details:"),
												$(ce("div"))
													.addClass("as_content_universe")
													.append(
														$(ce("span")).append("Name: " + uni.ext_name),
														(
															(uni.description && uni.description.length) && 
															$(ce("span"))
																.addClass("as_filter_desc")
																.append("Description: " + uni.description)
														),
														uni.buildExplainFilters(["Purchased Records", "Unpurchased Records"])
													),
												$(ce("div"))
													.addClass("allow_access")
													.append(
														$(ce("label"))
															.append(
																$(ce("input")).attr({
																	"type": "radio",
																	"name": "allowAccess",
																	"value": true,
																	"checked": (!control.asui.sendInfo || control.asui.sendInfo === true)
																}),
																control.asui.sendInfoText
															),
														$(ce("b"))
															.addClass("clickable")
															.attr({
																"title": control.asui.sendInfoDescription,
															})
															.append(" [?]").click(function(){
																MUILayoverPanel.alert(this.title);
															}),
														$(ce("br")),
														$(ce("br")),
														$(ce("label"))
															.append(
																$(ce("input"))
																	.attr({
																		"type": "radio",
																		"name": "allowAccess",
																		"value": false,
																		"checked": (control.asui.sendInfo === false)
																	}),
																	control.asui.doNotSendInfoText
															),
														$(ce("b"))
															.addClass("clickable")
															.append(" [?]")
															.click(function(){
																MUILayoverPanel.alert(this.title);
															})
															.attr("title", control.asui.doNotSendInfoDescription)
													)
											),
										$(ce("div"))
											.addClass("clear")
											
									),
								$(ce("div"))
									.addClass("contact_option")
									.append(
										$(ce("div"))
											.addClass("clickable")
											.append("About")
											.click({"control":control, "adsalepanel":adsalepanel}, function(e){
												if(e.data.control.asui.holdCustomerInfo()){
													e.data.control.asui.clearPanel(e.data.adsalepanel);
													e.data.control.asui.adSalesPages.learnMorePage(
														e.data.adsalepanel,
														e.data.control.getUnivControl()
													);
												}
											}),
										$(ce("div"))
											.addClass("clickable")
											.append("Next")
											.click({"control":control, "adsalepanel":adsalepanel}, function(e){
												if(e.data.control.asui.holdCustomerInfo()){
													e.data.control.asui.clearPanel(e.data.adsalepanel);
													e.data.control.asui.adSalesPages.page2(e.data.adsalepanel);
												}
											})
											
									)
							);

						callback && callback(adsalepanel);
					});
				},
				/**
				 *
				 * @method page2
				 * @param {} adsalepanel
				 * @param {} callback
				 */
				"page2": function(adsalepanel, callback){
					
					var ce = control.ce;
					control.asui.getFirmTypes(function(firmTypes){
						control.asui.getPartisanships(function(partisanshipTypes){
							control.asui.buildFirmsList(true, false, false, function(firmsList){
								$(adsalepanel)
									.addClass("adsales_page")
									.append(
										$(ce("div"))
											.addClass("page2")
											.append(
												$(ce("div"))
													.addClass("firms_panel")
													.append(
														$(ce("h4"))
															.addClass("as_universe_title agent_title")
															.append("Available Firms"),
														$(ce("h5"))
															.addClass("agent_subtitle")
															.append(
																"Check the box next to at least one firm. Click on a firm's " +
																"name to learn more about that firm.",
																$(ce("br")),
																"All records must be purchased prior to " +
																"delivering them to your chosen vender, except " +
																"in the case of online advertising firms."
															),
														$(ce("div"))
															.addClass("as_nav left")
															.append(
																$(ce("div"))
																	.addClass("firmtype_heading")
																	.append("Show firms of type:"),
																$(firmTypes).map(function(index, firmType){
																	return $(ce("div"))
																		.addClass("firm_type_filter")
																		.append(
																			$(ce("input"))
																				.attr({
																					"type": "checkbox",
																					"value": firmType.type.replace(" ", ""),
																					"checked": true
																				})
																				.click({"control": control}, function(e){
																					e.data.control.filterFirmTypes(this.value, this.checked);
																				}),
																			$(ce("span"))
																				.append(firmType.description)
																				.click({"control": control}, function(e){
																					var target = $("input", $(this).parent()).get(0);
																					target.checked = !target.checked;
																					e.data.control.filterFirmTypes(target.value, target.checked);
																				})
																		)
																		.get(0);
																}),
																function(){
																	return $(ce("div"))
																		.addClass("top_twenty")
																		.append(
																			$(ce("div"))
																				.addClass("firmtype_heading")
																				.append("Firm partisanship:"),
																			$(ce("select"))
																				.addClass("firm_partisanship_fiter")
																				.append(
																					$(ce("option"))
																						.attr({
																							"selected": true
																						})
																						.append("All")
																				)
																				.append(
																					$(partisanshipTypes).map(
																						function(index, partisanship){
																							return $(ce("option"))
																								.attr({
																									"value": partisanship
																								})
																								.append(Moonshadow.helpers.capitalize(partisanship))
																								.get(0);
																						}
																					)
																				)
																				.change({"control": control}, function(e){
																					e.data.control.filterPartisanship(this.value);
																				})
																			
																		)
																		.get(0);
																}()
																
															),
														$(ce("div"))
															.addClass("as_content left wider")
															.append(firmsList)
													),
												$(ce("div"))
													.addClass("clear")
											),
											$(ce("div"))
												.addClass("contact_option")
												.append(
													$(ce("div"))
														.addClass("clickable")
														.append("Back")
														.click({
																"control":control,
																"adsalepanel":adsalepanel
															}, function(e){
																if(e.data.control.asui.holdAgencies(true)){
																	e.data.control.asui.clearPanel(e.data.adsalepanel);
																	e.data.control.asui.adSalesPages.page1(e.data.adsalepanel);
																}
															}
														),
													$(ce("div"))
														.addClass("clickable")
														.append("Next")
														.click({
																"control":control,
																"adsalepanel":adsalepanel
															}, function(e){
																if(e.data.control.asui.holdAgencies()){
																	e.data.control.asui.clearPanel(e.data.adsalepanel);
																	e.data.control.asui.adSalesPages.page3(e.data.adsalepanel);
																}
															}
														)
												)
										)
								callback && callback(adsalepanel);
							});
						});
					});
				},
				/**
				 *
				 * @method page3
				 * @param {} adsalepanel
				 * @param {} callback
				 */ 
				"page3": function(adsalepanel, callback){
					
					var ce = control.ce;
					
					var selectedFirmsObj = {};
					for(var i = 0, l = control.asui.selectedFirms.length; i < l; ++i){
						selectedFirmsObj[control.asui.selectedFirms[i]] = 1;
					}
					var allFirmTypesObj = {};
					for(var i = 0, l = control.asui.allFirmTypes.length; i < l; ++i){
						allFirmTypesObj[control.asui.allFirmTypes[i].type] = control.asui.allFirmTypes[i];
					}
					
					var custFields = {};
					for(var i = 0, l = control.asui.allContactFields.length; i < l; ++i){
						custFields[control.asui.allContactFields[i]] = Moonshadow.helpers.capitalize(control.asui.allContactFields[i].replace("_"," "));
					}
					
					var makeFields = function(){
						var returnArray = [];
						var cu = control.asui.customerInfo;
						for(var i in cu){
							if(cu.hasOwnProperty(i)){
								var key = custFields[i];
								if(key && cu[i].length){
									returnArray.push(
										$(ce("label"))
											.append(key, ": ", cu[i])[0]
									)
								};
							}
						}
						return returnArray;
					};
					
					var expandInfo = function(e){
						var universeInfoPanel = e.data.universeInfoPanel;
						if(e.data.sendInfo){
							if($(".firm_info_expander", this).hasClass("sprite-expander_right") == 1){
								$(".firm_info_expander", this)
									.removeClass("sprite-expander_right")
									.addClass("sprite-expander_down");
								$(universeInfoPanel).removeClass("hide");
							}else{
								$(".firm_info_expander", this)
									.removeClass("sprite-expander_down")
									.addClass("sprite-expander_right");
								$(universeInfoPanel).addClass("hide");
							}
						}
					}
					
					$(adsalepanel)
						.addClass("adsales_page")
						.append(
							$(ce("div"))
								.addClass("page3")
								.append(
									$(ce("h4"))
										.addClass("as_universe_title agent_title")
										.append("Congratulations!"),
									$(ce("h5"))
										.addClass("agent_subtitle")
										.append(control.asui.sendInfo ? control.asui.finalMessage1 : control.asui.finalMessage2),
									$(ce("div"))
										.addClass("as_content left top_ten final_message")
										.append(
											$(ce("span"))
												.append("The firms you've selected will receive the following message:"),
											$(ce("div"))
												.addClass("customer_info_for_firms")
												.append(
													makeFields(),
													$(ce("label"))
														.append("Comments/Instructions:"),
													$(ce("textarea"))
														.attr("name", "comments")
														.addClass("asl_comments asf")
												),
											$(ce("span"))
												.append("If you choose to include a short description of your universe with the " +
														"email (right) the firms will also see the following:"),
											$(ce("div"))
												.addClass("customer_info_for_firms")
												.append(
													control.asui.universe.buildExplainFilters()
												)
										),
									$(ce("div"))
										.addClass("firm_info_container as_content left wide top_ten")
										.append(
											$(ce("span"))
												.append("The following firms will receive your information. Put a check next to the firm " +
														"name to also include a short description of your universe with the email."),
											$(ce("table"))
												.addClass("firm_info_container_table")
												.append(
													function(){
														var appendElems = [];
														for(var i = 0, l = control.asui.allFirms.length; i < l; ++i){
															var firm = control.asui.allFirms[i];
															
															var universeInfoPanel = $(ce("div"))
																.addClass("willrecv hide")
																.append(
																	$(ce("span"))
																		.addClass("bold")
																		.append("The firm will receive the following " +
																			"information about the voters in your universe:"
																		),
																	$(allFirmTypesObj[firm.firmType].willrecv)
																		.map(function(key, val){
																			return $(ce("span"))
																				.append(val)[0]
																		})
																);
															
															if(!selectedFirmsObj[firm.customername]){
																continue;
															}
															appendElems.push(
																$(ce("tr"))
																	.append(
																		$(ce("td"))
																			.append(
																				$(ce("input"))
																					.attr({
																						"type": "checkbox",
																						"name": "emailInfo",
																						"value": firm.customername,
																						"title": "Check here to send a short description to the firm about your data."
																					})
																			),
																		$(ce("td"))
																			.append(
																				$(ce("div"))
																					.addClass("firms_final")
																					.append(
																						$(ce("div"))
																							.addClass("firm_info_expander")
																							.addClass(
																								(!!control.asui.sendInfo) && 
																								"sprite-expander_right clickable"
																							),
																						$(ce("span"))
																							.addClass("bold")
																							.addClass(
																								(!!control.asui.sendInfo) && 
																								"clickable"
																							)
																							.append(firm.name)
																					)
																					.click({
																						"sendInfo": control.asui.sendInfo,
																						"universeInfoPanel": universeInfoPanel
																					}, expandInfo)
																			)
																	)
																	.get(0)
															);
															if(!!control.asui.sendInfo){
																appendElems.push(
																	$(ce("tr"))
																		.append(
																			$(ce("td")),
																			$(ce("td"))
																				.append(
																					universeInfoPanel
																				)
																		)
																		.get(0)
																)
															}
														}
														return appendElems;
													}()
												)
										),
									$(ce("div"))
										.addClass("clear")
						
								),
							$(ce("div"))
								.addClass("contact_option")
								.append(
									$(ce("div"))
										.addClass("clickable")
										.append("Back")
										.click({
												"control":control, 
												"adsalepanel":adsalepanel
											}, function(e){
												e.data.control.asui.clearPanel(e.data.adsalepanel);
												e.data.control.asui.adSalesPages.page2(e.data.adsalepanel);
											}
										),
									$(ce("div"))
										.addClass("clickable")
										.append("Cancel")
										.click(function(e){
											MUILayoverPanel.close("adsales");
										}),
									$(ce("div"))
										.addClass("clickable")
										.append("Send Info")
										.click(control.asui.submitRequest)
								)
							);
					
					callback && callback(adsalepanel);
				}
			}
		};
	},
	
	/**
	 * 
	 * @method filterPartisanship 
	 * @param partisanship
	 */
	filterPartisanship: function(partisanship){
		var ce = this.ce;
		var self = this;
		$(".firm_container_link").each(function(key, value){
			$(".no_firms_available", $(this).closest(".firm_type_item"))
				.remove();
			if($(this).hasClass("partisanship_" + partisanship) || partisanship == "All"){
				$(this).removeClass("hide");
			}else{
				$(this).addClass("hide");
				var numItems = $(".firm_container_link:not(.hide)", $(this).closest(".firm_type_item")).length;
				if(numItems == 0){
					$(this).closest(".firm_type_item")
						.append(
							$(ce("span"))
								.addClass("no_firms_available")
								.append("No firms to list for selected filters.")
						);
				}
			}
			
			self.addDividers($(this).closest(".firm_type_item"));
		})
	},
	
	/**
	 * 
	 * @method addDividers 
	 * @param target
	 */
	addDividers: function(target){
		var ce = this.ce;
		$(".divider", target)
			.remove();
		var items = $(".firm_container_link:not(.hide)", target);
		if(items.length > 1){
			$(items).each(function(key, value){
				if(key % 2 == 0)
					$(this).after(
						$(ce("div"))
							.addClass("divider")
					)
			});
		}
	},
	
	/**
	 * 
	 * @method filterFirmTypes 
	 * @param firmType
	 * @param include
	 */
	filterFirmTypes: function(firmType, include){
		var ce = this.ce;
		
		$(".no_firms_available")
			.remove();
		
		if(include){
			$(".type_" + firmType).removeClass("hide");
		}else{
			$(".type_" + firmType).addClass("hide");
		}
		if(!$(".firm_type_item:not(.hide)").length){
			$(".firms_panel .as_content")
				.append(
					$(ce("span"))
						.addClass("no_firms_available")
						.append("No firms to list for selected filters.")
				);
		}
	},
	/**
	 * 
	 * @method contatVotersPopup
	 */
	contactVotersPopup: function(){
		var ce = this.ce;
		$(".adsales_element_holder")
			.append(
				$(ce("div"))
					.addClass("ad_sales_panel_large hide")
					.append(
						$(ce("span"))
							.addClass("closer clickable")
							.append("X")
							.click({"caller": this}, function(e){
								$(".ad_sales_panel_large").remove();
								var manager = e.data.caller.getManager();
								manager.setOption("user_settings.asDescriptionClosed", true);
								manager.getControl("usersettings").saveUserSettings();
							}),
						$(ce("h4"))
							.append("Contact Your Voters with QuickConnect!"),
						$(ce("div"))
							.addClass("clickable")
							.append("Click here to learn more")
							.click({"caller": this}, function(e){
								var self = e.data.caller;
								self.asui.learnMore(
									self.getUnivControl(),
									true
								);
							})
					)
			);
	},
	/**
	 *
	 * @method getUnivControl
	 */
	getUnivControl: function(){
		var control = false;
		if(this.getManager().shouldControlBeLoaded("MPanelContentFilterV3")) {
			var ds = this.getManager().getControl("filters").datasources["__universes"];
			if(ds && ds.filterables["__universes"]) {
				control = ds.filterables["__universes"];
			}
		}
		return control;
	},
	adSalesEnabled: function(callback){
		if(this.getManager().hasAddon("ad_sales")){
			return this.asui.getFirms(function(firms){
				callback(firms.length > 0);
			});
		}
		return callback(false);
	},
	showAdSalesPopup: function(){
		if(!$(".ad_sales_panel_large.hide").length)
			this.contactVotersPopup();
		var manager = this.getManager();
		this.adSalesEnabled(function(enabled){
			if(enabled && !manager.getOption("user_settings.asDescriptionClosed")){
				$(".ad_sales_panel_large.hide").removeClass("hide");
			}
		});
	},
	show: function(){},
	hide: function(){}
};
Moonshadow.helpers.extend(MControlAdSales,MControl);

/**
 * Control for the collapsable side panel
 * @class MControlSidePanel
 * @module Moonshadow.Controls
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlSidePanel(options) {
	this.name = "sidepanel";
	this.ajaxRequest = null;
	this.manager = null;
	this.container = false;
	this.childContainer = null;
	this.fixedChildContainer = null;
	this.locked = false;
	this.isShown = false;
	this.controls = {};
	this.options = options || {};

	this.sidepanel_width = options.sidepanel_width;
	this.defaultWidth = 450;
	this.tip;

	this.options.open = (typeof this.options.open == "undefined" || this.options.open != false)
		? true : false;
	this.options.transitionTime = (this.options.transitionTime == undefined
								   || parseInt(this.options.transitionTime) == 0)
		? 450
		: parseInt(this.options.transitionTime);
};
MControlSidePanel.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	init: function(manager) {
		this.manager = manager;

		var sidePanelWidth = manager.getOption("user_settings.sidepanel_width");
		this.openedWidth = sidePanelWidth || this.sidepanel_width || this.defaultWidth;

		if (this.openedWidth < this.defaultWidth) {
			this.openedWidth = this.defaultWidth;
		}

		this.closedWidth = 20;

		var sidePanelOpen = this.getManager().getOption("user_settings.sidePanelOpen");
		if(sidePanelOpen != undefined) {
			this.options.open = sidePanelOpen;
		}

		manager.addMapObserver("addedfixeditem", this.adjustFixedPanel, this);
		manager.addWindowObserver('resize', this.validateAndResize, this);

		if(this.container == false) {
			var panelDiv = document.createElement("div");
			panelDiv.className = this.name;
			panelDiv.id = this.name;
			panelDiv.className += " "+Moonshadow.maps[this.getManager().getMapProvider()].name;
			this.locked && (panelDiv.title = "Locked");
			
			var ribbon = document.createElement("div");
			ribbon.className = "ribbon" + (this.locked ? "" : " clickable");

			var ribbonSprite = document.createElement('div');
			ribbonSprite.id = "ribbon_image";
			ribbonSprite.className = "image sprite-close";
			ribbon.appendChild(ribbonSprite);

			panelDiv.appendChild(ribbon);

			var fixedbox = document.createElement("div");
			fixedbox.className = 'fixedbox contentbox hide';

			panelDiv.appendChild(fixedbox);

			var fixedcontent = document.createElement("div");
			fixedcontent.className = "content";

			this.fixedChildContainer = fixedcontent;
			fixedbox.appendChild(fixedcontent);

			var scrollbox = document.createElement("div");
			scrollbox.className = 'scrollbox contentbox scrollable';

			panelDiv.appendChild(scrollbox);
			
			var fixedFooter = document.createElement("div");
			fixedFooter.className = 'fixedfooter contentbox';
			panelDiv.appendChild(fixedFooter);
			
			var tos = document.createElement("div");
			tos.className = "tos_links";
			var adapter = this.getManager().getAdapter();
			if(adapter.mapTos){
				var tosLink = document.createElement("a");
				tosLink.href = adapter.mapTos.url;
				tosLink.target = "_blank";
				$(tosLink).append(adapter.mapTos.title);
				tos.appendChild(tosLink);
			}
			fixedFooter.appendChild(tos);
			
			this.versionInfo(fixedFooter);
			
			var patent = document.createElement("span");
			patent.className = "patent";
			patent.appendChild(document.createTextNode("Patent pending"));
			fixedFooter.appendChild(patent);

			var content = document.createElement("div");
			content.className = "content";

			this.childContainer = content;
			scrollbox.appendChild(this.childContainer);
			
			this.container = panelDiv;

			var mainContainer = this.getManager().getContainer();
			mainContainer.insertBefore(this.container, mainContainer.firstChild);		

			var self = this;
			$(ribbonSprite).click(function(){
				self.togglePanel(); 
			});

			$(".contentbox").css("width", parseInt((this.openedWidth - this.closedWidth),10) + "px");

			$(scrollbox)
				.on("scroll", function(e) {
					self.manager.mapObservers.notify('sidepanelscroll');
				});

			if(this.options.open) {
				this.show(false);
			} else {
				this.hide(false);
			}
		}
	},
	versionInfo: function(target){
		var versionText = [];

		var qsv = Moonshadow.getManager().getOption('query_version', 'unknown');
		var clv =  Moonshadow.version;

		versionText.push('QS:');
		versionText.push(qsv);
		versionText.push('/');
		versionText.push('Cl:');
		versionText.push(clv);

		var versions = document.createElement("div");
		versions.className = "versions";
		var versionsSpan = document.createElement("span");
		versionsSpan.appendChild(document.createTextNode(versionText.join(' ')));
		versions.appendChild(versionsSpan);

		$(versions).click(function() {
			Moonshadow.getManager().toggleStats();
		});

		target.appendChild(versions);

	},
	/**
	 *
	 * @method adjustFixedPanel
	 */
	adjustFixedPanel: function(){
		var fixedbox = $(".fixedbox .content");
		if(fixedbox.children().length){
			$(".fixedbox").removeClass("hide");
			if(!$(".obligitoryclear", fixedbox).length){
				var clear = document.createElement("div");
				clear.className = "clear obligitoryclear";
				fixedbox.append(clear);
			}
			var top = fixedbox.outerHeight();
			if(!top || top < 30)
				top = 30;
			$(".scrollbox").css("top", top + "px");
		}
	},
	/**
	 *
	 * @method showResizingTip
	 */
	showResizingTip: function(){
		if(this.tip){
			return this.tip.show();
		}
		if(this.locked){
			return;
		}
		
		var tipRead = this.manager.getOption("user_settings.tips.sidepanelresize", false);
		if(tipRead){
			return;
		}
		
		var self = this;
		var getPosition = function(){
			var contLeft = $(self.container).offset().left;
			var alertWidth = 260;
			var alertShadowOffset = 10;
			var arrowLength = 50;
			return {
				"left": contLeft - arrowLength - (alertWidth - alertShadowOffset),
				"top": "50%"
			};
		};
		
		var adjust = function(){
			if(!self.tip){
				return;
			}
			self.tip.adjustOffset(getPosition());
		};
		
		var ce = Moonshadow.helpers.ce;
		var content = $(ce("div"))
			.append(
				$(ce("div"))
					.addClass("pro_tip_resize_panel")
					.append("Drag the edge of the panel to left to widen it and expose more data."),
				$(ce("div"))
					.addClass("below_alert_content")
					.append(
						$(ce("span"))
							.append("Do not show this message again"),
						$(ce("input"))
							.addClass("do_no_show_again")
							.attr({
								"type": "checkbox",
							})
					)
			);
		
		this.tip = MUILayoverPanel.alert({
			"title": "Pro Tip", 
			"message": content, 
			"modal": false,
			"position": getPosition(),
			"additionalClass": "pro_tip",
			"arrow": {
				"direction": "right", 
				"placement": "bottom", 
				"length": 50
			},
			"callback": function(response, id, close){
				var manager = self.getManager();
				manager.removeMapObserver('panel_resize', adjust, self);
				manager.removeWindowObserver('resize', adjust, self);
				var checkbox = $(".do_no_show_again", "#" + id);
				if($(checkbox).attr("checked")){
					manager.setOption("user_settings.tips.sidepanelresize", true);
					manager.getControl("usersettings").saveUserSettings();
				}
				self.tip = null;
				close();
			}
		});

		this.getManager().addMapObserver('panel_resize', adjust, this);
		this.getManager().addWindowObserver('resize', adjust, this);
	},
	/**
	 *
	 * @method notify
	 */
	notify: function() {},
	/**
	 *
	 * @method stateUpdate
	 */
	stateUpdate: function() {},
	isOpen: function() {
		return this.isShown;
	},
	/**
	 *
	 * @method togglePanel
	 */
	togglePanel: function() {
		if(this.isShown)
			return this.hide(true, true);
		this.show(true, true);
	},
	lock: function() {
		var rimage = $("#ribbon_image");
		this.container.title = 'Locked';
		rimage.addClass('sprite-locked');
		if(this.isShown) {
			rimage.addClass('sprite-close');
		} else {
			rimage.addClass('sprite-open');
		}
		$(".ribbon").removeClass("clickable");
		$('.sidepanel').resizable({disabled: true});
		this.locked = true;
	},
	unlock: function() {
		$(this.container)
			.removeAttr("title");
		var rimage = $("#ribbon_image");
		rimage.removeClass('sprite-locked');
		if(this.isShown) {
			rimage.addClass('sprite-close');
		} else {
			rimage.addClass('sprite-open');
		}

		$(".ribbon").addClass("clickable");
		$('.sidepanel').resizable({disabled: false});
		$('.sidepanel > .ui-resizable-handle')
			.addClass("side_panel_resizer")
			.show();
		
		this.locked = false;
	},
	/**
	 *
	 * @method show
	 */
	show: function(animation, save) {
		if (this.locked) {
			return false;
		}

		animation = (animation != false) ? true : false;
		var manager = this.getManager();
		manager.mapObservers.notify("before_panel_open");
		var self = this;
		if(animation && this.options.transitionTime >= 100) {
			$(this.container).animate(
				{'width': this.openedWidth + 'px'},
				this.options.transitionTime
			);
			$(this.getManager().getAdapter().container).animate(
				{'right': (this.openedWidth + 1) + "px"},
				this.options.transitionTime,
				function() {
					if(!self.validateSize()){
						self.resizeToFit();
					}
					manager.getAdapter().resize();
					manager.mapObservers.notify("panel_change");
					self.showResizingTip();
				}
			);
		} else {
			this.container.style.width = this.openedWidth + "px";
			this.getManager().getAdapter().container.style.right = (this.openedWidth + 1) + "px";
			this.getManager().getAdapter().resize();
			this.getManager().mapObservers.notify("panel_change");
			this.showResizingTip();
		}

		$('.contentbox', this.container).show();
		
		var rimage = $("#ribbon_image");

		rimage.addClass('sprite-close');
		rimage.removeClass('sprite-open');
		
		var ce = Moonshadow.helpers.ce;
		$('#sidepanel').resizable({
			"handles": "w",
			"minWidth": this.defaultWidth,
			"resize": function(event, ui){
				var parent = ui.element.parent();
				var remainingSpace = Math.round(parent.width() - ui.element.outerWidth());
				$('#mapcontainer').width(remainingSpace);
				ui.element.css({
					left: remainingSpace
				});
				
				self.manualWidth($('#sidepanel').width());
				manager.mapObservers.notify('panel_resize');
			},
			"stop": function(event, ui){
				self.manualWidth($('#sidepanel').width());
				
				if(!self.validateSize()){
					self.resizeToFit();
				}
				
				manager.mapObservers.notify('panel_stop');
				manager.getControl("usersettings").setUserSetting("sidepanel_width", Math.round(self.openedWidth));
			}
		});

		$('.sidepanel > .ui-resizable-handle')
			.addClass("side_panel_resizer")
			.show();

		this.isShown = true;
		if(save){
			this.getManager().getControl("usersettings").setUserSetting("sidePanelOpen", true);
		}
		
	},
	manualWidth: function(width){
		this.openedWidth = width;
		$('#sidepanel').width(this.openedWidth);
		$('#mapcontainer').css({
			width: "auto",
			right: Math.round(this.openedWidth) + 1
		});
		$('#sidepanel').css({
			left: "auto",
			right: "0px"
		});
		$(".contentbox").css({
			"width": parseInt((this.openedWidth - this.closedWidth),10) + "px"
		});
	},
	validateSize: function(){
		return $("#maincontainer").width() >= this.openedWidth;
	},
	resizeToFit: function(){
		this.manualWidth($('#maincontainer').width());
	},
	validateAndResize: function(){
		if(!this.validateSize()){
			this.resizeToFit();
		}
	},
	/**
	 *
	 * @method hide
	 * @param {} animation
	 */
	hide: function(animation, save, callback) {
		if (this.locked) {
			return false;
		}

		animation = (animation !== false) ? true : false;

		var manager = this.getManager();
		manager.mapObservers.notify("before_panel_close");

		if(animation) {
			$(this.container).animate({'width': this.closedWidth + 'px'},this.options.transitionTime);
			$(this.getManager().getAdapter().container).animate(
				{'right': (this.closedWidth + 1) + "px"},
				this.options.transitionTime,
				function() {
					$('.contentbox', this.container).hide();
					manager.getAdapter().resize();
					manager.mapObservers.notify("panel_change");
				}
			);
		} else {
			this.container.style.width = this.closedWidth + "px";
			this.getManager().getAdapter().container.style.right = (this.closedWidth + 1) + "px";
			this.getManager().getAdapter().resize();
			this.getManager().mapObservers.notify("panel_change");
			$('.contentbox', this.container).hide();
		}

		var rimage = $("#ribbon_image");
		rimage.addClass('sprite-open');
		rimage.removeClass('sprite-close');

		if($( "#sidepanel" ).hasClass( "ui-resizable" )) {
			$('div.ui-resizable-handle').hide();
		}

		this.isShown = false;
		if(save){
			this.getManager().getControl("usersettings").setUserSetting("sidePanelOpen", false);
		}
		
		if(this.tip){
			this.tip.hide();
		}
				
		callback && callback();
	}
};
Moonshadow.helpers.extend(MControlSidePanel,MControl);

/**
 *
 * @method MControlUserSettings
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlUserSettings(options) {
    this.name = "usersettings";
    this.manager = null;
    this.options = options || {};    
};

MControlUserSettings.prototype = {
    /**
     *
     * @method init
     * @param {} manager
     */
    init: function(manager) {
    	this.manager = manager;
    	manager.addAjaxEventListener("bounds",this);
    },
    /**
     *
     * @method notify
     */
    notify: function() {},
    /**
     *
     * @method show
     */
    show: function() {},
    /**
     *
     * @method hide
     */
    hide: function() {},
    /**
     *
     * @method getSettingsQuery
     * @param {} source
     */
    getSettingsQuery: function(source) {
    	return {
			query: "save_stored_state",
			qid: source,
			name: "user_settings",
			value: this.getManager().getOption("user_settings")
		};
    },
    /**
     *
     * @method saveUserSettings
     */
    saveUserSettings: function(callback) {
    	var ajax = new Moonshadow.Ajax();
		this.saveUserSettingsAjax(ajax);
		ajax.execute(callback);
    },
    saveUserSettingsAjax: function(ajax){
    	ajax.addQuery(this.getSettingsQuery('manual'),this);
    },
    /**
     *
     * @method onAjaxEvent
     * @param {} event 
     * @param {} data
     * @param {} ajax
     */
    onAjaxEvent: function(event, data, ajax) {
		var manager = this.getManager();
		var adapter = manager.getAdapter();
    	var center = adapter.getCenter();

		manager.setOption("user_settings.center.lat", center.lat());
		manager.setOption("user_settings.center.long", center.lng());
		manager.setOption("user_settings.z", adapter.getZoom());
		manager.setOption("user_settings.mapType", adapter.getMapType());
		manager.setOption("user_settings.datasource", manager.getDatasource().int_name);

    	ajax.addQuery(this.getSettingsQuery(event), this);
    },
    /**
     * 
     * @method onAjaxResponse
     * @param {} data
     */
    onAjaxResponse: function(data) {},
    setUserSetting: function(settingName, value, callback){
    	var settings = this.getManager().getOption("user_settings");
    	settings[settingName] = value;
    	this.saveUserSettings(callback);
    }
};
Moonshadow.helpers.extend(MControlUserSettings,MControl);

/**
 * Class that handles datasources for an app
 *
 * @class MControlDatasources
 * @constructor
 * @extends MControl
 * 
 */
function MControlDatasources(options) {
	this.name = 'datasources';
	this.manager = null;

	this.index = 0;
	this.datasources = {};
	this.aliases = {};
	this.ready = false;
};

MControlDatasources.prototype = new MControl;

/**
 * Init function for class, called as part of control loading
 * 
 * @method init
 * @param {Manager} manager Reference to manager
 */
MControlDatasources.prototype.init = function(manager) {
	this.manager = manager;
};

/**
 * Function to check if ready
 * 
 * @method isReady
 * @return {Boolean} true if ready, false if not
 */
MControlDatasources.prototype.isReady = function() {
	return this.ready;
};

/**
 * Get all datasources
 *
 * @method getAll
 * @return {Object} Map of datasource ids to ds details
 */
MControlDatasources.prototype.getAll = function() {
	return this.datasources;
};

/** 
 * Get datasource by id
 * 
 * @method getById
 * @param {String} id
 * @return {Object} DS object
 */
MControlDatasources.prototype.getById = function(id) {
	if (!id) {
		throw new Error('Invalid datasource id');
	}

	if (!this.datasources[id]) {
		throw new Error('Datasource not found');
	}

	return this.datasources[id];
};

/**
 * Get datasource by alias
 *
 * @method getByAlias
 * @return {Objet} DS object
 */
MControlDatasources.prototype.getByAlias = function(alias) {
	var id = this.getIdByAlias(alias);

	if (!this.datasources[id]) {
		throw new Error('Datasource not found');
	}

	return this.datasources[id];
};

/**
 * Get datasource by alias
 *
 * @method getByAlias
 * @return {Objet} DS object
 */
MControlDatasources.prototype.getIdByAlias = function(alias) {
	var id = this.aliases[alias];

	if (!id) {
		throw new Error('Alias not found');
	}

	return id;
};

/** 
 * Get datasource by index
 * 
 * @method getByIndex
 * @param {String} id
 * @return {Object} DS object
 */
MControlDatasources.prototype.getByIndex = function(index) {
	var datasources = this.getAll();

	for (var dsId in datasources) {
		var ds = datasources[dsId];
		if (ds.index === index) {
			return ds;
		}
	}

	throw new Error('Invalid datasource index');
};

MControlDatasources.prototype.getFieldDetails = function(fieldName, dsId){
	
	var getFieldFromDS = function(ds){
		if(ds.fields && ds.fields[fieldName]){
			var returnField = {
				"dsId": ds.id
			};
			for(var i in ds.fields[fieldName]){
				if(!ds.fields[fieldName].hasOwnProperty(i)){
					continue;
				}
				returnField[i] = ds.fields[fieldName][i];
			}
			return returnField;
		}
		return false
	}
	
	if(dsId){
		var ds = this.getById(dsId);
		return getFieldFromDS(ds);
	}
	
	var datasources = this.getAll();
	for (var dsId in datasources) {
		var ds = datasources[dsId];
		var fieldInfo = getFieldFromDS(ds);
		if(fieldInfo){
			return fieldInfo;
		}
	}
	return false;
};

MControlDatasources.prototype.getValues = function(dsId, path) {
	var ds = this.getById(dsId);
	path = path.split('|');
	return this.checkBranch(ds.struct, path);
};

MControlDatasources.prototype.checkBranch = function(branch, path) {
	for (var i = 0, l = branch.length; i < l; i++) {
		var filterable = branch[i];
		
		if (filterable.dtype === 'collection') {
			var result = this.checkBranch(filterable.filters, path);

			if (result) {
				return result;
			}
		}

		if (filterable.int_name === path[0]) {
			path.shift();

			if (!path.length) {
				var values = [];

				for (var ii = 0, ll = filterable.values.length; ii < ll; ii++) {
					var value = filterable.values[ii];

					if (typeof value === 'object') {
						values.push(value.int_name);
					} else {
						values.push(value);
					}
				}

				return values;
			}

			return this.checkBranch(filterable.values, path);
		}
	}

	return false;
};

/**
 * Get the datasource details from the remote server
 * 
 * @method getStructure
 * @private
 * @param {Object[]} datasources Array of datasources defs
 * @param {Function} callback Callback to call when data is loaded
 */
MControlDatasources.prototype.getStructure = function(datasources, callback) {
	var self = this;
	var ajax = new Moonshadow.Ajax();

	for (var i = 0, l = datasources.length; i < l; i++) {
		var ds = datasources[i];
		var dsId = ds.int_name;
		ajax.addQuery(self.getStructQuery(dsId, i), self.onStructResponse, self);
		ajax.addQuery(self.getFieldsQuery(dsId), self.onFieldsResponse, self);
		ajax.addQuery(self.getFilterQuery(dsId), self.onFilterResponse, self);
		ajax.addQuery(self.getColorQuery(dsId), self.onColorResponse, self);
		ajax.addQuery(self.getCountsModeQuery(dsId), self.onCountsModeResponse, self);
		self.getUniverses(dsId, ajax);
		ajax.addQuery(self.getUserColorByQuery(dsId), self.onUserColorByResponse, self);
	}

	ajax.execute(function() {
		callback();
	});	
};

/**
 * Get the query to retrieve all fields
 * 
 * @method getFieldsQuery
 * @param {String} dsId Id of DS
 * @private
 */
MControlDatasources.prototype.getFieldsQuery = function(dsId){
	return {
		"query":"get_fields",
		"no_values": 1,
		"ds": dsId
	};
}

/**
 * Get the universe details for all universes from the remote server
 * 
 * @method getUniverses
 * @param {Array, String} dsIds Array of Ids of DSs or a single DS ID
 * @param {Object} ajax AJAX object for adding queries
 * @param {Function} callback Callback to call when data is loaded (optional)
 * @private
 */
MControlDatasources.prototype.getUniverses = function(dsIds, ajax, callback) {
	if(!(dsIds instanceof Array)){
		dsIds = [dsIds];
	}
	var self = this;
	for(var i = 0, l = dsIds.length; i < l; ++i){
		ajax.addQuery(this.getUniverseQuery(dsIds[i]), function(data){
			self.onUniverseResponse(data);
			callback && callback();
		}, this);
	}
};

/**
 * Get the universe details of one specific universe from the remote server
 * 
 * @method getUniverse
 * @param {String} dsId Id of DS
 * @param {String} universId The ID of the universe
 * @param {Object} ajax AJAX object for adding queries
 * @param {Function} callback Callback to call when data is loaded
 * @private
 */
MControlDatasources.prototype.getUniverse = function(dsId, universId, callback) {
	this.getUniversesById(dsId, [universId], function(universes){
		callback(!!universes.length && universes[0]);
	});
};

/**
 * Get universe details from the remote server from list of ids
 * 
 * @method getUniversesById
 * @param {String} dsId Id of DS
 * @param {Array} universIds The IDs of the universes
 * @param {Object} ajax AJAX object for adding queries
 * @param {Function} callback Callback to call when data is loaded
 * @private
 */
MControlDatasources.prototype.getUniversesById = function(dsId, universIds, callback) {
	var self = this;
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(this.getUniverseQuery(dsId, universIds), function(data){
		var universes = data.universes || [];
		if(universes && universes.length > 0){
			for(var i = 0, l = universes.length; i < l; ++i){
				self.addUniverse(dsId, universes[i]);
			}
		}
		callback && callback(universes);
	}, self);
	ajax.execute();
};


/**
 * add single universe to existing datasource
 * 
 * @method addUniverse
 * @param {String} dsId Id of DS
 * @param {Object} universe Object of data representing universe
 */
MControlDatasources.prototype.addUniverse = function(dsId, universe){
	if (this.datasources[dsId]) {
		if(!this.datasources[dsId].universes){
			this.datasources[dsId].universes = [];
			this.datasources[dsId].universes.push(universe);
		}else{
			var us = this.datasources[dsId].universes;
			for(var i = 0, l = us.length; i < l; ++i){
				if(us[i].int_name == universe.int_name){
					this.datasources[dsId].universes.splice(i, 1, universe);
					return;
				}
			}
			this.datasources[dsId].universes.push(universe);
		}
	}
}

MControlDatasources.prototype.getCountsMode = function(dsId) {
	return this.datasources[dsId].countsMode || 'selected';
};

MControlDatasources.prototype.setCountsMode = function(dsId, mode) {
	this.datasources[dsId].countsMode = mode;
	
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery({
		'query': 'save_stored_state',
		'name': 'counts_mode',
		'ds': dsId,
		'value': mode
	}, function() {});
	ajax.execute();
};

/**
 * Getthe query to retrieve structure
 *
 * @method getStuctQuery
 * @private
 * @param {String} dsId Id of DS
 * @return {Object} Query to send to remote server
 */
MControlDatasources.prototype.getStructQuery = function(dsId) {
	var query = {
		"query":"get_filter_tree",
		"ds": dsId
	};

	var ds = this.manager.getDatasource(dsId);
	if(ds.exclude) {
		query.exclude = ds.exclude;
	}

	return query;
};

/**
 * Get the query to retrieve filters
 *
 * @method getFilterQuery
 * @private
 * @param {String} dsId Id of DS
 * @return {Object} Query to send to remote server
 */
MControlDatasources.prototype.getFilterQuery = function(dsId) {
	return {
		"query": "load_stored_state",
		"name": "filter__all",
		"ds": dsId
	}
};

/**
 * Get the query to retrieve colors
 *
 * @method getColorQuery
 * @private
 * @param {String} dsId Id of DS
 * @return {Object} Query to send to remote server
 */
MControlDatasources.prototype.getColorQuery = function(dsId) {
	return {
		"query": "load_stored_state",
		"name": "stored_colors",
		"ds": dsId
	}
};

/**
 * Get the query to retrieve universes
 *
 * @method getUniverseQuery
 * @private
 * @param {String} dsId Id of DS
 * @return {Object} Query to send to remote server
 */
MControlDatasources.prototype.getUniverseQuery = function(dsId, universeId) {
	var queryObj = {
		"query": "list_universes",
		"ds": dsId,
		"show_level_counts": 0,
		"show_purchased_counts": 0,
		"show_purchased_level_counts": 0
	}
	if(universeId){
		queryObj.show_level_counts = 1;
		queryObj.show_purchased_counts = 1;
		queryObj.name = universeId;
	}
	return queryObj;
};

/**
 * Get the query to retrieve user color by
 *
 * @method getUserColorByQuery
 * @private
 * @param {String} dsId Id of DS
 * @return {Object} Query to send to remote server
 */
MControlDatasources.prototype.getUserColorByQuery = function(dsId) {
	return {
			"query": "load_stored_state",
			"name": "color_by__set_color",
			"ds": dsId
	};
};

/**
 * Get the query to retrieve counts mode for a datasource
 *
 * @method getCountsModeQuery
 * @private
 * @param {String} dsId Id of DS
 * @return {Object} Query to send to remote server
 */
MControlDatasources.prototype.getCountsModeQuery = function(dsId) {
	return {
			"query": "load_stored_state",
			"name": "counts_mode",
			"ds": dsId
	};
};

/**
 * Function that stores key/value object of all fields' ext and int
 *
 * @method onFieldsResponse
 * @private
 * @param {Object} data The structure data
 */
MControlDatasources.prototype.onFieldsResponse = function(data) {
	var dsId = data.ds;
	var fieldstruct = {};
	
	if(data && data.fields){
		var datasource = this.datasources[dsId];
		if(datasource){
			datasource.fields = data.fields;
		}
	}
};


/**
 * Function that handles processing the retrieved structure data
 *
 * @method onStructResponse
 * @private
 * @param {Object} data The structure data
 */
MControlDatasources.prototype.onStructResponse = function(data) {
	var ds = data.ds;
	var struct = [];

	if(data.filters) {
		struct = data.filters;
	} else if(data.values) {
		struct = data.values; // @CLEANUP? I think this is legacy
	}								

	var datasource = this.create(ds, struct);
	this.datasources[datasource.id] = datasource;
	
	if(!this.aliases[datasource.alias]){
		this.aliases[datasource.alias] = datasource.id;
	}
};

/**
 * Function that handles processing the retrieved filter data
 *
 * @method onFilterResponse
 * @param {Object} data The filter data
 * @private
 */
MControlDatasources.prototype.onFilterResponse = function(data) {
	var filters = {};
	if(data.result === 'ok') {
		filters = $.extend({}, data.value);
	}

	if (this.datasources[data.ds]) {
		this.datasources[data.ds].filters = filters;
	}
};

/**
 * Function that handles processing the retrieved structure data
 *
 * @method onColorResponse
 * @private
 * @param {Object} data The color data
 */
MControlDatasources.prototype.onColorResponse = function(data, reload) {
	var colors = $.extend(true, {}, data.value);

	if (this.datasources[data.ds]) {
		this.datasources[data.ds].userColors = colors;
	}
	
	if(reload === true){
		var colorControl = this.getManager().getControl("colors");
		colorControl.reloadColorsForDatasource(this.datasources[data.ds].int_name);
	}
};

/**
 * Function that handles processing the retrieved structure data
 *
 * @method onUniverseResponse
 * @private
 * @param {Object} data The color data
 */
MControlDatasources.prototype.onUniverseResponse = function(data) {
	if (this.datasources[data.ds]) {
		this.datasources[data.ds].universes = data.universes;
	}
};

/**
 * Function that handles processing the retrieved structure data
 *
 * @method onUserColorByResponse
 * @private
 * @param {Object} data The color data
 */
MControlDatasources.prototype.onUserColorByResponse = function(data) {
	var value = null;
	if (data.result === 'ok') {
		value = data.value;
	}

	if (this.datasources[data.ds]) {
		this.datasources[data.ds].colorBy = value;
	}
};

/**
 * Function that handles processing the retrieved structure data
 *
 * @method onCountsModeResponse
 * @private
 * @param {Object} data The color data
 */
MControlDatasources.prototype.onCountsModeResponse = function(data) {
	var value = 'total';
	if (data.result === 'ok') {
		value = data.value;
	}

	// Legacy names, can be removed later
	if (value === 'selected') {
		value = 'total';
	}

	// More legacy names, can be removed later
	if (value === 'rate' || value === 'both') {
		value = 'row';
	}

	if (this.datasources[data.ds]) {
		this.datasources[data.ds].countsMode = value;
	}
};

/**
 * Function that handles final steps of data retrieval and processing
 *
 * @method onFinishedLoading
 * @private
 */
MControlDatasources.prototype.onFinishedLoading = function() {
	this.ready = true;
	this.manager.mapObservers.notify('datasourcesloaded');
};

/**
 * Creates a datasource object
 *
 * @method csreate
 * @param {String} id Datasources id
 * @param {Object} struct Datasource structure
 * @return {Object} Datasource object
 * @private
 */
MControlDatasources.prototype.create = function(id, struct) {
	var def = this.manager.getDatasource(id);
	var existing = this.datasources[id];
	
	var inc = true;
	var index = this.index;
	if(existing && existing.index != undefined){
		index = existing.index;
		inc = false;
	}
	
	var datasource = this.createDatasourceStructure(id, def, struct, index);
	if(inc){
		this.index++;
	}
	
	datasource.fetched = Moonshadow.helpers.getUTCDateISOString(new Date());
	return datasource;
};

/**
* Create datasource structure
*
* @method createDatasourceStructure
* @param {Object} def Datasource Definition object
* @param {Object} struct Datasource structure
* @param {Int} Index
* @return {Object} Datasource Structure object
* @private
*/
MControlDatasources.prototype.createDatasourceStructure = function(id, def, struct, index){
	var datasource = {
		'dtype': 'datasource',
		'id': id,
		'alias': def.set_name,
		'name': def.ext_name,
		'index': index,
		'dsIndex': index,
		'int_name': id, // old school shit
		'ext_name': def.ext_name, // old school shit
		'set_name': def.set_name,
		'layers': def.layers,
		'struct': struct || [],
		'filters': {},
		'heatmap_data': def.heatmap_data || null,
		'userColors': {},
		'defaultColors': $.extend(true, {}, def.colors),
		'defaultSort': def.defaultSort,
		'requiredAddons': def.requiredAddons,
		'metadata': def.metadata,
		'viewOnly': def.viewOnly || false,
		'hideBuy': def.hideBuy || false,
		'hidden': def.hidden || false, 
	};

	// Find heatmap and add missing values
	for (var i = 0, l = datasource.struct.length; i < l; i++) {
		if (datasource.struct[i].int_name === '__heatmap') {
			datasource.struct[i].values = ["0",	"12_5", "25", "37_5", "50", "62_5",
										   "75", "87_5", "100"];
		}
	}
	
	return datasource;
};

MControlDatasources.prototype.hasReqAddons = function(dsId){
	var datasource = this.datasources[dsId];
	if(!datasource || !datasource.requiredAddons || !datasource.requiredAddons.length){
		return true;
	}
	var self = this;
	var has = true;
	$.each(datasource.requiredAddons, function(k, v) {
		if(!self.manager.hasAddon(v)) {
			has = false;
		}
	});
	return has;
};

/**
 * Returns a single attribute of a datasource
 *
 * @method getDatasourceAttribute
 * @param {String} isId Can be the int_name of a datgasource, or an alias
 * @param {String} attribute The property requested
 */
MControlDatasources.prototype.getDatasourceAttribute = function(isId, attribute){
	var id = this.aliases[isId];
	if(id){
		isId = id;
	}
	var ds = this.manager.getDatasource(isId);
	if(ds[attribute]){
		return ds[attribute];
	}
}

/**
 * Rebuilds structures and colors
 *
 * @method rebuildStruct
 * @param {Object[]} datasources Array of datasources defs
 * @param {Function} callback Callback to call when data is loaded
 */
MControlDatasources.prototype.rebuildStruct = function(datasourceIDs, callback) {
	var self = this;
	var ajax = new Moonshadow.Ajax();

	for (var i = 0, l = datasourceIDs.length; i < l; i++) {
		var dsId = datasourceIDs[i];
		ajax.addQuery(self.getStructQuery(dsId, i), self.onStructResponse, self);
		ajax.addQuery(self.getFieldsQuery(dsId), self.onFieldsResponse, self);
		ajax.addQuery(self.getColorQuery(dsId), function(data){
			self.onColorResponse(data, true);
		}, self);
	}

	ajax.execute(function() {
		callback();
	});	
};



function MControlEditSurvey(manager) {
	this.manager = manager;
	this.container;
	this.header = "Edit Survey"; 
	this.surveyEditorDirty = false;
	this.unknownField = "unknown"; //the field name of select-one-of-many that the QS uses to group unanswered questions 
	this.openPanel;
	
	this.survey;
	this.storedOptionOrder = [];
	this.storedQuestionOrder = [];
};

MControlEditSurvey.prototype.setDirty = function(dirty){
	this.surveyEditorDirty = dirty;
};

MControlEditSurvey.prototype.getDirty = function(){
	return this.surveyEditorDirty;
};

MControlEditSurvey.prototype.viewSurvey = function(surveyId){
	this.getSurveyForEditor(surveyId);
	this.buildSurveyEditor("view", true);
};

MControlEditSurvey.prototype.copySurvey = function(surveyId){
	this.getSurveyForEditor(surveyId);
	
	var copyText = " (Copy)";
	var newAddrname = this.survey.ext_name_abbr.substring(
		0, (this.survey.ext_name_abbr.length - copyText.length)
	) + copyText;
	
	if(this.survey){
		this.survey.ext_name += copyText;
		this.survey.ext_name_abbr = newAddrname;
		this.survey.live = false;
		this.survey.isNew = true;
		delete this.survey.int_name;
		delete this.survey.metadata;
		this.buildSurveyEditor("copy");
	}
};

MControlEditSurvey.prototype.editSurvey = function(surveyId){
	this.getSurveyForEditor(surveyId);
	this.buildSurveyEditor("edit");
};

MControlEditSurvey.prototype.getSurveyForEditor = function(surveyId){
	var survey = this.getSurveyByPropertyName("int_name", surveyId);
	if(!survey){
		MUILayoverPanel.alert("Survey not found");
		return false;
	}
	this.survey = $.extend(true, {}, survey);
};

MControlEditSurvey.prototype.newSurvey = function(survey_type, callback){
	this.survey = {
		"survey_type": survey_type
	};
	this.buildSurveyEditor("new", null, callback);
};

MControlEditSurvey.prototype.addObservers = function(){
	var self = this;
	this.manager.dataObservers.addObserver('keydown_ctrl_83', function(){
		self._saveSurvey(false);
	}, this);
};

MControlEditSurvey.prototype.removeObservers = function(){
	this.manager.dataObservers.removeContext('keydown_ctrl_83', this);
};

MControlEditSurvey.prototype.getSurveyByPropertyName = function(propery, value){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyByPropertyName(propery, value);
};

MControlEditSurvey.prototype.getSurveyNames = function(){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyNames();
};

MControlEditSurvey.prototype.getSurveyAbbrNames = function(){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyAbbrNames();
};

MControlEditSurvey.prototype.createSurvey = function(survey, callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.createSurvey(survey, callback);
};

MControlEditSurvey.prototype.changeEditType = function(editType, data){
	var ce = Moonshadow.helpers.ce;
	var panelTitle = Moonshadow.helpers.capitalize(editType) + " Survey";
	MUILayoverPanel.get("edit_survey").changeTitle(panelTitle);
	
	$(".survey_edit_type", this.container).val(editType);
	
	if(data){
		if(data.date_modified){
			$(".survey_date_modified", this.container).val(data.date_modified);
		}
		if(data.ext_name){
			var ogName = $(".survey_original_name", this.container);
			if(!ogName.length){
				ogName = $(ce("input"))
					.addClass("survey_original_name")
					.attr({
						"type": "hidden",
						"name": "original_name"
					})
				$(".survey_hidden_data", this.container)
					.append(ogName);
			}
			$(ogName).val(data.ext_name);
		}
		if(data.ext_name_abbr){
			var ogbName = $(".survey_original_name_abbr", this.container);
			if(!ogbName.length){
				ogbName = $(ce("input"))
					.addClass("survey_original_name_abbr")
					.attr({
						"type": "hidden",
						"name": "original_name_abbr"
					})
				$(".survey_hidden_data", this.container)
					.append(ogbName);
			}
			$(ogbName).val(data.ext_name_abbr);
		}
		if(data.int_name){
			var intName = $(".survey_int_name", this.container);
			if(!intName.length){
				intName = $(ce("input"))
					.addClass("survey_int_name")
					.attr({
						"type": "hidden",
						"name": "int_name"
					})
				$(".survey_hidden_data", this.container)
					.append(intName);
			}
			$(intName).val(data.int_name);
		}
	}
};

MControlEditSurvey.prototype.questionTypesAvailable = function(surveyType){
	if(surveyType == "facebookpoll"){
		var selector_one = this.getQuestionType("selector_one");
		selector_one.ui_types = ["radio"];
		return [
			this.getQuestionType("remark"),
			selector_one,
			this.getQuestionType("string_one")
		];
	}
	if(surveyType == "phonecampaigns"){
		var selector_one = this.getQuestionType("selector_one");
		selector_one.ui_types = [];
		return [selector_one];
	}
	return [
	    this.getQuestionType("remark"),
		this.getQuestionType("selector_one"),
		this.getQuestionType("string_one")
	];
};

MControlEditSurvey.prototype.briefNameSpecs = function(){
	return {
		"surveyName": 40,
		"questionName": 40,
		"optionName": 16
	}
};

MControlEditSurvey.prototype.questionTypes = function(){
	return {
		"remark": {
			"name": "Remark",
			"type": "remark"
		},
		"boolean": {
			"name": "Yes / No",
			"type": "boolean",
			"options": [{
				"name": "Options",
				"opt": "static",
				"defaultValue": "No",
				"values": [
					"No",
					"Yes"
				]
			}],
			"ui_types": [
			    "radio"
			]
		},
		"selector_one": {
			"name": "Select One of Many",
			"type": "selector",
			"allow_multi": false,
			"options": [{
				"name": "Options",
				"opt": "values",
				"defaultValue": []
			}],
			"ui_types": [
			    "select",
				"radio"
			]
		},
		"selector_many": {
			"name": "Select Multiple of Many",
			"type": "selector",
			"allow_multi": true,
			"options": [{
				"name": "Options",
				"opt": "values",
				"defaultValue": []
			}],
			"ui_types": [
				"checkbox"
			]
		},
		"string_one": {
			"name": "Text Input, Single Line",
			"type": "string",
			"allow_multi": false,
			"ui_types": [
				"input"
			]
		},
		"string_many": {
			"name": "Text Input, Multi Line",
			"type": "string",
			"allow_multi": true,
			"ui_types": [
				"textarea"
			]
		},
		"numeric": {
			"name": "Numeric Only",
			"type": "int",
			"options": [
				{
					"name": "Default Value",
					"opt": "unknown_value",
					"defaultValue": 0
				},{
					"name": "Maximum Value",
					"opt": "max_value",
					"defaultValue": 4000000000
				}
		    ],
			"ui_types": [
				"input"
			]
		},
		"date": {
			"name": "Date",
			"type": "date",
			"ui_types": [
				"input"
			]
		}
	}
};

MControlEditSurvey.prototype.getQuestionType = function(type){
	return this.questionTypes()[type];
};

MControlEditSurvey.prototype._surveyTypeStatic = {
	"groundgame": {
		"opening_title": "Instructions",
		"option_title": "Options",
		"question_text_title": "Question Text",
		"question_subtext_title": "Question Subtext"
	},
	"phonecampaigns": {
		"opening_title": "Opening Speech",
		"option_title": "Option Text for Display",
		"question_text_title": "Question Text for Display",
		"question_subtext_title": "Question Text for Dictation",
		"opening_default": "[Suggested opening:] Hello! We are calling from [%_display_name] at [Caller ID Number] and [Website Address]. " +
			"We would appreciate your participation in a brief poll concerning [insert subject]. "
	},
	"facebookpoll": {
		"opening_title": "Opening Introduction",
		"option_title": "Options",
		"question_text_title": "Question Text",
		"question_subtext_title": "Question Subtext"
	}
};


MControlEditSurvey.prototype._scrollTo = function(elem, callback){
	$(".edit_survey_panel", this.openPanel.container).scrollTo(elem, 300, {
		"onAfter": callback
	});
};

MControlEditSurvey.prototype._scrollIntoView = function(elem, callback){
	if(!this._inView(elem)){
		this._scrollTo(elem, callback);
	}
	callback && callback();
};

MControlEditSurvey.prototype._inView = function(elem) {
    var offset = $(elem).offset();
    var height = $(elem).height();
    var top = offset.top;
    var bottom = offset.top + height;
    var vpOffset = $(".edit_survey_panel", this.openPanel.container).offset();
    var vpHeigth = $(".edit_survey_panel", this.openPanel.container).height();
    var vpTop = vpOffset.top;
    var vpBottom = vpOffset.top + vpHeigth;
    return (top >= vpTop && bottom <= vpBottom);
}

MControlEditSurvey.prototype.buildSurveyEditor = function(editType, readOnly, callback){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var ext_name, ext_name_abbr, questions, instructions, date_modified, live, int_name, routing_id, routingOptions;
	var routingObject = {};
	
	if(this.survey){
		ext_name = this.survey.ext_name;
		ext_name_abbr = this.survey.ext_name_abbr;
		questions = this.survey.questions;
		instructions = this.survey.instructions;
		date_modified = this.survey.date_modified;
		live = this.survey.live;
		editType == "edit" && (int_name = this.survey.int_name);
		
		if(this.survey.survey_type == "phonecampaigns"){
			routing_id = this.survey.routing_id;
			routingOptions = this.getRoutingFromSurvey(this.survey);
			
			for(var i = 0, l = routingOptions.length; i < l; ++i){
				var r = routingOptions[i];
				routingObject[r.routing] = r.optionNumber + ". " + r.question;
			}
		}
	}
	
	var panelTitle = Moonshadow.helpers.capitalize(editType) + " Survey";
	if(!ext_name && !questions){
		panelTitle = "New Survey";
	}
	var questionsLocked = readOnly;
	
	if (editType == "edit" && live === true)
		questionsLocked = true;
	
	if(editType == "copy"){
		this.setDirty(true);
	}
	
	var questionsContainer = $(ce("div"))
		.addClass("edit_survey_questions")
		.append(
			$(ce("label"))
				.append("Questions:"),
			this.buildQuestionEditor(questions, editType, questionsLocked, routingObject)
		);

	var restoreQuestionOrderHandler = function(e){
		$(".edit_survey_cancel_reorder_questions_button", self.openPanel.container)
			.addClass("hide");
		self.restoreQuestionOrder();
		exitReorderMode($(".edit_survey_reorder_questions_button", self.openPanel.container));
	};
	
	var changeOrderButtons = function(button){
		$(button).val("Save Order"); 
		$("input", ".add_question_button", self.openPanel.container)
			.attr(
				"disabled", true
			);
	};
	
	var exitReorderMode = function(button){
		$(button).val("Reorder Questions");
		$("input", ".add_question_button")
			.attr(
				"disabled", false
			);
		
		$(".edit_survey_cancel_reorder_questions_button", self.openPanel.container)
			.addClass("hide");
		
		self.applyQuestionReorder(questionsContainer);
	}
	
	var enterReorderMode = function(button){
		var reo = function(){
			$(".edit_survey_cancel_reorder_questions_button", self.openPanel.container)
				.removeClass("hide");
			
			changeOrderButtons(button);
			self.storeQuestionOrder();
			self.reorderQuestions(questionsContainer);
		}
		
		if(self.survey.survey_type == "phonecampaigns"){
			return MUILayoverPanel.confirm({
				"message": "Reordering questions will also affect question routing. Continue?",
				"callback": function(res, id, hide){
					if(res){
						reo();
					}
					hide();
				}
			});
		}
		reo();
	};
	
	var reorderQuestionsHandler = function(){
		if(!$(".edit_survey_item_question", questionsContainer).length)
			return false;
		
		if($(this).val() == "Save Order"){
			exitReorderMode(this);
		}else{
			enterReorderMode(this);
		}
	};
	
	var instructionsText = instructions;
	if(!instructionsText){
		var defaulInst = this._surveyTypeStatic[this.survey.survey_type].opening_default;
		if(defaulInst){
			instructionsText = defaulInst;
			if(this.survey.survey_type == "phonecampaigns"){
				var customerDisplay = this.manager.getOption("customer_display", "Company Name");
				instructionsText = instructionsText.replace("%_display_name", customerDisplay);
			}
		}
	}

	var buildSurveyContent = [$(ce("div"))
		.addClass("edit_survey_panel")
		.append(
			$(ce("div"))
				.addClass("edit_survey_item")
				.append(
					$(ce("div"))
						.addClass("edit_survey_item_row")
						.append(
							$(ce("div"))
								.addClass("edit_survey_item_right_col")
								.append(
									MUIFormElements.textContainer(
										"Abbreviated:", 
										$(ce("input"))
											.addClass("survey_brief_name_field ms_text_field_input")
											.attr({
												"type": "text",
												"value": ext_name_abbr,
												"maxlength": self.briefNameSpecs().surveyName
											})
									)
								),
							$(ce("div"))
								.addClass("edit_survey_item_left_col")
								.append(
									MUIFormElements.textContainer(
										"Survey Name:", 
										$(ce("input"))
											.addClass("survey_name_field required ms_text_field_input")
											.attr({
												"type": "text",
												"value": ext_name,
											})
											.on("change", function(e){
												var bname = $(".survey_brief_name_field", $(this).closest(".edit_survey_item"));
												if(!$(bname).val()){
													$(bname).val($(this).val().substr(0, self.briefNameSpecs().surveyName));
												}
											}), true
									)
								)
						),
						$(ce("div"))
							.addClass("edit_survey_item_row")
							.append(
								$(ce("div"))
									.addClass("edit_survey_item_full_col")
									.append(
										//sanitizeString
											//title, value, required, className, events, attr
										MUIFormElements.textArea(
											this._surveyTypeStatic[this.survey.survey_type].opening_title,
											instructionsText, 
											this.survey.survey_type == "phonecampaigns", 
											"survey_instructions_field"
										)
									)
							),
						$(ce("div"))
							.addClass("edit_survey_item_row")
							.append(
								$(ce("div"))
									.addClass("edit_survey_item_full_col edit_survey_button_row")
									.append(
										$(ce("input"))
											.addClass("edit_survey_cancel_reorder_questions_button hide reorder_question_button")
											.attr({
												"type": "button",
												"value": "Cancel Reorder"
											})
											.click(restoreQuestionOrderHandler),
										$(ce("input"))
											.addClass("edit_survey_reorder_questions_button reorder_question_button")
											.addClass(questions && questions.length > 1 ? null : "hide")
											.attr({
												"type": "button",
												"value": "Reorder Questions"
											})
											.click(reorderQuestionsHandler)
									)
							),
						$(ce("div"))
							.addClass("survey_hidden_data")
							.append(
								$(ce("input"))
									.addClass("survey_date_modified")
									.attr({
										"type": "hidden",
										"name": "date_modified",
										"value": date_modified
									}),
								$(ce("input"))
									.addClass("survey_edit_type")
									.attr({
										"type": "hidden",
										"name": "edit_type",
										"value": editType
									}),
								(ext_name && $(ce("input"))
									.addClass("survey_original_name")
									.attr({
										"type": "hidden",
										"name": "original_name",
										"value": ext_name
									})),
								(ext_name_abbr && $(ce("input"))
									.addClass("survey_original_name_abbr")
									.attr({
										"type": "hidden",
										"name": "original_name_abbr",
										"value": ext_name_abbr
									})),
								(int_name && $(ce("input"))
									.addClass("survey_int_name")
									.attr({
										"type": "hidden",
										"name": "int_name",
										"value": int_name
									}))
							)
				),
				questionsContainer
			).get(0),
			$(ce("div"))
				.addClass("add_question_button")
				.append(
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Add Question",
							"disabled": readOnly
						})
						.click(function(e){
							self.markDirty.apply(self, [this, true]);
							$(".no_quesitons").remove();
							var newQuestion = self.buildQuestionItemEditor(
								self.getNextQuestionIndex()
							);
							$(".edit_survey_questions").append(newQuestion);
							self._scrollTo(newQuestion, function(){
								$(".question_text", newQuestion).focus();
							});
							self.reorderQuestionsButton();
						}),
					$(ce("input"))
						.addClass("survey_save_button")
						.attr({
							"type": "button",
							"value": "Save As Copy and Close",
							"disabled": readOnly ? true : !self.getDirty()
						})
						.click(function(){
							self._saveCopyAndClose();
						}),
					$(ce("input"))
						.addClass("survey_save_button")
						.attr({
							"type": "button",
							"value": "Save Survey",
							"disabled": readOnly ? true : !self.getDirty()
						})
						.click(function(){
							self._saveSurvey(false);
						}),
					$(ce("input"))
						.addClass("survey_save_button")
						.attr({
							"type": "button",
							"value": "Save and Close",
							"disabled": readOnly ? true : !self.getDirty()
						})
						.click(function(e){
							self._saveSurvey(true);
						})
				).get(0)
			];
	
	var panelOptions = {
		"id": "edit_survey", 
		"content": buildSurveyContent,
		"title": panelTitle,
		"onClose": function(close, context){
			self.closeEditor(function(survey){
				callback && callback(survey);
				close && close();
			}, context);
		},
		"context": this,
		"fixed": false,
		"animate": true,
		"minWidth": 550,
		"maxHeight": 700,
		"position": {
			"width": 800,
			"height": 500
		}
	};
	
	if(this.survey.survey_type == "groundgame"){
		panelOptions.docs = {
			"url": Moonshadow.gg_tutorials,
			"icon": "sprite-tutorial tut_icon",
			"title": "Ground Game Tutorials"
		};
	}
	
	this.openPanel = new MUILayoverPanel(panelOptions);
	this.addObservers();
	this.openPanel.open();
	this.reorderQuestionsButton();
	this.enableEdit(readOnly);
};

MControlEditSurvey.prototype._saveCopyAndClose = function(){
	var copyText = " (Copy)";
	var name = $(".survey_name_field", this.openPanel.container).val();
	$(".survey_name_field", this.openPanel.container).val(name + copyText)
	
	var abbrname = $(".survey_brief_name_field", this.openPanel.container).val();
	var newAddrname = abbrname.substring(0, (abbrname.length - copyText.length)) + copyText;
	$(".survey_brief_name_field", this.openPanel.container).val(newAddrname)
	
	var self = this;
	this.changeEditType("copy");
	this.validate(function(valid){
		if(valid){
			$(".survey_int_name", this.openPanel.container).remove();
			self.saveSurvey(true);
		}
	})
};

MControlEditSurvey.prototype._saveSurvey = function(close){
	var self = this;
	$(".survey_edit_type", this.openPanel.container).val("edit");
	this.validate(function(valid){
		if(valid){
			self.saveSurvey(close);
		}
	})
};

MControlEditSurvey.prototype.enableEdit = function(readOnly){
	if(readOnly){
		this.unbind();
		$(".panel_content", this.openPanel.container)
			.addClass("disabled_gray");
		$("input, textarea, select", this.openPanel.container)
			.attr({
				"disabled": true
			});
		$(".lock_button", this.openPanel.container)
			.remove();
		$(".delete_question", this.openPanel.container)
			.remove();
		$(".question_option_add_option_button", this.openPanel.container)
			.remove();
		$(".question_option_reorder_options_button", this.openPanel.container)
			.remove();
		$(".remove_question_text_option", this.openPanel.container)
			.remove();
		$(".randomize_option", this.openPanel.container)
			.remove();
		$(".reorder_question_button", this.openPanel.container)
			.remove();
	}else{
		this.bind();
	}
};

MControlEditSurvey.prototype.unbind = function(elem){
	if(elem == undefined){
		elem = this.openPanel.container;
	}
	$("input[type='text'], textarea, select", elem)
		.unbind("change keypress", this.bindActions.markDirty);
	
	$("input[type='text'], textarea", elem)
		.unbind("change", this.bindActions.sanitize);
	
	$("input[type='text'], textarea", elem)
		.unbind("keypress", this.bindActions.markValid);
};

MControlEditSurvey.prototype.bind = function(elem){
	if(elem == undefined){
		elem = this.openPanel.container;
	}
	
	this.unbind(elem);

	$("input[type='text'], textarea, select", elem)
		.on("change keypress", {"self": this}, this.bindActions.markDirty);
	
	$("input[type='text'], textarea", elem)
		.on("change", this.bindActions.sanitize);

	$("input[type='text'], textarea", elem)
		.on("keypress", this.bindActions.markValid);
};

MControlEditSurvey.prototype.unBindDragging = function(elem){
	if(elem == undefined){
		elem = this.openPanel.container;
	}
		
	$(document.body).unbind("mouseup", this.bindActions.endDrag);
	
	$(".dragger", elem)
		.unbind("mousedown", this.bindActions.startDrag);
	
	$(".dragger, .dragTarget", elem)
		.unbind("mouseup", this.bindActions.endDrag)
		.unbind("mousemove", this.bindActions.activeDrag);
};


MControlEditSurvey.prototype.bindDragging = function(elem){
	if(elem == undefined){
		elem = this.openPanel.container;
	}
	
	this.unBindDragging(elem);
	
	$(document.body).on("mouseup", {"self": this}, this.bindActions.endDrag)
	
	$(".dragger", elem)
		.on("mousedown", {"self": this}, this.bindActions.startDrag);
	
	$(".dragger, .dragTarget", elem)
		.on("mouseup", {"self": this}, this.bindActions.endDrag)
		.on("mousemove", {"self": this}, this.bindActions.activeDrag);
};


MControlEditSurvey.prototype.bindActions = {
	"markDirty": function(e){
		e.data.self.markDirty.apply(e.data.self, [this, true]);
	},
	"markValid": function(e){
		$(this).removeClass("invalid");
	},
	"sanitize": function(){
		this.value = Moonshadow.helpers.sanitizeString(this.value);
	},
	"startDrag": function(e){
		e.data.self.endDrag.apply(e.data.self);
		e.data.self.startDrag.apply(e.data.self, [e, $(this).closest(".dragTarget")]);
	},
	"endDrag": function(e){
		e.data.self.endDrag.apply(e.data.self);
	},
	"activeDrag": function(e){
		e.data.self.activeDrag.apply(e.data.self, [e]);
	}
};

MControlEditSurvey.prototype.closeEditor = function(callback, context){
	
	var self = this;
	var close = function(){
		context.setDirty(false);
		context.removeObservers();
		callback && callback(self.survey);
	};
	
	if(context.getDirty()){
		return MUILayoverPanel.confirm({
			"message": "Closing will discard all unsaved changes. Continue?",
			"callback": function(res, id, hide){
				if(res){
					close();
				}
				hide();
			}
		});
	}
	close();
};

MControlEditSurvey.prototype.markDirty = function(elem, isDirty){
	if(isDirty == undefined){
		isDirty = true;
	}
	$(".survey_save_button").attr("disabled", !isDirty);
	
	if(!this.getDirty() && isDirty != this.getDirty()){
		$(".survey_date_modified").val(
			Moonshadow.helpers.getUTCDateISOString()
		);
		if(elem){
			if($("> .option_date_modified", $(elem).parent()).length){
				$("> .option_date_modified", $(elem).parent()).val(
					Moonshadow.helpers.getUTCDateISOString()
				);
			}
			if($("> .question_date_modified", $(elem).closest(".edit_survey_item_question_container")).length){
				$("> .question_date_modified", $(elem).closest(".edit_survey_item_question_container")).val(
					Moonshadow.helpers.getUTCDateISOString()
				);
			}
		}
	}
	
	this.openPanel.showIsDirty(isDirty);
	
	this.setDirty(isDirty);
};

MControlEditSurvey.prototype.startDrag = function(e, elem){
	if(!this.dragging.isDragging){
		this.dragging.isDragging = true;
		this.dragging.topOffset = e.pageY;
		this.dragging.draggedElem = elem;
		$(elem).addClass("dragging_color");
	}
};

MControlEditSurvey.prototype.endDrag = function(){
	if(this.dragging.isDragging){
		this.dragging.isDragging = false;
		this.dragging.topOffset = 0;
		$(this.dragging.draggedElem)
			.removeAttr("style")
			.removeClass("dragging_color");
		window.getSelection && window.getSelection().removeAllRanges();
	}
};

MControlEditSurvey.prototype.activeDrag = function(e){
	if(this.dragging.isDragging && this.dragging.draggedElem){
		var top = (e.pageY - this.dragging.topOffset);
		var draggabledContainer = $(this.dragging.draggedElem).parent();
		var isFirstDraggable = $(this.dragging.draggedElem).index() == 
			$(".dragTarget", draggabledContainer).first().index();
		if(isFirstDraggable && top < 0){
			return false;
		}
		var isLastDraggable = $(this.dragging.draggedElem).index() == 
			$(".dragTarget", draggabledContainer).last().index();
		if(isLastDraggable && top > 0){
			return false;
		}
		if(top > $(this.dragging.draggedElem).height()){
			this.markDirty(this.dragging.draggedElem, true);
			var nextElem = $(this.dragging.draggedElem)
				.next(".dragTarget");
			$(nextElem)
				.after(this.dragging.draggedElem);
			top = 0;
			this.dragging.topOffset = e.pageY;
		}
		if(top < ($(this.dragging.draggedElem).height() * -1)){
			this.markDirty(this.dragging.draggedElem, true);
			var prevElem = $(this.dragging.draggedElem)
				.prev(".dragTarget");
			$(prevElem)
				.before(this.dragging.draggedElem);
			top = 0;
			this.dragging.topOffset = e.pageY;
		}
		$(this.dragging.draggedElem)
			.css({
				"position": "relative",
				"top": top + "px",
				"z-index": 10000
			});
	}
};

MControlEditSurvey.prototype.dragging = {
	"isDragging": false,
	"topOffset": 0,
	"draggedElem": null
};

MControlEditSurvey.prototype.buildQuestionEditor = function(questions, editType, questionsLocked, routingObject){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	if(!questions || !questions.length)
		return $(ce("div"))
			.addClass("no_quesitons")
			.append("No questions added");
	
	return $(questions).map(function(index, question){
		var container = self.buildQuestionItemEditor(index, editType, question, routingObject);
		if(questionsLocked){
			self.toggleDisabledQuestionEditing($(".edit_survey_item_question_container", container), true);
		}
		return container;
	});
	
};

MControlEditSurvey.prototype.renumberEditQuestions = function(){
	$(".question_number").each(function(index, item){
	    $(item).empty().append(index +1);
	});
};

MControlEditSurvey.prototype.storeQuestionOptionOrder = function(container){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	this.storedOptionOrder = [];
	$(".question_option_container", container).each(function(index, item){
	    self.storedOptionOrder.push(item);
	});
};

MControlEditSurvey.prototype.restoreQuestionOptionOrder = function(button){
	var container = $(button).closest(".survey_question_options");
	if(!this.storedOptionOrder.length){
		return;
	}
	$(".question_option_container", container).remove();
	$(container).append(
		$.map(this.storedOptionOrder, function(option){
			return $(option).get(0);
		})
	);
	this._exitReorderOptionMode(container);
};

MControlEditSurvey.prototype.renumberEditQuestionOptions = function(container){
	var ce = Moonshadow.helpers.ce;
	$(".question_option_container", container).each(function(index, item){
	    $(".edit_survey_option_number_container", item).empty().append(
	    	(index +1) + ":"
	    );
	});
};

MControlEditSurvey.prototype.toggleDisabledQuestionEditing = function(container, disabled){
	if(disabled === undefined)
		disabled = !$(".question_text", container).get(0).disabled;
	if(disabled){
		if($(".question_options_apply_reorder", container).length > 0)
			this.applyOptionReorder(container);
		$(container).addClass("disabled_gray");
		$(".delete_question", container).addClass("invisible");
		$(".question_options_button_panel > *", container).addClass("hide");
		$(".remove_question_text_option", container).addClass("hide");
	}else{
		$(container).removeClass("disabled_gray");
		$(".delete_question", container).removeClass("invisible");
		$(".question_options_button_panel > *", container).removeClass("hide");
		$(".remove_question_text_option", container).removeClass("hide");
	}
	$("input, textarea, select", container).attr("disabled", disabled);
};

MControlEditSurvey.prototype.clearInvalid = function(elem){
	$(".invalid", elem).removeClass("invalid");
};


MControlEditSurvey.prototype.validate = function(callback){
	var valid = true;
	this.clearInvalid();
	$(".required").each(
		function(key, item){
			var val = $(item).val().trim();
			$(item).val(val);
			if (!val.length){
				valid = false;
				$(item).addClass("invalid");
			}
		}
	);
	var issues = {};
	if(!valid){
		issues["Some required fields are missing information. Please double check your input and try again."] = true;
	}
	var hasAtLeastOneQuestion = false;
	$(".question_type_select").each(function(key, item){
		if(item.value != "remark")
			hasAtLeastOneQuestion = true;
	});
	if(!hasAtLeastOneQuestion){
		valid = false;
		issues["You need at least one non-remark type quesiton in your survey."] = true;
	}
	
	var editType = $(".survey_edit_type", this.container).val();
	
	if(editType != "edit"){
		var int_name = $(".survey_int_name", this.container).val();
		var uniqueNames = this.getSurveyNames();
		if(uniqueNames.length){
			if($.inArray($(".survey_name_field", this.container).val(), uniqueNames) > -1){
				$(".survey_name_field", this.container).addClass("invalid");
				issues["There is already a survey by this name. Please supply a different survey name."] = true;
				valid = false;
			}
		}
		
		var uniqueAbbrNames = this.getSurveyAbbrNames();
		if(uniqueAbbrNames.length){
			if($.inArray($(".survey_brief_name_field", this.container).val(), uniqueAbbrNames) > -1){
				$(".survey_brief_name_field", this.container).addClass("invalid");
				issues["There is already a survey with this abbreviation. Please supply a different survey name."] = true;
				valid = false;
			}
		}
	}
	
	var self = this;
	$(".question_option_textfield").each(function(k, v){
		var validMessage = self.validateOption(this);
		if(!validMessage.valid){
			var message = "";
			for(var i in validMessage){
				if(!validMessage.hasOwnProperty(i) || i == "valid"){
					continue;
				}
				issues[i] = true;
			}
			valid = false;
			return false;
		}
	});
	
	var question_brief_name_field_unique = {};
	$(".question_brief_name_field").each(function(k, v){
		var val = $(v).val();
		if(val != ""){
			if(question_brief_name_field_unique[val]){
				$(v).addClass("invalid");
				$(question_brief_name_field_unique[val]).addClass("invalid");
				issues["Quesiton abbreviations must be unique."] = true;
				valid = false;
				return false;
			}
			question_brief_name_field_unique[val] = v;
		}
		var option_brief_name_field_unique = {};
		$(".option_brief_name_field", $(v).closest(".edit_survey_item_question_container")).each(function(key, val){
			var value = $(val).val();
			if(value != ""){
				if(option_brief_name_field_unique[value]){
					$(val).addClass("invalid");
					$(option_brief_name_field_unique[value]).addClass("invalid");
					issues["Option abbreviations must be unique per question."] = true;
					valid = false;
					return true;
				}
				option_brief_name_field_unique[value] = val;
			}
		});
	});
	
	if(Moonshadow.helpers.objCount(issues) > 0){
		MUILayoverPanel.alert({
			"title": "Please correct the following issues:",
			"message": function(){
				var retStr = "";
				for(var i in issues){
					retStr += "* " + i + "<br>";
				}
				return retStr;
			}()
		})
	}
	
	callback(valid);
};

MControlEditSurvey.prototype.validateOption = function(optionContainer){
	var allOptCont = $(optionContainer).closest(".survey_question_options");
	var allOpts = $(".question_option_textfield", allOptCont);
	var uniqueItems = {};
	var self = this;
	var messages = {
		"valid": true
	};
	$.each(allOpts, function(index, field){
		field.value = field.value.trim();
		if(!field.value){
			return true;
		}
		if(uniqueItems[field.value]){
			$(field).addClass("invalid");
			$(uniqueItems[field.value]).addClass("invalid");
			messages["All options for a single question must be unique."] = true;
			messages.valid = false;
		}else if(field.value.toLowerCase() == self.unknownField.toLowerCase()){
			$(field).addClass("invalid");
			messages["Invalid field name: \"" + field.value + "\". Please change."] = true;
			messages.valid = false;
		}else{
			uniqueItems[field.value] = field;
		}
	});
	
	return messages;
};

MControlEditSurvey.prototype.buildQuestionItemEditor = function(index, editType, questionObj, routingObject){
	
	var ext_name, ext_name_abbr, int_name, subtext, type, allow_multi, ui_type, 
		data_attributes, date_modified, query_result, routing_id, randomize_options;
	if(questionObj){
		ext_name = questionObj.ext_name;
		ext_name_abbr = questionObj.ext_name_abbr;  
		editType == "edit" && (int_name = questionObj.int_name); 
		subtext = questionObj.subtext; 
		type = questionObj.type; 
		allow_multi = questionObj.allow_multi; 
		ui_type = questionObj.ui_type; 
		data_attributes = questionObj.data_attributes; 
		date_modified = questionObj.date_modified; 
		query_result = questionObj.query_result; 
		routing_id = questionObj.routing_id;
		randomize_options = questionObj.randomize_options;
	}
	
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var qtObj;
	var qtObjects = {};
	var qTypes = this.questionTypesAvailable(this.survey.survey_type);
	for(var i = 0, l = qTypes.length; i < l; ++i){
		qtObjects[qTypes[i].name] = qTypes[i];
	}
	
	if(this.survey.survey_type == "phonecampaigns"){
		qtObj = qTypes[0];
	}
	
	var questionNumberInt = index + 1;
	
	var surveyQuestionOptions = $(ce("div"))
		.addClass("survey_question_options");
	
	var alertRow = function(){
		if(query_result && query_result.result != "ok"){
			return $(ce("div"))
				.addClass("edit_survey_item_row")
				.append(
					$(ce("div"))
						.addClass("creation_error")
						.append(
							$(ce("span"))
								.append("There was a problem creating this question:"),
							$(ce("span"))
								.append(query_result.message)
						)
				);
		}
		return "";
	};
	
	var buttonRow = function(){
		return $(ce("div"))
			.addClass("edit_survey_number_row")
			.append(
				$(ce("div"))
					.addClass("question_button delete_question right clickable")
					.attr({
						"title": "Delete Question"
					})
					.click(function(e){
						var container = $(this).closest(".edit_survey_item_question");
						if(!container.disabled){
							MUILayoverPanel.confirm({
								"message": "Permanently delete this question? If the survey is saved, this action cannot by undone.",
								"callback": function(res, id, hide){
									if(res){
										self.markDirty.apply(self, [null, true]);
										$(container).remove();
										self.renumberEditQuestions();
										self.reorderQuestionsButton();
										self.applyQuestionReorder(self.openPanel.container);
									}
									hide();
								}
							});
						}
					}),
				$(ce("div"))
					.addClass("question_button clickable right lock_button")
					.attr({
						"title": "Lock/Unlock Question"
					})
					.click(function(e){
						$(this).toggleClass("lock_button unlock_button");
						var container = $(this).closest(".edit_survey_item_question_container");
						self.toggleDisabledQuestionEditing.apply(self, [container]);
					}),
				$(ce("div"))
					.addClass("question_number")
					.append(questionNumberInt)
			);
	};
	
	var questionAndAbbrevRow = function(){
		return $(ce("div"))
			.addClass("edit_survey_item_row")
			.append(
				$(ce("div"))
					.addClass("edit_survey_item_right_col")
					.append(
						MUIFormElements.textContainer(
							"Abbreviated:",
							$(ce("input"))
								.addClass("question_brief_name_field ms_text_field_input")
								.attr({
									"type": "text",
									"maxlength": self.briefNameSpecs().questionName,
									"value": ext_name_abbr
								})
						)
					),
				$(ce("div"))
					.addClass("edit_survey_item_left_col")
					.append(
						MUIFormElements.textField(
							self._surveyTypeStatic[self.survey.survey_type].question_text_title,
							ext_name, true, "question_text required", {
								"change": function(e){
									var bname = $(".question_brief_name_field", $(this).closest(".edit_survey_item_question"));
									if(!$(bname).val()){
										$(bname).val($(this).val().substr(0, self.briefNameSpecs().questionName));
									}
								}
							}
						)
					)
			);
	};
	
	var questionSubtextRow = function(){
		return $(ce("div"))
			.addClass("edit_survey_item_row")
			.append(
				$(ce("div"))
					.addClass("edit_survey_item_full_col")
					.append(
						MUIFormElements.textArea(
							self._surveyTypeStatic[self.survey.survey_type].question_subtext_title, 
							subtext,
							self.survey.survey_type == "phonecampaigns",
							"question_subtext"
						)
					)
			);
	};
	
	var buttonTypeRow = function(){
		return $(ce("div"))
			.addClass("edit_survey_item_row")
			.append(
				$(ce("div"))
					.addClass("edit_survey_item_full_col edit_survey_type_button_row")
					.append(
						MUIFormElements.textContainer(
							"Question Type:", 
							$(ce("select"))
								.addClass("question_type_select ms_select_input")
								.append(
									$(qTypes).map(function(ind, qt){
										return $(ce("option"))
											.attr({
												"value": qt.type,
												"name": qt.name,
												"selected": function(){
													if(type == qt.type){
														if(qt.allow_multi == null){
															qtObj = qtObjects[qt.name];
															return true;
														}else if(allow_multi == qt.allow_multi){
															qtObj = qtObjects[qt.name];
															return true;
														}
													}
													return false;
												}()
											})
											.append(qt.name)
											.get(0);
									})
								)
								.on("change", {
										"surveyQuestionOptions": surveyQuestionOptions,
										"data_attributes": data_attributes
									}, function(e){
									var surveyQuestionOptions = e.data.surveyQuestionOptions;
									var data_attributes = e.data.data_attributes;
									for(var i = 0, l = qTypes.length; i < l; ++i){
										if(qTypes[i].name == $("option:selected", this).attr('name')){
											$(surveyQuestionOptions)
												.append(
													self.buildQuestionTypeInterface(
														qTypes[i], 
														data_attributes, 
														e.data.surveyQuestionOptions,
														ui_type, i, routingObject,
														randomize_options
													)
												)
												.attr("name", qTypes[i].type);
											break;
										}
									}
								})
						)
					)
			);
	};

	var questionContainer = $(ce("div"))
		.addClass("edit_survey_item_question")
		.append(
			$(ce("div"))
				.addClass("reorder_info dragger hide"),
			$(ce("div"))
				.addClass("edit_survey_item_question_container")
				.append(
					$(ce("input"))
						.addClass("question_temp_val_holder")
						.attr({
							"type": "hidden",
							"name": "tempVals"
						}),
					$(ce("input"))
						.addClass("question_date_modified")
						.attr({
							"type": "hidden",
							"name": "date_modified",
							"value": date_modified || Moonshadow.helpers.getUTCDateISOString()
						}),
					alertRow(),
					buttonRow(),
					questionAndAbbrevRow(),
					questionSubtextRow(),
					this.survey.survey_type != "phonecampaigns" && buttonTypeRow(),
					$(surveyQuestionOptions)
						.append(
							self.buildQuestionTypeInterface(qtObj, data_attributes, surveyQuestionOptions, ui_type, index, routingObject, randomize_options)
						)
						.attr("name", (qtObj && qtObj.type) || "remark"),
					$(ce("div"))
						.addClass("clear"),
					int_name ? $(ce("input"))
						.addClass("question_int_name")
						.attr({
							"type": "hidden",
							"name": "int_name",
							"value": int_name
						}) : "",
					this.survey.survey_type == "phonecampaigns" && $(ce("input"))
						.addClass("question_type_select")
						.attr({
							"type": "hidden",
							"value": "selector"
						}),
					this.survey.survey_type == "phonecampaigns" && $(ce("input"))
						.addClass("question_routing_id")
						.attr({
							"type": "hidden",
							"value": routing_id || ("routing_" + this.generateRoutingId(questionNumberInt))
						})
				)
		)
		.get(0);
	
	self.bind(questionContainer);
	return questionContainer;
};

MControlEditSurvey.prototype.generateRoutingId = function(seed){
	return Moonshadow.helpers.generateMD5Id(seed + "_" + new Date());
};

MControlEditSurvey.prototype.reorderQuestionsButton = function(){
	var num = $(".edit_survey_item_question", this.openPanel.container).length;
	if(num > 1){
		return $(".edit_survey_reorder_questions_button", this.openPanel.container).removeClass("hide");
	}
	$(".edit_survey_reorder_questions_button", this.openPanel.container).addClass("hide");
};

MControlEditSurvey.prototype.reorderQuestions = function(container){
	var self = this;
	$(".edit_survey_item_question", container)
		.each(function(index, item){
			var qInfoCont = $(".edit_survey_item_question_container", item);
			var number = $(".question_number", qInfoCont).text();
			var text = $(".question_text", qInfoCont).val();
			
			var type = "";
			var questionType = $(".question_type_select option:selected", qInfoCont);
			if(questionType.length){
				type = " (" + $(".question_type_select option:selected", qInfoCont).text() + ")";
			}
			$(".reorder_info", item)
				.empty()
				.append(
					number, ": ", text, type
				)
				.removeClass("hide");
			$(qInfoCont)
				.addClass("hide");
			$(item)
				.addClass("dragTarget");
			
			self.bindDragging(container);
		});
};

MControlEditSurvey.prototype.getNextQuestionIndex = function(){
	return $("> div",".edit_survey_questions", this.openPanel.container).length;
};

MControlEditSurvey.prototype.getRoutingOptions = function(){
	var questionsElems = $(".question_text", this.openPanel.container);
	var options = [];
	for(var i = 0, l = questionsElems.length; i < l; ++i){
		var question = questionsElems[i];
		var p = $(question).closest(".edit_survey_item_question");
		var routing = $(".question_routing_id", p).val();
		options.push({
			"question": $(question).val(),
			"routing": routing,
			"optionNumber": i + 1
		})
	}
	return options;
};

MControlEditSurvey.prototype.getRoutingFromSurvey = function(survey){
	var options = [];
	if(!survey.questions){
		return options;
	}
	for(var i = 0, l = survey.questions.length; i < l; ++i){
		var question = survey.questions[i];
		options.push({
			"question": question.ext_name,
			"routing": question.routing_id,
			"optionNumber": i + 1
		})
	}
	return options;
};

MControlEditSurvey.prototype.updateRoutingUI = function(container, questionIndex){
	var routingOptions = this.getRoutingOptions();
	var routingObject = {};
	for(var i = 0, l = routingOptions.length; i < l; ++i){
		var r = routingOptions[i];
		r.display = r.optionNumber + ". " + r.question;
		routingObject[r.routing] = r;
	}
	var ce = Moonshadow.helpers.ce;
	
	$(".question_option_routing", container).each(function(index, item){
		var v = $(item).val();
		if(!v || v == "auto"){
			return true;
		}

		$(item)
			.empty()
			.append(
				routingObject[v] && routingObject[v].optionNumber > questionIndex + 2 
					? $(ce("option"))
						.attr({
							"value": v
						})
						.append(routingObject[v].display)
					: $(ce("option"))
						.attr({
							"value": "auto"
						})
						.append("Next question")
			);
	});
};

MControlEditSurvey.prototype.getQuestionsForRoutingOptions = function(select, routingKey){
	var ce = Moonshadow.helpers.ce;
	var self = this;

	var routingOptions = this.getRoutingOptions();
	var forwardOptions = [];
	var fromIndex = -1;
	for(var i = 0, l = routingOptions.length; i < l; ++i){
		if(routingOptions[i].routing == routingKey){
			fromIndex = i;
		}
	}
	
	var forwardOptions = routingOptions.slice(fromIndex + 2);
	if(!forwardOptions.length){
		return;
	}

	$(select)
		.empty()
		.append(
			$(ce("option"))
				.attr({
					"value": "auto"
				})
				.append("Next question"),
			$.map(forwardOptions, function(option){
				return $(ce("option"))
					.attr({
						"value": option.routing
					})
					.append(option.optionNumber + ". " + option.question)
					.get(0);
			})
		);
};

MControlEditSurvey.prototype.applyQuestionReorder = function(container){
	var self = this;
	$(".edit_survey_item_question", container)
		.each(function(index, item){
			$(".reorder_info", item)
				.empty()
				.addClass("hide");
			$(".edit_survey_item_question_container", item)
				.removeClass("hide");
			$(".question_number", item)
				.empty()
				.append(index + 1);
			self.updateRoutingUI(item, index);
			$(item)
				.removeClass("dragTarget");
			
			self.unBindDragging(container);
		});
};

MControlEditSurvey.prototype.storeQuestionOrder = function(){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	this.storedQuestionOrder = [];
	$(".edit_survey_item_question", this.openPanel.container).each(function(index, item){
	    self.storedQuestionOrder.push(item);
	});
};

MControlEditSurvey.prototype.restoreQuestionOrder = function(){
	if(!this.storedQuestionOrder.length){
		return;
	}
	$(".edit_survey_item_question", this.openPanel.container).remove();
	$(".edit_survey_questions", this.openPanel.container).append(
		$.map(this.storedQuestionOrder, function(question){
			return $(question).get(0);
		})
	);
};

MControlEditSurvey.prototype._enterReorderOptionMode = function(container){
	switch(this.survey.survey_type){
		case "phonecampaigns": 
			$(".edit_survey_option_left_col", container).removeClass("edit_survey_option_left_col_dictation");
			break;
		case "facebookpoll":
			$(".randomize_options_label input", container).attr({
				"disabled": true
			});
			$(".randomize_options_label", container).css({
				"font-style": "italic",
				"color": "gray"
			});
		case "groundgame":
		default:
	}
	
	$(".question_option_container", container).addClass("dragTarget");
	$(".edit_survey_option_delete_col", container).addClass("invisible");
	$(".edit_survey_option_number_container", container).addClass("dragger");
	$(".ms_text_field_small_label", container).addClass("invisible");
	$(".hidable", container).addClass("hide");
	$(".reorder_button", container).attr({
		"value": "Save Order"
	});
	$(".question_option_container input, .add_option_button, .question_option_uitype_select", container).attr({
		"disabled": true
	});
	$(".cancel_reorder_button", container).removeClass("hide");
	this.bindDragging(container);
	this.storeQuestionOptionOrder(container);
};

MControlEditSurvey.prototype._exitReorderOptionMode = function(container){
	switch(this.survey.survey_type){
		case "phonecampaigns": 
			$(".invisible", container).removeClass("invisible");
			$(".edit_survey_option_left_col", container).addClass("edit_survey_option_left_col_dictation");
			break;
		case "facebookpoll":
			$(".randomize_options_label input", container).attr({
				"disabled": false
			});
			$(".randomize_options_label", container).css({
				"font-style": "inherit",
				"color": "inherit"
			});
		case "groundgame":
		default:
			$(".invisible", $(".question_option_container", container).get(0)).removeClass("invisible");
		
	}
	$(".question_option_container", container).removeClass("dragTarget");
	$(".edit_survey_option_delete_col", container).removeClass("invisible");
	$(".edit_survey_option_number_container", container).removeClass("dragger");
	$(".hidable", container).removeClass("hide");
	$(".reorder_button", container).attr({
		"value": "Reorder Options"
	});
	$(".question_option_container input, .add_option_button, .question_option_uitype_select", container).attr({
		"disabled": false
	});
	$(".cancel_reorder_button", container).addClass("hide");
	this.unBindDragging(container);
	this.renumberEditQuestionOptions(container);
};


MControlEditSurvey.prototype.reorderOptions = function(button){
	var container = $(button).closest(".survey_question_options");
	if($(".question_option_container", container).hasClass("dragTarget")){
		this._exitReorderOptionMode(container);
	}else{
		this._enterReorderOptionMode(container);
	}
};

MControlEditSurvey.prototype.toggleRandomizerState = function(onOff, elements, index){
	if(!(elements instanceof Array)){
		elements = [elements];
	}

	for(var i = 0, l = elements.length; i < l; ++i){
		var state = onOff;
		if(onOff == undefined){
			//toggle
			state = $(elements[i]).hasClass("locked_randomize_option");
		}
		var ind = index || i;
		$(elements[i])
			.attr("title", "Order " + (state ? "randomized" : "locked") + " for option " + (ind + 1) + ". Click to " + (state ? "lock" : "randomize") + ".")
			.addClass(state ? "unlocked_randomize_option" : "locked_randomize_option")
			.removeClass(state ? "locked_randomize_option" : "unlocked_randomize_option");
	}
};


MControlEditSurvey.prototype.buildQuestionTypeInterface = function(qtObj, data_attributes, surveyQuestionOptions, ui_type, questionIndex, routingObject, randomize_options){
	
	var blarg = arguments;
	
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var returnElems = [];
	var buttonPanel = $(ce("div"))
		.addClass("question_options_button_panel")
		.get(0);


	var buildOptionUI = function(index, value, readOnly){
		var randomize;
		if(value){
			randomize = value.randomize != undefined ? value.randomize : false;
		}
		
		var optionContainer = $(ce("div"))
			.addClass("question_option_container");
		
		var deleteColumn = $(ce("div"))
			.addClass("edit_survey_option_delete_col")
			.append(
				$(ce("div"))
					.addClass("edit_survey_option_delete_container")
					.append(
						function(){
							if(self.survey.survey_type == "facebookpoll"){
								var locker = $(ce("div"))
									.addClass("randomize_option clickable")
									.addClass(randomize_options ? null : "hide")
									.on("click", function(){
										self.markDirty.apply(self, [this, true]);
										self.toggleRandomizerState(null, this, index);
									});
								self.toggleRandomizerState(randomize, locker, index);
								return locker;
							}
							return "";
						}(),
						$(ce("div"))
							.addClass("remove_question_text_option clickable")
							.attr("title", "Remove option "+ (index +1))
							.click({
									"index": index, 
									"optionContainer":optionContainer, 
									"surveyQuestionOptions": surveyQuestionOptions
								}, function(e){
									var remOpt = function(){
										self.markDirty.apply(self, [this, true]);
										$(e.data.optionContainer).remove();
										self.renumberEditQuestionOptions(e.data.surveyQuestionOptions);
									};
									if($(".question_option_textfield", e.data.optionContainer).val() != ""){
										return MUILayoverPanel.confirm({
											"message": "Remove option "+(index + 1)+" from this question? If the survey is saved, this action cannot by undone",
											"callback": function(res, id, hide){
												if(res){
													remOpt();
												}
												hide();
											}
										});
									}
									remOpt();
								}
							)
					)
			);

		var rightColumn = $(ce("div"))
			.addClass("edit_survey_option_right_col")
			.append(
				MUIFormElements.textContainer(
					"Abbreviated:",
					$(ce("input"))
						.addClass("option_brief_name_field ms_text_field_input")
						.attr({
							"type": "text",
							"maxlength": self.briefNameSpecs().optionName,
							"value": value && value.ext_name_abbr
						})
				),
				function(){
					if(self.survey.survey_type == "phonecampaigns"){
						var cont = MUIFormElements.textContainer(
							"If this option pressed, route to question:",
							$(ce("select"))
								.addClass("question_option_routing ms_select_input")
								.append(
										function(){
											if(value && value.routing && value.routing != "auto"){
												return $(ce("option"))
													.attr({
														"value": value.routing
													})
													.append(routingObject[value.routing])
													.get(0);
											}
											return $(ce("option"))
												.attr({
													"value": "auto"
												})
												.append("Next question")
												.get(0);
										}()
								)
								.on("mousedown", function(){
									var routingKey = $(this).closest(".edit_survey_item_question").find(".question_routing_id").val();
									self.getQuestionsForRoutingOptions(this, routingKey);
							}), 
							false
						);
						$(cont).addClass("hidable");
						return cont;
					}
					return "";
				}()
			);
		
		var questionPrefix = self.survey.survey_type == "phonecampaigns" ? "Opt" : "";
		
		var numberColumn = $(ce("div"))
			.addClass("edit_survey_option_number_col")
			.append(
				$(ce("div"))
					.addClass("edit_survey_option_number_container")
					.append(questionPrefix + (index + 1) + ":")
			);
				
		var leftColumn = $(ce("div"))
			.addClass("edit_survey_option_left_col")
			.addClass(self.survey.survey_type == "phonecampaigns" ? "edit_survey_option_left_col_dictation" : null)
			.append(
				MUIFormElements.textContainer(
					self._surveyTypeStatic[self.survey.survey_type].option_title + ":",
					$(ce("input"))
						.addClass("question_option_textfield ms_text_field_input")
						.addClass(self.survey.survey_type == "phonecampaigns" ? "required" : null)
						.attr({
							"type": "text",
							"value": value && value.option ? value.option : "",
							"name": "option"
						})
						.change(function(e){
							var bname = $(".option_brief_name_field", $(this).closest(".question_option_container"));
							if(!$(bname).val()){
								$(bname).val($(this).val().substr(0,self.briefNameSpecs().optionName));
							}
							self.clearInvalid(this);
							var field = this;
							var validMessage = self.validateOption(this);
							if(!validMessage.valid){
								var message = "";
								for(var i in validMessage){
									if(!validMessage.hasOwnProperty(i) || i == "valid"){
										continue;
									}
									message += i + "<br>";
								}
								MUILayoverPanel.alert({
									"message":message,
									"callback": function(res, id, hide){
										hide();
										field.focus();
									}
								});
							}
						}), 
					true
				),
				self.survey.survey_type == "phonecampaigns" 
					? MUIFormElements.textArea(
						"Option Text for Dictation:",
						value && value.dictation ? value.dictation : "",
						true, "option_dictation_field"
					)
					: ""
			);
		
		
		$(optionContainer)
			.append(
				deleteColumn,
				rightColumn,
				numberColumn,
				leftColumn
			);

		if((self.survey.survey_type == "groundgame" || self.survey.survey_type == "facebookpoll" )&& index !== 0){
			$(".ms_text_field_small_label", leftColumn).addClass("invisible");
			$(".ms_text_field_small_label", rightColumn).addClass("invisible");
		}
		
		return $(optionContainer).get(0);
	};
	
	var addButton = function(){
		return $(ce("input"))
			.addClass("add_option_button")
			.attr({
				"type": "button",
				"value": "Add Option"
			})
			.click(function(e){
				self.markDirty(null, true);
				var container = $(this).closest(".survey_question_options");
				var index = $(".question_option_container", container).length;
				if(self.survey.survey_type == "phonecampaigns" && index == 10){
					//might be an issue with having over 10 items
					return MUILayoverPanel.alert("Phone polls cannot exceed 10 options at this time.");
				}
				var newOpt = buildOptionUI(index);
				$(container).append(newOpt);
				self.bind(container);
				self._scrollIntoView(newOpt, function(){
					$(".question_option_textfield", newOpt).focus();
				});
			});
	};
	
	var rearrangeButton = function(){
		return $(ce("input"))
			.addClass("right reorder_button")
			.attr({
				"id": "reorder_button",
				"type": "button",
				"value": "Reorder Options",
				"disabled": randomize_options
			})
			.click(function(e){
				self.reorderOptions(this);
			});
	};
	
	var randomizeOptionsCheck = function(){
		var checkBox = $(ce("input"))
			.addClass("randomize_options")
			.attr({
				"id": "randomize_options",
				"type": "checkbox",
				"value": "true",
				"checked": randomize_options
			})
			.on("change", function(){
				$(this)
					.closest(".question_options_button_panel")
					.find("#reorder_button")
					.attr({
						"disabled": this.checked
					});
				self.markDirty.apply(self, [this, true]);
				$(".randomize_option", surveyQuestionOptions)
					.addClass(!this.checked ? "hide" : null)
					.removeClass(this.checked ? "hide" : null)
				self.toggleRandomizerState(this.checked, $(".randomize_option", surveyQuestionOptions).toArray());
			})
		
		return $(ce("label"))
			.addClass("right randomize_options_label")
			.attr({
				"for": "randomize_options"
			})
			.append(
				"Randomize Order ",
				checkBox
			);
	};

	var cancelReorderButton = function(){
		return $(ce("input"))
			.addClass("right cancel_reorder_button hide")
			.attr({
				"type": "button",
				"value": "Cancel Reorder"
			})
			.click(function(e){
				self.restoreQuestionOptionOrder(this);
			});
	};
	
	var interfaceType = function(){
		return $(ce("div"))
			.addClass("edit_survey_interface_type_panel right")
			.append(
				$(ce("span"))
					.addClass("edit_survey_interface_type_label")
					.append(" Interface Type: "),
				$(ce("div"))
					.addClass("edit_survey_interface_type_select_container right")
					.append(
						$(ce("select"))
							.addClass("ms_select_input question_option_uitype_select")
							.append(
								$(qtObj.ui_types).map(function(key, item){
									return $(ce("option"))
										.attr("selected", ui_type == item)
										.val(item)
										.append(Moonshadow.helpers.capitalize(item))
										.get(0);
								})
							)
					)
			);
	};
	
	var tempSavedValues;
	try{
		if($(".question_temp_val_holder").val()){
			tempSavedValues = JSON.parse($(".question_temp_val_holder").val());
		}else{
			tempSavedValues = [];
		}
	}catch(e){
		tempSavedValues = [];
	}
	if($(surveyQuestionOptions).attr("name") == "selector"){
		tempSavedValues = [];
		$(".question_option_container", surveyQuestionOptions).each(function(index, div){
			var value = {
				"option": $(".question_option_textfield", div).val(),
				"date_modified": $(".date_modified", div).val(),
				"ext_name_abbr": $(".option_brief_name_field", div).val(),
                "randomize": $(".randomize_option", div).hasClass("unlocked_randomize_option")
			};
			tempSavedValues.push(value);
		});
		$(".question_temp_val_holder").val(JSON.stringify(tempSavedValues));
	}
	
	$(surveyQuestionOptions)
		.empty();
	
	if(qtObj && qtObj.options){
		for(var i = 0, l = qtObj.options.length; i < l; ++i){
			$(buttonPanel).empty();
			if(qtObj.options[i].opt == "values" || qtObj.options[i].opt == "static"){
				$(buttonPanel).append(
					qtObj.options[i].opt != "static" && addButton(),
					rearrangeButton(),
					cancelReorderButton(),
					randomizeOptionsCheck(),
					function(){
						if(qtObj && qtObj.ui_types && qtObj.ui_types.length > 1){
							return interfaceType();
						}
						return "";
					}()
				);
			}
			
			if($(buttonPanel).children().length){
				returnElems.push(
					$(buttonPanel).get(0)
				);
			} 
			
			var vals;
			if(qtObj.options[i].opt == "values"){
				vals = [{"option": ""}];
				if(tempSavedValues.length > 0){
					vals = tempSavedValues;
				}else{
					if(data_attributes && data_attributes[qtObj.options[i].opt]){
						if($.type(data_attributes[qtObj.options[i].opt]) == "array"){
							vals = $(data_attributes[qtObj.options[i].opt]).map(function(index, item){
								return typeof item == "string" ? {"option": item} : item;
							})
							.toArray();
						}else{
							vals = data_attributes[qtObj.options[i].opt];
						}
					}
				}
			}else if(qtObj.options[i].opt == "static"){
				vals = qtObj.options[i].values && $(qtObj.options[i].values).map(function(key, item){
					return {"option": item};
				}) || [];
			}else{
				returnElems.push(
					$(ce("input"))
						.addClass("question_option_textfield")
						.attr({
							"type": "text",
							"name": qtObj.options[i].opt
						})
						.val(qtObj.options[i].defaultValue)
						.get(0),
					$(ce("input"))
						.attr({
							"type": "hidden",
							"name": "date_modified"
						})
						.val("")
						.get(0)
				);
			}
			
			if(vals){
				for(var j = 0, ll = vals.length; j < ll; ++j){
					var readOnly = qtObj.options[i].opt == "static";
					returnElems.push(buildOptionUI(j, vals[j], readOnly));
				}
			}
		}
	}
	return returnElems;
};

MControlEditSurvey.prototype.saveSurvey = function(closeAfter){
	var self = this;
	var survey_type = (this.survey && this.survey.survey_type) || "groundgame";
	if(this.getDirty()){
		$(".survey_save_button").attr("disabled", true);
		var editSureyPanel = $(".edit_survey_panel");
		var surveyObject = {
			"ext_name": Moonshadow.helpers.sanitizeString($(".survey_name_field", editSureyPanel).val()),
			"survey_type": survey_type,
			"questions": []
		};
		if($(".survey_brief_name_field", editSureyPanel).val().length){
			surveyObject.ext_name_abbr = Moonshadow.helpers.sanitizeString($(".survey_brief_name_field", editSureyPanel).val()) || "";
		}
		var instructions = $(".survey_instructions_field", editSureyPanel).val();
		if(instructions.length){
			surveyObject.instructions = Moonshadow.helpers.sanitizeString(instructions);
		}
		surveyObject.questions = $(".edit_survey_item_question", editSureyPanel).map(
			function(key, item){
				var questionObj = {
					"ext_name": Moonshadow.helpers.sanitizeString($(".question_text", item).val()),
					"type": $(".question_type_select", item).val(),
					"routing_id": $(".question_routing_id", item).val(),
					"data_attributes": {},
					"date_modified": $(".question_date_modified", item).val(),
					"allow_multi": ($(".question_type_select", item).val() == "selector" 
						&& $(".question_type_select option:selected", item).attr("name") == "Select Multiple of Many")
						|| ($(".question_type_select", item).val() == "string"
						&& $(".question_type_select option:selected", item).attr("name") == "Text Input, Multi Line")
				};
				if($(".question_brief_name_field", item).val().length){
					questionObj.ext_name_abbr = Moonshadow.helpers.sanitizeString($(".question_brief_name_field", item).val());
				}
				if($(".question_int_name", item).length){
					questionObj.int_name = $(".question_int_name", item).val();
				}
				if($(".question_subtext", item).val().length){
					questionObj.subtext = Moonshadow.helpers.sanitizeString($(".question_subtext", item).val());
				}
				if($(".question_option_uitype_select", item).length){
					questionObj.ui_type = $(".question_option_uitype_select", item).val();
				}
				if($(".randomize_options", item).length){
					questionObj.randomize_options = $(".randomize_options", item).attr("checked") ? true : false;
				}
				var values = [];
				if($(".question_option_container", item).length){
					values = $(".question_option_container", item).map(
						function(optionKey, optionItem){
							var obj = {
								"option": Moonshadow.helpers.sanitizeString($(".question_option_textfield", optionItem).val()),
								"date_modified": $(".option_date_modified", optionItem).val() || Moonshadow.helpers.getUTCDateISOString()
							};
							if(self.survey.survey_type == "phonecampaigns"){
								if($(".option_dictation_field", optionItem).val().length){
									obj.dictation = Moonshadow.helpers.sanitizeString($(".option_dictation_field", optionItem).val());
								}
							}
							if($(".option_brief_name_field", optionItem).val().length){
								obj.ext_name_abbr = Moonshadow.helpers.sanitizeString($(".option_brief_name_field", optionItem).val());
							}
							obj.routing = "auto";
							if($(".question_option_routing", optionItem).val() != "auto"){
								obj.routing = $(".question_option_routing", optionItem).val();
							}
							if($(".randomize_option", optionItem).length){
								obj.randomize = $(".randomize_option", optionItem).hasClass("unlocked_randomize_option") ? true : false;
							}
							return obj;
						}
					)
					.toArray();
					if(values.length){
						questionObj.data_attributes.values = values;
					}
				}else if($(".survey_question_options .question_option_textfield", item).length){
					$(".survey_question_options .question_option_textfield", item).each(
						function(optionKey, optionItem){
							var val = Moonshadow.helpers.sanitizeString($(optionItem).val());
							if($(optionItem).parent().attr("name") == "int")
								val = parseInt(val, 10);
							questionObj.data_attributes[$(optionItem).attr("name")] = val;
						}
					);
				}
				return questionObj;
			}
		)
		.toArray();
		if($(".survey_int_name", editSureyPanel).length){
			var prevSavedInfo = self.getSurveyByPropertyName(
				"int_name", 
				$(".survey_int_name", editSureyPanel).val()
			);
			if(prevSavedInfo){
				for(var i in prevSavedInfo){
					if(prevSavedInfo.hasOwnProperty(i)){
						if(!surveyObject[i]){
							surveyObject[i] = prevSavedInfo[i];
						}
					}
				}
			}
		}
		this.createSurvey(surveyObject, function(data){
			self.markDirty(null, false);
			self.survey = data.survey;
			if(closeAfter){
				MUILayoverPanel.close("edit_survey");
			}else{
				self.changeEditType("edit", data.survey);
			}
		});
	}
};





/**
 * Handles access to filters
 *
 * @class MControlFilters
 * @constructor
 */
function MControlFilters(options) {
	this.name = 'filterscontrol';
	this.manager = null;
	this.filterOperation;
	this.options = options || {};
	this.filters = {};
	this.observers = new Moonshadow.Observer();
};

MControlFilters.prototype = new MControl;

/**
 * Init function for control
 *
 * @method init
 * @private
 * @param {MManager} manager Instance of MManager
 */
MControlFilters.prototype.init = function(manager) {
	this.manager = manager;
	this.bind();

	Moonshadow.helpers.updateProgress(80, 'Loading filters...');

	var filters = manager.getOption('filters');
	if (filters) {
		this.loadInitialFilters(filters);
	} else {
		this.processDatasourceFilters();
	}

	manager.dataObservers.notify("filtersprocessed");
};

/**
 * Load pre-set/default filters from datasource attrs
 *
 * @method loadInitialFilters
 * @private
 * @param {Object} filters Filters tree from ds attrs 
 */
MControlFilters.prototype.loadInitialFilters = function(filters) {
	var self = this;
	$(filters).each(function(index, filter){
		var ds = self.manager.getControl('datasources').getByAlias(filter.datasource);
		if (!ds) {
			throw new Error('Invalid datasource alias');
		}

		if (!self.filters[ds.id]) {
			self.filters[ds.id] = {};
		}

		self.setFilter(ds.id, filter.path, {'value': filter.value});
	});	
};

/**
 * Load filters from user stored state
 *
 * @method processDatasourceFilters
 * @private
 */
MControlFilters.prototype.processDatasourceFilters = function() {
	var datasourceControl = this.manager.getControl('datasources');
	var datasources = datasourceControl.getAll();

	for (var id in datasources) {
		var ds = datasources[id];
		if (!ds.filters) {
			continue;
		}

		this.filters[id] = {};
		this.parseFilters(id, [], ds.filters);
	}
};

/**
 * Parse parse legacy filter tree format in to new key/val format
 *
 * @method parseFilters
 * @private
 * @param {String} dsId Datasources id/int_name
 * @param {String[]} path Filter path - used as key
 * @param {Object} branch Branch/root of legacy filter tree
 */
MControlFilters.prototype.parseFilters = function(dsId, path, branch){
	for (var key in branch) {
		if (key === '__variables') {
			continue;
		}
		
		if(key === 'universe_filter_op') {
			this.setFilterOperator(branch[key]);
			continue;
		}

		var subPath = path.concat(key);
		if (branch[key].values) {
			this.parseFilters(dsId, subPath, branch[key].values);
			delete branch[key].values;
		}

		var countKeys = 0;
		for (var k in branch[key]) {
			countKeys++;
		}

		if (countKeys) {
			if(!this.filters[dsId])
				this.filters[dsId] = {};
			
			this.filters[dsId][subPath.join('|')] = branch[key];
		}
	}

	// Process __variables
	if (branch['__variables']) {
		this.filters[dsId][key] = branch['__variables'];
	}
};

/**
 * Bind event listeners
 *
 * @method bind
 * @private
 */
MControlFilters.prototype.bind = function() {
	this.manager.addAjaxEventListener('filterchange', this);
	this.manager.addAjaxEventListener('shapechanged', this);
	this.manager.addMapObserver('setFilter', this.onSetFilter, this);
	this.manager.addMapObserver('clearFilter', this.onClearFilter, this);
	//this.manager.addMapObserver('clearFilters', this.onClearFilters, this);
};

/**
 * Unbind event listeners
 *
 * @method unbind
 * @private
 */
MControlFilters.prototype.unbind = function() {
	this.manager.removeAjaxEventListener('filterchange', this);
	this.manager.removeAjaxEventListener('shapechanged', this);
	this.manager.removeMapObserver('setFilter', this.onSetFilter, this);
	this.manager.removeMapObserver('clearFilter', this.onClearFilter, this);
	//this.manager.removeMapObserver('clearFilters', this.clearFilters, this);
};

/**
 * Convert new key/val format to legacy tree structure
 *
 * @method filtersToJSON
 * @private
 * @param {String} dsId Datasource id/int_name
 * @return {Object} Legacy tree structure
 */
MControlFilters.prototype.filtersToJSON = function(dsId) {
	var result = {'values': {}}; 

	var dsFilters = this.filters[dsId];	
	if (dsFilters === undefined) {
		dsFilters = {};
	}

	var pointer = result;
	
  	for (var key in dsFilters) {
		if (key === '__variables') {
			continue;
		}

		var path = key.split('|');

		for (var i = 0, l = path.length; i < l; i++) {
			if (!pointer.values) {
				pointer.values = {};
			}

			pointer = pointer.values;

			if (!pointer[path[i]]) {
				pointer[path[i]] = {};
			}

			pointer = pointer[path[i]];
		}

		for (var filter in dsFilters[key]) {
			pointer[filter] = dsFilters[key][filter];
		}

		pointer = result;
	}

	if (dsFilters['__variables']) {
		result.values['__variables'] = dsFilters['__variables'];
	}

	return result.values;
};

/**
 * Get filters for data and path
 *
 * @method getFilter
 * @param {String} dsId Datasource id/int_name
 * @param {String} path Datasource path
 */
MControlFilters.prototype.getFilter = function(dsId, path, defaultValue) {
	var filters = this.getFilters(dsId);
	
	if (!filters) {
		return defaultValue || null;
	}

	return filters[path] || defaultValue || null;
};

/**
 * Get filters for data
 *
 * @method getFilters
 * @param {String} dsId Datasource id/int_name
 */
MControlFilters.prototype.getFilters = function(dsId, defaultValue) {
	return this.filters[dsId] || defaultValue || null;
};

/**
 * Get universe specific filters
 *
 * @method getUniverseFilters
 * @return {Object{}} Key/Value map of universe filters
 */
MControlFilters.prototype.getUniverseFilters = function() {
	var datasourceControl = this.manager.getControl('datasources');
	var universeControl = this.manager.getControl('universecontrol');
	
	var datasources = datasourceControl.getAll();
	var universeFilters = {};
	
	for (var id in datasources) {
		var filters = this.getFilters(id);
		for (var filter in filters) {
			if(filter.search(/^__universes/) > -1){
				universeFilters[filter] = filters[filter];
			}
		}
	}
	return universeFilters;
};

/**
 * Get universe specific filter ids
 *
 * @method getUniverseFilterIds
 * @return {Array[]} Array of universe ids
 */
MControlFilters.prototype.getUniverseFilterIds = function() {
	var datasourceControl = this.manager.getControl('datasources');
	var universeControl = this.manager.getControl('universecontrol');
	
	var filters = this.getUniverseFilters();
	var datasources = datasourceControl.getAll();
	var universeIds = [];
	
	for (var id in datasources) {
		var usersUniverses = universeControl.getUniverses(id);
		for (var filter in filters) {
			var uid = filter.split('|')[1];
			if(usersUniverses[uid]){
				universeIds.push(uid);
			}
		}
	}
	return universeIds;
};

/**
 * Get declarations (__variable)
 *
 * @method getDeclaration
 * @param {String} dsId Datasource id/int_name
 * @return {Object} Declarations or null if not found
 */
MControlFilters.prototype.getDeclarations = function(dsId) {
	var filters = this.getFilters(dsId);

	if (!filters || !filters['__variables']) {
		return null;
	}	

	return this.filters[dsId]['__variables'];
};

/**
 * Get declaration (__variable)
 *
 * @method getDeclaration
 * @param {String} dsId Datasource id/int_name
 * @param {String} id Declaration id/int_name
 * @param {String} [path] Declaration filter path
 * @return {Object} Declaration or null if not found
 */
MControlFilters.prototype.getDeclaration = function(dsId, id, path) {
	var dec = this.lookupDeclaration(dsId, id);
	if (!dec) {
		return null;
	}

	if (path) {
		var pointer = dec.values;
		var parts = path.split('|');
		for (var i = 0, l = parts.length; i < l; i++) {
			if (pointer[parts[i]]) {
				pointer = pointer[parts[i]];
			} else {
				return null;
			}
		}

		return $.extend({}, pointer);
	} else {
		return dec;
	}
};

/**
 * Set a declaration (__variable)
 *
 * @method setDeclaration
 * @param {String} dsId Datasource id/int_name
 * @param {Object} dec Declaration details
 * @param {String} [path] Declaration filter path
 * @param {Objcet} [value] Declaration filter value
 */
MControlFilters.prototype.setDeclaration = function(dsId, def, path, value) {
	if (!path && !def.int_name) {
		throw new Error('Declaration missing int_name');
	}

	var defId = def.int_name;
	var dec = this.lookupDeclaration(dsId, def.int_name);	
	if (!dec) {
		dec = def;
	}

	var values = {};
	if (!dec.values) {
		dec.values = {};
	} else {
		values = dec.values;
	}

	if (path) {
		var pointer = dec.values;
		var parts = path.split('|');
		for (var i = 0, l = parts.length; i < l; i++) {
			if (!pointer[parts[i]]) {
				pointer[parts[i]] = {};
			}

			if (i === l - 1) {
				pointer[parts[i]] = value;
			} else {
				pointer = pointer[parts[i]];	
			}
		}
	} else {
		dec = def;
		dec.values = values;
	}

 	var index = this.getDeclarationIndex(dsId, def.int_name);
	if (index === -1) {
		if (!this.filters[dsId]) {
			this.filters[dsId] = {};
		}

		if (!this.filters[dsId]['__variables']) {
			this.filters[dsId]['__variables'] = []
		}

		this.filters[dsId]['__variables'].push(dec);
	} else {
		this.filters[dsId]['__variables'][index] = dec;
	}


	if (!this.filters[dsId][defId]) {
		this.filters[dsId][defId] = {};
	}

	//this.manager.mapObservers.notify('filterchange', [dsId]);
};

/**
 * Clear declaration (__variable)
 *
 * @method clearDeclaration
 * @param {String} dsId Datasource id/int_name
 * @param {Object} dec Declaration details
 * @param {String} path Declaration filter path
 * @reutrn {Boolean} true if cleared, false if not found
 */
MControlFilters.prototype.clearDeclaration = function(dsId, id, path) {	
	if (path) {
		var dec = this.getDeclaration(dsId, id);
		if (!dec) {
			return false;
		}

		if (dec.values) {
			delete dec.values[path];
		}
	} else {
		var decIndex = this.getDeclarationIndex(dsId, id);
		if (decIndex === -1) {
			return false;
		}

		this.filters[dsId]['__variables'].splice(decIndex, 1);
	}

	//this.manager.mapObservers.notify('filterchange', [dsId]);
};

/**
 * Lookup declaration
 *
 * @method lookupDeclaration
 * @private
 * @param {String} dsId Datasource id/int_name
 * @param {String} id Declartion id/int_name
 * @return {Object} Declaration or null of not found
 */
MControlFilters.prototype.lookupDeclaration = function(dsId, id) {
	var decIndex = this.getDeclarationIndex(dsId, id);
	if (decIndex === -1) {
		return null;
	}

	return this.filters[dsId]['__variables'][decIndex];
};

/**
 * Lookup declaration
 *
 * @method lookupDeclaration
 * @private
 * @param {String} dsId Datasource id/int_name
 * @param {String} id Declartion id/int_name
 * @return {Number} index of declaration or -1 if not found
 */
MControlFilters.prototype.getDeclarationIndex = function(dsId, id) {
	var filters = this.getFilters(dsId);

	if (!filters || !filters['__variables']) {
		return -1;
	}

	for (var i = 0, l = filters['__variables'].length; i < l; i++) {
		var dec = filters['__variables'][i];
		if (dec.int_name === id) {
			return i;
		}
	}

	return -1;
};

MControlFilters.prototype.countFilters = function(dsId, path) {
	var filters = this.getFilters(dsId);
	var count = 0;

	if (!filters) {
		return count;
	}
	
	for (var id in filters) {
		// Don't count the __variables/declarations structure
		if (id === '__variables') {
			continue;
		}

		if(!path || (id.indexOf(path) === 0 && id !== path)) {
			count++;
			continue;
		}
		
		if(id === path && (filters[id].from != undefined || filters[id].to != undefined)){
			count++;
		}
	}

	return count;
};

MControlFilters.prototype.hasFilters = function(dsId){
	var filters = this.getFilters(dsId);
	if(!filters){
		return false;
	}
	return Moonshadow.helpers.objCount(filters) > 0;
};

MControlFilters.prototype.countDeclaration = function(dsId, decId, path) {
	var count = 0;

	var dec = this.getDeclaration(dsId, decId);

	if (!dec || !dec.values) {
		return count;
	}
	
	for (var key in dec.values) {
		if (!path || key === path) {
			count++;
		}
	}

	return count;
};

MControlFilters.prototype.hasDeclarations = function(dsId){
	var declarations = this.getDeclaration(dsId);
	if(!declarations){
		return false;
	}
	return Moonshadow.helpers.objCount(declarations) > 0;
};

MControlFilters.prototype.countDeclarations = function(dsId) {
	var decs = this.getDeclarations(dsId);

	if (!decs) {
		return 0;
	}

	var count = 0;

	for (var i = 0, l = decs.length; i < l; i++) {
		var dec = decs[i];
		count += this.countDeclaration(dsId, dec.int_name);
	}

	return count;
};

MControlFilters.prototype.onSetFilter = function (event, data) {
	var dsId = data.datasource;

	this.setFilter(dsId, data.path, data.value);
};

MControlFilters.prototype.notifyFilterChanges = function (dsIds){
	this.manager.mapObservers.notify('filterchange', dsIds);
};

MControlFilters.prototype.setFilter = function (dsId, path, value) {
	this.setFilterValue(dsId, path, value);
	this.manager.mapObservers.notify('filterchange', [dsId]);
};

MControlFilters.prototype.setFilterValue = function (dsId, path, value) {
	if (!this.filters[dsId]) {
		this.filters[dsId] = {};
	}

	this.filters[dsId][path] = value;
};

MControlFilters.prototype.onClearFilter = function(event, data, ajax) {
	var dsId = data.datasource;

	if (dsId !== undefined) {
		this.clearFilter(dsId, data.path);
	}
};

MControlFilters.prototype.clearFilter = function(dsId, path) {
	if (!this.filters[dsId]) {
		return; 
	}

	this.clearFilterValue(dsId, path);
	this.manager.mapObservers.notify('filterchange', [dsId]);
};

MControlFilters.prototype.clearFilterValue = function(dsId, path) {
	if (!this.filters[dsId]) {
		return; 
	}

	if(this.filters[dsId][path]){
		delete this.filters[dsId][path];
	}
	
	if($.isEmptyObject(this.filters[dsId])){
		delete this.filters[dsId];
	}
};

//MControlFilters.prototype.onClearFilters = function(event, data, ajax) {
//	var dsId = data.datasource;
//
//	if (this.filters[dsId]) {
//		this.clearFilters(dsId);
//	}
//};

MControlFilters.prototype.clearFiltersRegEx = function(dsId, pattern) {
	var filters = this.getFilters(dsId);
	
	var matches = [];
	for (var path in filters) {
		if (path.search(pattern) > -1) {
			matches.push(path);
		}
	}
	for(var i = 0, l = matches.length; i < l; ++i){
		delete this.filters[dsId][matches[i]];
	}
	
	this.manager.mapObservers.notify('filterchange', [dsId]);
};

MControlFilters.prototype.clearFilters = function(dsId) {
	delete this.filters[dsId];

	this.manager.mapObservers.notify('filterchange', [dsId]);
};

MControlFilters.prototype.clearAllFilters = function() {
	var dsControl = this.manager.getControl('datasources');
	var datasources = dsControl.getAll();
	var dsIds = [];

	for (var id in datasources) {
		dsIds.push(id);
		delete this.filters[id];
	};
	
	this.clearFilterOperator();
	this.manager.mapObservers.notify('filterchange', dsIds);
};

MControlFilters.prototype.filterQuery = function(dsId, event) {
	var query = {
		'query': 'save_stored_state',
		'ds': dsId,
		'qid': event,
		'name': 'filter__all'
	};

	
	var filters = this.filtersToJSON(dsId);

	//Check if universe filter operation is selected
	this.attachFilterOperator(filters);

	query.value = filters

	return query;
};

MControlFilters.prototype.attachFilterOperator = function(filters) {
	var colorByControl = this.getManager().getControl("colorbycontrol");
	var filteredUniverses = this.getUniverseFilterIds();
	var filterOp = this.getFilterOperator();
	if (filterOp && filteredUniverses.length){
		filters['universe_filter_op'] = filterOp;
	}
};

MControlFilters.prototype.setFilterOperator = function(operation) {
	this.filterOperation = operation;
};

MControlFilters.prototype.getFilterOperator = function() {
	return this.filterOperation;
};

MControlFilters.prototype.clearFilterOperator = function() {
	this.filterOperation = null;
};

MControlFilters.prototype.addListener = function(dsId, listener, context ) {
	if (!dsId) {
		throw new Error('Invalid datasource id');
	}

	this.observers.addObserver(dsId, listener, context);
	this.notifyListeners(dsId);
};

MControlFilters.prototype.removeListener = function(dsId, listener, 
																context) {
	if (!dsId) {
		throw new Error("Invalid datasource id");
	}

	this.observers.removeObserver(dsId, listener, context);
};


// @DEPCECATED
MControlFilters.prototype.removeAllFilterChangeListeners = function(setName) {
	var allObs = this.observers.getObservers();
	
	for (var dsId in allObs) {
		var obs = allObs[dsId];

		for (var i = 0, l = obs.length; i < l; i++) {
			this.observers.removeObserver(dsId, obs[i].o, obs[i].c);
		}
	}
};


MControlFilters.prototype.onAjaxEvent = function(event, data, ajax) {
	var query;

	if($.inArray(event, ['filterchange', 'shapechanged']) !== -1) {
		if (!data || !data.length) {
			return;
		}

		for (var i = 0, l = data.length; i < l; i++) {
			query = this.filterQuery(data[i], event);
			ajax.addQuery(query, this, true);			
		}
	}
};

MControlFilters.prototype.onAjaxResponse = function(event) {
	if (event.result != "ok") {
		return;
	}

	switch(event.qid) {
	case "filterchange":
		this.manager.mapObservers.notify('filterupdated', event);
		this.notifyListeners(event.ds);
		break;
	}
};

MControlFilters.prototype.notifyListeners = function(dsId) {
	this.observers.notify(dsId, this.filtersToJSON(dsId));
};

MControlFilters.prototype.getNextOrderInt = function(){
	var nextOrder = 0;
	var filters = this.getUniverseFilters();
	
	for(var i in filters){
		if(!filters.hasOwnProperty(i))
			continue;
		if(filters[i] && filters[i].order){
			var order = parseInt(filters[i].order, 10);
			if(nextOrder < order)
				nextOrder = order;
		}
	}
	return nextOrder + 1;
};

MControlFilters.prototype.filterCrawl = function(filters, tree){
	var self = this;
	var pairs = [];
	var rDateDecode	= Moonshadow.helpers.rDateDecode; // Need for to/from

	// Get all the filter names, we will use it to check if we need to process values
	// and any remaining items at the end were not found.
	var filterKeys = [];
	$.each(filters, function(key) {
		filterKeys.push(key);
	});

	// Crawl the tree looking for nodes that match the filters
	var crawler = function(branch) {
		for (var i = 0, l = branch.length; i < l; i++) {
			var node = branch[i];
			var intName = node.int_name;

			// Check if it is node we are looking for, if so process it
			if($.inArray(intName, filterKeys) !== -1) {
				var name = node.ext_name;

				// In some case, like bools, we need to use a cleaned up int_name
				if(node.dtype === 'boolean') {
					name = node.int_name.replace(/\_/g, ' ');

					// If date in name clean it up	
					var date = name.match(/(\d+)-(\d+)-(\d+)$/);
					if(date && date.length) {
						// Get the parts and map through parseInt to drop leading 0s
						var parts = date.slice(1);
						parts = $.map(parts, function(part) {
							return parseInt(part, 10);
						});							

						// Remove old date
						name = name.substring(0, name.indexOf(date[0]));
						// Concat new date
					  	name += [parts[1], parts[2], parts[0]].join('/');
					}
				}

				// Get values and possible subfilter pairs
				var values = processer(filters[intName], node.dtype, node.values);

				pairs.push({
					'ext': name,
					'val': values[0]
				});

				// Some filters have subfilters, if subfilters were found and processed
				// we need to add them to our pairs
				if(values[1].length) {
					pairs = pairs.concat(values[1]);
				}

				// Remove found filter from list of filters we are looking for
				filterKeys.splice($.inArray(intName, filterKeys), 1); 
			}

			// Short curcuit the search once we found everything
			if(!filterKeys.length) {
				break;
			}
			
			// Recursively run crawler on children
			if(node.filters) {
				crawler(node.filters);
			}
		}
	};

	// Processes filters and their values
	var processer = function(filter, type, branch) {
		// Push item on to pairs and get values			
		var values = [];
		var subPairs = [];

		// Ranged from
		if(filter.from) {
			var from = filter.from;

			if (type === 'date') {
				var fd = rDateDecode(filter.from);	
				from = [fd.getMonth() + 1, fd.getDate(), fd.getFullYear()].join('/');
			}

			values.push('From: ' + from);
		}
		
		// Ranged to
		if (filter.to) {
			var to = filter.to;

			if (type === 'date') {
				var td = rDateDecode(filter.to);
				to = [td.getMonth() +1, td.getDate(), td.getFullYear()].join('/');
			}

			values.push('To: ' + to);
		}

		// bools
		if(filter.values && branch != undefined) {
			$.each(filter.values, function(key, value) {
				if(value.value === 1) {
					values.push(key);
				}

				// Sub filters? 
				if(value.values) {
					var tree = [];
					// Find the right branch to crawl
					$.each(branch, function(index, node) {
						if(node.int_name === key) {
							tree = node.values;
							return false;
						}
					});

					// Recursively get the sub filters, we crawl even if didn't fine the 
					// that way we get the missing items too
					subPairs = self.filterCrawl(value.values, tree);
				}
			});
		}

		return [values, subPairs];
	};

	// Start crawling
	crawler(tree);

	
	var selectedElections = function(filters){
		var header = "";
		var allVals = [];
		if(filters["select_elections"]){
			var number = filters["select_elections"].to || filters["select_elections"].from || 0;
			if(filters["select_elections"].suffix){
				if(filters["select_elections"].suffix == "exact"){
					header = "Voted in exactly " + number + " of the following";
				}else if(filters["select_elections"].suffix == "fewer"){
					header = "Voted in fewer than " + number + " of the following";
				}
			}else{
				header = number + " or more of the following";
			}
		}
		if(filters["__variables"] && filters["__variables"].length > 0){
			$.each(filters["__variables"], function(key, item){
				if(item["values"]){
					$.each(item["values"], function(value){
						allVals.push(value.replace(/\_/g, " "));
					});
				}
			});
		}
		pairs.push({
			'ext': header,
			'val': allVals
		});
	};

	// Process not founds
	if($.isArray(filterKeys)){
		
		if(filters["__variables"] && filters["select_elections"]){
			selectedElections(filters);
		}else if(filters["__polygon"]){
			pairs.push({
				'ext': "Polygon",
				'val': ["User defined"]
			});
		}else if(filters["circle_filter"]){
			pairs.push({
				'ext': "Circle",
				'val': ["User defined"]
			});
		}else if(!filters["__universes"]){
			$.each(filterKeys, function(key, item) {
				pairs.push({
					'ext': item,
					'val': processer(filters[item], undefined)
				});
			});
		}
	}else{
		$.each(filterKeys, function(key) {
			pairs.push({
				'ext': key,
				'val': processer(filters[key], undefined)
			});
		});		
	}

	return pairs;
};

MControlFilters.prototype.explainFilters = function(dsId, filters){
	
	var dsControl = this.manager.getControl("datasources");
	var universeControl = this.manager.getUniverseControl();
	var datasource = dsControl.getById(dsId);
	var filters = filters || {};

	var pairs = [];
	
	var getUniverseExplain = function(values){
		var universeNames = [];
		for (var key in values) {
			if (values.hasOwnProperty(key)) {
				if (key.indexOf('__unpurchased') !== -1) {
					universeNames.push("Unpurchased Records");
					continue;
				}

				if (key.indexOf('__purchased') !== -1) {
					universeNames.push("Purchased Records");
					continue;
				}

				var extNamefound = false;
				// two versions, one for array type and the other for object :\
				if(universeControl.values.length) {
					for (var j = 0, l = universeControl.values.length; j < l; j++) {
						if(universeControl.values[j] && universeControl.values[j].int_name == key){
							universeNames.push(universeControl.values[j].ext_name);
							extNamefound = true;
							break;
						}
					}
				} else {
					for(var u in universeControl.values) {
						if(u == key) {
							universeNames.push(universeControl.values[u].ext_name);
							extNamefound = true;
							break;
						}
					}
				}

				// Not found, so push int name
				if (!extNamefound) {
					universeNames.push(key);
				}
			}
		}

		pairs.push({
			"ext": "Universes",
			"val": universeNames
		});
	};

	if(filters.non_filter){
		if(filters.expand_contact){
			var operations = [];
			if(filters.expand){
				operations.push("Expand");
			}
			if(filters.contract){
				operations.push("Contract");
			}

			pairs.push({
				"ext": "Operation",
				"val": operations.join(", ")
			});

			var universeItem = {};
			universeItem[filters.base_universe] = 1;
			getUniverseExplain(universeItem);
		}
	}else{
		// Get pairs for filters;
		pairs = pairs.concat(this.filterCrawl(filters, datasource.struct));
	}
		
	if (filters['__universes'] && filters['__universes'].values) {
		getUniverseExplain(filters['__universes'].values);
	}

	//remove invalid details. This can happen if the universe was 
	//	created with a data path that no longer exists.
	for(var i = 0, l = pairs.length; i < l; ++i){
		var p = pairs[i];
		if(p.val && p.val.length){
			for(var ii = 0, ll = p.val.length; ii < ll; ++ii){
				v = p.val[ii];
				if(typeof v == "object"){
					p.invalid = true;
				}
			}
		}
	}
	
	return $(pairs).filter(function(index, item){
		if(!item.invalid)
			return true;
		return false;
	})
	.toArray();
};



function MControlColorBy(options) {
	this.name = 'colorbycontrol';
	this.manager = null;

	this.options = options || {};
	this.defaultDsId = null;

	this.colorBys = {};

	this.activeDsId = null;
	this.activeColorBy = null;
};

MControlColorBy.prototype = new MControl;

MControlColorBy.prototype.init = function(manager) {
	this.manager = manager;

	this.setDefaultDatasource();
	
	// Colors from user stored state
	this.loadDatasourceColorBys();
	// If instance color by, then load it (embedded client)
	this.loadInstanceColorBy();
	// Default colors from attrs
	this.loadDefaultColorBy();

	manager.addAjaxEventListener("colorbychange", this);

	var dsId = this.getActiveDsId() || this.defaultDsId;
	this.setActiveColorBy(dsId);
};

MControlColorBy.prototype.setDefaultDatasource = function() {
	var dsId = this.manager.getOption('datasource', null);
	if (dsId === null) {
		throw new Error('No default datasource defined');
	}

	this.defaultDsId = dsId;
};

MControlColorBy.prototype.loadDefaultColorBy = function() {
	
	var dsId = this.defaultDsId;
	
	//if color by already set (user stored color first) return false
	var colorBy = this.getActiveColorBy();
	if (colorBy)
		return false;
	
	colorBy = this.manager.getOption('map.tile', null);
	if (!colorBy) {
		throw new Error('No default tile defined');
	}
	
	if (!colorBy.dataType){
		throw new Error('Invalid default color');
	}

	//This is a @HACK to deal with colors in attrs not matching
	var colorsControl = this.manager.getControl('colors');
	if(!colorsControl.defaults[dsId][colorBy.dataType]){
		Moonshadow.helpers.LogHandler(
			new Error(['Invalid default colorby path', dsId, colorBy.dataType].join(' ')),
			window.location.href,
			"MControlColorBy.prototype.loadDefaultColorBy"
		);
		colorBy.dataType = "__total";
	}
	
	// Deal with missing properties
	if (!colorBy.color) {
		colorBy.color = colorBy.dataType;
	}

	// This is a @HACK to deal with the attrs being old
	// once we define a tree path, data path, etc... this won't be used
	if (!colorBy.treePath) {
		colorBy.treePath = colorBy.dataPath;
		colorBy.dataPath = [colorBy.color];
	}
	
	// Time to update set the default color by
	this.setColorBy(dsId, colorBy.color, colorBy.colors, colorBy.dataPath,
					colorBy.treePath);
};

MControlColorBy.prototype.loadDatasourceColorBys = function(){
	var datasources = this.manager.getControl('datasources').getAll();

	for (var dsId in datasources) {
		var ds = datasources[dsId];
		if (ds.colorBy) {
			var colorBy = ds.colorBy;
			if (!colorBy.dataPath) {
				colorBy.dataPath = [colorBy.color];
			}

			this.setColorBy(dsId, colorBy.color, colorBy.colors, 
							colorBy.dataPath, colorBy.treePath);

			if(ds.colorBy.universes){
				this.setColorByUniverses(dsId, ds.colorBy.universes);
			}
			
			if (dsId === this.defaultDsId) {
				this.activeDsId = dsId;
				this.activeColorBy = this.getColorBy(dsId);
			}

		}
	}
};

MControlColorBy.prototype.loadInstanceColorBy = function() {
	var colorBy = this.manager.getOption('colorBy');
	if (colorBy) {
		// Instance colors by need to set each time to ensure
		// that the layers show current (not past) state.
		this.activeDsId = null;

		var datasources = this.manager.getControl('datasources');
		var ds = datasources.getByAlias(colorBy.datasource);

		var path = colorBy.path.split('|');
		var color = path.slice().shift();

		this.setColorBy(ds.id, color, null, path, null);
		this.setActiveColorBy(ds.id);
	}				
};

MControlColorBy.prototype.getActiveDsId = function() {
	return this.activeDsId;
};

MControlColorBy.prototype.getActiveColorBy = function() {
	return this.activeColorBy;
};

MControlColorBy.prototype.setActiveColorBy = function(dsId) {
	var previousColorBy = this.getActiveColorBy();
	if(previousColorBy && previousColorBy != this.getActiveColorBy()){
		this.deactivateColorBy(previousColorBy);
	}
	
	var colorBy = this.getColorBy(dsId);
	this.activateColorBy(colorBy);
	if (previousColorBy && previousColorBy.dsId != colorBy.dsId) {
		this.manager.notify("datasourcechange");
	}

	this.manager.notify('colorbychange', dsId, true);
};

MControlColorBy.prototype.deactivateColorBy = function(colorBy){
	if(!colorBy){
		return;
	}
	this.activeColorBy = null;
	this.activeDsId = null;
	var colors = this.manager.getControl('colors');
	colors.removeListener(
		colorBy.dsId, 
		colorBy.dataPath.join('|'), 
		null, this.onColorChange, this
	);
};

MControlColorBy.prototype.activateColorBy = function(colorBy){
	if(!colorBy){
		return;
	}
	this.activeColorBy = colorBy;
	this.activeDsId = colorBy.dsId;
	var colors = this.manager.getControl('colors');
	colors.addListener(
		colorBy.dsId, 
		colorBy.dataPath.join('|'),
		null, this.onColorChange, this
	);
};

MControlColorBy.prototype.getColorBy = function(dsId) {
	if (!this.colorBys[dsId]) {
		throw new Error('Color by not found');
	}

	var colorBy = this.colorBys[dsId];
	
	if(colorBy.color == "__universes"){
		this.getUniversesForColorBy(dsId);
	}else{
		this.deleteColorByUniverses(dsId);
	}
	
	return this.colorBys[dsId];
};

MControlColorBy.prototype.setColorBy = function(dsId, color, colors, dataPath,
												treePath) {
	if (!colors) {
		var colorsControl = this.manager.getControl('colors');		
		colors = colorsControl.getColorsForField(dsId, dataPath.join('|'));
		colors = this.getQueryColors(colors);
	}

	var colorBy = {
		'color': color,
		'colors': colors,
		'dataPath': dataPath,
		'treePath': treePath,
		'dsId': dsId
	};
	
	var baseLayer = this.manager.getControl('layerBase');
	if(baseLayer){
		baseLayer.changeSettings({
			'dataType': color,
			'datasource': dsId
		});
	}
	
	this.colorBys[dsId] = colorBy;
};

MControlColorBy.prototype.getUniversesForColorBy = function(dsId) {
	var filtersControl = this.manager.getControl('filterscontrol');
	var universes = filtersControl.getUniverseFilterIds();
	this.setColorByUniverses(dsId, universes);
};

MControlColorBy.prototype.setColorByUniverses = function(dsId, universes) {
	var colorBy = this.colorBys[dsId];
	if(universes.length){
		colorBy.universes = universes;
	}else{
		this.deleteColorByUniverses(dsId);
	}
};

MControlColorBy.prototype.deleteColorByUniverses = function(dsId){
	var colorBy = this.colorBys[dsId];
	delete colorBy.universes;
};

MControlColorBy.prototype.getSetColorByQuery = function(dsId) {
	return {
		"query": "save_stored_state",
		"name": "color_by__set_color",
		"ds": dsId,
		"value": this.getColorBy(dsId)
	}
};

MControlColorBy.prototype.onColorChange = function() {
	var dsId = this.getActiveDsId();
	var colorBy = this.getActiveColorBy(dsId);

	var colorsControl = this.manager.getControl('colors');
	
	if(colorBy.color === "__universes"){
		colors = {};
	}else{
		colors = colorsControl.getColorsForField(dsId, colorBy.dataPath.join('|'));
	}
	
	colorBy.colors = this.getQueryColors(colors);
	this.setActiveColorBy(dsId);
};

MControlColorBy.prototype.onAjaxEvent = function(event, data, ajax) {
	var dsId = this.getActiveDsId();

	ajax.addQuery(this.getSetColorByQuery(dsId), this, this, true);

	var colorBy = this.getActiveColorBy();
	if (colorBy.color === '__heatmap') {
		// Put this one in the very front
		ajax.addQuery(this.getHeatMapOptionsQuery(dsId), this, this, true);
	}
};

MControlColorBy.prototype.onAjaxResponse = function() {};

MControlColorBy.prototype.getHeatMapOptionsQuery = function() {
	var colors = [];
	var filter = this;
	var colorOrder = ["0","12_5","25","37_5","50","62_5","75","87_5","100"];

	var dsId = this.getActiveDsId();

	var colorsControl = this.manager.getControl('colors');
	var heatmapColors = colorsControl.getColorsForField(dsId, '__heatmap');

	$.each(colorOrder,function(k,v) {
		colors.push(heatmapColors[v]);
	});

	var query = {
		"query":"save_stored_state",
		"name":"heatmap_options",
		"value": {
			"scale":1.00000000,
			"colors":colors
		},
		"qid":"heatmapcolor",
		"ds": "__app"
	};

	return query;
};

MControlColorBy.prototype.getQueryColors = function(colors) {
	var legacyFormat = {};

	for(var color in colors) {
		legacyFormat[color] = {
			'value': colors[color]
		};
	}

	return legacyFormat;
};

MControlColorBy.prototype.getPathFromTree = function(tree){
	var flat = [];
	var recurs = function(branch) {
		for (var i in branch) {
			if (i !== "values" && i !== "value") {
				flat.push(i);
				if (branch[i].values) {
					recurs(branch[i].values);
				}
			}
		}
	}

	recurs(tree);

	return flat.join('|');
};

	/**
 * Handles access to colors 
 *
 * @class MControlColors
 * @constructor
 */
function MControlColors(options) {
	this.name = 'colors';
	this.manager = null;

	this.index = 0;

	this.colors = {};
	this.gradients = {};
	this.defaults = {};
	this.defaultGradients = {};
	this.users = {};
	this.observers = new Moonshadow.Observer();

	this.aliases = {};
	this.ready = false;
	this.dirty = {};
};

MControlColors.prototype = new MControl;

/**
 * Init function for class, called as part of control loading
 * 
 * @method init
 * @param {Manager} manager Reference to manager
 */
MControlColors.prototype.init = function(manager) {
	this.manager = manager;

	// Setup default and user colors
	this.loadColors();
	// Load instance colors (embedded client)
	this.loadInstanceColors();
};

/**
 * Load colors from datasources
 * 
 * @method loadColors
 * @private
 */
MControlColors.prototype.loadColors = function() {
	Moonshadow.helpers.updateProgress(70, 'Loading colors...');

	var datasources = this.manager.getControl('datasources').getAll();
	for (var dsId in datasources) {
		this.loadColorsForDatasource(datasources[dsId]);
	}
};

/**
 * Load colors for a datasource.
 * 
 * @method loadColorsForDatasource
 * @private
 * @param {Datasource} ds Datasource to reload colors for
 */
MControlColors.prototype.loadColorsForDatasource = function (ds) {
	var dsId = ds.id;
	this.aliases[ds.alias] = dsId;
	this.defaults[dsId] = {};
	this.defaultGradients[dsId] = {};
	this.colors[dsId] = {};
	this.gradients[dsId] = {};

	this.processDatasource(ds, this.defaults[dsId]);
};

/**
 * Reload colors for a datasource.
 * 
 * @method reloadColorsForDatasource
 * @private
 * @param {String} dsId Datasource id to reload colors for
 */
MControlColors.prototype.reloadColorsForDatasource = function (dsId) {
	var ds = this.manager.getControl('datasources').getById(dsId);
	this.loadColorsForDatasource(ds);
};

/**
 * Walk datasources colors and update colors and defColors with a map of data
 * data paths to map of values to colors
 *
 * @method processDatasource
 * @private
 * @param {Datasource} ds Datsource to process
 * @param {Object} defColors Reference to object that will store default colors
 */
MControlColors.prototype.processDatasource = function(ds, defColors) {
	var dsId = ds.id;
	var dsDefaults = ds.defaultColors || {};
	var dsUser = ds.userColors || {};
	var dsStruct = ds.struct;

	for (var i = 0, l = ds.struct.length; i < l; i++) {
		var branch = ds.struct[i];
		var branchId = branch.int_name;
		var branchDefaults = this.getBranch(dsDefaults, branchId);

		var path = [];
		if (branch.dtype !== 'collection') {
			path.push(branchId);
		} else {
			if (!branchDefaults) {
				branchDefaults = dsDefaults;			
			}
		}

		this.processDefaults(dsId, branch, path, branchDefaults);
	}

	// Process user colors
	this.processUser(dsId, dsUser, []);
};

/**
 * Recursivly process default colors
 *
 * @method processDefaults
 * @private
 * @param {String} dsId Id for datasource
 * @param {Object} struct Structure to walk and process colors
 * @param {Array} path Path to struct
 * @param {Object} defaults Default branch for struct
 */
MControlColors.prototype.processDefaults = function(dsId, struct, path, defaults) {
	var branchPath = path.slice();

	if (struct.dtype === 'boolean' && !struct.values) {
		struct.values = ['Yes', 'No', 'Unknown'];
	}

	if (struct.values) {
		var values = {};
		for (var i = 0, l = struct.values.length; i < l; i++) {
			var value = struct.values[i];
			var id = typeof value !== 'object' ? value : value.int_name;

			var gradientColors = [];
			if (defaults && defaults.__gradient) {
				var gradient = defaults.__gradient
				gradientColors = this.getGradientColors(gradient.points, gradient.model,
														struct.values.length);

				this.defaultGradients[dsId][path.join('|')] = gradient;
			}

			var subDefaults = this.getBranch(defaults, id);
			var defaultColor = this.getValue(subDefaults);
			var gradientColor = gradientColors[i] ? gradientColors[i].replace('#', '') :
				null;

			values[id] = defaultColor || gradientColor || this.genColorForString(id);

			if (typeof value === 'object' && value.values) {
				var subPath = branchPath.concat(value.int_name);

				for(var ii = 0, ll = value.values.length; ii < ll; ii++) {
					var subBranch = value.values[ii];
					var subBranchId = subBranch.int_name;
					var subSubDefaults = this.getBranch(subDefaults, subBranchId);

					var subSubPath = subPath.slice();
					if (subBranch.dtype !== 'collection') {
						subSubPath.push(subBranchId);
					} else {
						if (!subSubDefaults) {
							subSubDefaults = subDefaults;
						}
					}

					this.processDefaults(dsId, subBranch, subSubPath, subSubDefaults);
				}
			}
		}

		var key = path.join('|');
		this.defaults[dsId][key] = values;
	}

	if (struct.filters) {
		for (var i = 0, l = struct.filters.length; i < l; i++) {
			var subBranch = struct.filters[i];
			var subBranchId = subBranch.int_name;
			var subDefaults = this.getBranch(defaults, subBranchId);

			var subPath = branchPath.slice();
			if (subBranch.dtype !== 'collection') {
				subPath.push(subBranchId);
			} else {
				if (!subDefaults) {
					subDefaults = defaults;
				}
			}

			this.processDefaults(dsId, subBranch, subPath, subDefaults);
		}		
	}
};

/**
 * Process user colors
 * 	
 * @method processUser
 * @private
 * @param {String} dsId Datasource id
 * @param {Object} colors User colors for path
 * @param {Array} path Path of colors
 */
MControlColors.prototype.processUser = function(dsId, colors, path) {
	var values = {};
	var branchPath = path.slice();

	var userGradient = {};
	if (colors.__gradient) {
		

		var datasources = this.manager.getControl('datasources');
		var dsValues = datasources.getValues(dsId, path.join('|'));
		if(dsValues){
			
			var gradient = colors.__gradient;
			this.setUserGradient(dsId, path, gradient);
			
			var gradientColors = this.getGradientColors(gradient.points, gradient.model,
					dsValues.length);

			for (var i = 0, l = dsValues.length; i < l; i++) {
				userGradient[dsValues[i]] = gradientColors[i].replace('#', '');
			}
		}
	}

	for (var branchId in colors.values) {
		var branch = this.getBranch(colors, branchId);

		// If gradient defined, then set that before checking for a specific color
		if (userGradient[branchId]) {
			values[branchId] = userGradient[branchId];
		}

		if (branch.value) {
			values[branchId] = branch.value;
		}
		
		if (branch.values) {
			this.processUser(dsId, branch, branchPath.concat(branchId));
		}		
	}

	if (!$.isEmptyObject(values)) {
		this.setUserColors(dsId, path, values);
	}
};

/**
 * Set user level colors
 * 
 * @method setUserColors
 * @param {String} dsId Datasource id
 * @param {Array} path
 * @param {Object} values Color values to set
 */
MControlColors.prototype.setUserColors = function(dsId, path, values) {
	try {
		this.setColors(dsId, path.join('|'), values);
	} catch (e) {
		path.shift();

		if (!path.length) {
			return;
		}	

		this.setUserColors(dsId, path, values);
	}
};

/**
 * Set user level gradient
 * 
 * @method setUserGradient
 * @param {String} dsId Datasource id
 * @param {Array} path
 * @param {Object} gradient Gradient to set
 */
MControlColors.prototype.setUserGradient = function(dsId, path, gradient) {
	try {
		this.setGradient(dsId, path.join('|'), gradient);
	} catch (e) {
		path.shift();

		if (!path.length) {
			return;
		}	

		this.setUserGradient(dsId, path, gradient);
	}
};

/**
 * Load instance colors (for embedded client)
 *
 * @method loadInstanceColors
 * @private
 */
MControlColors.prototype.loadInstanceColors = function() {
	var instanceColors = this.manager.getOption('colors');
	if (!instanceColors || !instanceColors.length) {
		return;
	}

	var datasources = this.manager.getControl('datasources');	

	for (var i = 0, l = instanceColors.length; i < l; i++) {
		var colors = instanceColors[i];
		var ds = datasources.getByAlias(colors.datasource);
		this.setColorsForField(ds.id, colors.path, colors.value);
	}
};

/**
 * Check for datasource
 *
 * @method hasDatasource
 * @param {String} dsId
 */
MControlColors.prototype.hasDatasource = function(dsId) {
	if (!this.defaults[dsId]) {
		throw new Error('Invalid datasource id ' + dsId);
	}
};

/** 
 * Check for path
 *
 * @method hasPath
 * @param {String} dsId
 * @param {String} path
 */
MControlColors.prototype.hasPath = function(dsId, path) {
	this.hasDatasource(dsId);

	if (!this.defaults[dsId][path]) {
		throw new Error(['Invalid color path', dsId, path].join(' '));
	}
};

/**
 * Check for value
 *
 * @method hasValue
 * @param {String} dsId 
 * @param {String} path
 * @param {Object} value
 */
MControlColors.prototype.hasValue = function(dsId, path, value) {
	this.hasPath(dsId, path);

	if (!this.defaults[dsId][path][value]) {
		throw new Error(['Invalid color value', dsId, path, value].join(' '));
	}
};

/**
 * Get branch from structure
 *
 * @method getBranch
 * @private
 * @param {Object} branch 
 * @param {String} id Id in branch to get
 * @return {Object} branch
 */ 
MControlColors.prototype.getBranch = function(branch, id) {
	return (branch && branch.values && branch.values[id]) ?
		branch.values[id] : null;
};

/**
 * Get value from branch
 *
 * @method getValue
 * @private
 * @param {Object} branch
 * @return {Object} value
 */
MControlColors.prototype.getValue = function(branch) {
	return (branch && branch.value) ? branch.value : null;
};

/**
 * Get colors for field
 *
 * @method getColorsForField
 * @param {String} dsId
 * @param {String} path
 * @return {Object} Colors
 */
MControlColors.prototype.getColorsForField = function(dsId, path) {
	this.hasPath(dsId, path);

	var userColors = {};
	if (this.colors[dsId][path]) {
		userColors = this.colors[dsId][path];
	}
	
	return $.extend({}, this.defaults[dsId][path], userColors);
};

/**
 * Get color for value
 *
 * @method getColorsForValue
 * @param {String} dsId
 * @param {String} path
 * @param {String} value Value id
 * @return {Object} Color
 */
MControlColors.prototype.getColorForValue = function(dsId, path, value) {
	this.hasValue(dsId, path, value);

	var colors = this.getColorsForField(dsId, path);
	return colors[value];
};

/**
 * Get gradient for field
 *
 * @method getGradientForField
 * @param {String} dsId
 * @param {String} path
 * @return {Object} gradient
 */
MControlColors.prototype.getGradientForField = function(dsId, path) {
	this.hasPath(dsId, path);

	if (this.gradients[dsId][path]) {
		return this.gradients[dsId][path];
	}

	if (this.defaultGradients[dsId][path]) {
		return this.defaultGradients[dsId][path];
	}

	return null;
};

/**
 * Set gradient for field
 * 
 * @method setGradientForField
 * @param {String} dsId
 * @param {String} path
 * @param {Object} gradient
 */
MControlColors.prototype.setGradientForField = function(dsId, path, gradient) {
	this.hasPath(dsId, path);

	if (!gradient || !gradient.points.length) {
		delete this.gradients[dsId][path];
	} else {
		this.gradients[dsId][path] = gradient;
	}	

	this.setDirty(dsId);
	this.saveColors();
};

/**
 * Get colors for a gradient
 *
 * @method getGradientColors
 * @param {Array} points Array of gradient points, {'color': '#ffffff', 'position': 0}
 * @param {String} colorModel Defaults to "hsl"
 * @param {Number} numNeeded Number of colors needed
 * @return {Array} Array of colors
 */
MControlColors.prototype.getGradientColors = function(points, colorModel,
													  numNeeded) {
	points = points.slice();

	var scales = [];
	var ranges = [];

	var pair = [];
	var range = [];

	if (points[0].position !== 0) {
		points.unshift({'color': points[0].color, 'position': 0});
	}

	if (points[points.length - 1].position !== 1) {
		points.push({'color': points[points.length - 1].color, 'position': 1});
	}

	for (var i = 0, l = points.length; i < l; i++) {
		var point = points[i];
		pair.push(point.color);
		range.push(point.position);

		if (pair.length === 2 && range.length === 2) {
			var adjustedRange = [0, range[1] - range[0]];

			var scale = chroma.scale(pair)

 			if (colorModel && colorModel === 'hsl') {
				scale.mode('hsl');
			}

			scale.domain(adjustedRange);

			scales.push(scale);
			ranges.push(range.slice());

			pair.shift();
			range.shift();
		}
	}

	// Deals with Infinity issue can result from a single value filterable (like Total).
	if (numNeeded === 1) {
		numNeeded++;
	}

	var stepSize = 1 / (numNeeded - 1);
	var scaleIndex = 0;

	var result = [];
	for (var i = 0; i < numNeeded; i++) {
		var step = i * stepSize;

		var start = ranges[scaleIndex][0];
		var end = ranges[scaleIndex][1];

		// If step doesn't fall in to current scale, move to next scale
		while (!(start <= step && end >= step)) {
			scaleIndex++;

			if (!ranges[scaleIndex]) {
				throw new Error('Invalid color range');
			}

			start = ranges[scaleIndex][0];
			end = ranges[scaleIndex][1];
		}

		var adjustedStep = step - ranges[scaleIndex][0];			
		result.push(scales[scaleIndex](adjustedStep).hex());
	}

	return result;
};

/**
 * Get default colors for datasource
 * 
 * @method getDefaultsForDatasource
 * @param {String} dsId Datasource id
 * @return {Object} Datasource colors
 */
MControlColors.prototype.getDefaultsForDatasource = function(dsId) {
	this.hasDatasource(dsId);

	return this.defaults[dsId];
};

/**
 * Get default colors for field
 *
 * @method getDefaultsForField
 * @param {String} dsId
 * @param {String} path
 * @return {Object} colors
 */
MControlColors.prototype.getDefaultsForField = function(dsId, path) {
	this.hasPath(dsId, path);

	return this.defaults[dsId][path];
};

/**
 * Get default value for color
 * 
 * @method getDefaultForValue
 * @param {String} dsId 
 * @param {String} path
 * @param {String} value Id for value
 * @return {String} color
 */
MControlColors.prototype.getDefaultForValue = function(dsId, path, value) {
	this.hasValue(dsId, path, value);

	var colors = this.getDefaultsForField(dsId, path);
	return colors[value];
};

/**
 * Generate rw5 color for a string
 * 
 * @method genColorForString
 * @param {String} string
 * @return {String} hex color
 */
MControlColors.prototype.genColorForString = function(string) {
	return Moonshadow.helpers.rw5(string)
};

/**
 * Clear all user colors and gradients for a datasource
 *
 * @method resetDatasource
 * @param {String} dsId
 */
MControlColors.prototype.resetDatasource = function(dsId) {
	// Reset the user defined colors
	var ds = this.manager.getControl('datasources').getById(dsId);
	ds.userColors = {}; 

	// Reset the user defined colors
	this.colors[dsId] = {};
	this.gradients[dsId] = {};

	this.notifyListeners(dsId);

	this.setDirty(dsId);
	this.saveColors(dsId);
};

/**
 * Clear colors/gradients for a field
 *
 * @method resetField
 * @param {String} dsId
 * @param {String} path
 */
MControlColors.prototype.resetField = function(dsId, path) {
	var defaults = this.getDefaultsForField(dsId, path);

	delete this.gradients[dsId][path]
	delete this.colors[dsId][path]

	this.setColorsForField(dsId, path, defaults);
};

/**
 * Clear user color/gradient
 *
 * @method resetValue
 * @param {String} dsId
 * @param {String} path
 * @param {String} value
 */
MControlColors.prototype.resetValue = function(dsId, path, value) {
	var color = this.getDefaultsForValue(dsId, path, value);
	this.setColorsForValue(dsId, path, value, color);
};

/**
 * Set datasource user colors
 *
 * @method setColorsForDatasource
 * @param {String} dsId
 * @param {Object} colors
 */
MControlColors.prototype.setColorsForDatasource = function(dsId, colors) {
	this.hasDatasource(dsId);

	this.colors[dsId] = $.extend({}, colors);
	this.notifyListeners(dsId);

	this.setDirty(dsId);
	this.saveColors(dsId);
};

MControlColors.prototype.setColors = function(dsId, path, colors) {
	this.hasPath(dsId, path);

	var currentColors = this.colors[dsId][path] || {};
	var defaults = this.defaults[dsId][path];

	// Remove # from colors (embedded client) and remove defaults
	for (var color in colors) {
		if (colors[color].indexOf('#') === 0) {
			colors[color] = colors[color].substring(1);
		}

		if (colors[color] === defaults[color]) {
			delete colors[color];
			delete currentColors[color];
		}
	}

	this.colors[dsId][path] = $.extend({}, currentColors, colors);
	this.removeIfEmpty(dsId, path);
};

MControlColors.prototype.setGradient = function(dsId, path, gradient, save) {
	this.hasPath(dsId, path);

	this.gradients[dsId][path] = gradient;

	if (save) {
		this.setDirty(dsId);
		this.saveColors(dsId);
	}
};

MControlColors.prototype.setColorsForField = function(dsId, path, colors) {
	this.setColors(dsId, path, colors);
	this.notifyListeners(dsId, path);

	this.setDirty(dsId);
	this.saveColors(dsId);
};

MControlColors.prototype.setColor = function(dsId, path, value, color) {
	this.hasValue(dsId, path, value);

	if (color.indexOf('#') === 0) {
		color = color.substring(1);
	}

	if (this.defaults[dsId][path][value] === color && this.colors[dsId][path]) {
		delete this.colors[dsId][path][value];
	} else {
		if (!this.colors[dsId][path]) {
			this.colors[dsId][path] = {};
		}

		this.colors[dsId][path][value] = color;
	}

	this.removeIfEmpty(dsId, path);
};

//for use when redrawing collections after creating a survey
MControlColors.prototype.addDefaultColor = function(dsId, path, value) {
	this.hasDatasource(dsId);
	
	if(!this.defaults[dsId][path]){
		this.defaults[dsId][path] = {};
	}
	
	if(!this.defaults[dsId][path][value]){
		this.defaults[dsId][path][value] = this.genColorForString(value);
	}
};

MControlColors.prototype.setColorForValue = function(dsId, path, value,
													  color) {
	this.setColor(dsId, path, value, color);
	this.notifyListeners(dsId, path, value);

	this.setDirty(dsId);
	this.saveColors(dsId);
};

MControlColors.prototype.removeIfEmpty = function(dsId, path) {
	if ($.isEmptyObject(this.colors[dsId][path])) {
		delete this.colors[dsId][path];
	}
};

MControlColors.prototype.setDirty = function(dsId) {
	this.dirty[dsId] = true;
};

MControlColors.prototype.setClean = function(dsId) {
	delete this.dirty[dsId];
};

MControlColors.prototype.checkDirty = function() {
	var dirty = false;
	for (dsId in this.dirty) {
		if (this.dirty[dsId]) {
			dirty = true;
			break;
		}
	}

	return dirty;
};

MControlColors.prototype.saveColors = function() {
	var prev = this.previousRequest || null;
	if (prev && (request = prev.getRequest()) && request.readyState !== 0 &&
		request.readyState < 4 ) {
		return;
	}

	if (!this.checkDirty()) {
		return;
	}

	var self = this;
	var ajax = new Moonshadow.Ajax();
	this.previousRequest = ajax;

	for (dsId in this.dirty) {
		if (this.dirty[dsId]) {
			var query = this.getColorQuery(dsId);
			ajax.addQuery(query, function(response) {
				if (response.result != "ok") {
					throw new Error('Bad response when saving colors');
				}
			}, this);

			this.setClean(dsId);
		}
	}

	ajax.execute(function() {
		if (self.checkDirty()) {
			self.saveColors();
		}
	});
};

MControlColors.prototype.getColorQuery = function(dsId) {
	var colors = this.colors[dsId];
	var gradients = this.gradients[dsId];

	if (!colors) {
		throw new Error('No colors to save');
	}

	legacy = this.getLegacyFormat(colors, gradients);
	
	var query = {
		'query': 'save_stored_state',
		'ds': dsId,
		'name': 'stored_colors',
		'value': legacy
	};

	return query;
};

MControlColors.prototype.getLegacyFormat = function(colors, gradients) {
	var legacy = {};
	var pointer = legacy;	

	for (var key in colors) {
		var path = key.split('|');

		for (var i = 0, l = path.length; i < l; i++) {
			if (!pointer.values) {
				pointer.values = {};
			}

			pointer = pointer.values;

			if (!pointer[path[i]]) {
				pointer[path[i]] = {};
			}

			pointer = pointer[path[i]];
		}

		if (!pointer.values) {
			pointer.values = {};
		}

		pointer = pointer.values;

		for (var color in colors[key]) {
			if (!pointer[color]) {
				pointer[color] = {}; 
			}

			pointer[color].value = colors[key][color];
		}

		pointer = legacy;
	}

	for (var key in gradients) {
		var path = key.split('|');

		for (var i = 0, l = path.length; i < l; i++) {
			if (!pointer.values) {
				pointer.values = {};
			}

			pointer = pointer.values;

			if (!pointer[path[i]]) {
				pointer[path[i]] = {};
			}

			pointer = pointer[path[i]];
		}

		pointer['__gradient'] = gradients[key];

		pointer = legacy;
	}

	return legacy;
};

MControlColors.prototype.notifyListeners = function(dsId, path, value) {
	var eventId = this.getEventRegExp(dsId, path, value);
	this.observers.notify(eventId, {'id': eventId});	
};

MControlColors.prototype.addListener = function(dsId, path, value, 
												listener, context) {
	var eventId = this.getEventId(dsId, path, value);
	this.observers.addObserver(eventId, listener, context);
};

MControlColors.prototype.removeListener = function(dsId, path, value,
											   listener, context) {
	var eventId = this.getEventId(dsId, path, value);
	this.observers.removeObserver(eventId, listener, context);
};

MControlColors.prototype.getEventId = function(dsId, path, value) {
	var id = dsId;

	if (path) {
		id = [dsId, path].join(':');
	}

	if (path && value) {
		id = [id, value].join('|');
	}

	return id;
};

MControlColors.prototype.getEventRegExp = function(dsId, path, value) {
	var id = dsId; 

	if (path) {
		id = [dsId, path].join(':');
	}

	return new RegExp("^" + id + ((path && value) ? '(.'+ value +')?' : ''));
};




/**
 * Class that handles universes
 *
 * @class MControlUniveres
 * @constructor
 * @extends MControl
 * 
 */
function MControlUniverses() {
	this.name = 'universecontrol';
	this.manager = null;
	this.datasources = {};
	this.queuedAlterations = [];
	this.queuedDeletions = [];
	this.deletedUniverses = {};
	this.universeCreationJobs = {};
};
Moonshadow.helpers.extend(MControlUniverses, MControl);

MControlUniverses.prototype = new MControl;

/**
 * Init function for class, called as part of control loading
 * 
 * @method init
 * @param {Manager} manager Reference to manager
 */
MControlUniverses.prototype.init = function(manager) {
	this.manager = manager;	
	this.processUniverses();
};

/**
 * Processes the universe stored with each datasource
 * 
 * @method processUniverses
 * @return {Boolean} true if ready, false if not
 */
MControlUniverses.prototype.processUniverses = function() {
	var datasources = this.manager.getControl('datasources').getAll();
	
	for (var dsId in datasources) {
		var ds = datasources[dsId];

		var universes = ds.universes;

		if (!this.datasources[dsId]) {
			this.datasources[dsId] = {
				'users': {},
				'purchased': null,
				'unpurchased': null
			};
		}

		if(universes) {
			for (var i = 0, l = universes.length; i < l; i++) {
				var universe = universes[i];
				var id = universe.int_name;
				var type = universe.type;
				
				switch (type) {
				case 2:
				case 1:
					this.datasources[dsId].users[id] = universe;
					break;
				case 3000:
					this.datasources[dsId].purchased = universe;
					break;
				case 3001:
					this.datasources[dsId].unpurchased = universe;
					break;
				default: 
					throw new Error('Invalid universe type ' + type);
				}
			}
		}
	}
};

/**
 * Get all universes by datasource ID
 *
 * @method getUniverses
 * @param {String} dsId ID for datasource
 * @return {Object} key/value object of universes
 */
MControlUniverses.prototype.getUniverses = function(dsId) {
	return this.datasources[dsId].users;
};

MControlUniverses.prototype.checkPrePurchased = function(){
	var cartControl = this.manager.getControl("cartcontrol");
	return cartControl && cartControl.prePurchased;
};

/**
 * Get a universe by datasource ID and universe ID
 *
 * @method getUniverse
 * @param {String} dsId ID for datasource
 * @param {String} id ID for universe
 * @return {Object} universes object
 */
MControlUniverses.prototype.getUniverse = function(dsId, id) {
	return this.datasources[dsId].users[id];
};

/**
 * Get universe representing all purchased records
 *
 * @method getPurchased
 * @param {String} dsId ID for datasource
 * @return {Object} purchase universes
 */
MControlUniverses.prototype.getPurchased = function(dsId) {
	if (!this.datasources[dsId]) {
		return null;
	}

	return this.datasources[dsId].purchased;
};

/**
 * Get universe representing all not purchased records
 *
 * @method getUnpurchased
 * @param {String} dsId ID for datasource
 * @return {Object} unpurchase universes
 */
MControlUniverses.prototype.getUnpurchased = function(dsId) {
	if (!this.datasources[dsId]) {
		return null;
	}

	return this.datasources[dsId].unpurchased;
};
/**
 * Delete a universe
 *
 * @method deleteUniverse
 * @param {String} dsId ID for datasource
 * @param {String} id ID for universe
 * @param {Function} callback Callback to call when universes is deleted or on fail
 */
MControlUniverses.prototype.deleteUniverse = function(dsId, id, callback) {
	var ajax = new Moonshadow.Ajax();
	var queryObj = this._buildUniverseDeletionQuery(dsId, id, callback);
	ajax.addQuery(queryObj.query, queryObj.callback);
	ajax.execute();
};

/**
 * Queue a universe delete query
 *
 * @method queueUniverseForDeletion
 * @param {String} dsId ID for datasource
 * @param {String} id ID for universe
 * @param {Function} deleteCallback Callback to call when universes is deleted or on fail
 */
MControlUniverses.prototype.queueUniverseForDeletion = function(dsId, id, deleteCallback) {
	this.queuedDeletions.push(this._buildUniverseDeletionQuery(dsId, id, deleteCallback));
};

/**
 * Create and return a universe deletion query
 *
 * @method _buildUniverseDeletionQuery
 * @private
 * @param {String} dsId ID for datasource
 * @param {String} id ID for universe
 * @param {Function} deleteCallback Callback to call when universes is deleted or on fail
 */
MControlUniverses.prototype._buildUniverseDeletionQuery = function(dsId, id, deleteCallback) {
	var self = this;
	return {
		"query": {
			"query": "delete_universe",
			"int_name": id,
			"ds": dsId
		},
		"callback": function(data){
			if(data.result == "ok"){
				__deleteUniverse.apply(self, [dsId, id]);
				self._dirtyDeletedUniverses(dsId);
				return deleteCallback(data);
			}
			throw new Error("Problem deleting universe.")
		}
	};
};


/**
 * execute list of deletions   
 *
 * @method runDeletionQueue
 * @param {Object} ajax Moonshadow Ajax object (optional)
 * @param {Function} callback Function to be called after alteration queue is done
 */
MControlUniverses.prototype.runDeletionQueue = function(ajax, callback){
	if(!this.queuedDeletions.length){
		return callback && callback();
	}
	if(!ajax){
		ajax = new Moonshadow.Ajax();
	}
	for(var i = 0, l = this.queuedDeletions.length; i < l; ++i){
		var queryObject = this.queuedDeletions[i];
		ajax.addQuery(queryObject.query, queryObject.callback);
	}

	ajax.execute(callback);
	this.queuedDeletions = [];
};


/**
 * Get a get a key/value object of universe ids with arrays of firms who are in line to export universes   
 *
 * @method getQueuedUniverses
 * @param {Array[]} universesIds Array of universe IDs
 * @param {Function} callback Callback to call when universes it deleted or on fail
 * @return {Object} key/value object representing firm ids
 */
MControlUniverses.prototype.getQueuedUniverses = function(universesIds, callback) {
	new Moonshadow.Ajax({
		"url": "/exportal/queueduniverses",
		"wrapPost": true,
		"payload": {
			"universes": universesIds
		},
		"execute": true,
		"onSuccess": function(resp){
			if(resp && resp.result == "ok"){
				var qex = resp.queuedexports;
				var queObj = {};
				for(var i = 0, l = qex.length; i < l; ++i){
					for(var j = 0, ll = qex[i].length; j < ll; ++j){
						var uid = qex[i][j].universe.universeId;
						if(!queObj[uid])
							queObj[uid] = [];
						
						queObj[uid].push(qex[i][j].firm);
					}
				}
				callback(queObj);
			}else{
				callback();
			}
		}
	});
};

/**
 * get universes from server
 *
 * @method repollUniverses
 * @param {Array, String} dsIds Array of Ids of DSs or a single DS ID
 * @param {MoonshdowAjax} ajax Instance of MoonshadowAjax object
 */
MControlUniverses.prototype.repollUniverses = function(dsIds, ajax) {
	var self = this;
	var datasourcesControl = this.getManager().getControl("datasources");
	datasourcesControl.getUniverses(dsIds, ajax, function(){
		self.processUniverses();
	});
};

/**
 * get specific universe from server
 *
 * @method fetchUniverse
 * @param {String} dsId ID for datasource
 * @param {String} universeId ID for universe
 * @param {Function} callback    
 */
MControlUniverses.prototype.fetchUniverse = function(dsId, universeId, callback) {
	var self = this;
	var datasourcesControl = this.getManager().getControl("datasources");
	datasourcesControl.getUniverse(dsId, universeId, function(universe){
		if(universe){
			self.processUniverses();
		}
		callback && callback(universe);
	});
};

/**
 * get specific universes from server by list of ids
 *
 * @method fetchUniverses
 * @param {String} dsId ID for datasource 
 * @param {Array} universeIds IDs for universes 
 * @param {Function} callback
 */
MControlUniverses.prototype.fetchUniverses = function(dsId, universeIds, callback) {
	var self = this;
	var datasourcesControl = this.getManager().getControl("datasources");
	datasourcesControl.getUniversesById(dsId, universeIds, function(universes){
		if(universes && universes.length){
			self.processUniverses();
		}
		callback && callback(universes);
	});
};

/**
 * Get info on all deleted universes
 *
 * @method getDeletedUniverses
 * @param {String} dsId ID for datasource 
 * @param {Function} callback
 */
MControlUniverses.prototype.getDeletedUniverses = function(dsId, callback) {
	if(this.deletedUniverses[dsId]){
		if(!this.deletedUniverses[dsId].dirty){
			return callback(this.getDeletedUniversesList(dsId));
		}
	}
	this.deletedUniverses[dsId] = {
		"dirty": false,
		"list": []
	}
	var self = this;
	this.fetchDeletedUniverses(dsId, function(deletedUniverses){
		self.mapDeletedUniverses(dsId, deletedUniverses);
		callback && callback(self.getDeletedUniversesList(dsId));
	});
};

MControlUniverses.prototype.mapDeletedUniverses = function(dsId, deletedUniverses){
	var _map = {};
	for(var i = 0, l = deletedUniverses.length; i < l; ++i){
		_map[deletedUniverses[i].int_name] = deletedUniverses[i];
	}
	this.deletedUniverses[dsId]._map = _map;
};

MControlUniverses.prototype.getDeletedUniversesList = function(dsId){
	var deletedUniversesMap = this.deletedUniverses[dsId]._map;
	var deletedUniverses = []
	for(var i in deletedUniversesMap){
		if(!deletedUniversesMap.hasOwnProperty(i)){
			continue;
		}
		deletedUniverses.push(deletedUniversesMap[i]);
	}
	return deletedUniverses;
};

/**
 * Fetch info on all deleted universes from server
 *
 * @method fetchDeletedUniverses
 * @param {String} dsId ID for datasource 
 * @param {Function} callback
 */
MControlUniverses.prototype.fetchDeletedUniverses = function(dsId, callback) {
	var self = this;
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(this._getDeletedUniversesQuery(dsId), function(response){
		if(response || response.result == "ok"){
			callback && callback(response.universes);
		}
	}, this);
	ajax.execute();
};

/**
 * Get the query to retrieve deleted universes
 *
 * @method getDeletedUniversesQuery
 * @private
 * @param {String} dsId Id of DS
 */
MControlUniverses.prototype._getDeletedUniversesQuery = function(dsId) {
	return {
		"query": "list_deleted_universes",
		"ds": dsId
	};
};

MControlUniverses.prototype._dirtyDeletedUniverses = function(dsId){
	if(this.deletedUniverses[dsId]){
		this.deletedUniverses[dsId].dirty = true;
	}
};

MControlUniverses.prototype.recoverUniverses = function(deletedUniverses, callback){
	var dsIds = {};
	var self = this;
	var ajax = new Moonshadow.Ajax();
	
	for(var i = 0, l = deletedUniverses.length; i < l; ++i){
		var z = deletedUniverses[i];
		dsIds[z.ds] = true;
		var jsonMeta = z.json_metadata || {};
		jsonMeta.path = "Recovered";

		ajax.addQuery(this._recoverUniverseQuery(z.ds, z.int_name, jsonMeta), function(response){
			if(response && response.result == "ok"){
				var zid = response.qid;
				delete self.deletedUniverses[response.ds]._map[zid];
				return;
			}
			if(response.message){
				var code = response.error_code ? ("Code: " + response.error_code + " "): null;
				throw new Error(code + response.message)
			}
		});
	}

	var dsIdsArray = $.map(dsIds, function(i, v){
		return v;
	});

	this.repollUniverses(dsIdsArray, ajax);
	ajax.execute(function(){
		if(dsIdsArray.length){
			var filtersControl = self.manager.getControl('filterscontrol');
			filtersControl.notifyFilterChanges(dsIdsArray);
		}
		callback && callback();
	});
};

/**
 * Create and return a universe deletion query
 *
 * @method _buildUniverseDeletionQuery
 * @private
 * @param {String} dsId ID for datasource
 * @param {String} id ID for universe
 * @param {Function} deleteCallback Callback to call when universes is deleted or on fail
 */

MControlUniverses.prototype._recoverUniverseQuery = function(dsId, id, jsonMeta) {
	return {
		"query": "undelete_universe",
		"qid": id,
		"int_name": id,
		"ds": dsId,
		"json_metadata": jsonMeta 
	};
};

/**
 * Create a job for universe creation, store it until finalized
 * 
 * @method queueUniverseCreation
 * @param {Object} options (required) An object which may contain the following properties:
 * 		@property {String} 		dsId 			(required) ID for datasource 
 * 		@property {String} 		name 			(required) Name for universe
 * 		@property {String}		description 	(optional) Description for universe
 * 		@property {String} 		color 			(optional) Universe color
 * 		@property {String} 		createType 		(optional) Create Type (expand, contract, intersection, difference, union) 
 * 		@property {Array} 		markedUniverses (optional) Array of universes that have been checked
 * 		@property {Array} 		points 			(optional) Array points for a shape
 * 		@property {String}		path 			(optional) Folder name to put universe into
 * 		@property {Object} 		filters 		(optional) Additional filters
 * 		@property {Function} 	callback 		(required) Callback to call when universes it deleted or on fail
 * 		@property {String}		universeType 	(optional, default: "universe") "universe" or "sample"
 * 		@property {Integer} 	count 			(required [sample only]) Number or records for sample
 * 		@property {Integer}		cluster_size 	(optional [sample only], default: 2) Cluster size for sample
 * 		@property {Boolean} 	one_voter_per_residence (optional [sample only]) Reduce results to on record per household
 * 		@property {Boolean} 	normalized 		(optional [sample only]) Normalize age buckets
 * 		@property {Integer} 	records_with_phone (optional [sample only]) Only include records with a phone
 * 		@property {Integer}		telephone_confidence_code (optional [sample only]) Proprietary code grading confidence that the number is correct
 * 		@property {Integer}		priority_confidence_code (optional [sample only]) 0 or 1, Prioritize on condifence code 
 */
MControlUniverses.prototype.queueUniverseCreation = function(options){
	if(!options){
		throw new Error("No options supplied for universe creation");
	}
	if(!options.dsId || !options.name || !options.callback){
		throw new Error("Required options not met for universe creation");
	}
	if(!options.universeType){
		options.universeType = "universe";
	}
	if(options.universeType == "sample"){
		if(!options.count){
			throw new Error("No count supplied for sample");
		}
		if(!options.cluster_size){
			options.cluster_size = 2;
		}
	}
	
	var key = $.md5(options);
	this.universeCreationJobs[key] = options;
	
	var query;
	if(options.universeType == "universe"){
		query = this.createUniverseQuery(
			options.dsId, options.name, options.description, 
			options.color, options.createType, options.markedUniverses, 
			options.points, options.path, options.filters, options.callback
		);
	}
	
	if(options.universeType == "sample"){
		query = this.createSampleQuery(
			options.dsId, options.name, options.description, 
			options.color, options.createType, options.markedUniverses,
			options.count, options.cluster_size, options.one_voter_per_residence, 
			options.normalized, options.records_with_phone, 
			options.telephone_confidence_code, options.priority_confidence_code, 
			options.points, options.path, options.filters, options.callback
		);
	}
	
	if(!query){
		return;
	}
	
	var self = this;
	this._runQuery(query, function(error, data){
		if(error){
			return query.callback(error);
		}
		
		delete self.universeCreationJobs[key];
		self._creationPostProcess(data.universe, query.callback);
	});
};


/**
 * Build the query to create a universe  
 *
 * @method createUniverseQuery
 * @param {String} dsId ID for datasource 
 * @param {String} name Name for universe
 * @param {String} description Description for universe
 * @param {String} color Universe color
 * @param {String} createType Create Type
 * @param {Array[]} markedUniverses Array of universes that have been checked
 * @param {Object} filters Optional additional filters
 * @param {Boolean} delayPostCreation If false (or undefined/null) add universe to list, process and callback. if true, just callback with created universe
 * 
 */
MControlUniverses.prototype.createUniverseQuery = function(dsId, name, description, color, 
		createType, markedUniverses, points, path, filters, callback) {
	
	var query = {
		"query": "create_universe",
		"ds": dsId,
		"name": name
	};
	
	var addJsonMetadata = function(key, val){
		if(!query.json_metadata){
			query.json_metadata = {};
		}
		
		query.json_metadata[key] = val;
	};
	
	if(description){
		query.description = description;
	}
	
	if(color){
		query.color = color;
	}
	
	if(path){
		addJsonMetadata("path", path);
	}
	
	var fc = this.getManager().getControl('filterscontrol');
	query.filter = fc.filtersToJSON(dsId);
	if(filters){
		for(var i in filters){
			if(!filters.hasOwnProperty(i)){
				continue;
			}
			query.filter[i] = filters[i];
		}
	}

	if(points){
		query.points = points;
	}
	
	if(createType){
		__prepareCreateType(query, createType, markedUniverses);
	}
	
	query.callback = callback;
	return query;
};

/**
 * Build the query to create a sample   
 *
 * @method createSampleQuery
 * @param {String} dsId ID for datasource 
 * @param {String} name Name for sample
 * @param {String} description Description for sample
 * @param {String} color Sample color
 * @param {String} createType Create Type
 * @param {Array[]} markedUniverse Array of universe that have been checked
 * @param {Integer} count
 * @param {Integer} cluster_size 
 * @param {Boolean} one_voter_per_residence
 * @param {Boolean} normalized
 * @param {Integer} records_with_phone
 * @param {Integer} telephone_confidence_code
 * @param {Integer} priority_confidence_code
 * @param {Array} points An array of point in a shape
 * @param {Object} Optional additional filters
 */
MControlUniverses.prototype.createSampleQuery = function(dsId, name, description, color, createType, 
		markedUniverses, count, cluster_size, one_voter_per_residence, normalized, 
		records_with_phone, telephone_confidence_code, priority_confidence_code, points, 
		path, filters, callback) {
	
	
	var query = {
		"query": "create_sample",
		"ds": dsId,
		"name": name,
		"count": count,
		"cluster_size": cluster_size,
		"parameters": {
			"sample_filter": {},
			"one_voter_per_residence": one_voter_per_residence
		}
	};
	
	var addJsonMetadata = function(key, val){
		if(!query.json_metadata){
			query.json_metadata = {};
		}
		
		query.json_metadata[key] = val;
	};
	
	if(description){
		query.description = description;
	}
	
	if(color){
		query.color = color;
	}
	
	if(count){
		query.count = count;
	}
	
	var fc = this.getManager().getControl('filterscontrol');
	query.filter = fc.filtersToJSON(dsId);
	if(filters){
		for(var i in filters){
			if(!filters.hasOwnProperty(i)){
				continue;
			}
			query.filter[i] = filters[i];
		}
	}
	
	if(path){
		addJsonMetadata("path", path);
	}
	
	if(cluster_size > 1){
		query.key_field = this.manager.getOption("datasources." + dsId + ".key_field", "LALVOTERID");
	}

	if(normalized){
		query.parameters.normalization_fields = [{
			"int_name": "Voters_Age",
			"buckets":[0,25,34,45,60]
		}];
	}
	
	var sample_filter = {};
	
	if(records_with_phone){
		
		sample_filter.phone_num_exists = {
			values: {}
		};
		
		switch(records_with_phone){
			case 1:
				sample_filter.phone_num_exists.values.Yes = {
					"value": 1
				};
				break;
			case 2:
				sample_filter.phone_num_exists.values.Yes = {
					"value": 1
				};
				sample_filter.VoterTelephones_TelCellFlag = {
					"values":{
						"False":{
							"value":1
						}
					}
				};
				break;
			case 3:
				sample_filter.phone_num_exists.values.Yes = {
					"value": 1
				};
				sample_filter.VoterTelephones_TelCellFlag = {
					"values":{
						"True":{
							"value":1
						}
					}
				};
				break;
			case 4:
				sample_filter.phone_num_exists.values.No = {
					"value": 1
				};
		}
	}
	
	if(telephone_confidence_code){
		sample_filter.VoterTelephones_TelConfidenceCode = {
			"to": telephone_confidence_code
		};
	}
	query.parameters.sample_filter = sample_filter;
	
	if(priority_confidence_code){
		query.parameters.priority_fields = [{
            "int_name": "VoterTelephones_TelConfidenceCode",
            "priority": "min"
		}];
	}
	
	if(createType){
		__prepareCreateType(query, createType, markedUniverses);
	}
	
	query.callback = callback;
	return query;
};

/**
 * queue a universe for alteration of one or more props   
 *
 * @method queueAlteration
 * @param {String} id id for universe
 * @param {String} dsId ID for datasource 
 * @param {Object} properties Object with key/values for alteration
 * @param {Function} alterationCallback Callback to be called after alteration item
 */
MControlUniverses.prototype.queueAlteration = function(id, dsId, properties, alterationCallback){
	this.queuedAlterations.push(this._buildAlterUniverseQuery(
		id, dsId, properties, alterationCallback
	));
};

/**
 * execute list of alterations   
 *
 * @method runAlterationQueue
 * @param {Object} ajax Moonshadow Ajax object (optional)
 * @param {Function} callback Function to be called after alteration queue is done
 */
MControlUniverses.prototype.runAlterationQueue = function(ajax, callback){
	if(!this.queuedAlterations.length){
		return callback && callback();
	}
	if(!ajax){
		ajax = new Moonshadow.Ajax();
	}
	for(var i = 0, l = this.queuedAlterations.length; i < l; ++i){
		var queryObject = this.queuedAlterations[i];
		ajax.addQuery(queryObject.query, queryObject.callback);
	}
	ajax.execute(callback);
	this.queuedAlterations = [];
};

/**
 * alteration of one or more properties on one universe   
 *
 * @method alterUniverse
 * @param {String} id id for universe
 * @param {String} dsId ID for datasource 
 * @param {Object} properties Object with key/values for alteration
 * @param {Object} ajax Moonshadow Ajax object (optional)
 * @param {Function} alterationCallback Callback to be called after alteration item
 */
MControlUniverses.prototype.alterUniverse = function(id, dsId, properties, ajax, alterationCallback){
	var queryObject = this._buildAlterUniverseQuery(
		id, dsId, properties, alterationCallback
	);
	
	var ajaxObj = ajax;
	if(!ajax){
		//if ajax object not passed in, make one
		ajaxObj = new Moonshadow.Ajax();
	}
	
	ajaxObj.addQuery(queryObject.query, queryObject.callback);
	
	if(!ajax){
		//if ajax not passed in, excecute created one
		ajaxObj.execute();
	}
};

/**
 * Run single query
 * 
 * @method _runQuery
 * @private
 * @param {Object} query (required) Query object
 * @param {Function} callback (required) Callback function
 */
MControlUniverses.prototype._runQuery = function(query, callback){
	var self = this;
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(query, function(data){
		if (data.result == "fail"){
			return callback(new Error(data.message || "unknown"));
		}
		
		callback && callback(null, data);
	});
	
	ajax.execute();
};

/**
 * Process newly created universes
 * 
 * @method _creationPostProcess
 * @private
 * @param {Object} universe (required) newly created universe
 * @param {Function} callback (optional) Callback function
 */
MControlUniverses.prototype._creationPostProcess = function(universe, callback){
	var dsId = universe.ds;
	var datasourceControl = this.manager.getControl('datasources');
	datasourceControl.addUniverse(dsId, universe);
	this.processUniverses();
	callback && callback(null, universe);
};

/**
 * Display error
 * 
 * @method _displayError
 * @private
 * @param {Error/String} error (required) JS Error object or string of error
 */
MControlUniverses.prototype._displayError = function(error){
	MUILayoverPanel.alert("There was a problem creating the universe.\n Details: " + error.toString());
};


/**
 * Build query structure for universe alteration   
 *
 * @method _buildAlterUniverseQuery
 * @private
 * @param {String} id id for universe
 * @param {String} dsId ID for datasource 
 * @param {Object} properties Object with key/values for alteration
 * @param {Function} alterationCallback Callback to be called after alteration item
 */
MControlUniverses.prototype._buildAlterUniverseQuery = function(id, dsId, properties, alterationCallback){
	
	var alterableProps = ["color", "name", "description", "json_metadata", "read_users", "purchase_state"];
	var lu = this.getUniverse(dsId, id);
	
	var finalize = function(res){
		if(res.result != "ok"){
			throw new Error(res.message || res.error || 'Error updating universe');
		}
		for(var i in properties){
			if($.inArray(i, alterableProps) > -1){
				//lame
				if(i == "name"){
					lu.ext_name = properties[i];
					continue;
				}
				lu[i] = properties[i];
			}
		}
		alterationCallback && alterationCallback(res);
	};
	
	return {
		"query": $.extend({
			"query": "alter_universe",
			"int_name": id,
			"ds": dsId
		}, properties),
		"callback": finalize
	}
};

var __prepareCreateType = function(query, createType, markedUniverses){
	if(createType == "expand"){
		query.expand = 1;
	}else if(createType == "contract"){
		query.contract = {};
	}else{
		query[createType] = [];
	}
	var reordered = [];
	var lastMarked; 
	for(var i in markedUniverses){
		if (markedUniverses.hasOwnProperty(i)){
			reordered[parseInt(markedUniverses[i],10)] = i;
		}
		lastMarked = i;
	}
	if((createType == "expand" || createType == "contract") && lastMarked){
		query.query = "expand_contract_universe";
		query.source_universe_id = lastMarked;
	}else{
		for(var i = 0, l = reordered.length; i < l; ++i){
			if(reordered[i])
				query[createType].push({"int_name": reordered[i]});
		}
	}
}

/**
 * delete a universe and the universe from the datasouces listing   
 *
 * @method __deleteUniverse
 * @private 
 * @param {String} dsId ID for datasource 
 * @param {String} id id for universe
 */
var __deleteUniverse = function(dsId, id){
	delete this.datasources[dsId].users[id];
	var ds = this.manager.getControl('datasources').getById(dsId);
	for (var i = 0, l = ds.universes.length; i < l; i++) {
		if(ds.universes[i].int_name == id){
			ds.universes.splice(i, 1);
			break;
		}
	}
};

/** working documentation for using objects as options in function arguments
 * @param {Object} options (required) An object which may contain the following properties:
 *		@property {String} 				string ([optional/required], default = blah) Description
 *		@property {Function} 			function ([optional/required], default = blah) Description [having these params:]
 *							@param {[Blah]} Descripton
 *		@property {Object} 				object ([optional/required], default = blah) Description [contain the following properties:]
 *							@property {[Blah]} Descripton
 *		@property {Boolean} 			bool ([optional/required], default = blah) Description
 *		@property {Integer} 			int ([optional/required], default = blah) Description
 *		
 */



function MControlCounts(options) {
	this.name = "countsmodel";

	this.position = 6;
	this.manager = null;
	this.options = options || {};

	this.scopeTypes = ["map", "viewport", "mesh", "all", "global"];
	this.countScope = 'all';

	this.countsMode = {};

	this.datasources = {};
	this.loaded = false;
}

MControlCounts.prototype = new MControl;

MControlCounts.prototype.init = function(manager) {
	this.manager = manager;
	
	var mapopts = this.getManager().getOption("mapoptions");
	if (mapopts) {
		this.options = $.extend(true, {}, this.options, mapopts);
	}
	
	this.countScope = this.getDefaultScope() || 'global';
	this.countScope = this.getManager().getOption(
		'user_settings.count_scope', this.countScope);

	// Load counts mode for each ds
	var dsControl = this.manager.getControl('datasources');
	for (var dsId in dsControl.datasources) {
		this.countsMode[dsId] = dsControl.getCountsMode(dsId);
	}

	this.getManager().addMapObserver("changecountscope", this.scopeChange, this);

	this.show();
};

MControlCounts.prototype.getDefaultScope = function() {
	if(this.options.count_scopes){
		for(i = 0, l = this.options.count_scopes.length; i < l; ++i){
			if(this.options.count_scopes[i]["default"] == 1){
				return this.options.count_scopes[i].type;
			}
		}
	}
};

MControlCounts.prototype.scopeChange = function(event, data) {
	this.countScope = data.scope || 'global';
	var manager = this.getManager();

	if (this.countScope === 'viewport') {
		manager.addAjaxEventListener("resize", this);
		manager.addAjaxEventListener("bounds", this);
	} else {
		manager.removeAjaxEventListener("bounds", this);
		manager.removeAjaxEventListener("resize", this);
	}

	manager.setOption("user_settings.count_scope", this.countScope);
	manager.getControl("usersettings").saveUserSettings();

	manager.mapObservers.notify('filterchange');
};

MControlCounts.prototype.getCountsForPairs = function(pairs, listener, 
													  context) {
	var datasources = {};
	
	for (var i = 0, l = pairs.length; i < l; i++) {
		var pair = pairs[i];
		var dsId = pair[0];
		var path = pair[1];

		if (!datasources[dsId]) {
			datasources[dsId] = {};
		}

		if (!datasources[dsId][path]) {
			datasources[dsId][path] = [];
		}

		datasources[dsId][path].push(this.processListener(dsId, path, listener,
														  context));
	}

	for (var dsId in datasources) {
		this.performRequest(dsId, datasources[dsId], function() {
			listener.apply(context, arguments);
		});	
	}
};

MControlCounts.prototype.addCounted = function(dsId, path, listener, context,
											   embedded) {
	var listener = this.processListener(dsId, path, listener, context, embedded);

	if (!this.isAlreadyListening(listener)) {
		if (!this.datasources[dsId]) {
			this.datasources[dsId] = {};
		}

		if (!this.datasources[dsId][path]) {
			this.datasources[dsId][path] = [];
		}

		this.datasources[dsId][path].push(listener);
	}

	var fields = {};
	fields[path] = this.datasources[dsId][path];		
	this.performRequest(dsId, fields, this.onResponse, this);
};

MControlCounts.prototype.removeCounted = function(dsId, path, listener, context, embedded) {
	var listener = this.processListener(dsId, path, listener, context, embedded);

	if (!this.datasources[dsId]) {
		return;
	}

	if (!this.datasources[dsId][path]) {
		return;
	}

	var listeners = this.datasources[dsId][path];
	var found = false;
	for(var i = 0, l = listeners.length; i < l; i++) {
		var item = listeners[i];

		if (this.compareListeners(item, listener)) {
			this.datasources[dsId][path].splice(i, 1);
		}
	}
};

// @DEPCECATED
MControlCounts.prototype.removeCountedByDatasource = function(dsId) {
	this.datasources[dsId] = {};
};

MControlCounts.prototype.getCountScope = function() {
	return this.countScope;
};

MControlCounts.prototype.getCountScopeTypes = function() {
	return this.scopeTypes;
};

MControlCounts.prototype.getCountsMode = function(dsId) {
	return this.countsMode[dsId];
};

MControlCounts.prototype.setCountsMode = function(dsId, mode) {
	this.countsMode[dsId] = mode;
	var dsControl = this.manager.getControl('datasources');
	dsControl.setCountsMode(dsId, mode);

	this.manager.mapObservers.notify('countsmodechange');
	this.manager.mapObservers.notify('filterchange');
};

MControlCounts.prototype.getStatsQueries =  function() {
	var self = this;
	var queries = [];

	$.each(this.datasources, function(key, value) {
		queries.push(self.getStatsQuery(key, value));
	});

	return queries;
};

MControlCounts.prototype.addScopeToQuery = function(query) {
	switch(this.countScope) {
	case "map":
	case "viewport":
		var bounds = this.getManager().getAdapter().getBounds();
		query.lat_s = bounds.swLat;
		query.lat_n = bounds.neLat;
		query.long_w = bounds.swLon;
		query.long_e = bounds.neLon;
		break;
	case "mesh":
	case "all":
	case "global":
	default:
		query.lat_s = -85;
		query.lat_n = 85;
		query.long_w = -180;
		query.long_e = 180;
	}
	
	return query;
};

MControlCounts.prototype.addModeToQuery = function(ds, query) {
	var mode = this.getCountsMode(ds);
	switch(mode) {
	case "total":
		break;
	case "row":
		query.include_unfiltered = true;
		break;
	default:
		throw new Error('Invalid counts mode');
	}

   return query;
};

MControlCounts.prototype.getStatsQuery = function(ds, fields) {
	var stats = [];

	$.each(fields, function(key, value) {
		// Don't count items with zero listeners
		if (!value.length || key === 'totals') {
			return;
		}

		var parts = key.split('|');
		var id = parts.pop();
		var path = [];

		var item = [];
		for (var i = 0, l = parts.length; i < l; i++) {
			item.push(parts[i]);

			if (item.length > 1) {
				path.push(item);
				item = [];
			}
		}

		stats.push({
			filter_name: id,
			filter_tree: path
		});
	});

	var query = {
		'query': 'get_data_statistics_with_totals',
		'statistics_tree': stats,
		'ds': ds
	};

	query = this.addScopeToQuery(query);
	query = this.addModeToQuery(ds, query);


	return query;
};

MControlCounts.prototype.performRequest = function(ds, fields, dispatcher, context) {
	if(Moonshadow.getManager().getOption("neutered") == 1) {
		return false;
	}
	
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(this.getStatsQuery(ds, fields), dispatcher, context);
	ajax.execute();
};

/**
 *
 * @method onAjax
 * @param {} event
 * @param {} data
 * @param {} ajax
 */
MControlCounts.prototype.onAjaxEvent = function(event, data, ajax) {
	var whenUpdate = ['loaded', 'bounds', 'resize', 'colorbychange',
					  'filterchange', 'shapechanged', 'scopechanged'];

	if ($.inArray(event, whenUpdate) !== -1) {
		if (event === 'loaded') {
			this.loaded = true;
		}

		var queries = this.getStatsQueries();
		for(var i = 0, l = queries.length; i < l; i++) {
			ajax.addQuery(queries[i], this.onResponse, this);
		}
	}
};

/**
 *
 * @method onAjaxResponse
 * @param {} data
 */
MControlCounts.prototype.onResponse = function(response) {
	if (response && response.result !== 'ok') {
		throw new Error(response.message || 'Unknown error');
	}

	this.dispatchCounts(response);
};

MControlCounts.prototype.dispatchCounts = function(counts) {
	var ds = counts.ds;
	var total = counts.total;
	var totals = counts.totals;

	if (this.datasources[ds] && this.datasources[ds].totals) {
		for(var i = 0, l = this.datasources[ds].totals.length; i < l; i++) {
			var listener = this.datasources[ds].totals[i];
			listener.listener.call(listener.context, ds, '', totals, total);
		}
	}

	var embedded = [];
	var embeddedContext;
	var embeddedListener;

	for(var i = 0, l = counts.stats.length; i < l; i++) {
		var stat = counts.stats[i];

		var field = [];
		for (var ii = 0, ll = stat.filter_tree.length; ii < ll; ii++) {
			var treeItem = stat.filter_tree[ii];
			//special case for "unknown"
			var unkIndex = $.inArray("Unknown", treeItem);
			if(unkIndex > -1){
				treeItem.splice(unkIndex, 1, "__unknown");
			}
			field = field.concat(treeItem);
		}
		field = field.concat(stat.filter_name);
		field = field.join('|');

		if (this.datasources[ds][field]) {
			var listeners = this.datasources[ds][field];

			for(var iii = 0, lll = listeners.length; iii < lll; iii++) {
				var listener = listeners[iii];

				// Check if embedded listener. Embedded listeners expect a single
				// array of all stats that it's listening for
				// Normal listeners only get a single set of stats
				if (listener.embedded) { // Collect embedded stats for later
					embeddedContext = listener.context;
					embeddedListener = listener.listener;
					embedded.push(stat);
				} else { // Call the non-embedded listeners now
					listener.listener.call(listener.context, ds, field, 
										   stat.filter_result, total);
				}
			}
		}
	}

	// If any embedded stats where collected, send them
	if (embedded.length) {
		this.embeddedListener(ds, embedded, embeddedListener, embeddedContext);
	}
};

MControlCounts.prototype.embeddedListener = function(dsId, stats, listener,
													 context) {
	listener.call(context, dsId, stats);
};

/**
 *
 * @method show
 */
MControlCounts.prototype.show = function() {
	this.getManager().addAjaxEventListener("colorbychange", this);
	this.getManager().addAjaxEventListener("filterchange", this);
	this.getManager().addAjaxEventListener("shapechanged", this);
	this.getManager().addAjaxEventListener("scopechanged", this);

	if (this.countScope === 'viewport') {
		this.getManager().addAjaxEventListener("resize", this);
		this.getManager().addAjaxEventListener("bounds", this);
	}
};

/**
 *
 * @method hide
 */
MControlCounts.prototype.hide = function() {
	this.getManager().removeAjaxEventListener("colorbychange", this);
	this.getManager().removeAjaxEventListener("filterchange", this);
	this.getManager().removeAjaxEventListener("shapechanged", this);
	this.getManager().removeAjaxEventListener("scopechanged", this);

	this.getManager().removeAjaxEventListener("bounds", this);
	this.getManager().removeAjaxEventListener("resize", this);
};

MControlCounts.prototype.processListener = function(dsId, path, listener,
													context, embedded) {
	return {
		'ds': dsId,
		'field': path,
		'listener': listener,
		'context': context,
		'embedded': embedded
	};
};

MControlCounts.prototype.isAlreadyListening = function(listener) {
	if (!this.datasources[listener.ds]) {
		return false;
	}

	if (!this.datasources[listener.ds][listener.field]) {
		return false;
	}

	var listeners = this.datasources[listener.ds][listener.field];
	for(var i = 0, l = listeners.length; i < l; i++) {
		var item = listeners[i];

		if (this.compareListeners(item, listener)) {
			return true;
		}
	}

	return false;
};

MControlCounts.prototype.compareListeners = function(a, b) {
	return (a.ds === b.ds && a.field === b.field && a.listener === b.listener 
			&& a.context === b.context && a.embedded === b.embedded);
};
/**
 *
 * @class MControlDataCount
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlDataCount(options) {
	this.name = "datacounts";
	this.position = 6;
	this.manager = null;
	this.container = false;
	this.options = options || {};
	this.needMoreDots = options.needMoreDots || 50;
	this.datasourceId = null;
	this.shown = true;
}

MControlDataCount.prototype = {
	/**
 	 *
	 * @method init
	 * @param manager
	 */
	init: function(manager) {
		this.manager = manager;

		if(this.container == false) {
			var mainDiv = document.createElement("div");
			mainDiv.className = this.name+" control";
			mainDiv.id = this.name;
			
			var providerName = this.getManager().getMapProvider();
			mainDiv.className += " "+Moonshadow.maps[providerName].name;

			var dataDiv = document.createElement("div");
			mainDiv.appendChild(dataDiv);

			this.container = mainDiv;
			this.dataContainer = dataDiv;

			var thisControl = this.getManager().getControl(this.name);
			this.getManager().getAdapter().addControlToMap(thisControl);

			// NOt sure what this is for
			if(typeof this.afterAddToMap == "function") {
				this.afterAddToMap();
			}

			if (this.getManager().getDatasource().int_name.indexOf("_") != 0) {
				this.datasourceId = this.getManager().getDatasource().int_name;
			}

			if (this.datasourceId) {
				this.bindCountListener(this.datasourceId);
			}
	
			this.show();
		}
	},
	bindCountListener: function(ds) {
		var counts = this.manager.getControl('countsmodel');
		counts.addCounted(ds, 'totals', this.updateCounts, this, false);
	},
	unbindCountListener: function(ds) {
		var counts = this.manager.getControl('countsmodel');
		counts.removeCounted(ds, 'totals', this.updateCounts, this, false);
	},
	/**
 	 *
	 * @method updateCounts
	 * @param {} data
	 */
	updateCounts: function(dsId, path, totals, total) {
		var container = this.dataContainer;
		var parentContainer = this.container;

		var containerDiv = $(container);
		var parentContainerDiv = $(parentContainer);
		var parent = this;
		var allowed = this.options.allowed || null;
		var locale = this.options.locale || {};
		var formatOpts = {
			numberOfDecimals: 0,
			decimalSeparator: '.',
			thousandSeparator: ','
		};

		if (container.hasChildNodes()) {
			while (container.childNodes.length >= 1) {
				container.removeChild(container.firstChild);
			}
		}

		$.each(totals, function(k,v) {
			if (allowed) {
				var notFound = true;
				for(var i = 0,l = allowed.length;i < l;i++) {
					if(allowed[i] == k) {
						notFound = false;
						break;
					}
				}

				if(notFound) {
					return;
				}
			}

			// This deal with the awful type switching from the
			// include_unfiltered switch
			if (v instanceof Array) {
				v = v[0];
			}

			var totalContainer = document.createElement("div");
			var labelDiv = document.createElement("label");
			labelDiv.appendChild(document.createTextNode((locale[k] || k)+": "));
			var spanDiv = document.createElement("span");

			var num = $().number_format(v, formatOpts);
			spanDiv.appendChild(document.createTextNode(num));
			totalContainer.appendChild(labelDiv);
			totalContainer.appendChild(spanDiv);
			container.appendChild(totalContainer);
		});

		if(parentContainer.style.display != "block" && this.shown) {
			parentContainer.style.display = "block";
		}

		var shapeActive = false;
		var shapeControl = this.manager.getControl('shape');
		if (shapeControl) {
			shapeActive = shapeControl.isActive();
		}		

		// This deal with the awful type switching from the
		// include_unfiltered switch
		if (total instanceof Array) {
			total = total[0];
		}

		if (total <= this.needMoreDots && !shapeActive && !this.lessDots) {
			this.lessDots = true;

			var markers = this.getManager().getControl("markers");
			if (markers) markers.adjustOverride(1);
		} else if((total > this.needMoreDots || shapeActive) && this.lessDots) {
			this.lessDots = false;

			var markers = this.getManager().getControl("markers");
			if (markers) markers.adjustOverride(-1);
		}
	},
	/**
	 *
	 * @method onAjax
	 * @param {} event
	 * @param {} data
	 * @param {} ajax
	 */
	onAjaxEvent: function(event, data, ajax) {
		var ds = this.getManager().getDatasource().int_name;

		if (this.datasourceId != ds) {
			this.unbindCountListener(this.datasourceId);
			this.datasourceId = ds;
			this.bindCountListener(this.datasourceId);
		}
	},
	/**
	 *
	 * @method stateUpdate
	 */
	stateUpdate: function() {},
	/**
	 *
	 * @method show
	 */
	show: function(ds) {
		this.shown = true;
		this.container.style.display = 'block';
		this.getManager().addAjaxEventListener("colorbychange", this);
	},
	/**
	 *
	 * @method hide
	 */
	hide: function(ds) {
		this.shown = false;
		this.container.style.display = 'none';
		this.getManager().removeAjaxEventListener("colorbychange", this);
	}
};
Moonshadow.helpers.extend(MControlDataCount,MControl);


function MControlListAssignment(manager) {
	this.manager = manager;
	this.sorter;
	this.users;
	this.dataType;
	this.universes;
	this.container;
	this.userAssignments;
	this.buttons;
	this.displayLoading = true;
	this.openPanel;
};

MControlListAssignment.prototype.controlButtons = function(){
	var self = this;
	if(!this.buttons){
		this.buttons = [{
				"id": "listtype",
				"title": "List by Walkinglist",
				"action": function(){
					self.switchContent();
				}
			}
		];
	};
	return this.buttons;
};

MControlListAssignment.prototype.switchContent = function(dataType){
	if(dataType == undefined){
		dataType = this.dataType;
	}
	if(dataType == "users"){
		this.dataType = "universes";
		$(this.buttons[0].elem).attr({
			"value": "List by Username"
		});
	}else{
		this.dataType = "users";
		$(this.buttons[0].elem).attr({
			"value": "List by Walkinglist"
		});
	}
	this.fillList();
};

MControlListAssignment.prototype.getContent = function(callback){
	this.dataType = "users";
	
	var ce = Moonshadow.helpers.ce;
	this.container = $(ce("div"))
		.addClass("universe_users_assignment");
	
	callback(this.container);
	
	var self = this;
	this.getCanvasserUsers(function(users){
		self.getUniverses(function(universes){
			self.universes = universes;
			self.getAssignedUsers(universes);
			self.fillList();
			if(self.openPanel){
				self.openPanel.loadIndicator(false);
			}
		});
	});
};

MControlListAssignment.messages = {
	"unpurchasedMessage": "\n\rYou are attempting to assign voter records " +
		"to a canvasser when those records have not yet " +
		"been purchased and unlocked. If you choose to " +
		"proceed, the canvasser will see only the " +
		"purchased records. To assign all records " +
		"to the canvasser, please exit this panel, " +
		"purchase the remaining records and then assign " +
		"the list to the Canvasser.\n\r",
	"noSurveysMessage": "\n\rThere are currently no surveys assigned to " +
		"this walking list. To be able to assign this list " +
		"to a canvasser, click on the Walking Lists tab " +
		"and assign a survey to this list.\n\r",
	"notUniverseOwner": "\n\rThis universe was assigned to you by the " +
			" user who created it and cannot be modified. To assign/unassign it, contact " +
			" the universe owner: "
};

MControlListAssignment.prototype.getAssignedUsers = function(universes){
	var userAssignments = {};
	for(var i = 0, l = universes.length; i < l; ++i){
		var u = universes[i];
		if(u.read_users && u.read_users.length){
			for(var j = 0, ll = u.read_users.length; j < ll; ++j){
				var user = u.read_users[j];
				if(!userAssignments[user]){
					userAssignments[user] = [];
				}
				userAssignments[user].push({
					"int_name": u.int_name,
					"ext_name": u.ext_name
				});
			}
		}
	}
	this.userAssignments = userAssignments;
};

MControlListAssignment.prototype.getUniverses = function(callback){
	var universeControl = this.manager.getUniverseControl();
	callback(universeControl.getAllUniversesArray());
};

MControlListAssignment.prototype.getCanvassersUniverses = function(username){
	var universes = [];
	if(this.userAssignments[username]){
		var universeControl = this.manager.getUniverseControl();
		for(var i = 0, l = this.userAssignments[username].length; i < l; ++i){
			var ui = this.userAssignments[username][i];
			var uo = universeControl.getChildrenByAttribute("int_name", ui.int_name);
			universes.push(uo[ui.int_name]);
		}
	}
	return universes;
};

MControlListAssignment.prototype.getCanvasserUsers = function(callback){
	if(!this.users){
		var self = this;
		if(this.manager.shouldControlBeLoaded("MControlManagement")){
			var um = this.manager.getControl("customer_management");
			if(um.canvassingEnabled()){
				return um.getCustomersUsers(function(users){
					
					var canvassers = $.grep(users, function(user, index){
						if(user.type == "read-only")
							return false;
						return user.access;
					});
					
					canvassers.sort(function(a, b){
						if(a.username.toLowerCase() > b.username.toLowerCase())
							return 1;
						if(a.username.toLowerCase() < b.username.toLowerCase())
							return -1;
						return 0;
					});
					
					self.users = canvassers;
					callback(canvassers);
				});
			}
		}
		throw(new Error("User managment not enabled"));
	}
	callback(this.users);
};

MControlListAssignment.prototype.expandUserAssignmentSection = function(universeId){
	var assignPanel = $("#user_assign_" +  universeId, this.container);
	$(assignPanel).click();
	$(".assignment_list_item", this.container).scrollTop(
		$(assignPanel).position().top
	);
};

MControlListAssignment.prototype.fillList = function(){
	if(this.dataType == "users"){
		return $(this.container)
			.empty()
			.append(this.buildUsersList(this.users))
	}
	$(this.container)
		.empty()
		.append(this.buildUniverseList(this.universes));
};

MControlListAssignment.prototype.getNumberListsAssigned = function(username){
	if(this.userAssignments[username]){
		return this.userAssignments[username].length;
	}
	return "0"; 
};

MControlListAssignment.prototype.assignUserUniverse = function(username, universe, callback){
	var self = this;
	universe.assignReadOnlyUser(username, function(){
		if(!self.userAssignments[username]){
			self.userAssignments[username] = [];
		}
		self.userAssignments[username].push({
			"int_name": universe.int_name,
			"ext_name": universe.ext_name
		})
		callback();
	});
};

MControlListAssignment.prototype.removeUserUniverse = function(username, universe, callback){
	var self = this;
	universe.removeReadOnlyUser(username, function(){
		for(var i = 0, l = self.userAssignments[username].length; i < l; ++i){
			var as = self.userAssignments[username][i];
			if(as && as.int_name == universe.int_name){
				self.userAssignments[username].splice(i, 1);
				return callback();
			}
		}
	});
};

MControlListAssignment.prototype.buildUsersList = function(users, universe){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	var sorter = this.buildUserSorter();

	return [$(sorter.sorterCont).get(0),
		$(sorter.container)
			.append(
				$.map(users, function(user){
					var dataRow;
					var userAssignableControl = $(ce("div"))
						.addClass("user_assignable_control");
					
					var usernameDisplay = $(ce("div"))
						.append(
							user.username
						);
					
					if(self.dataType == "users"){
						
						$(usernameDisplay)
							.prepend(userAssignableControl)
						
						$(userAssignableControl)
							.addClass("sprite-expander_right user_expander_handle clickable")
							.on("click", function(){
								$(this)
									.toggleClass("sprite-expander_right sprite-expander_down");
								
								var userPanel = $(this)
									.closest(".survey_list_user_item")
									.find(".user_expanding_panel");
								
								$(userPanel)
									.toggleClass("hide");
								
								if(!($(userPanel).hasClass("hide"))){
									dataRow.triggerExpander();
								}
							});
					}else{
						if(universe){
							$(userAssignableControl)
								.append(
									self.makeAssignmentCheckbox(universe, user.username)
								);
						}
					}
					
					var userRowObject = {
						"username": usernameDisplay,
						"lastname": user.lastname,
						"firstname": user.firstname,
						"number_lists": self.getNumberListsAssigned(user.username),
						"onExpand": function(){
							$(dataRow.expandingContainer)
								.empty()
								.append(
									self.buildUniverseList(
										self.universes, user
									)
								)
						}
					};
					
					if(self.dataType != "users"){
						userRowObject.user_assignable_control = userAssignableControl
					}
					
					dataRow = sorter.sorterObj.getDataRow(userRowObject);
					return dataRow.row;
				})
			).get(0)];
};

MControlListAssignment.prototype.getAssignableInfo = function(universe){
	var info = {
		"able": true,
		"purchased": 0,
		"count": universe.cardinality,
		"status": "green",
		"message": ""
	}
	
	if(universe.counts && universe.counts[0]){
		info.purchased = universe.counts[0].purchased_count;
	}else{
		info.purchased = universe.purchased;
	}
	
	if(info.count != info.purchased){
		info.warn = true;
		if(info.purchased === 0){
			info.status = "red";
			info.able = false;
			info.message += MControlListAssignment.messages.unpurchasedMessage;
		}else{
			info.status = "yellow";
		}
	}
	
	if(!universe.getSurveys().length){
		info.able = false;
		info.message += MControlListAssignment.messages.noSurveysMessage;
	}

	if(this.manager.getOption("user") != universe.owner){
		info.able = false;
		info.message += MControlListAssignment.messages.notUniverseOwner + universe.owner;
	}
	
	return info;
};

MControlListAssignment.prototype.buildUniverseList = function(universes, user){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	var sorter = this.buildUniverseSorter();

	return [$(sorter.sorterCont).get(0),
		$(sorter.container)
			.append(
				$.map(universes, function(universe){
					var aInfo = self.getAssignableInfo(universe);
					
					var assignableControl = $(ce("div"))
						.addClass("assignable_control")
						.attr({
							"id": "user_assign_" + universe.int_name
						});

					if(!aInfo.able){
						$(assignableControl)
							.addClass("not_assignable_why clickable")
							.append(
								$(ce("span"))
									.append("?")
							)
							.on("click", function(){
								MUILayoverPanel.alert(aInfo.message);
							});
						
						if(self.dataType == "users"){
							$("span", assignableControl)
								.addClass("disabled_assignment");
						}
					}
					
					if(user){
						$(assignableControl)
							.append(
								self.makeAssignmentCheckbox(universe, user.username, aInfo.able)
							);
					}
					
					var expandingContainer;

					if(self.dataType == "universes"){
						if(aInfo.able){
							
							expandingContainer = self.buildUsersList(self.users, universe);
							
							$(assignableControl)
								.addClass("sprite-expander_right universe_assignment_expander clickable")
								.on("click", function(){
									$(this).toggleClass("sprite-expander_right sprite-expander_down");
									
									$(this)
										.closest(".assign_user_item")
										.find(".universe_expanding_panel")
										.toggleClass("hide");
								});
						}
					}
					
					var universeRowObject = {
						"assignable": assignableControl,
						"listname": universe.ext_name,
				 		"list_voter_counts": $(ce("div"))
							.addClass(aInfo.status)
							.append(
								$(ce("span"))
									.addClass("a")
									.append(
										aInfo.purchased
									),
								aInfo.warn ? $(ce("span"))
									.addClass("b")
									.append(
										" purchased of " + aInfo.count + " total"
									) : ""
							),
				 		"survey_count": $(ce("div"))
							.addClass(universe.getSurveys().length ? "green" : "red")
							.append(universe.getSurveys().length || "0"),
						"expandingContainer": expandingContainer
					};
					
					return sorter.sorterObj.getDataRow(universeRowObject).row;
				})
			).get(0)];
};

MControlListAssignment.prototype.makeAssignmentCheckbox = function(universe, username, enabled){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	
	return $(ce("input"))
		.attr({
			"type": "checkbox",
			"checked": (universe.read_users &&	$.inArray(username, universe.read_users) > -1),
			"disabled": enabled != undefined && !enabled
		})
		.change(function(e){
			if(this.disabled){
				return;
			}
			var row = $(this).closest(".survey_list_user_item");
			var numberCont = $(".sortable_data_column_number_lists", row);
			if(this.checked){
				self.assignUserUniverse(username, universe, function(){
					$(numberCont).empty().append(self.getNumberListsAssigned(username));
				});
			}else{
				self.removeUserUniverse(username, universe, function(){
					$(numberCont).empty().append(self.getNumberListsAssigned(username));
				});
			}
		})
};

MControlListAssignment.prototype.buildUserSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("survey_list_users scrollable");
	
	var sorter = $(ce("div"))
		.addClass("user_list_columns");

	var columns = [{
		"value": "No. Lists",
 		"sortby": "number_lists",
 		"float": "right"
	},{
 		"value": "User Name",
 		"sortby": "username",
 		"sortdefault": true
	},{
 		"value": "First Name",
 		"sortby": "firstname"
	},{
 		"value": "Last Name",
 		"sortby": "lastname"
	},{
		"spacer": "scrollbar_spacer",
		"float": "right"
	}];
	
	if(this.dataType != "users"){
		columns.unshift({
	 		"sortby": "user_assignable_control",
	 		"float": "left"
		});
	} 
	
	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".survey_list_user_item",
		"sortFunctions": {
			"user_assignable_control": function(a, b, sortorder){
				var avalue = !!$(".user_assignable_control input", a).attr("checked") ? 1 : 0;
				var bvalue = !!$(".user_assignable_control input", b).attr("checked") ? 1 : 0;
				var retVal = this.sortFunctions.returnVal.apply(this, [avalue, bvalue, sortorder]);
	 			if(retVal == 0){
	 				return this.sortFunctions.username.apply(this, [a, b, 1]);
	 			}
	 			return retVal;
				
			},
 			"number_lists": function(a, b, sortorder){
				var avalue = parseInt($(".sortable_data_column_number_lists", a).text(), 10);
				var bvalue = parseInt($(".sortable_data_column_number_lists", b).text(), 10);
				return this.sortFunctions.returnVal.apply(this, [avalue, bvalue, sortorder]);
			},
			"username": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_username", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_username", b).text().toLowerCase();
				return this.sortFunctions.returnVal.apply(this, [avalue, bvalue, sortorder]);
			},
			"firstname": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_firstname", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_firstname", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			},
			"lastname": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_lastname", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_lastname", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			},
			"stringSort": MUIFilterableSorter.predefinedSorting.stringSort,
			"returnVal": MUIFilterableSorter.predefinedSorting.returnVal
		},
		"columnSettings": columns,
		"sorterContainerClassName": "sortsurveyusers",
		"sorterContainer": sorter,
		"columnDataContainer": container,
		"expandingContainer": this.dataType == "users" 
			? $(ce("div"))
				.addClass("hide user_expanding_panel")
			: false
	});
	
	colsorter.makeColumnSorter(true);
		
	return {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	}; 
};

MControlListAssignment.prototype.buildUniverseSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("assignment_list_item scrollable");
	
	var sorter = $(ce("div"))
		.addClass("assignment_list_columns");
	
	var columns = [{
 		"sortby": "assignable",
 		"float": "left"
	},{
 		"value": "List Name",
 		"sortby": "listname",
 		"sortdefault": true
	},{
		"value": "Record Count",
 		"sortby": "list_voter_counts"
	},{
 		"value": "Surveys",
 		"sortby": "survey_count",
 		"float": "right"
	},{
		"spacer": "scrollbar_spacer",
		"float": "right"
	}];

	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".assign_user_item",
		"sortFunctions": {
			"assignable": function(a, b, sortorder){
				var avalue = $(".assignable_control.not_assignable_why", a);
				var bvalue = $(".assignable_control.not_assignable_why", b);
				var retVal = this.sortFunctions.returnVal.apply(this, [avalue.length, bvalue.length, sortorder]);
				if(retVal == 0){
	 				return this.sortFunctions.listname.apply(this, [a, b, 1]);
	 			}
				return retVal;
			},
			"listname": function(a, b, sortorder){
	 			var avalue = $(".sortable_data_column_listname", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_listname", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
	 		},
	 		"list_voter_counts": function(a, b, sortorder){
	 			var avalue = $(".sortable_data_column_list_voter_counts .a", a).text();
				var bvalue = $(".sortable_data_column_list_voter_counts .a", b).text();
				var aInt = parseInt(avalue, 10);
				var bInt = parseInt(bvalue, 10);
				var retVal = this.sortFunctions.returnVal.apply(this, [aInt, bInt, sortorder]);
	 			if(retVal == 0){
	 				var avalue = $(".sortable_data_column_list_voter_counts .b", a).text();
					var bvalue = $(".sortable_data_column_list_voter_counts .b", b).text();
					var aInt = parseInt(avalue, 10);
					var bInt = parseInt(bvalue, 10);
					var retVal = this.sortFunctions.returnVal.apply(this, [aInt, bInt, sortorder]);
					if(retVal == 0){
		 				return this.sortFunctions.listname.apply(this, [a, b, 1]);
		 			}
	 			}
	 			return retVal;
				
	 		},
	 		"survey_count": function(a, b, sortorder){
	 			var avalue = parseInt($(".sortable_data_column_survey_count", a).text(), 10);
	 			var bvalue = parseInt($(".sortable_data_column_survey_count", b).text(), 10);
	 			var retVal = this.sortFunctions.returnVal.apply(this, [avalue, bvalue, sortorder]);
	 			if(retVal == 0){
	 				return this.sortFunctions.listname.apply(this, [a, b, 1]);
	 			}
	 			return retVal;
	 		},
			"stringSort": MUIFilterableSorter.predefinedSorting.stringSort,
			"returnVal": MUIFilterableSorter.predefinedSorting.returnVal
		},
		"columnSettings": columns,
		"sorterContainerClassName": "sortlistassignment",
		"sorterContainer": sorter,
		"columnDataContainer": container,
		"expandingContainer": this.dataType == "universes" 
			? $(ce("div"))
					.addClass("hide universe_expanding_panel")
			: false
	});
	
	colsorter.makeColumnSorter(true);
	
	return {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	};
};





function MControlListSurveys(manager, listType) {
	this.manager = manager;
	this.sorter;
	this.buttons;
	this.activeControl = "draft";
	this.contentPanelSelector = ".survey_list_universe";
	this.listType = listType || "groundgame";
};

MControlListSurveys.prototype.getContent = function(callback){
	this.activeControl = this.activeControl || "draft";
	callback(this.buildSurveyList(this.activeControl));
	
	this.addObservers();
	var self = this;
	this.getSurveys(function(){
		self.activateFilterType(self.activeControl);
	});
};

MControlListSurveys._staticText = {
	"default": {
		"finalize": "Finalize this survey? Finalizing will make it not editable."
	},
	"phonecampaigns": {
		"finalize": "Finalize this survey? Finalizing will make it not editable."
	},
	"groundgame": {
		"finalize": "Finalize this survey? Finalizing will make it available for assigning to walking lists and make it not editable."
	},
	"facebookpoll": {
		"finalize": "Finalize this survey? Finalizing will make it available for assigning to use on social media and make it not editable."
	}
}

MControlListSurveys.prototype.onClose = function(callback){
	this.removeObservers();
	callback(true);
};

MControlListSurveys.prototype.addObservers = function(){
	var self = this;
	this.manager.dataObservers.addObserver('surveyremoved', function(event, surveyId){
		self.rebuildSurveyList(self.activeControl);
	}, this);
	this.manager.dataObservers.addObserver('surveyfinalized', function(event, surveyId){
		self.rebuildSurveyList("final");
	}, this);
	this.manager.dataObservers.addObserver('surveyrecovered', function(event, surveyId){
		self.rebuildSurveyList(self.activeControl, surveyId);
	}, this);
	this.manager.dataObservers.addObserver('surveyadded', function(event, surveyId){
		self.rebuildSurveyList("draft");
	}, this);
};

MControlListSurveys.prototype.removeObservers = function(){
	this.manager.dataObservers.removeContext('surveyremoved', this);
	this.manager.dataObservers.removeContext('surveyfinalized', this);
	this.manager.dataObservers.removeContext('surveyrecovered', this);
	this.manager.dataObservers.removeContext('surveyadded', this);
};

MControlListSurveys.prototype.buildSurveyList = function(statusType){
	var ce = Moonshadow.helpers.ce;
	statusType == statusType || this.activeControl;
	
	this.buildSorter();
	return [
		this.sorter.sorterCont.get(0),
		this.sorter.container.get(0)
	];
};

MControlListSurveys.prototype.fillList = function(statusType){
	$(this.sorter.container)
		.empty()
		.append(
			this.buildSurveyItemsList(
				this.getFilteredSurveys(statusType), statusType
			)
		);
};

MControlListSurveys.prototype.controlButtons = function(){
	var self = this;
	if(!this.buttons){
		this.buttons = [{
				"id": "draft",
				"title": "Drafts",
				"filter": true,
				"action": function(){
					self.activeControl = "draft";
					self.fillList("draft");
					self.refreshSort();
				}
			},{
				"id": "final",
				"title": "Finalized",
				"filter": true,
				"action": function(){
					self.activeControl = "final";
					self.fillList("final");
					self.refreshSort();
				}
			},{
				"id": "hidden",
				"title": "Removed",
				"filter": true,
				"action": function(){
					self.activeControl = "hidden";
					self.fillList("hidden");
					self.refreshSort();
				}
			},{
				"id": "surveys",
				"title": "All",
				"filter": true,
				"action": function(){
					self.activeControl = "surveys";
					self.fillList("surveys");
					self.refreshSort();
				}
			},{
				"id": "new",
				"title": "New Survey",
				"right": true,
				"filter": false,
				"action": function(){
					self.newSurvey();
				}
			}
		];
	};
	return this.buttons;
};

MControlListSurveys.prototype.getButton = function(id){
	if(!this.buttons){
		this.controlButtons();
	}
	for(var i = 0, l = this.buttons.length; i < l; ++i){
		if(this.buttons[i].id == id){
			return this.buttons[i];
		}
	}
	return false;
};

MControlListSurveys.prototype.activateFilterType = function(filterType){
	this.activeControl = filterType;
	this.fillList(filterType);
	this.refreshSort();
	var button = this.getButton(filterType);
	button && $(button.elem).trigger("activate");
};

MControlListSurveys.prototype.rebuildSurveyList = function(filterType, surveyId){
	var self = this;
	this.requestSurveys(function(){
		if(surveyId){
			filterType = self.getSurveyStatus(surveyId);
		}
		
		self.activateFilterType(filterType);
	});
};

MControlListSurveys.prototype.refreshSort = function(){
	this.sorter && this.sorter.sorterObj && this.sorter.sorterObj.refreshSort();
};

MControlListSurveys.prototype.recoverSurveyUIActions = function(survey){
	var self = this;
	MUILayoverPanel.confirm({
		"id": "recover_survey_dialog",
		"title": "Recover Survey",
		"message": "Attempt to recover this survey" + (survey.live ? " and associated data" : "") +	"?",
		"closeText": "Recover",
		"callback": function(res, id, hide){
			if(res){
				MUILayoverPanel.get("recover_survey_dialog").loadIndicator(true);
				return self.recoverSurvey(survey.int_name, hide);
			}
			hide();
		}
	});
};

MControlListSurveys.prototype.removeSurveyAction = function(survey){
	var self = this;
	if(this.listType == "phonecampaigns"){
		return this.isPhoneCampSurveyRemovable(survey.int_name, function(removeable){
			if(!removeable){
				return MUILayoverPanel.alert("This survey may not be removed at this time.")
			}
			self.removeSurveyUIActions(survey);
		});
	}
	this.removeSurveyUIActions(survey);
}

MControlListSurveys.prototype.removeSurveyUIActions = function(survey){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	
	var message = $(ce("div"))
		.append(
			"Remove this survey? It will be removed from the active list and not be assignable. ",
			function(){
				if(survey.live){
					return $(ce("div"))
						.css({"margin-top": "10px"})
						.append(
							$(ce("input"))
								.attr({
									"type": "checkbox",
									"name": "removedata"
								}),
							$(ce("a"))
								.addClass("clickable")
								.append(
									"Also remove gathered data? (This option hides gathered data from side panel)"
								)
								.on("click", function(){
									$("input", $(this).parent())
										.attr({
											"checked": !$("input", $(this).parent()).attr("checked")
										})
								})
						);
				}
				return "";
			}()
		);
	
	MUILayoverPanel.confirm({
		"id": "remove_survey",
		"title": "Remove Survey",
		"message": message,
		"closeText": "Remove",
		"callback": function(res, id, hide){
			if(res){
				MUILayoverPanel.get("remove_survey").loadIndicator(true);
				var removedata = !!$("input[name='removedata']", $("#" + id)).attr("checked");
				return self.removeSurvey(survey.int_name, removedata, hide);
			}
			hide();
		}
	});
};

MControlListSurveys.prototype.buildSurveyItemsList = function(surveys, statusType){
	var ce = Moonshadow.helpers.ce;
	
	if(!surveys.length){
		var stText = statusType;
		if(statusType == "surveys"){
			stText = "";
		}
		if(statusType == "hidden"){
			stText = "removed";
		}
		return $(ce("div"))
			.addClass("survey_list_empty")
			.append("There are currently no "+stText+" surveys.");
	}
	
	surveys.sort(function(a, b){
		if(a.ext_name.toLowerCase() > b.ext_name.toLowerCase())
			return 1;
		if(a.ext_name.toLowerCase() < b.ext_name.toLowerCase())
			return -1;
		return 0;
	});
	
	var self = this;
	return $(surveys).map(function(key, survey){
		return self.buildSurveyRow(survey);
	});
};

MControlListSurveys.prototype.getSurveyStatus = function(surveyId){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyStatus(surveyId);
};

MControlListSurveys.prototype.requestSurveys = function(callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.getSurveysOfType(this.listType, true, callback);
};

MControlListSurveys.prototype.getSurveys = function(callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.getSurveysOfType(this.listType, false, callback);
};

MControlListSurveys.prototype.getAllSurveyIds = function(callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.getAllSurveyIds(callback);
};

MControlListSurveys.prototype.getSurveyByPropertyName = function(propery, value){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyByPropertyName(propery, value);
};

MControlListSurveys.prototype.getSurveysFields = function(surveyIds, abbriviate, callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.getSurveysFields(surveyIds, abbriviate, callback);
};

MControlListSurveys.prototype.getSurveyFields = function(surveyId){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyFields(surveyId);
};

MControlListSurveys.prototype.getLiveSurveys = function(){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getLiveSurveys();
};

MControlListSurveys.prototype.finalizeSurvey = function(int_name, callback){
	this.disableSurveyList();
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.finalizeSurvey(int_name, callback);
};

MControlListSurveys.prototype.getFilteredSurveys = function(filterType){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getFilteredSurveys(filterType, this.listType);
};

MControlListSurveys.prototype.reBuildCollections = function(int_name, callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.reBuildCollections(int_name, callback);
};

MControlListSurveys.prototype.recoverSurvey = function(int_name, callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.recoverSurvey(int_name, callback);
};

MControlListSurveys.prototype.disableSurvey = function(int_name, hidedata, callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.disableSurvey(int_name, hidedata, callback);
};

MControlListSurveys.prototype.disableSurveyList = function(){
	$(".survey_list").each(function(a, b){
	    $("input[type='button']", b).each(function(c, d){
	        $(d).attr({"disabled": true});
	    });
	    $("span, div", b).addClass("disabled");
	});
};

MControlListSurveys.prototype.removeSurvey = function(int_name, hidedata, callback){
	var self = this;
	var disableSurveyCall = function(hidedata){
		self.disableSurveyList();
		self.disableSurvey(int_name, hidedata, callback);
	};

	if(hidedata){
		return MUILayoverPanel.confirm({
			"title": "Confirm: Hide Survey Data",
			"message": "Are you sure you want to hide all gathered data associated with this survey?",
			"closeText": "Hide Data",
			"callback": function(res, id, hide){
				if(res){
					disableSurveyCall(true);
				}else{
					MUILayoverPanel.get("remove_survey").loadIndicator(false);
					callback(true);
				}
				hide();
			}
		});
	}
	disableSurveyCall(false);
};

MControlListSurveys.prototype.getSurveyStatusForDisplay = function(survey){
	if(survey.deleted)
		return "hidden";
	if(survey.live)
		return "final";
	return "draft";
};

MControlListSurveys.prototype.buildSurveyRow = function(survey){
	
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var surveystatus = this.getSurveyStatusForDisplay(survey);
	
	var formatDate = function(date){
		var dt = Moonshadow.helpers.parseIsoTS(date);
		var hour = dt.getHours();
		var ampm = "am";
		if(hour > 12){
			hour = hour - 12;
			ampm = "pm";
		}
		return (dt.getMonth() + 1) + "/" + 
			dt.getDate() + "/" +
			dt.getFullYear() + " " +
			hour + ":" +
			(dt.getMinutes() < 10 ? "0" + dt.getMinutes() : dt.getMinutes()) +
			ampm;
	};
	
	var removeButton = $(ce("a"))
		.addClass("link")
		.append("Remove")
		.click(function(e){
			self.removeSurveyAction(survey);
		});
		
	var recover = $(ce("a"))
		.addClass("link")
		.append("Recover")
		.click(function(){
			self.recoverSurveyUIActions(survey);
		});
	
	
	var finalizeButon = $(ce("a"))
		.addClass("link")
		.append("Finalize")
		.click(function(){
			var staticText = MControlListSurveys._staticText[self.listType] || MControlListSurveys._staticText["default"];
			MUILayoverPanel.confirm({
				"title": "Confirm: Finalize",
				"message": staticText.finalize,
				"closeText": "Finalize",
				"callback": function(res, id, hide){
					if(res){
						self.finalizeSurvey(survey.int_name);
					}
					hide();
				}
			});
		});
	
	var editButton = $(ce("a"))
		.addClass("link")
		.append("Edit")
		.click(function(){
			self.editSurvey(survey.int_name);
		});
	
	
	var nbEnabled = self.manager.getOption("nationbuilder");
	var nbButton = $(ce("a"))
		.addClass("link")
		.append("Sync to NationBuilder")
		.click(function(){
			self.syncToNationbuilder(survey.int_name);
		});
	
	var scriptExportButton = $(ce("a"))
		.addClass("link")
		.append("Script File")
		.click(function(){
			self.scriptFile(survey);
		});
	
	var copyExternalButton = $(ce("a"))
		.addClass("link")
		.append("Copy to Application")
		.click(function(e){
			self.copyExternal(survey);
		});
		
	var duplicateButton = $(ce("a"))
		.addClass("link")
		.append("Duplicate")
		.click(function(e){
			MUILayoverPanel.confirm({
				"message": "This will duplicate all questions on this survey, not any of the collected data. " +
				"Data collected on the duplicted survey will be in it's own collection and cannot be merged" +
				" with the data collected from the original survey. Proceed? ",
				"callback": function(res, id, hide){
					if(res){
						self.copySurvey(survey.int_name);
					}
					hide();
				}
			});
		});
	
	var viewAggregateResultsButton = $(ce("a"))
		.addClass("link")
		.append("Aggregate Results")
		.on("click", function(){
			self.viewAggregateResults(survey.int_name);
		});
	
	var rowData = {
		"survey_name": $(ce("div"))
			.addClass("clickable")
			.append(
				$(ce("div"))
					.addClass("survey_expander sprite-expander_right"),
				$(ce("span"))
					.addClass("survey_display_name")
					.append(survey.ext_name),
				$(ce("span"))
					.addClass("survey_view_button")
					.append(
						$(ce("input"))
							.attr({
								"type": "button",
								"value": "View"
							})
							.click({
									"surveyId": survey.int_name, 
									"control": this
								}, function(e){
									e.preventDefault();
									e.stopImmediatePropagation();
									e.data.control.viewSurvey(e.data.surveyId);
								}
							)
					)
			)
			.click(this.expandDetails2),
		"status": "(" + survey.status.charAt(0).toUpperCase() + survey.status.slice(1) + (survey.deleted ? ", Removed" : "") + ")",
		"date_modified": formatDate(survey.date_modified),
		"date_created": formatDate(survey.date_created),
		"expandingContainer": $(ce("div"))
			.addClass("hide survey_details item_details")
			.append(
				$(ce("div"))
					.addClass("survey_question_details survey_question_detail_links clickable right")
					.append(
						surveystatus != "hidden" ? removeButton : "",
						surveystatus == "hidden" ? recover : "",
						!survey.live && surveystatus != "hidden" && survey.survey_type != "phonecampaigns" ? finalizeButon : "",
						!survey.live && surveystatus != "hidden" ? editButton : "",
						nbEnabled ? nbButton : "",
						duplicateButton,
						surveystatus != "hidden" && surveystatus != "error" ? copyExternalButton : "",
						survey.survey_type == "phonecampaigns" ? scriptExportButton : "",
						survey.survey_type == "facebookpoll" && survey.live ? viewAggregateResultsButton : ""
					),
				$(ce("div"))
					.addClass("survey_question_details")
					.append(
						$(ce("div"))
							.append("Number of questions: ", survey.questions.length),
						survey.ext_name_abbr ? $(ce("div"))
							.append("Brief name: ", survey.ext_name_abbr) : ""
					),
				$(ce("div"))
					.addClass("survey_question_list_header")
					.append("Questions:"),
				$(survey.questions).map(function(k, v){
					return $(ce("span"))
						.addClass("survey_question_list_item")
						.attr("title", v.ext_name)
						.append((k + 1) + ": " + v.ext_name)
						.get(0);
				})
			)
	};
	
	return this.sorter.sorterObj.getDataRow(rowData).row;
};

MControlListSurveys.prototype.viewAggregateResults = function(survey_id, fbpageids, show_global){
	MControlFacebookPolls.viewAggregateResults(survey_id, fbpageids, show_global);
};

MControlListSurveys.prototype.copyExternal = function(survey){
	var addonName;
	switch(survey.survey_type){
		case "facebookpoll":
			addonName = "fbpolls";
			break;
		case "groundgame":
			addonName = "groundgame";
			break;
		case "phonecampaigns":
			addonName = "phonecampaigns";
			break;
	}
	if(!addonName){
		return;
	}
	
	var self = this;
	new Moonshadow.Ajax({
		"url": "/surveys/copytolist/" + addonName,
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			self.copyExternalPanel(survey.int_name, data.apps);
		}
	});
};

MControlListSurveys.prototype.scriptFile = function(survey){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/surveys/scriptfile/" + survey.int_name,
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			self.displayScriptFile(survey, data);
		}
	});
};

MControlListSurveys.prototype.isPhoneCampSurveyEditable = function(surveyId, callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/phonecampaigns/surveyeditable/" + surveyId,
		"type": "GET",
		"execute": true,
		"onSuccess": function(response){
			 if(response.result == "ok"){
				 return callback(response.editable);
			 }
			 MUILayoverPanel.alert("There was a problem: " + response.toString());
		}
	});
};

MControlListSurveys.prototype.isPhoneCampSurveyRemovable = function(surveyId, callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/phonecampaigns/surveyremovable/" + surveyId,
		"type": "GET",
		"execute": true,
		"onSuccess": function(response){
			 if(response.result == "ok"){
				 return callback(response.removable);
			 }
			 MUILayoverPanel.alert("There was a problem: " + response.toString());
		}
	});
};

MControlListSurveys.prototype.copyExternalPanel = function(int_name, apps){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var content;
	if(!apps.length){
		content = $(ce("div"))
			.addClass("copy_external_panel")
			.append(
				$(ce("b"))
					.append("There are no valid target applications.")
			);
	}else{
		content = $(ce("div"))
			.addClass("copy_external_panel")
			.append(
				$(ce("b"))
					.append("Select the applications to which to copy this survey."),
				$(ce("label"))
					.attr({
						"for": "copy_external_to_all"
					})
					.append(
						$(ce("input"))
							.attr({
								"id": "copy_external_to_all",
								"type": "checkbox"
							})
							.on("change", function(){
								$(".copy_to_checkbox", content)
									.attr({
										"checked": this.checked
									});
								var title = $(this)
									.closest("label")
									.find("span");
								if(this.checked){
									$(title)
										.empty()
										.append("Deselect all")
								}else{
									$(title)
										.empty()
										.append("Select all")
								}
							}),
						$(ce("span"))
							.append("Select all")
					),
				$.map(apps, function(app){
					if(app.appname == self.manager.getOption("app")){
						return null;
					}
					return $(ce("label"))
						.attr({
							"for": "copy_to_" + app.appname
						})
						.append(
							$(ce("input"))
								.addClass("copy_to_checkbox")
								.attr({
									"id": "copy_to_" + app.appname,
									"type": "checkbox",
									"value": app.appname
								}),
							app.display_name
						)
						.get(0)
				})
			);
	}
	
	
	
	var copyPanel = MUILayoverPanel.confirm({
		"title": "Copy Survey to Another Application",
		"message": content,
		"callback": function(res, id, close){
			if(!res){
				return close();
			}
			var checkedApps = [];
			$(".copy_to_checkbox:checked", content).each(function(index, box){
				checkedApps.push($(box).val());
			});
			if(checkedApps.length){
				MUILayoverPanel.confirm({
					"message": "Press OK to start the copy process. Note that it might take some time to finish.",
					"callback": function(res, id, close){
						if(res){
							self.startCopyExternal(int_name, checkedApps);
						}
						close();
					}
				});
			}
			close();
		}
	});
};

MControlListSurveys.prototype.startCopyExternal = function(int_name, apps){
	new Moonshadow.Ajax({
		"url": "/surveys/copyexternal/" + int_name,
		"type": "POST",
		"payload": {"target_apps": apps},
		"execute": true,
		"wrapPost": false
	});
};

MControlListSurveys.prototype.displayScriptFile = function(survey, data){
	var ce = Moonshadow.helpers.ce;
	
	var content = $(data.script);
	$(content.get(0)).addClass("script_file_preview scrollable");
	
	new MUILayoverPanel({
		"id": "view_script", 
		"content": content,
		"title": "Dictation for " + survey.ext_name,
		"fixed": false,
		"animate": true,
		"minWidth": 550,
		"maxHeight": 700,
		"position": {
			"width": 800,
			"height": 500
		}
	}).open();
};

MControlListSurveys.prototype.editSurvey = function(surveyId){
	var self = this;
	var openEdit = function(){
		var surveyControl = new MControlEditSurvey(self.manager);
		surveyControl.editSurvey(surveyId);
	}
	if(this.listType == "phonecampaigns"){
		return this.isPhoneCampSurveyEditable(surveyId, function(editable){
			if(!editable){
				return MUILayoverPanel.alert("This survey may not be edited at this time.")
			}
			openEdit();
		});
	}
	openEdit();
};

MControlListSurveys.prototype.copySurvey = function(surveyId){
	var surveyControl = new MControlEditSurvey(this.manager);
	surveyControl.copySurvey(surveyId);
};

MControlListSurveys.prototype.viewSurvey = function(surveyId){
	var surveyControl = new MControlEditSurvey(this.manager);
	surveyControl.viewSurvey(surveyId);
};

MControlListSurveys.prototype.newSurvey = function(){
	var surveyControl = new MControlEditSurvey(this.manager);
	surveyControl.newSurvey(this.listType);
};

//too many of these
MControlListSurveys.prototype.expandDetails2 = function(){
	var getExp = function(elem){
		if($(elem).hasClass("survey_expander"))
			return elem;
		if($(".survey_expander", elem).length){
			return $(".survey_expander", elem);
		}
		return getExp($(elem).parent());
	};
	var exp = getExp(this);
	var targ = $(this).closest(".survey_list_item").find(".item_details");
	if($(targ).hasClass("hide")){
		$(exp)
			.removeClass("sprite-expander_right")
			.addClass("sprite-expander_down");
		$(targ).removeClass("hide");
		var resizer = $(".is_resizable", targ);
		if(resizer.length){
			$(resizer).resizable({
				"handles": "s"
			});
		}
	}else{
		$(exp)
			.addClass("sprite-expander_right")
			.removeClass("sprite-expander_down");
		$(targ).addClass("hide");
		var resizer = $(".is_resizable", targ);
		if(resizer.length){
			$(resizer).resizable("destroy");
		}
	}
};

MControlListSurveys.prototype.syncToNationbuilder = function(surveyId){
	var hasNBOAuthCreds = this.manager.hasOAuth('nationbuilder');
	if(!hasNBOAuthCreds){
		var nationbuilderui = this.manager.getControl("nationbuilderui");
		return MUILayoverPanel.confirm({
			"message": "Syncing this survey to NationBuilder requires that you configure " +
					" NationBuilder credentials. Click OK to start NationBuilder configuration.",
			"callback": function(res, id, hide){
				if(res){
					nationbuilderui.getStarted(true);
				}
				hide();
			}
		});
	}
	this.manager.getControl("nationbuilderAdmin").syncSurvey(surveyId);
};


MControlListSurveys.prototype.buildSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("survey_list scrollable");
	
	var sorter = $(ce("div"))
		.addClass("survey_list_columns");
	
	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".survey_list_item",
		"sortFunctions": this.sortOpts(),
		"columnSettings": [{
	 		"value": "Status",
	 		"sortby": "status",
	 		"float": "right",
 		},{
	 		"value": "Date Modified",
	 		"sortby": "date_modified",
	 		"float": "right",
 		},{
	 		"value": "Date Created",
	 		"sortby": "date_created",
	 		"float": "right",
 		},{
 			"spacer": "scroller_spacer",
 			"float": "right"
 		},{
	 		"value": "Survey Name",
	 		"sortby": "survey_name",
	 		"sortdefault": true
 		}],
		"sorterContainerClassName": "sortsurveys",
		"sorterContainer": sorter,
		"columnDataContainer": container,
		"expandingContainer": true,
	});
	
	colsorter.makeColumnSorter(true);
	
	this.sorter = {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	}; 
};

MControlListSurveys.prototype.sortOpts = function(){
	return {
		"status": function(a, b, sortorder){
 			var avalue = $(".sortable_data_column_status", a).text().toLowerCase();
			var bvalue = $(".sortable_data_column_status", b).text().toLowerCase();
			var val1 = this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			if(val1 == 0){
				return this.sortFunctions.survey_name.apply(this, [a, b, 1]);
			}
			return val1;
 		},
 		"date_modified": function(a, b, sortorder){
			var avalue = $(".sortable_data_column_date_modified", a).text();
			var bvalue = $(".sortable_data_column_date_modified", b).text();
			return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
		},
		"date_created": function(a, b, sortorder){
			var avalue = $(".sortable_data_column_date_created", a).text();
			var bvalue = $(".sortable_data_column_date_created", b).text();
			return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
		},
		"survey_name": function(a, b, sortorder){
			var avalue = $(".survey_display_name", a).text().toLowerCase();
			var bvalue = $(".survey_display_name", b).text().toLowerCase();
			var val1 = this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			if(val1 == 0){
				return this.sortFunctions.date_created.apply(this, [a, b, 1]);
			}
			return val1;
		},
		"stringSort": MUIFilterableSorter.predefinedSorting.stringSort,
		"returnVal": MUIFilterableSorter.predefinedSorting.returnVal
	};
};
/**
 *
 * @class MControlLogout
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlLogout(options) {
	this.name = "logout";
	this.index = -1;
	this.manager = null;
	this.container = false;
	this.options = options || {};
	this.position = this.options.position || 3;
	this.precedence = 1;
	this.apps;
	this.managementApp;
	this.phoneManagementApp;
	this.exportPortals = [];
	this.settings_opts = {};
	this.settingsGear;
	this.reauthForm;
	this.controlNames = [
		"settings-options",
		"login-options",
		"app-list",
		"appfeatures-options"
	];
}

MControlLogout.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	_manButton: function(){
		var man_interface = document.createElement("div");
		man_interface.className = "clickable opt";
		man_interface.appendChild(document.createTextNode("System Management"));
		return man_interface;
	},
	_phoneManButton: function(){
		var phoneman_interface = document.createElement("div");
		phoneman_interface.className = "clickable opt";
		phoneman_interface.appendChild(document.createTextNode("Phone Campaign Management"));
		return phoneman_interface;
	},
	
	init: function(manager) {
		this.manager = manager;
		
		var caller = this;
		
		if(!this.container){
			this.createContainer();
		}
		
		this.getManager().getAdapter().addControlToMap(this.getManager().getControl(this.name));
		
		var gearButton = this.makeGearButton();
		var appFeatureButton = this.appFeaturesButton();
		
		this.manager.addMapObserver([
				"before_panel_close", 
				"before_panel_open",
				"panel_resize",
				"click"
			], function(){
			this.closeAllLists();
		}, this);
		
		this.manager.addMapObserver("universesuiloaded", function(){
			this.appFeatureOptions();
		}, this);
		
		this.manager.addMapObserver("loaded",(function() {
			this.apps = manager.getOption('apps').slice();
			var appsToMove = {
				"_exportportal":"exportPortal",
				"_management": "managementApp",
				"_phonecampaignmanager": "phoneCampaignManager"
			};
			
			if(this.apps && this.apps.length > 0){
				for(var i = 0, l = this.apps.length; i < l; ++i){
					if(this.apps[i] && appsToMove[this.apps[i].app]){
						if(appsToMove[this.apps[i].app] == "managementApp"){
							this.managementApp = this.apps[i];
						}
						if(appsToMove[this.apps[i].app] == "phoneCampaignManager"){
							this.phoneManagementApp = this.apps[i];
						}
						if(appsToMove[this.apps[i].app] == "exportPortal"){
							this.exportPortals.push(this.apps[i]);
						}
						delete this.apps[i];
					}
				}
			}
			
			var filteredApps = [];
			for(var i = 0, l = this.apps.length; i < l; ++i){
				if(this.apps[i] && typeof this.apps[i] == "object"){
					filteredApps.push(this.apps[i]);
				}
			}
			this.apps = filteredApps;
			
			if(this.managementApp && !this.settings_opts.man_interface){
				this.settings_opts.man_interface = this._manButton();
			}
			
			if(this.phoneManagementApp && !this.settings_opts.phoneman_interface){
				this.settings_opts.phoneman_interface = this._phoneManButton();
			}
			
			if(!this.container){
				this.createContainer();
			}
	
			var isAnon = this.manager.isAnonymous();
			var appType = this.manager.getOption('app_details.type');

			//app switcher---
			if(this.apps.length > 1 && !this.manager.getOption('disableLogoutControl')) {
				var buttonAction = function(button, control){
					if(control.apps.length > 1) {
						control.toggleList("app-list", control.appList, button);
					} else {
						if(!isAnon) {
							Moonshadow.helpers.login.logout();
						}
					}
				};

				this.container.appendChild(
					this.makeButton(
						Moonshadow.appDisplay,
						buttonAction,
						true,
						"app_switcher",
						"Current Application"
					)
				);
			}
			//---
		
			//Add App Features button
			if(appFeatureButton){
				$(this.container).append(appFeatureButton);
			}
			//---
			
			//logout and user display---
			if(!isAnon && !this.manager.getOption('disableLogoutControl')) {
				this.container.appendChild(
					this.makeButton(
						Moonshadow.user, 
						function(button, control) {
							control.toggleList(
								"login-options", 
								control.loginOptions, 
								button
							);
						}, 
						(!isAnon), 
						"logout", 
						("Logged in as " + Moonshadow.user)
					)
				);
			}
			//---
			
			//settings button---
			var showConfig = false;
			if(this.settings_opts.man_interface)
				showConfig = true;
			
			if(this.settings_opts.phoneman_interface)
				showConfig = true;
			
			if(this.settings_opts.exportPortalsInterface)
				showConfig = true;
			
			if(showConfig && this.settingsGear){
				$(this.container).append(gearButton);
				$(".settings_button.hide").removeClass("hide");
			}
			//---
			
			//login / registration and about for censusviewer---
			if(isAnon && appType == "censusviewer"){
				$(this.container).append(
					this.makeButton(
						"About", function(){
							window.open("http://www.censusviewer.com", "_blank");
						}, false, "about", "About CensusViewer"
					),
					this.makeButton(
						"Login / Register", function(button, control){
							control.regLoginForm();
						}, false, "login_form", "Already subscribed? Click to login."
					)
				);
			}
			//---
				
			var clear = document.createElement('div');
			clear.className = 'clear';
			this.container.appendChild(clear);
			
			this.show();
		}),this);
	},
	/**
	 *
	 * @method appFeaturesButton
	 */
	appFeaturesButton: function(){
		
		var availableOptions = [];
		var ul = this.manager.getOption("user_details.user_type");
		
		if(this.getManager().getControl("customer_management").canvassingEnabled() && ul != "read-only" && ul != "canvasser"){
			availableOptions.push("customer_management");
		}
		
		if(this.getManager().hasAddon("phonecampaigns") && ul != "read-only" && ul != "canvasser"){
			availableOptions.push("phonecampaigns");
		}
		
		if(this.getManager().hasAddon("groundgame") && ul != "read-only" && ul != "canvasser") {
			availableOptions.push("groundgame");
		}
		
		if(this.getManager().hasAddon("fbpolls") && ul != "read-only" && ul != "canvasser") {
			availableOptions.push("fbpolls");
		}
		
		if(!availableOptions.length){
			return false;
		}
		
		var ce = Moonshadow.helpers.ce;

		this.appFeatureButton = $(ce("div"))
			.addClass("appfeatures_options")
			.append("App Features")
			.get(0);
		
		var self = this;
		return this.makeButton(
			this.appFeatureButton, 
			function(button, control){
				control.toggleList(
					"appfeatures-options",
					control.appFeatureOptions,
					availableOptions
				);
				self.clickActions();
			}, true, "appfeatures_options", "Application Features"
		);
	},
	/**
	 *
	 * @method appFeatureOptions
	 */
	appFeatureOptions: function(availableOptions){
		//sprite-groundgame_13x13
		var options = {};
		
		var ce = Moonshadow.helpers.ce;
		if($.inArray("groundgame", availableOptions) > -1){
			this.settings_opts.surveyManagement = 
				options.surveyManagement = $(ce("div"))
					.addClass("clickable opt")
					.append("Ground Game")
					.get(0);
		}
		
		if($.inArray("customer_management", availableOptions) > -1){			
			this.settings_opts.userManagement = 
				options.userManagement = $(ce("div"))
					.addClass("clickable opt")
					.append("User Management")
					.get(0);
		}
		
		if($.inArray("phonecampaigns", availableOptions) > -1){			
			this.settings_opts.phonecampaignsManagement = 
				options.phonecampaignsManagement = $(ce("div"))
					.addClass("clickable opt")
					.append("Phone Campaigns")
					.get(0);
		}
		
		if($.inArray("fbpolls", availableOptions) > -1){			
			this.settings_opts.fbpollsManagement = 
				options.fbpollsManagement = $(ce("div"))
					.addClass("clickable opt")
					.append("Facebook Polls")
					.get(0);
		}
		
		return this.makeList(options, "appfeatures-options", this.appFeatureButton);
	},
	/**
	 *
	 * @method clickActions
	 */
	clickActions: function(){
		if(this.settings_opts.userManagement){
			$(this.settings_opts.userManagement).unbind('click').click({
					"control": this
				}, function(e){
				var appmanager = e.data.control.manager.getControl('customer_management');
				e.data.control.toggleList("appfeatures-options");
				appmanager.show();
			});
		}
		if(this.settings_opts.surveyManagement){
			$(this.settings_opts.surveyManagement).unbind('click').click({
					"control": this
				}, function(e){
				var surveymanager = e.data.control.manager.getControl('groundgame');
				e.data.control.toggleList("appfeatures-options");
				surveymanager.show();
			});
		}
		
		if(this.settings_opts.phonecampaignsManagement){
			$(this.settings_opts.phonecampaignsManagement).unbind('click').click({
					"control": this
				}, function(e){
				var phonecampaigns = e.data.control.manager.getControl('phonecampaigns');
				e.data.control.toggleList("appfeatures-options");
				phonecampaigns.show();
			});
		}
		
		if(this.settings_opts.fbpollsManagement){
			$(this.settings_opts.fbpollsManagement).unbind('click').click({
					"control": this
				}, function(e){
				var fbpolls = e.data.control.manager.getControl('fbpolls');
				e.data.control.toggleList("appfeatures-options");
				fbpolls.show();
			});
		}

		if(this.settings_opts.man_interface){
			$(this.settings_opts.man_interface).unbind('click').click({"control": this}, function(e){
				var control = e.data.control;
				var customer = control.manager.getOption("customer");
				var app = control.managementApp.app;
				Moonshadow.helpers.login.changeApp(customer, app, control, function() {
					$(".settings_button .settings_options").addClass("tiny_wait");
				}, function(response){
					var message = "";
					if(response.error)
						message = response.error;
					MUILayoverPanel.alert("There was a problem with the request. Please refresh your browser and try again in a moment.");
					$(".settings_button .settings_options").removeClass("tiny_wait");
				}, function() {
					$(".settings_button .settings_options").removeClass("tiny_wait");
				});
			});
		}
		
		if(this.settings_opts.phoneman_interface){
			$(this.settings_opts.phoneman_interface).unbind('click').click({"control": this}, function(e){
				var control = e.data.control;
				var customer = control.manager.getOption("customer");
				var app = control.phoneManagementApp.app;
				Moonshadow.helpers.login.changeApp(customer, app, control, function() {
					$(".settings_button .settings_options").addClass("tiny_wait");
				}, function(response){
					var message = "";
					if(response.error)
						message = response.error;
					MUILayoverPanel.alert("There was a problem with the request. Please refresh your browser and try again in a moment.");
					$(".settings_button .settings_options").removeClass("tiny_wait");
				}, function() {
					$(".settings_button .settings_options").removeClass("tiny_wait");
				});
			});
		}
	},
	
	/**
	 *
	 * @method makeGearButton
	 */
	makeGearButton: function(){
		var settingsGear = document.createElement("div");
		settingsGear.className = "settings_options sprite-settingsSmall";
		this.settingsGear = settingsGear;
		var caller = this;
		return this.makeButton(
			settingsGear,
			function(button, control){
				control.toggleList(
					"settings-options",
					control.settingsOptions,
					button
				);
				caller.clickActions();
			}, 
			false, 
			"settings_button hide", 
			"Application Options"
		);
	},
	/**
	 *
	 * @method createContainer
	 */
	createContainer: function(){
		var container = document.createElement("div");
		container.id = "logoutContainer";
		container.className = "logoutContainer";
		this.container = container;
	},
	/**
	 *
	 * @method regLoginForm
	 */
	regLoginForm: function(){
		var ce = Moonshadow.helpers.ce;
		var manager = this.manager;
		
		var loginContent = $(ce("div"))
			.append(
				Moonshadow.helpers.login.form(),
				$(ce("div"))
					.addClass("loginform_footer")
					.append(
						$(ce("div"))
							.addClass("loginform_footer_center")
							.append(
								$(ce("span"))
									.append("Not yet registered?"),
								$(ce("div"))
									.addClass("loginform_register_button clickable")
									.append("Register")
									.on("click", function(){
										var regURL = manager.getOption("server") + "/subscription/plans/censusviewer/";
										window.open(regURL, "_blank");
									})
							)
					)
			);
		
		var _loginForm = new MUILayoverPanel({
			"id": "login_form",
			"content": loginContent, 
			"title": "Login / Register",
			"onClose": function(callback){
				Moonshadow.helpers.login.resetForm();
				callback();
			},
			"animate": true,
			"position": {
				"height": 300
			}
		});
		_loginForm.open();
	},
	/**
	 *
	 * @method loginForm
	 */
	reloginForm: function(message, callback){
		if(this.reauthForm){
			return;
		}
		
		var ce = Moonshadow.helpers.ce;
		var manager = this.manager;
		var loginContent = $(ce("div"))
			.append(
				$(ce("div"))
					.addClass("loginform_header")
					.append(message || "Please log in to proceed."),
				Moonshadow.helpers.login.formWithOptions({
					"isReauth": true,
					"callback": function(isAuthed){
						MUILayoverPanel.close("login_form");
						if(!isAuthed){
							return Moonshadow.helpers.login.logout();
						}
						callback && callback();
					}
				})
			);
		
		var self = this;
		var _loginForm = new MUILayoverPanel({
			"id": "login_form",
			"content": loginContent, 
			"title": "Login",
			"onClose": function(hide){
				Moonshadow.helpers.login.resetForm();
				self.reauthForm = null; 
				hide();
			},
			"animate": true,
			"position": {
				"height": 300
			}
		});
		_loginForm.open();
		
		this.reauthForm = _loginForm;
	},
	/**
	 *
	 * @method personalAccountInfo
	 * @param {} tok
	 * @param {} subdomain
	 */
	personalAccountInfo : function(tok, subdomain){
		var controls = [];
		
		var recurly_link = document.createElement("a");
		recurly_link.appendChild(document.createTextNode("View / Change Billing Info"));
		recurly_link.className = "classic_link clickable";
		$(recurly_link).click({'tok': tok, 'subdomain': subdomain},function(e) {
			window.open('https://' + e.data.subdomain + '.recurly.com/account/' + e.data.tok, '_blank');
		});
		controls.push(recurly_link);
		
		var password_link = document.createElement("a");
		password_link.appendChild(document.createTextNode("Logout and Change Password or User Information"));
		password_link.className = "classic_link clickable";
		$(password_link).click({"control":this},function(e){
			e.data.control.changeAccountInfo();
		});
		controls.push(password_link);
		
		var personal_account = document.createElement("div");
		personal_account.className = "personal_account";
		
		var header = document.createElement("div");
		header.appendChild(document.createTextNode("Account Options:"));
		personal_account.appendChild(header);
		
		var lu = document.createElement("ul");
		controls.map(function(cont){
			var li = document.createElement("li");
			li.appendChild(cont);
			lu.appendChild(li);
		});
		personal_account.appendChild(lu);
		
		var _personalAccountInfo = new MUILayoverPanel({
			"id": "personal_account",
			"content": personal_account,
			"title": "Account Management",
			"animate": true,
			"position": {
				"height": 350
			}
		});
		_personalAccountInfo.open();
	},
	/**
	 *
	 * @method makeButton
	 * @param {} content content for the button's content (HTML element(like label or image), or textNode or string)
	 * @param {} action callback function to run when button clicked. action([ref to button], [ref to control])
	 * @param {} hasOptions will display the down arrow if clicking reveals other options
	 * @param {} className additional classname of the button
	 * @param {} toolTip text that will show in tooltip when hovered over button
	 */
	makeButton: function(content, action, hasOptions, className, toolTip) {
		var button = document.createElement("div");
		button.className = "outset_button";
		if(className)
			button.className += " "+className;

		if(toolTip)
			button.title = toolTip;
		
		var buttonSub = document.createElement("div");
		buttonSub.className = "auto_width";

		var buttonSubSub = document.createElement("div");
		buttonSubSub.className = "buttonContent";
		
		if(typeof content == "string"){
			var contentElem = document.createElement('div');
			contentElem.appendChild(document.createTextNode(content));
			content = contentElem;
		}
		
		if(hasOptions){
			if(typeof hasOptions == "object"){
				var moreOptions = document.createElement('div');
				moreOptions.className = hasOptions.className;
				buttonSubSub.appendChild(moreOptions);
			}else{
				var moreOptions = document.createElement('div');
				moreOptions.className = 'more-options sprite-expander_down';
				buttonSubSub.appendChild(moreOptions);
				if(content.nodeType == 3){ //textNode
					var contentElem = document.createElement('div');
					contentElem.appendChild(content);
					content = contentElem;
				}
				
				content.className += " opt-current";
			}
		}
		
		buttonSubSub.appendChild(content);
		
		if(hasOptions){
			var clear = document.createElement('div');
			clear.className = 'clear';
			buttonSubSub.appendChild(clear);
		}
		
		var buttonAction = document.createElement("span");
		if(action){
			button.className += " clickable";
			$(buttonAction).click({"control":this, "action": action},function(e) {
				var control = e.data.control;
				var action = e.data.action;
				action(this, control);
			});
		}
		
		buttonAction.appendChild(buttonSubSub);
		buttonSub.appendChild(buttonAction);
		button.appendChild(buttonSub);
		return button;
	},
	/**
	 *
 	 * @method makeList
	 * @param {} content
	 * @param {} id
	 * @param {} target
	 * @param {} className
	 */
	makeList: function(content, id, target, className){
		var list = document.createElement("div");
		list.className = "floating option-list scrollable";
		if(className)
			list.className += " "+className;
		list.id = id;
		var targetElem = $("#logoutContainer");
		if(target)
			targetElem = $(target).parent();

		if($(targetElem).closest(".outset_button").length > 0){
			list.style.right = $("#maincontainer").outerWidth() -
				($(targetElem).closest(".outset_button").offset().left +
				 $(targetElem).closest(".outset_button").outerWidth())+"px";
			list.style.top = (($(targetElem).closest(".outset_button").offset().top +
							   $(targetElem).closest(".outset_button").outerHeight()) -
							  2 )+"px";
		}
		
		for(var i in content) {
			if(content.hasOwnProperty(i)){
				list.appendChild(content[i]);
			}
		}

		return list;
	},
	/**
	 *
	 * @method toggleList
	 * @param {} id
	 * @param listBuilder
	 * @param {} button
	 */
	toggleList: function(id, listBuilder, button){
		if($("#"+id).length > 0) {
			this.closeList(id);
		}else{
			var listObj = listBuilder.apply(this,[button]);
			$(".option-list").remove();
			$("#maincontainer")[0].appendChild(listObj);
		}
	},
	closeList: function(id){
		$("#"+id).remove();
	},
	closeAllLists: function(){
		for(var i = 0, l = this.controlNames.length; i < l; ++i){
			this.closeList(this.controlNames[i]);
		}
	},
	/**
	 *
	 * @method settingsOptions
	 * @param {} target
	 */
	settingsOptions: function(target){	
		if(this.managementApp && !this.settings_opts.man_interface){
			this.settings_opts.man_interface = this._manButton();
		}
		if(this.phoneManagementApp && !this.settings_opts.phoneman_interface){
			this.settings_opts.phoneman_interface = this._phoneManButton();
		}

		var ul = this.manager.getOption("user_details.user_type");
		if (!this.settings_opts.map_interface && ul == "superuser") {
			var mapAdapter = this.getManager().getOption('user_settings.mapAdapter');
			
			var map_interface = document.createElement('div');
			map_interface.className = 'map';
			map_interface.appendChild(document.createTextNode("Map"));

			var mapSelect = document.createElement('select');
			var options = Moonshadow.mapList();
			
			for (var i = 0, l = options.length; i < l; i++) {
				var _opt = new Option(options[i].desc, options[i].index);
				if (!options[i].enabled){
					_opt.disabled = "disabled";
				}
				if (options[i].index == mapAdapter) {
					_opt.selected = "selected";
				}
				mapSelect.appendChild(_opt);
			}

			mapSelect.onchange = (function(self) {
				return function(event) {
					var selected = event.target.options[event.target.selectedIndex];
					var value = selected.value ? parseInt(selected.value, 10) : null;

					var settings = self.getManager().getControl('usersettings');
					settings.setUserSetting('mapAdapter', value, function() {
						window.location.reload();
					});

					event.preventDefault();
				};
			}(this));

			map_interface.appendChild(mapSelect);
			this.settings_opts.map_interface = map_interface;		
		}
		
		if(this.exportPortals.length && !this.settings_opts.exportPortalsInterface){
			for(var i = 0, l = this.exportPortals.length; i < l; ++i){
				var exportPortalsInterface = document.createElement("div");
				exportPortalsInterface.className = "clickable opt";
				exportPortalsInterface.appendChild(document.createTextNode(this.exportPortals[i].name));
				$(exportPortalsInterface).click({
					"control": this,
					"customer": this.exportPortals[i].customer,
					"app": this.exportPortals[i].app
				},this.switchApp);
				this.settings_opts["exportPortalsInterface_" + i] = exportPortalsInterface;
			}
		}
		var settingObjects = {};
		if(this.settings_opts.man_interface){
			settingObjects.man_interface = this.settings_opts.man_interface;
		}
		if(this.settings_opts.phoneman_interface){
			settingObjects.phoneman_interface = this.settings_opts.phoneman_interface;
		}
		if (this.settings_opts.map_interface) {
			settingObjects.map_interface = this.settings_opts.map_interface;
		}
		if(this.settings_opts.exportPortalsInterface){
			settingObjects.exportPortalsInterface = this.settings_opts.exportPortalsInterface;
		}
		return this.makeList(settingObjects,"settings-options",target);
	},
	/**
	 *
	 * @method loginOptions
	 */
	loginOptions: function(target) {
		var listItems = {};
		
		var tok = this.manager.getOption("customer_details.recurly_management_token");
		if(tok){
			var paymentSubdomain = this.getManager().getOption('customer_details.recurly_payment_subdomain');
			var account_management = document.createElement("div");
			account_management.className = "clickable opt";
			account_management.appendChild(document.createTextNode("Account Management"));
			$(account_management).click({"control": this}, function(e){
				e.data.control.personalAccountInfo(tok, paymentSubdomain);
			});
			listItems.account_management = account_management;
		}
		
		var nbEnabled = this.manager.getOption("nationbuilder");
		if(nbEnabled){
			var nboauth_interface = document.createElement("div");
			nboauth_interface.className = "clickable opt";
			nboauth_interface.appendChild(document.createTextNode("NationBuilder Account"));
			$(nboauth_interface).unbind('click').click({"control": this}, function(e){
				var control = e.data.control;
				control.getManager().getControl("nationbuilderui").getStarted(true);
			});
			listItems.nboauth_interface = nboauth_interface;
		}
		
		if(this.manager.shouldControlBeLoaded("MControlManagement") && 
				this.manager.getControl("customer_management").options.contactInfo) {
			var customer_management = document.createElement("div");
			customer_management.className = "clickable opt";
			customer_management.appendChild(document.createTextNode("Contact Information"));
			$(customer_management).click({"manager": this.manager}, function(e){
				var appmanager = e.data.manager.getControl('customer_management');
				appmanager.aiui.gatherCustomerContactInfo();
			});
			listItems.customer_management = customer_management;
		}
		
		var logout = document.createElement("div");
		logout.className = "clickable opt";
		logout.appendChild(document.createTextNode("Logout"));
		$(logout).click(function(){
			Moonshadow.helpers.login.logout();
		});
		listItems.logout = logout;
		
		//disabling for now
//		var switchUsers = document.createElement("div");
//		switchUsers.className = "clickable opt";
//		switchUsers.appendChild(document.createTextNode("Switch Users"));
//		var self = this;
//		$(switchUsers).click(function(){
//			self.reloginForm("Provide username and password.");
//		});
//		listItems.switchUsers = switchUsers;
		
		return this.makeList(listItems,"login-options",target);
	},
	/**
	 *
	 * @method changeAccountInfo
	 */
	changeAccountInfo: function(){
		window.location = "/user/adjustaccount/changepersonalinfo/"+ this.getManager().getOption('user');
	},
	/**
	 * 
	 * @method appList
	 * @param {} target
	 */
	appList: function(target) {
		var apps = this.apps;
		var currApp = Moonshadow.app;
		var currCustomer = Moonshadow.customer;
		
		var listCon = {};
		var header = document.createElement("h2");
		header.appendChild(document.createTextNode("Switch to:"));
		listCon.header = header;

		for(var i = 0, l = apps.length; i < l; i++) {
			var app = apps[i];
			if(app.customer == "_management" || app.customer == "_phonecampaignmanager" || app.customer == "_exportportal"){
				continue;
			}
			if(!(currApp == app.app && currCustomer == app.customer)) {
				var item = document.createElement("div");
				item.className = "opt";
				
				if(app.addon_details && app.addon_details.length){
					for(var j = 0, ll = app.addon_details.length; j < ll; ++j){
						var addonItem = document.createElement("span");
						addonItem.className = app.addon_details[j].name + " addon";
						addonItem.title = app.addon_details[j].description;
						item.appendChild(addonItem);
					}
				}else if(app.addons && app.addons.length > 0){
					for(var j = 0, ll = app.addons.length; j < ll; ++j){
						var addonItem = document.createElement("span");
						addonItem.className = app.addons[j] + " addon";
						item.appendChild(addonItem);
					}
				}
				
				var appTypeItem = document.createElement("span");
				appTypeItem.className = app.type + " apptype";
				appTypeItem.title = "Type: " + Moonshadow.helpers.capitalize(app.type);
				if(app.addons && app.addons.length > 0){
					appTypeItem.appendChild(document.createTextNode(":"));
				}
				item.appendChild(appTypeItem);
				
				var appname = document.createElement("span");
				appname.className = "appname";
				appname.appendChild(document.createTextNode(app.name));
				
				item.appendChild(appname);

				if(!app.maintenance) {
					item.className += " clickable";
					$(item).click({
						"control": this,
						"customer": app.customer,
						"app": app.app
					},this.switchApp);
				} else {
					item.className += " opt-disabled";
				}
				
				listCon[app.name+i] = item;
			}	
		}
		return this.makeList(listCon, "app-list", target);
	},
	/**
	 *
	 * @method switchApp
	 * @param {} e
	 */
	switchApp: function(e){
		var control = e.data.control;
		var customer = e.data.customer;
		var app = e.data.app;
		
		var closePanel = function(){
			$(".app_switcher .more-options")
				.removeClass("sprite-expander_down")
				.addClass("tiny_wait");
			$(".app_switcher").removeClass("clickable");
			$(".app_switcher span").unbind();
			$(".app_switcher .buttonContent ").addClass("button_disabled");
			control.toggleList("app-list");
		};
		
		Moonshadow.helpers.login.changeApp(customer, app, control, 
			null,
			function(response){
				var message;
				if(response && response.error){
					message = response.error;
				}
				MUILayoverPanel.alert(message || "There was a problem with the request. Please refresh your browser and try again in a moment.");
			}
		);
		
		closePanel();
	},
	/**
	 *
	 * @method onAjaxResponse
	 * @param {} data
	 */
	onAjaxResponse: function(data) {
		if(data.qid == "logout") {
			window.location = "/user/unauth";
		}
	},
	/**
	 *
	 * @method show
	 */
	show: function() {
		this.container.style.display = "block";
	},
	/**
	 *
	 * @method hide
	 */
	hide: function() {
		this.container.style.display = "none";
	}
};
Moonshadow.helpers.extend(MControlLogout,MControl);

/**
 *
 * @class MControlLogos
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlLogos(options) {
    this.name = "logos";
    this.manager = null;
    this.container = false;
    this.options = options || {};
    this.position = null;
    this.logoContainers = {};
}

MControlLogos.prototype = {
    /**
     *
     * @method init
     * @param {} manager
     */
    init: function(manager) {	
		this.manager = manager;

		this.manager.addMapObserver("loaded",function() {
			this.addLogos();
		},this);

		this.options.cdn = this.getManager().getOption("cdn") || "https://cdn1.moonshadowmobile.net";
		this.pushDefaultLogos();
		
		if(!this.options.logos) {
			return;
		}

		var caller = this;
		$.each(this.options.logos,function(k,v) {
			var logoObj = {};
			logoObj.position = v.position || 1;
			var image;
			
			if (caller.logoContainers[logoObj.position]){
				logoObj.container = caller.logoContainers[logoObj.position].container;
			}else{
				logoObj.container = document.createElement("div");
				logoObj.container.className = "logo-item "+Moonshadow.maps[caller.getManager().getMapProvider()].name;
				caller.logoContainers[logoObj.position] = logoObj;
				if(logoObj.position < 0)
					logoObj.container.className += " side_panel";
			}
			if(v.src){
				image = document.createElement("img");
				image.src = v.src;
				if(typeof v.width != "undefined" && v.width.length > 0)
					image.style.width = v.width;
	    		
			}
			if(v.div){
				image = document.createElement("div");
			}
			if (v.href){
				var a = document.createElement("a");
				a.className = "link";
				if(v.className){
					a.className += " " + v.className;
				}
    			a.target = v.target || "_blank";
    			a.appendChild(image);

    			$(a).click({"href":v.href},function(e){
    				window.open(e.data.href);
    			});

    			logoObj.container.appendChild(a);

				var clear = document.createElement('div');
				clear.className = 'clear';

				logoObj.container.appendChild(clear);
			}else if (v.src){
				logoObj.container.appendChild(image);
			}
			
			if (logoObj.position < 0) { //>
				var spl = caller.sidePanelLogo();
				spl.setContent(logoObj.container);
				caller.logoContainers[logoObj.position] = spl;
			}    		
		});	
	},
	/**
	 *
	 * @method addLogos
	 */
	addLogos: function(){
		for(var v in this.logoContainers) {
			if (this.logoContainers[v]){
				if(this.logoContainers[v].position == "inside"){
					this.getManager().getAdapter().addControlInsideMap(this.logoContainers[v]);
				}else{
					if(this.logoContainers[v].position > 0){
						this.getManager().getAdapter().addControlToMap(this.logoContainers[v]);
					}else{
						this.getManager().getControl('sidepanel').addControl(this.logoContainers[v]);
					}
				}
			}
		}
	},
	/**
	 * 
	 * @method sidePanelLogo
	 */
	sidePanelLogo: function() {
		var spl = {
			"name" : "spl",
			"container" : null,
			"position" : -1,
			"fixed": true,
			"ui" : function() {
				this.container = document.createElement("div");
				this.container.className = "logos";
				this.container.id = 'logos-sidepanel';
			},
			"setContent" : function(content) {
				this.container.appendChild(content);
			}
		};
		spl.ui();
		return spl;
	},
	/** 
	 *
	 * @method pushDefaultLogos
	 */
	pushDefaultLogos: function(){
		this.options.logos.push({
			"href": "http://www.moonshadowmobile.com",
			"className": "moonshadow_logo_powered_by_light_dark",
			"div": true,
			"position": "inside"
		});
	},
	/**
	 *
	 * @method show
	 */
	show: function() {},
	/**
	 *
	 * @method hide
	 */
	hide: function() {}
};
Moonshadow.helpers.extend(MControlLogos,MControl);

/**
 *
 * @method MControlCart
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlCart(options) {
	this.name = "cartpanel";
	this.manager = null;
	this.container = false;
	this.controls = {}; 
	this.options = options || {};
	this.cartFrame = null;
	this.psQueries = [];
	this.panel_instructs = null;
	this.panelContentContainer = null;
	this.restrict = { "read-only" : true };
	this.disabled = options.disabled || false;
	this.listQuery = null;
	this.registrationURL = options.registrationURL || "http://www.censusviewer.com/subscribe/";
};

MControlCart.prototype = new MControl;

/**
 *
 * @method init
 * @param {} manager
 */
MControlCart.prototype.init = function(manager) {
	this.manager = manager || Moonshadow.getManager();
};

MControlCart.prototype.cartDisabled = function(){
	return this.disabled || this.manager.getOption("cart.disabled") || this.isRestricted();
};

/**
*
* @method isRestricted
*/
MControlCart.prototype.isRestricted = function(){
	var ut = this.getManager().getOption("user_details.user_type");
	return this.restrict && this.restrict[ut];
};

/**
*
* @method toggleAddUniverse
* @param {Object} universe
*/
MControlCart.prototype.toggleAddUniverse = function(universe) {
	if(this.isRestricted())
		return false;
	switch(universe.purchase_state){
		case 0:
		case 1:
			this.addUniverse(universe);
			break;
		case 10:
		case 20:
		default:
			this.removeUniverse(universe);
	}
};

/**
 *
 * @method createGatewayPanel
 * @param content
 * @param panel_instructs
 */
MControlCart.prototype.createGatewayPanel = function(){
	var ce = Moonshadow.helpers.ce;
	if (!this.cartFrame){
		this.cartFrame = $(ce("iframe"))
			.attr({"id": "cartFrame"})
			.get(0);
		
		this.cartFrameWait();			
	}
	
	$(this.container)
		.empty()
		.append(
			$(ce("div"))
				.addClass("cartframe_container")
				.append(this.cartFrame),
			$(ce("input"))
				.addClass("cartframe_closebutton")
				.attr({
					"type": "button",
					"value": "Close"
				})
				.on("click", function(){
					MUILayoverPanel.close("cartpanel");
				})
		);
};

/**
 *
 * @method show
 */
MControlCart.prototype.show = function() {
	if(this.cartDisabled()){
		return false;
	}
	if(this.container == false) {
		this.container = document.createElement("div");
		this.container.className = "cart_container";
	}
	this.createGatewayPanel();
	this.cart();
};

/**
 *
 * @method openPanel
 */
MControlCart.prototype.openPanel = function(){
	if(this.cartDisabled()){
		return false;
	}
	var self = this;
	
	var _cartPanel = new MUILayoverPanel({
		"id": "cartpanel", 
		"content": this.container, 
		"title": "Checkout",
		"onClose": function(callback){
			self.hide.call(self, callback);
		},
		"animate": true
	});
	_cartPanel.open();
};

MControlCart.prototype.checkPrePurchased = function(){
	var dsControl = this.manager.getControl('datasources');
	//@TODO this only works with DS in position 1
	var dsId = dsControl.getByIndex(0).alias;
	return !!dsControl.getDatasourceAttribute(dsId, "pre_purchased");
};

/**
 *
 * @method hide
 * @param {} callback
 */
MControlCart.prototype.hide = function(callback){
	this.verifyPurchases(function(){
		Moonshadow.getManager().mapObservers.notify("purchases_verified");
	});
	this.cartFrameWait();
	callback && callback();
};

/**
 *
 * @method loadGatewayFrame
 * @param {} url
 */
MControlCart.prototype.loadGatewayFrame = function(url){
	this.cartFrame.src = url;
};

/**
 *
 * @method cartFrameWait
 */
MControlCart.prototype.cartFrameWait = function(){
	var waitURL = ["https://",
		this.getManager().getOption("cart.cart_host"),
		this.getManager().getOption("cart.cart_prefix"),
		this.getManager().getOption("cart.cart_path"),
		"?wait"
	].join("");
	if (this.cartFrame)
		this.cartFrame.src = waitURL;
};

/**
 *
 * @method getItemsLocal
 */
MControlCart.prototype.getItemsLocal = function(){
	var uc = this.manager.getUniverseControl();
	var returnObj = {};
	if (uc && uc.children){
		$.extend(returnObj, uc.children);
	}
	return returnObj;
}

MControlCart.prototype.getItemIds = function(univs){
	var ids = [];		
	for(var id in univs){
		var ps = univs[id].purchase_state;
		if((ps > 1 && ps < 30) && !univs[id].countsFetched){
			ids.push(id);
		}
	}
	return ids;
};

/**
 *
 * @method getRemovedItemsLocal
 */
MControlCart.prototype.getRemovedItemsLocal = function(){
	var u = this.manager.getUniverseControl();
	return u.getChildrenByAttribute("purchase_state", 1);
};

/**
 *
 * @method hasUniverses
 */
MControlCart.prototype.hasUniverses = function(){
	var u = this.manager.getUniverseControl();
	if (u && u.values && !$.isEmptyObject(u.values)){
		return true;
	}
	return false;
};

/**
 *
 * @method addPSQuery
 * @param {} int_name
 * @param {} ps
 */
MControlCart.prototype.addPSQuery = function(int_name, ps){
	this.psQueries.push({
		"query": "alter_universe",
		"int_name": int_name,
		"purchase_state": ps,
		"ds": Moonshadow.getManager().getDatasource(0).int_name
	});
};

/**
*
* @method addCountsQuery
* @param {} dsId
* @param {} universeId
*/
MControlCart.prototype.addCountsQuery = function(dsId, universeId){
	if(!this.listQuery){
		var dsControl = this.manager.getControl("datasources");
		this.listQuery = dsControl.getUniverseQuery(dsId, universeId);
		this.listQuery.name = [];
	}
	this.listQuery.name.push(universeId);
};

/**
 *
 * @method runPSQuery
 * @param {} callback
 */
MControlCart.prototype.runPSQuery = function(callback){
	if(!this.psQueries.length){
		if(callback)
			return callback();
		return false;
	}
	var ajax = new Moonshadow.Ajax();
	for(var i = 0, l = this.psQueries.length; i < l; ++i){
		ajax.addQuery(this.psQueries[i], function(){});
	}
	if(this.listQuery){
		var universeUIControl = this.manager.getUniverseControl();
		ajax.addQuery(this.listQuery, function(results){
			universeUIControl.assignCounts(results.universes);
		}, true);
	}
	ajax.execute(callback);
	this.psQueries = [];
};

/**
 *
 * @method getUniversesForCart
 * @param {} callback
 */
MControlCart.prototype.getUniversesForCart = function(callback){
	var univ_object = function(u){
		return {
			"geovis_id":u.int_name, 
			"upc":u.upc, 
			"cardinality":u.numberOfRecords(true),
			"title":u.ext_name,
			"description":u.description,
			"filter_comp":u.explainFilters(),
			"customername":self.manager.getOption("customer"),
			"appname":self.manager.getOption("app"),
			"username":self.manager.getOption("user"),
			"datasource":u.datasource,
			"purchasestate":u.purchase_state
		}
	};
	
	var self = this;
	this.prepUniversesForCart(function(obj){
		if(obj && obj.items && obj.items.length){
			var items = [];
			for(var i = 0, l = obj.items.length; i < l; ++i){
				items.push(univ_object(obj.items[i]));
			}
			obj.items = items;
		}
		callback(obj);
	});
};

/**
*
* @method prepUniversesForCart
* @param {} callback
*/
MControlCart.prototype.prepUniversesForCart = function(callback){
	var universes = this.getItemsLocal();
	var returnObject = {
		"items": [],
		"remove": []
	};
	
	this.listQuery = null;
	for(var id in universes){
		if(universes.hasOwnProperty(id)){
			var u = universes[id];
			var ps = u.purchase_state;
			if (ps == 1){
				returnObject.remove.push({"geovis_id": u.int_name});
				this.addPSQuery(u.int_name, 0);
				u.changePurchaseState(0, true);
			}
			if (ps == 10 || ps == 20){
				if(!u.countsFetched){
					this.addCountsQuery(u.datasource, u.int_name);
				}
				if(ps == 10){
					returnObject.items.push(u);
					this.addPSQuery(u.int_name, 20);
					u.changePurchaseState(20, true);
				}
			}
		}
	}
	this.runPSQuery(function(){
		callback(returnObject);
	});
};

/**
 *
 * @method onAjaxResponse
 */
MControlCart.prototype.onAjaxResponse = function(){
	
};

/**
 *
 * @method enableOutgoing
 * @param {} univ
 */
MControlCart.prototype.enableOutgoing = function(univ){
	if(univ.ui && univ.ui.infoButton)
		univ.ui.infoButton.disable(false);
};

/**
 *
 * @method checkCustomerContactInfo
 * @param {} callback
 */
MControlCart.prototype.checkCustomerContactInfo = function(callback){
	var self = this;
	
	var custMan;
	if(this.manager.shouldControlBeLoaded("MControlManagement"))
		custMan = self.manager.getControl('customer_management');
	
	if(!custMan || !custMan.options.contactInfo)
		return callback();

	var onSuccess = function(data) {
		if(data.result == "ok") {
			if(!data.customerId){
				//if customer has no locally stored remote gateway id (customernr) gather contact info
				return custMan.aiui.gatherCustomerContactInfo(null, function(closeGatherWindow){
					closeGatherWindow();
					callback();
				});
			}else{
				//if customer does have a locally stored remote gateway id, check '
				//if they have 2 valid addresses (billing, taxes)
				var parseContactInfo = function(addressData) {
					if(!addressData.addressInfo || addressData.addressInfo.length <= 1){
						//if not valid taxes and/or billing addresses, gather them
						custMan.aiui.gatherCustomerContactInfo(addressData, function(closeGatherWindow){
							closeGatherWindow();
							callback();
						});
					}else{
						self.hasValidContactInfo(addressData.addressInfo, function(valid){
							if(!valid){
								custMan.aiui.gatherCustomerContactInfo(addressData, function(closeGatherWindow){
									closeGatherWindow();
									callback();
								});
							}else{
								callback();
							}
						});
					}
				};
				new Moonshadow.Ajax({
					"url": "/customer/get/contactinfo",
					"type": "GET",
					"execute": true,
					"onSuccess": parseContactInfo
				});
			}
		}else{
			MUILayoverPanel.alert("Problem Detected: " + JSON.stringify(data));
		}
	};

	new Moonshadow.Ajax({
		"url": "/customer/get/gatewayid",
		"type": "GET",
		"execute": true,
		"onSuccess": onSuccess
	});
};

/**
 *
 * @method hasValidContactInfo
 * @param {} adresses
 * @param {} callback
 */
MControlCart.prototype.hasValidContactInfo = function(addresses, callback){
	var types = {"billing":1, "taxes":1};
	var requiredFields = {
		"contact_type":1,
		"first_name":1,
		"last_name":1,
		"street1":1,
		"city":1,
		"state":1,
		"zip":1,
		"country":1
	};
	
	var valid = true;
	for(var i = 0, l = addresses.length; i < l; ++i){
		if(!types[addresses[i].contact_type])
			continue;
		for(var j in requiredFields){
			if(requiredFields.hasOwnProperty(j)){
				if(addresses[i][j].length == 0){
					valid = false;
					break;
				}
			}
		}
	}
	callback(valid);
};

/**
 *
 * @method cart
 */
MControlCart.prototype.cart = function() {
	if (!this.hasUniverses()) 
		return false;
	var self = this;
	this.checkCustomerContactInfo(function(){
		self.openPanel();
		self.getUniversesForCart(function(obj){
			new Moonshadow.Ajax({
				"url": "/purchase/createorder",
				"type": "POST",
				"payload": obj,
				"execute": true,
				"wrapPost": false,
				"onSuccess": function(data){
					if(data.result == "ok") {
						if(data.cartpanelurl){
							return self.loadGatewayFrame(data.cartpanelurl);
						}
						if(data.refresh){
							return Moonshadow.getManager().logout();
						}
					}
					if(data.message){
						throw new Error(data.message);
					}
				}
			});
		});
	});
};

/**
 *
 * @method verifyPurchases
 * @param {} callback
 */
MControlCart.prototype.verifyPurchases = function(callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "purchase/verifypuchased",
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			if(data.result == "ok"){
				self.getManager().mapObservers.notify("puchasesverified");
			}
			
			callback && callback(true);
		},
		"onFail": function(data){
			if(data.result == "fail"){
				if(data.type == 402){
					self.getManager().mapObservers.notify("puchasesdisabled", data.message);
				}
			}
			callback && callback(false);
		}
	});
};

/**
*
* @method adjustPurchaseState
* @param {Object} universe
*/
MControlCart.prototype.adjustPurchaseState = function(universe){
	var univControl = this.manager.getControl("universecontrol");
	univControl.alterUniverse(
		universe.int_name, 
		universe.datasource, 
		{"purchase_state": universe.purchase_state}
	);
};

/**
*
* @method queuePurchaseStateAlteration
* @param {Object} universe
* @param {Function} alterationCallback 
*/
MControlCart.prototype.queuePurchaseStateAlteration = function(universe, alterationCallback){
	var univControl = this.manager.getControl("universecontrol");
	univControl.queueAlteration(
		universe.int_name, universe.datasource, 
		{"purchase_state": universe.purchase_state},
		alterationCallback
	);
};

/**
*
* @method runPurchaseStateAlterationQueue
* @param {Function} callback 
*/
MControlCart.prototype.runPurchaseStateAlterationQueue = function(callback){
	var univControl = this.manager.getControl("universecontrol");
	univControl.runAlterationQueue(null, callback);
};

/**
 *
 * @method addUniverse
 * @param {Object} universe
 */
MControlCart.prototype.addUniverse = function(universe, delayed) {
	universe.changePurchaseState(10);
	if(delayed){
		return this.queuePurchaseStateAlteration(universe);
	}
	this.adjustPurchaseState(universe);
};
	
/**
 *
 * @method removeUniverse
 * @param {Object} universe
 */
MControlCart.prototype.removeUniverse = function(universe, delayed) {
	universe.changePurchaseState(1);
	if(delayed){
		return this.queuePurchaseStateAlteration(universe);
	}
	this.adjustPurchaseState(universe);
};
 

/**
 *
 * @class MControlManagement
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlManagement(options) {
	this.name = "customer_management";
	this.manager = null;
	this.options = options || {};
	this.container = null;
	
	this.userManagementPanel;
};

MControlManagement.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	init: function(manager) {
		this.manager = manager;
		this.container = document.createElement("div");
		this.container.className = "management_container"
		var control = this;
		this.buildAddressInfo();
		this.buildUserManagementUI(function(){
			control.ui.setAllClean();
			control.ui.usermanagement.makeUserList();
		});
	},
	/**
	 *
	 * @method buildAddressInfo
	 */
	buildAddressInfo: function(){
		var control = this;
		this.aiui = {
			"all_customer_fields": ["firstname","lastname","street1","street2","city","state","zip","country","phone1","phone2","fax"],
			"required_customer_fields": ["firstname","lastname","street1","city","state","zip","country"],
			/**
			 *
			 * @method gatherCustomerContactInfo
			 * @param {} addressData
			 * @param {} callback
			 */
			"gatherCustomerContactInfo": function(addressData, callback){
				if(!addressData ||  addressData.length <= 1){
					new Moonshadow.Ajax({
						"url": "/customer/get/contactinfo",
						"type": "GET",
						"execute": true,
						"onSuccess": function(data){
							control.aiui.buildAddressInfoUI(data, callback);
						}
					});
				}else{
					control.aiui.buildAddressInfoUI(addressData, callback);
				}				
			},
			/**
			 *
			 * @method addressField
			 * @param {} name
			 * @param {} value
			 * @param {} required
			 */
			"addressField": function(name, value, required){
				var fld = document.createElement("input");
				fld.type = "text";
				fld.className = "contact_address_field";
				required && (fld.className += " required");
				fld.name = name;
				value && (fld.value = value);
				return fld;
			},
			/**
			 *
			 * @method areaSelectField
			 * @param {} areaslist
			 * @param {} selected
			 * @param {} name 
			 * @param {} required
			 */
			"areaSelectField": function(areaslist, selected, name, required){
				var areasSelect = document.createElement("select");
				areasSelect.name = name;
				areasSelect.className = "contact_address_field";
				required && (areasSelect.className += " required");
				var areasSelectOpt = document.createElement("option");
				areasSelectOpt.value = "";
				areasSelectOpt.appendChild(document.createTextNode("Choose "+Moonshadow.helpers.capitalize(name)));
				areasSelect.appendChild(areasSelectOpt);
				for(var i = 0, l = areaslist.length; i < l; ++i){
					var areasSelectOpt = document.createElement("option");
					areasSelectOpt.value = areaslist[i][name+"Abbr"];
					areasSelectOpt.appendChild(document.createTextNode(areaslist[i][name+"Name"]));
					if(selected && selected == areaslist[i][name+"Abbr"])
						areasSelectOpt.selected = true;
					areasSelect.appendChild(areasSelectOpt);
				}
				return areasSelect;
			},
			/**
			 *
			 * @method buildAddressInfoUI
			 * @param {} data
			 * @param {} callback
			 */
			"buildAddressInfoUI": function(data, callback) {
				if(data.result == "ok") {
					var onSuccess = function(stateslistdata) {
						if(stateslistdata.result == "ok") {
							var customeraddresses = {};
							if(data.addressInfo && data.addressInfo.length){
								for(var i = 0, l = data.addressInfo.length; i < l; ++i){
									customeraddresses[data.addressInfo[i].contact_type] = data.addressInfo[i];
								}
							}
							
							var billingSameAsTaxes = true;
							if(customeraddresses.taxes && customeraddresses.billing){
								for(var i = 0, l = control.aiui.all_customer_fields.length; i < l; ++i){
									if(customeraddresses.taxes[control.aiui.all_customer_fields[i]] != customeraddresses.billing[control.aiui.all_customer_fields[i]])
										billingSameAsTaxes = false;
								}
							}else{
								billingSameAsTaxes = false;
							}
							
							var allTypes = ["billing", "taxes"];
							var addressCont = document.createElement("div");
							addressCont.className = "customer_address_panel";
							for(var t = 0, ll = allTypes.length; t < ll; ++t){
								var addressTypeCont = document.createElement("div");
								addressTypeCont.className = "customer_address_type_panel "+allTypes[t];
								var addressTypeLabel = document.createElement("span");
								addressTypeLabel.appendChild(document.createTextNode(
									Moonshadow.helpers.capitalize(allTypes[t]) + " Address"
								));
								addressTypeCont.appendChild(addressTypeLabel);
								
								if(allTypes[t] == "taxes"){
									
									var sameAsBillingLabel = document.createElement("p");
									sameAsBillingLabel.className = "same_as_billing";
									sameAsBillingLabel.appendChild(document.createTextNode("Same as billing: "));
									
									var sameAsBilling = document.createElement("input");
									sameAsBilling.type = "checkbox";
									sameAsBilling.name = "sameAsBilling";
									
									$(sameAsBilling).click({"control":control},function(e){
										e.data.control.aiui.useBillingForTaxes.call(this);
									});
									
									sameAsBillingLabel.appendChild(sameAsBilling);
									addressTypeLabel.appendChild(sameAsBillingLabel);
								}
								
								for(var i = 0, l = control.aiui.all_customer_fields.length; i < l; ++i){
									var addressFieldLabel = document.createElement("label");
									addressFieldLabel.appendChild(document.createTextNode(
										Moonshadow.helpers.capitalize(control.aiui.all_customer_fields[i].replace("_"," ")) + ": "
									));
									
									var fieldRequired = false;
									if($.inArray(control.aiui.all_customer_fields[i], control.aiui.required_customer_fields) > -1){
										var reqField = document.createElement("p");
										reqField.appendChild(document.createTextNode("*"));
										addressFieldLabel.appendChild(reqField);
										fieldRequired = true;
									}
									
									if(control.aiui.all_customer_fields[i] == "state"){
										addressFieldLabel.appendChild(control.aiui.areaSelectField(
											stateslistdata.stateslist, 
											(customeraddresses[allTypes[t]] && customeraddresses[allTypes[t]][control.aiui.all_customer_fields[i]]), 
											"state",
											fieldRequired
										));
									}else if(control.aiui.all_customer_fields[i] == "country"){
										addressFieldLabel.appendChild(control.aiui.areaSelectField(
											stateslistdata.countrylist, 
											(customeraddresses[allTypes[t]] && customeraddresses[allTypes[t]][control.aiui.all_customer_fields[i]]), 
											"country",
											fieldRequired
										));
									}else{
										addressFieldLabel.appendChild(control.aiui.addressField(
												control.aiui.all_customer_fields[i],
												(customeraddresses[allTypes[t]] && customeraddresses[allTypes[t]][control.aiui.all_customer_fields[i]]),
												fieldRequired
										));
									}
									addressTypeCont.appendChild(addressFieldLabel);
								}
								addressCont.appendChild(addressTypeCont);
							}
							var clear = document.createElement("div");
							clear.className = "clear";
							addressCont.appendChild(clear);
							
							var feedback = document.createElement("div");
							feedback.className = "feedback";
							addressCont.appendChild(feedback);
							
							var spinner = document.createElement("div");
							spinner.className = "spinner hide";
							addressCont.appendChild(spinner);
							
							var saveButton = document.createElement("input");
							saveButton.type = "button";
							saveButton.value = "Save";
							addressCont.appendChild(saveButton);
							
							var clickData = {
								"control":control
							};
							if(callback)
								clickData.callback = callback;

							$(saveButton).click(clickData, function(e){
								var dataFields = e.data.control.aiui.verifyCustomerContactInfo();
								if(dataFields){
									$(".customer_address_panel .spinner").removeClass("hide");
									$(".customer_address_panel input[type='button']").attr("disabled","disabled");
									e.data.control.aiui.saveCustomerContactInfo(dataFields, e.data.callback);
								}
							});
							
							var cancelButton = document.createElement("input");
							cancelButton.type = "button";
							cancelButton.value = "Cancel";
							$(cancelButton).click(function(){
								MUILayoverPanel.close("customer_address_panel_cont");
							});
							addressCont.appendChild(cancelButton);
						
							var _addressCont = new MUILayoverPanel({
								"id": "customer_address_panel_cont",
								"content": addressCont,
								"title": "Address Info",
								"onOpen": function onOpen(){
									if(billingSameAsTaxes && sameAsBilling){
										sameAsBilling.checked = true;
										control.aiui.useBillingForTaxes.call(sameAsBilling);
									}
								}
							});
							_addressCont.open();

						}
					}
					
					new Moonshadow.Ajax({
						"url": "/purchase/get/areaselectlists",
						"type": "GET",
						"execute": true,
						"onSuccess": onSuccess
					});
				}else{
					MUILayoverPanel.alert("Problem Detected: " + JSON.stringify(data));
				}
			}, 
			/**
			 *
			 * @method useBillingForTaxes
			 */
			"useBillingForTaxes": function(){
				var taxFields = $(".customer_address_type_panel.taxes input[type='text'], .customer_address_type_panel.taxes select");
				if(this.checked){
					$(taxFields).removeClass("missing").attr("disabled","disabled");
				}else{
					$(taxFields).removeAttr("disabled");
				}
			},
			/**
			 *
			 * @method verifyCustomerContactInfo
			 */
			"verifyCustomerContactInfo": function(){
				var valid = true;
				$(".feedback").empty();
				$(".customer_address_type_panel.billing .required").removeClass("missing").each(function(index, field){
					if(field.value.length == 0){
						$(field).addClass("missing");
						valid = false;
					}
				});
				if(!$(".customer_address_type_panel input[name='sameAsBilling']")[0].checked){
					$(".customer_address_type_panel.taxes .required").removeClass("missing").each(function(index, field){
						if(field.value.length == 0){
							$(field).addClass("missing");
							valid = false;
						}
					});
				}			
				if(!valid){
					$(".feedback").append("Please supply data for the required fields.");
					return false;
				}
				
				var addresses = [];
				var billingAddress = {
					contact_type: "billing"
				};
				var taxesAddress = {
					contact_type: "taxes"
				};
				$(".customer_address_type_panel.billing input, .customer_address_type_panel.billing select").each(function(index, field){
					if($.inArray(field.name, control.aiui.all_customer_fields) > -1){
						billingAddress[field.name] = field.value;
					}
				});
				if($(".customer_address_type_panel input[name='sameAsBilling']")[0].checked){
					taxesAddress = $.extend({}, billingAddress);
					taxesAddress.contact_type = "taxes";
				}else{
					$(".customer_address_type_panel.taxes input, .customer_address_type_panel.taxes select").each(function(index, field){
						if($.inArray(field.name, control.aiui.all_customer_fields) > -1){
							taxesAddress[field.name] = field.value;
						}
					});
				}
				addresses.push(billingAddress, taxesAddress);
				return addresses;
			},
			/**
			 *
			 * @method saveCustomerContactInfo
			 * @param {} contact_info
			 * @param {} callback
			 */
			"saveCustomerContactInfo": function(contact_info, callback){
				new Moonshadow.Ajax({
					"url": "/customer/set/contactinfo",
					"execute": true,
					"wrapPost": true,
					"payload": contact_info,
					"onSuccess": function(){
						if(callback){
							callback(function(){
								MUILayoverPanel.close("customer_address_panel_cont");
							});
						}else{
							MUILayoverPanel.close("customer_address_panel_cont");
						}
					}
				});
			}
		};
	},
	/**
	 *
	 * @method buildUserManagementUI
	 * @param {} callback
	 */
	buildUserManagementUI: function(callback){
		var control = this;
		this.ui = {
			"tabIndex": 1,
			"initUI": function(){
				control.ui.usermanagement.viewActive();
			},
			"refreshControls": function(){
				control.ui.usermanagement.refreshControls();
			},
			"cleanUp": function(){
				control.ui.usermanagement.cleanUp();
			},
			"setAllClean": function(){
				control.ui.dirty = {
					"usermanagement": {}
				}
			},
			"dirtyMessage": "You have unsaved changes. Click OK to discard changes or Cancel to return.",
			"noneDirty": function(callback){
				
				var noneDirty = true;
				var dirty_list = control.ui.dirty;
				for (var i in dirty_list){
					if(dirty_list.hasOwnProperty(i)){
						if(Moonshadow.helpers.objCount(dirty_list[i]) > 0){
							noneDirty = false;
							break;
						}
					}
				}
				if(!noneDirty){
					return MUILayoverPanel.confirm({
						"message": control.ui.dirtyMessage,
						"callback": function(res, id, hide){
							if(res){
								control.ui.setAllClean();
							}
							hide();
							callback(res);
						}
					});
				}
				callback(noneDirty);
			},
			"sortOptions": function(target, button, sort_by, sortDir){
				var sort = "a_z";
				if($(button).hasClass("a_z")){
					sort = "z_a";
				}
				if($(button).hasClass("z_a")){
					sort = "a_z";
				}
				if(sortDir)
					sort = sortDir;
				
				$(".a_z, .z_a").removeClass("a_z z_a");
				var sprite = sort == "a_z" ? "sprite-expander_down" : "sprite-expander_up";
				$(button).addClass(sort);
				
				$(".disclosureTriangle", button)
					.removeClass("sprite-expander_down sprite-expander_up")
					.addClass(sprite);
				
				target.sortElements(function(a, b){
					var A = $("."+sort_by, a).text().toLowerCase();
					var B = $("."+sort_by, b).text().toLowerCase();
					if(sort == "a_z"){
						if(A > B)
							return 1;
						if(A < B)
							return -1;
						return 0;
					}else{
						if(A > B)
							return -1;
						if(A < B)
							return 1;
						return 0;
					}
				});
			},
			"usermanagement": {
				"sortUsers": function(target, button, sortDir){
					control.ui.sortOptions(target, button, button && button.id, sortDir);
					var allOpenEditPanels = $(".user_edit, .user_collection_list");
					if(allOpenEditPanels.length > 0){
						for(var i = 0, l = target.length; i < l; ++i){
							if($(target[i]).hasClass("edit_open")){
								$(target[i]).after($("input[name='"+$(".username",target[i]).text()+"']",allOpenEditPanels).parent());							
							}
						}
					}	
				},
				"refreshSort": function(){
					var sortOn = $(".a_z, .z_a")[0];
					var sortDir = "a_z";
					if($(sortOn).hasClass("z_a")){
						sortDir = "z_a";
					}
					control.ui.usermanagement.sortUsers($(".usermanagement_list .content .user_item"), $(".a_z, .z_a")[0], sortDir);
				},
				"cleanUp": function(){
					if($(".add_user").length > 0){
						$(".edit_open").remove();
						$(".add_user").remove();
					}
					$(".collape_all_button", control.ui.usermanagement.userList).remove();
					$(".a_z, .z_a").removeClass("a_z z_a sprite-expander_down sprite-expander_up");
					$(".inactive_users_button").removeClass("active_button").attr("title", "View Inactive Users");
				},
				"noneDirty": function(callback, message){
					var noneDirty = true;
					if(Moonshadow.helpers.objCount(control.ui.dirty.usermanagement) > 0){
						noneDirty = false;
					}
					if(!noneDirty){
						return MUILayoverPanel.confirm({
							"message": (message || control.ui.dirtyMessage),
							"callback": function(res, id, hide){
								if(res){
									control.ui.dirty.usermanagement = {};
								}
								hide();
								callback(res);
							}
						});
					}
					callback(noneDirty);
				},
				"closeEditUserPanel": function(id, target){
					
					var self = this;
					var close = function(){
						$(target).removeClass("edit_open");
						$("#"+id).remove();
						delete self.pointers[id];
						delete control.ui.dirty.usermanagement[id];
						control.ui.usermanagement.hideCollapeAllButton();
					};
					
					if(control.ui.dirty.usermanagement[id]){
						MUILayoverPanel.confirm({
							"message": control.ui.dirtyMessage,
							"callback": function(res, id, hide){
								if(res){
									close();
								}
								hide();
							}
						});
					}else{
						close();
					}

				},
				"closeAllEditUserPanels": function(callback){
					control.ui.usermanagement.noneDirty(function(res){
						if(!res){
							return callback(false);
						}
						$(".user_edit, .user_collection_list").remove();
						$(".edit_open").removeClass("edit_open");
						callback(true);
					});
				},
				"makeUserList": function(){
					var userList = document.createElement("div");
					userList.className = "usermanagement_list";
					control.container.appendChild(userList);
					
					var managementButton = document.createElement("div");
					managementButton.className = "management_buttons";
					userList.appendChild(managementButton);

					var viewInactive = document.createElement("div");
					viewInactive.className = "inactive_users_button clickable management_button sprite-viewInactiveUsers";
					viewInactive.title = "View Inactive Users";
					managementButton.appendChild(viewInactive);
					
					var addUser = document.createElement("div");
					addUser.className = "add_user_button clickable management_button sprite-addUser";
					addUser.title = "Add User";
					managementButton.appendChild(addUser);
					
					var userListHeader = document.createElement("div");
					userListHeader.className = "header";
					userListHeader.appendChild(document.createTextNode("User Management"));
					userList.appendChild(userListHeader);
					
					var user_item_header = document.createElement("div");
					user_item_header.className = "user_item_header";
			
					// name sorter
					var sortercontainer1 = document.createElement("div");
					sortercontainer1.className = "clickable user_item_sorter user_item_sorter_size user_item_sorter_border";
					sortercontainer1.id = "name";
					
					var disc1 = document.createElement("span");
					disc1.className = "disclosureTriangle";
					sortercontainer1.appendChild(disc1);
					
					var nameLabel = document.createElement("label");
					nameLabel.appendChild(document.createTextNode("Name"));
					nameLabel.className = "clickable";
					sortercontainer1.appendChild(nameLabel);
					user_item_header.appendChild(sortercontainer1);

					// username sorter
					var sortercontainer2 = document.createElement("div");
					sortercontainer2.className = "clickable user_item_sorter user_item_sorter_size user_item_sorter_border";
					sortercontainer2.id = "username";					
				
					var disc2 = document.createElement("span");
					disc2.className = "disclosureTriangle";
					sortercontainer2.appendChild(disc2);
					
					var usernameLabel = document.createElement("label");
					usernameLabel.appendChild(document.createTextNode("Username"));
					usernameLabel.className = "clickable";
					sortercontainer2.appendChild(usernameLabel);
					user_item_header.appendChild(sortercontainer2);

					// type sorter
					var sortercontainer3 = document.createElement("div");
					sortercontainer3.id = "type";
					sortercontainer3.className = "user_item_sorter";

					var disc3 = document.createElement("span");
					disc3.className = "disclosureTriangle";
					sortercontainer3.appendChild(disc3);
					user_item_header.appendChild(sortercontainer3);
					
					var typeLabel = document.createElement("label");
					typeLabel.appendChild(document.createTextNode("Type"));
					typeLabel.className = "clickable type";
					sortercontainer3.appendChild(typeLabel);

					
					userList.appendChild(user_item_header);
					
					var userListContent = document.createElement("div");
					userListContent.className = "content";
					userList.appendChild(userListContent);

					control.ui.usermanagement.userList = userList;
				},
				"clearList": function(callback){
					control.ui.usermanagement.noneDirty(function(res){
						if(!res){
							return callback(false);
						}
						$(".content", control.ui.usermanagement.userList).empty();
						return callback(true);
					});
				},
				"refreshControls": function(){
					$(control.ui.usermanagement.nameSorter).addClass("a_z sprite-expander_down");
					$(".user_item_sorter").click({"sorter": control.ui.usermanagement.sortUsers}, function(e){
						// clear disclosures on all other sorters
						var sorters = $(".user_item_sorter");
						for(var i=0; i<sorters.length; i++) {
							var s = sorters[i];
							if(s.getAttribute("id") != this.getAttribute("id")) {
								var disc = $(s.getElementsByClassName("disclosureTriangle")[0]);
								disc.removeClass("sprite-expander_down sprite-expander_up");
							}
						}
						e.data.sorter($(".usermanagement_list .content .user_item"), this);
					});
					$(".inactive_users_button").click({"control":control}, function(e){
						var app_display = control.manager.getOption("app_display");
						if($(this).hasClass("active_button")){
							e.data.control.ui.usermanagement.viewActive();
							this.title = "View only users not having access to "+app_display;
							$(this).toggleClass("active_button");
						}else{
							e.data.control.ui.usermanagement.viewInactive();
							this.title = "View users with access to "+app_display;
							$(this).toggleClass("active_button");
						}
					});
					$(".add_user_button").click({"control":control},function(e){
						if($(".add_user").length == 0){
							var newUser = document.createElement("div");
							$(this).closest(".usermanagement_list").find(".header").after(newUser);
							e.data.control.ui.usermanagement.buildUserEditPanel(newUser,null,"edit_"+(new Date().getTime()));
						}
					});
				},
				"viewActive": function(){
					control.ui.usermanagement.clearList(function(res){
						res && control.ui.usermanagement.buildUserManagement(true);
					});
				},
				"viewInactive": function(){
					control.ui.usermanagement.clearList(function(res){
						res && control.ui.usermanagement.buildUserManagement(false);
					});
				},
				"buildUserManagement": function(access){
					var userListContent = $(".content", control.ui.usermanagement.userList);
					control.refreshUserLists(function(){
						var user_list = control.users || {};
						var message = "No active users.";
						if(access === false){
							user_list = control.inactive || {};
							message = "No inactive users.";
						}
						
						for(var i in user_list){
							userListContent.append(control.ui.usermanagement.buildUserItem(user_list[i]));
						}
						// sort by name by default
						var sorter = $(".user_item_sorter")[0];
						$(sorter.getElementsByClassName("disclosureTriangle")[0]).addClass("sprite-expander_down");
						control.ui.usermanagement.sortUsers($(".usermanagement_list .content .user_item"), sorter, "a_z");
						control.ui.usermanagement.hideCollapeAllButton();
						control.ui.usermanagement.emptyListItem(message);
					});
				},
				"makeEditField": function(title, field_name, field_value, type, disabled, container, onChange){
					var label = document.createElement("label");
					label.appendChild(document.createTextNode(title));
					var field = document.createElement("input");
					if(field_name)
						field.name = field_name;
					if(disabled){
						field.className = "disabled";
						field.disabled = true;
					}else{
						field.tabIndex = control.ui.tabIndex;
						++control.ui.tabIndex;
					}
					field.type = type;
					field.value = field_value;
					if(onChange)
						$(field).change({"target": container}, onChange);
					
					if(type == "checkbox"){
						field.value = "true";
						if(field_value === true)
							field.checked = true;
						label.className = "checkbox";
					}
					if(type == "password"){
						field.autocomplete = "off";
					}
					
					container.appendChild(label);
					container.appendChild(field);
				},
				"userInfoObject": function(){
					return {
						"firstname": null,
						"lastname": null,
						"email": null,
						"type": null,
						"username": null,
						"passwd": null,
						"access": false
					};
				},
				"buildEditPanel": function(id, className, hiddenElems, title, target, content, button){
					var editPanelHolder = document.createElement("div");
					editPanelHolder.className = className;
					editPanelHolder.id = id;
					
					for(var i in hiddenElems){
						if(hiddenElems.hasOwnProperty(i)){
							$(editPanelHolder).append(hiddenElems[i]);
						}
					}
					
					var editPanelOffset = document.createElement("div");
					editPanelOffset.className = "user_edit_offset";
					editPanelHolder.appendChild(editPanelOffset);
					
					var editPanelTitle = document.createElement("span");
					editPanelTitle.className = "title";
					editPanelTitle.appendChild(document.createTextNode(title));
					editPanelOffset.appendChild(editPanelTitle);
					
					var editPanelCloser = document.createElement("span");
					editPanelCloser.className = "edit_closer clickable";
					editPanelCloser.appendChild(document.createTextNode("X"));
					$(editPanelCloser).click({"control": control, "id": id, "target": target}, function(e){
						e.data.control.ui.usermanagement.closeEditUserPanel(e.data.id, e.data.target);
					});
					editPanelOffset.appendChild(editPanelCloser);

					if(button){
						var pointer = document.createElement("span");
						pointer.className = "pointer sprite-boxpointerup";
						$(pointer).click({"control": control, "id": id, "target": target}, function(e){
							e.data.control.ui.usermanagement.closeEditUserPanel(e.data.id, e.data.target);
						});
						editPanelOffset.appendChild(pointer);
						this.pointers[id] = {"pointer": pointer, "button": button};
					}
					
					content.className = "user_edit_content";
					editPanelOffset.appendChild(content);
					
					return editPanelHolder;
				},
				"pointers": {},
				"adjustPointers": function(){
					var p = this.pointers;
					for(var i in p){
						if(!p.hasOwnProperty(i))
							continue;
						if(p[i].button && p[i].pointer){
							var pointer_left = parseInt($(p[i].button).position().left, 10) - parseInt($(p[i].button).width() / 2, 10);
							p[i].pointer.style.left = pointer_left + "px";
						}
					}
				},
				"buildUserEditPanel": function(target, user, id, button){
					var user_info = control.ui.usermanagement.userInfoObject();
					var new_user = false;
					if(user && control.users && control.users[user]){
						user_info = control.users[user];
					}else{
						new_user = true;
					}
					
					//left
					var userEditPanelLeft = document.createElement("div");
					userEditPanelLeft.className = "user_edit_content_left";
					
					//first name
					control.ui.usermanagement.makeEditField("First Name:", "firstname", user_info.firstname, "text", false, userEditPanelLeft);
					
					//last name
					control.ui.usermanagement.makeEditField("Last Name:", "lastname", user_info.lastname, "text", false, userEditPanelLeft);
					
					//email
					control.ui.usermanagement.makeEditField("Email:", "email", user_info.email, "text", false, userEditPanelLeft, new_user && function(e){
						$("input[name='username']", $(e.data.target).parent()[0]).val(this.value);
					});
					
					//password
					control.ui.usermanagement.makeEditField("Password:", "passwd", (new_user ? "" : "********"), "password", false, userEditPanelLeft);
					
					//confirm password
					control.ui.usermanagement.makeEditField("Confirm Pass:", "cpasswd", (new_user ? "" : "********"), "password", false, userEditPanelLeft);
					
					var clear = document.createElement("div");
					clear.className = "clear";
					userEditPanelLeft.appendChild(clear);
					
					//right
					var userEditPanelRight = document.createElement("div");
					userEditPanelRight.className = "user_edit_content_right";
					
					//type select
					var type_label = document.createElement("label");
					type_label.appendChild(document.createTextNode("User Type:"));
					userEditPanelRight.appendChild(type_label);
					var type_select = document.createElement("select");
					type_select.name = "type";
					type_select.tabIndex = control.ui.tabIndex;
					++control.ui.tabIndex;
					var opt = document.createElement("option");
					opt.appendChild(document.createTextNode("Choose User Type"));
					opt.value = "";
					type_select.appendChild(opt);
					var all_types = ["canvasser","standard","read-only"];
					for(var i = 0, l = all_types.length; i < l; ++i){
						var opt = document.createElement("option");
						opt.value = all_types[i];
						opt.appendChild(document.createTextNode(Moonshadow.helpers.capitalize(all_types[i])));
						user_info.type == all_types[i] && (opt.selected = true);
						type_select.appendChild(opt);
					}
					userEditPanelRight.appendChild(type_select);
					
					//username (not editable)
					control.ui.usermanagement.makeEditField("Username:", "username", user_info.username, "text", true, userEditPanelRight);
					
					//created by (not editable)
					if(!new_user && user_info.createdBy)
						control.ui.usermanagement.makeEditField("Created By:", null, user_info.createdBy, "text", true, userEditPanelRight);
					
					if(new_user)
						user_info.access = true;
					
					//add to this app
					var app_display = control.manager.getOption("app_display");
					control.ui.usermanagement.makeEditField("Access to "+app_display+":", "access", user_info.access, "checkbox", false, userEditPanelRight);
					
					var save_button = document.createElement("input");
					save_button.type = "button";
					save_button.value = "Save";
					save_button.className = "save_user_details";
					save_button.disabled = true;
					save_button.tabIndex = control.ui.tabIndex;
					++control.ui.tabIndex;
					userEditPanelRight.appendChild(save_button);
					
					var clear = document.createElement("div");
					clear.className = "clear";
					userEditPanelRight.appendChild(clear);

					var userEditPanel = document.createElement("div");
					userEditPanel.appendChild(userEditPanelRight);
					userEditPanel.appendChild(userEditPanelLeft);
					
					var hiddenElems = {};
					
					if(!new_user){
						hiddenElems.sort_support = document.createElement("input");
						hiddenElems.sort_support.type = "hidden";
						hiddenElems.sort_support.name = user_info.username;
					}
					
					var className =  "user_edit";
					!user_info.username && (className += " add_user");
					
					var title = user_info.username ? "Edit User "+user_info.username : "New User";
					
					var userEditPanelHolder = control.ui.usermanagement.buildEditPanel(id, className, hiddenElems, title, target, userEditPanel, button);
					
					$("input, select",userEditPanel).on("change keypress", {
							"control": control, 
							"id":id, 
							"save_button": save_button
						},
						function(e){
							e.data.save_button.disabled = false;
							e.data.control.ui.dirty.usermanagement[e.data.id] = true;
						}
					);
					
					$(save_button).click({
						"control": control, 
						"content": userEditPanel, 
						"target": target, 
						"id": id, 
						"new_user": new_user}, function(e){
						var control = e.data.control;
						var content = e.data.content;
						var details = control.ui.usermanagement.userInfoObject();
						for(var i in details){
							if(details.hasOwnProperty(i)){
								var field = $("input[name='"+i+"'], select[name='"+i+"']", content);
								if(field.length == 1){
									if(field[0].type == "checkbox" && field[0].checked == false){
										details[i] = "false";
									}else{
										details[i] = $(field).val();
									}
								}
							}
						}
						details.new_user = e.data.new_user;
						control.ui.usermanagement.validateFields(content, details, function(isValid){
							if(isValid){
								control.saveUserDetails(details, function(response){
									if(response && response.result == "ok"){
										delete control.ui.dirty.usermanagement[e.data.id];
										control.ui.usermanagement.closeEditUserPanel(e.data.id, e.data.target);
										var user_item = control.ui.usermanagement.buildUserItem(details);
										control.refreshUserLists(function(){
											if(details.access == "true"){
												if(e.data.new_user === true){
													$(e.data.target).remove();
													$(".content", control.ui.usermanagement.userList).append(user_item);
												}else{
													$(e.data.target).replaceWith(user_item);
												}
											}else{
												if(!e.data.new_user){
													if(control.users)
														delete control.users[details.username];
													control.ui.usermanagement.removeUserItem(e.data.target);
												}
											}
											control.ui.usermanagement.refreshSort();
										});
									}
								});
							}
						});
					});
					
					control.ui.usermanagement.collapeAllButton();
					$(target).addClass("edit_open");
					$(target).after(userEditPanelHolder);
					control.ui.usermanagement.adjustPointers();
				},
				"listUserCollection": function(target, user, id, button){
					var univControl = control.getUnivControl();
					if(univControl){
						var content = document.createElement("div");
						var hiddenElems = {};
						
						hiddenElems.sort_support = document.createElement("input");
						hiddenElems.sort_support.type = "hidden";
						hiddenElems.sort_support.name = user.username;
						
						for(var i in univControl.children){
							if(univControl.children.hasOwnProperty(i) && 
									univControl.children[i].read_users && 
									univControl.children[i].read_users.length){
								
								if($.inArray(user.username, univControl.children[i].read_users) == -1){
									continue;
								}

								var contentItem = document.createElement("div");
								contentItem.className = "assigned_universe";

								var clearAssignButton = document.createElement("div");
								clearAssignButton.className = "remove_assignment clickable";
								$(clearAssignButton).append("X");
								$(clearAssignButton).click({
										"contentItem": contentItem, 
										"caller": univControl.children[i],
										"username": user.username,
										"container": content,
										"listButton": button,
										"target": target,
										"id": id,
										"control": control
									}, function(e){
										if(e.data.control.manager.getOption("user") != e.data.caller.owner){
											return MUILayoverPanel.alert("This universe was assigned to you by the " +
												" user who created it and cannot be modified. To assign/unassign it, contact " +
												" the universe owner: " + e.data.caller.owner);
										}
										e.data.caller.removeReadOnlyUser(e.data.username, function(){
											$(e.data.contentItem).remove();
											if($(e.data.container).children().length == 0){
												e.data.listButton.disabled = true;
												e.data.control.ui.usermanagement.closeEditUserPanel(e.data.id, e.data.target);
											}
										}
									)
								});
								$(contentItem).append(clearAssignButton);
								
								var nameSpan = document.createElement("span");
								$(nameSpan).append(univControl.children[i].ext_name);
								$(contentItem).append(nameSpan);
								
								$(content).append(contentItem);
							}
						}
						var userCollectionListPanelHolder = control.ui.usermanagement.buildEditPanel(
							id, 
							"user_collection_list", 
							hiddenElems, 
							"List for "+user.username, 
							target, 
							content,
							button
						);
						
						control.ui.usermanagement.collapeAllButton();
						$(target).addClass("edit_open");
						$(target).after(userCollectionListPanelHolder);
						control.ui.usermanagement.adjustPointers();
					}
				},
				"collapeAllButton": function(){
					var target = $(".management_buttons")[0];
					if($(".collape_all_button", target).length == 0){
						var collape_all_button = document.createElement("span");
						collape_all_button.className = "clickable collape_all_button";
						collape_all_button.appendChild(document.createTextNode("-"));
						collape_all_button.title = "Close all edit panels";
						$(collape_all_button).click({"control": control},function(e){
							var self = this;
							e.data.control.ui.usermanagement.closeAllEditUserPanels(function(res){
								res && $(self).remove();
							});
						});
						$(target).prepend(collape_all_button);
					}
				},
				"hideCollapeAllButton": function(){
					if($(".user_edit, .user_collection_list").length == 0){
						$(".collape_all_button", control.ui.usermanagement.userList).remove();
					}
				},
				"removeUserItem": function(item){
					$(item).remove();
					$("input[name='"+$(".username",item).text()+"']").parent().remove();
							
					var message = "No active users.";
					if(!control.inactive){
						message = "No inactive users.";
					}
					
					control.ui.usermanagement.hideCollapeAllButton();
					control.ui.usermanagement.emptyListItem(message);
				},
				"emptyListItem": function(message){
					$(".empty_list").remove();
					var userListContent = $(".content", control.ui.usermanagement.userList);
					if(userListContent.children().length == 0){
						var empty_list = document.createElement("div");
						empty_list.className = "user_item empty_list";
						empty_list.appendChild(document.createTextNode(message || "Empty List"));
						userListContent.append(empty_list);
					}
				},
				"passwordsMatch": function(content){
					var pass = $("input[name='passwd']", content).val();
					var cpass = $("input[name='cpasswd']", content).val();
					return pass == cpass;
				},
				"validateFields": function(content, details, callback){
					var errors = [];
					var required = {
						"firstname": "First Name",
						"lastname": "Last Name",
						"email": "Email",
						"type":	"User Type",
						"passwd": "Password"
					};
					for(var i in required){
						if(required.hasOwnProperty(i)){
							if(!details[i] || details[i].length == 0){
								errors.push(required[i]);
							}
						}
					}
					if (details.email){
						if (details.email.search(/^[a-zA-Z]+([_\.-]?[a-zA-Z0-9]+)*@[a-zA-Z0-9]+([\.-]?[a-zA-Z0-9]+)*(\.[a-zA-Z]{2,4})+$/ig) == -1){
							errors.push("A valid email address");
						}
					}
					
					if(!control.ui.usermanagement.passwordsMatch(content)){
						errors.push("Password fields do not match");
					}
					
					var displayErrors = function(){
						if(errors.length > 0){
							var message = "Please provide the following information:";
							message += "<li>" + errors.join("</li><li>") + "</li>";
							MUILayoverPanel.alert(message);
						}else{
							callback(true);
						}
					}
					
					if(details.new_user && details.username){
						control.userExists(details.username, function(exists){
							if(exists){
								errors.push("Email address is already in use. Please try another.");
							}
							displayErrors();
						});
					}else{
						displayErrors();
					}
				},
				"updateListsAndListButtons": function(){
					var univControl = control.getUnivControl();
					if(univControl){
						var availButtons = $(".collection_list_button");
						$.each(availButtons, function(key, item){
							var panelHolder = $(item).parent().parent();
							var username = $(".username", $(panelHolder)).text();
							$(item).attr("disabled", true);
							for(var i in univControl.children){
								if(univControl.children.hasOwnProperty(i) && 
										univControl.children[i].read_users && 
										univControl.children[i].read_users.length){
									if($.inArray(username, univControl.children[i].read_users) > -1){
										$(item).attr("disabled", false);
									}
								}
							}
							if($(panelHolder).hasClass("edit_open")){
								if($("input[name='"+$(".username", panelHolder).text()+"']").parent().hasClass("user_collection_list")){
									$(item).click();
									if(!item.disabled){
										$(item).click()
									}
								}
							} 
						});
					}
				},
				"buildUserItem": function(user_data){
					var access = user_data.access;
					
					var edit_id = "edit_"+(user_data.username.replace(/\W/g,""))+(new Date().getTime());
					
					var userItem = document.createElement("div");
					userItem.className = "user_item";
					!access && (userItem.className += " inactive");
					
					var nameLabel = document.createElement("label");
					nameLabel.appendChild(document.createTextNode(user_data.lastname+", "+user_data.firstname));
					nameLabel.className = "name";
					userItem.appendChild(nameLabel);
					
					var usernameLabel = document.createElement("label");
					usernameLabel.appendChild(document.createTextNode(user_data.username));
					usernameLabel.className = "username";
					userItem.appendChild(usernameLabel);
					
					var typeLabel = document.createElement("label");
					typeLabel.appendChild(document.createTextNode(Moonshadow.helpers.capitalize(user_data.type)));
					typeLabel.className = "type";
					userItem.appendChild(typeLabel);

					if(control.canvassingEnabled()){
						var univControl = control.getUnivControl();
						
						var listsLabel = document.createElement("div");
						listsLabel.className = "edit_button";
						
						var listsButton = document.createElement("input");
						listsButton.type = "button";
						listsButton.value = "Lists";
						listsButton.className = "collection_list_button"; 
						listsButton.disabled = true;
						
						for(var i in univControl.children){
							if(univControl.children.hasOwnProperty(i) && 
									univControl.children[i].read_users && 
									univControl.children[i].read_users.length){
								if($.inArray(user_data.username, univControl.children[i].read_users) > -1){
									listsButton.disabled = false;
								}
							}
						}
						
						listsButton.tabIndex = control.ui.tabIndex;
						++control.ui.tabIndex;
						$(listsButton).click({
								"control": control,
								"target": userItem,
								"user": user_data,
								"id": edit_id
							},
							function(e){
								var button = this;
								var editPanel = $("#"+e.data.id);
								if(editPanel.length > 0){
									var opened = $(editPanel).hasClass("user_collection_list");
									e.data.control.ui.usermanagement.closeEditUserPanel(e.data.id, e.data.target);
									if(!opened){
										e.data.control.ui.usermanagement.listUserCollection(e.data.target, e.data.user, e.data.id, button);
									}
								}else{
									e.data.control.ui.usermanagement.listUserCollection(e.data.target, e.data.user, e.data.id, button);
								}
						});
						listsLabel.appendChild(listsButton);
						userItem.appendChild(listsLabel);
					}
					
					if(!access){
						var editLabel = document.createElement("div");
						editLabel.className = "edit_button";
						userItem.appendChild(editLabel);
						
						var activateLabel = document.createElement("span");
						activateLabel.className = "activate_user";
						
						var app_display = control.manager.getOption("app_display");
						activateLabel.appendChild(document.createTextNode("Access:"));
						var contTitle = "Give "+app_display+" access to user "+user_data.username;
						activateLabel.title = contTitle
						
						var activate = document.createElement("input");
						activate.tabIndex = control.ui.tabIndex;
						activate.title = contTitle;
						++control.ui.tabIndex;
						activate.type = "checkbox";
						$(activate).click({
							"control":control,
							"userItem": userItem, 
							"username": user_data.username
							}, function(e){
							if(this.checked){
								control.giveAccessToUser(e.data.username, function(response){
									e.data.control.refreshUserLists(function(){
										if(response && response.result == "ok"){
											if(control.inactive)
												delete control.inactive[e.data.username];
											control.ui.usermanagement.removeUserItem(e.data.userItem);
										}
									});
								});
							}
						});
						
						editLabel.appendChild(activateLabel);
						editLabel.appendChild(activate);
					}else{
						if(user_data.type != "administrator" && user_data.type != "superuser"){
							var editLabel = document.createElement("div");
							editLabel.className = "edit_button";
							userItem.appendChild(editLabel);
							
							var editButton = document.createElement("input");
							editButton.type = "button";
							editButton.value = "Edit";
							editButton.tabIndex = control.ui.tabIndex;
							++control.ui.tabIndex;
							$(editButton).click({
								"control": control, 
								"target": userItem, 
								"user": user_data.username, 
								"id": edit_id}, function(e){
								var button = this;
								e.data.control.getUserDetails(e.data.user, function(){
									e.data.control.refreshUserLists(function(){
										var editPanel = $("#"+e.data.id);
										if(editPanel.length > 0){
											var opened = $(editPanel).hasClass("user_edit");
											e.data.control.ui.usermanagement.closeEditUserPanel(e.data.id, e.data.target);
											if(!opened){
												e.data.control.ui.usermanagement.buildUserEditPanel(e.data.target, e.data.user, e.data.id, button);
											}
										}else{
											e.data.control.ui.usermanagement.buildUserEditPanel(e.data.target, e.data.user, e.data.id, button);
										}
									});
								});
							});
							editLabel.appendChild(editButton);
						}
					}
					return userItem;
				}
			}
		};
		callback();
	},
	canvassingEnabled: function(enable){
		return $.inArray('groundgame', this.getManager().getOption("app_addons")) > -1;
	},
	getUnivControl: function(){
		var control = false;
		if(this.getManager().shouldControlBeLoaded("MPanelContentFilterV3")) {
			var ds = this.getManager().getControl("filters").datasources["__universes"];
			if(ds && ds.filterables["__universes"]) {
				control = ds.filterables["__universes"];
			}
		}
		return control;
	},
	getUserDetails: function(username, callback){
		var control = this;
		new Moonshadow.Ajax({
			"url": "/management/lowend/user/getdetails/" + username,
			"type": "GET",
			"execute": true,
			"onSuccess": function(response){
				if(response && response.result == "ok"){
					if(!control.users)
						control.users = {};
					control.users[response.data.username] = response.data;
					callback(response.data);
				}
			}
		});
	},
	userExists: function(username, callback){
		new Moonshadow.Ajax({
			"url": "/user/exists/" + username,
			"type": "GET",
			"execute": true,
			"onSuccess": function(response){
				if(response && response.result == "ok"){
					callback(response.exists);
				}
			}
		});
	},
	saveUserDetails: function(details, callback){
		if(details.passwd && details.passwd == "********")
			delete details.passwd;
		new Moonshadow.Ajax({
			"url": "/management/lowend/user/update/" + details.username,
			"payload": details,
			"execute": true,
			"onSuccess": callback,
			"wrapPost": true
		});
	},
	giveAccessToUser: function(username, callback){
		new Moonshadow.Ajax({
			"url": "/management/lowend/user/access/" + username,
			"type": "GET",
			"execute": true,
			"onSuccess": callback
		});
	},
	show: function(){
		this.ui.initUI();
		var control = this;
		
		$(".content", this.container)
			.removeAttr("style")
		
		this.userManagementPanel = new MUILayoverPanel({
			"content": this.container,
			"title": "User Management",
			"animate": true,
			"resizeAlso": ".content",
			"fixed": false,
			"minWidth": 720,
			"displayLoading": true,
			"onResizing": function(){
				control.ui.usermanagement.adjustPointers();
			},
			"position": {
				"height": 300,
				"width": 720
			},
			"onClose": function(callback){
				control.hide(callback);
			}
		});
		
		if(this.canvassingEnabled()){
			this.userManagementPanel.set("docs", {
				"url": Moonshadow.gg_tutorials,
				"icon": "sprite-tutorial tut_icon",
				"title": "Ground Game Tutorials"
			});
		}
		this.userManagementPanel.open();
		
		this.ui.refreshControls();
	},
	hide: function(callback){
		var self = this;
		this.ui.noneDirty(function(res){
			if(res){
				self.ui.cleanUp();
				callback && callback();
			}
		});
	},
	refreshUserLists: function(callback){
		var control = this;
		this.users = null;
		this.inactive = null;
		var self = this;
		this.getCustomersUsers(function(data){
			for(var i = 0, l = data.length; i < l; ++i){
				if(data[i].access){
					if(!control.users)
						control.users = {};
					control.users[data[i].username] = data[i];
				}else{
					if(!control.inactive)
						control.inactive = {};
					control.inactive[data[i].username] = data[i];
				}
			}
			callback();
			self.userManagementPanel.loadIndicator(false);
		})
	},
	getCustomersUsers: function(callback){
		var caller = this;
		new Moonshadow.Ajax({
			"url": "/management/lowend/user/getlist",
			"type": "GET",
			"execute": true,
			"onSuccess": function(response){
				if(response && response.result == "ok" && response.data.length > 0){
					return callback(response.data);
				}
				callback([]);
			}
		});
	}
};
Moonshadow.helpers.extend(MControlManagement,MControl);

/**
 *
 * @class MControlMarkers
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlMarkers(options) {
	this.name = "markers";
	this.position = 7;
	this.manager = null;
	this.container = false;
	this.markerMap = {};
	this.tilesHidden = false;
	this.markersShowing = false;
	this.options = options || {};
	this.initLoad = false;

	if(isNaN(this.options.zoom_level)) {
		this.options.zoom_level = 18;
	}

	this.override = 0;

	this.listenOn = ["bounds", "filterchange", "colorchange", "colorbychange", "shapechanged"];
	this.disabled = false;
}

MControlMarkers.prototype = new MControl;

/**
 *
 * @method init
 * @param {} manager
 */
MControlMarkers.prototype.init = function(manager) {
	this.manager = manager;

	this.disabled = manager.getOption('disableMarkers', false);		

	if (!this.disabled) {
		this.addListeners();
	}
};

MControlMarkers.prototype.enable = function() {
	this.disabled = false;

	this.addListeners();
	this.addRemoveListeners(this.listenOn, "add");
	this.updateMarkers("filterchange");
};

MControlMarkers.prototype.disable = function() {
	this.disabled = true;

	this.removeListeners();
	this.addRemoveListeners(this.listenOn, "remove");
	this.clearMarkers();
	this.toggleTileLayer();
	this.closeInfoWindow();
};

MControlMarkers.prototype.addListeners = function() {
	this.manager.addMapObserver("zoom", this);
	this.manager.addMapObserver("colorbychange", this);
};

MControlMarkers.prototype.removeListeners = function() {
	this.manager.removeMapObserver("zoom", this);
	this.manager.removeMapObserver("colorbychange", this);
};

/**
 *
 * @method forceBoundsEvent
 */
MControlMarkers.prototype.forceBoundsEvent = function(){
	var ajax = new Moonshadow.Ajax();
	this.onAjaxEvent("bounds", {}, ajax);
	ajax.execute();
};

/**
 *
 * @method onAjaxEvent
 * @param {} event
 * @param {} data
 * @param {} ajax
 */
MControlMarkers.prototype.onAjaxEvent = function(event, data, ajax) {
	switch(event) {
		case "colorbychange":
			if(this.isAcceptableColorBy() == false) { 
				break;
			}
		case "zoom":
		case "bounds":
		case "colorchange":
		case "shapechanged":
		case "filterchange":
			if(this.override > 0 || this.isInZoomLevel()){
				this.updateMarkers(event, ajax);
			}
			break;
	}
};

MControlMarkers.prototype.updateMarkers = function(event, ajax) {
	var hadAjax = true;
	if (!ajax) {
		hadAjax = false;
		ajax = new Moonshadow.Ajax();
	}

	var caller = this;
	ajax.addQuery(this.getMarkerQuery(), function(data) {
		if (data.result == "ok") {
			caller.onMarkerData(data, event);
		}
	});

	if (!hadAjax) {
		ajax.execute();
	}
};

/**
 *
 * @method addRemoveListeners
 * @param {} listenOn
 * @param {} addRemove
 */
MControlMarkers.prototype.addRemoveListeners = function(listenOn, addRemove){
	for(var i = 0, l = listenOn.length; i < l; ++i){
		this.getManager()[addRemove+"AjaxEventListener"](listenOn[i], this);
	}
};

/**
 *
 * @method notify
 */
MControlMarkers.prototype.notify = function() {
	if((this.override > 0 || this.isInZoomLevel()) && this.isAcceptableColorBy()) {
		if (this.markersShowing == false) {
			this.addRemoveListeners(this.listenOn, "add");
			this.markersShowing = true;
			this.switchToMarkers();
		}
	} else {
		if(this.markersShowing == true) {
			this.addRemoveListeners(this.listenOn, "remove");
			this.markersShowing = false;
			this.switchToTiles();
		}
	}
};

/**
 *
 * @method toggleTileLayer
 * @param {} onOff
 */
MControlMarkers.prototype.toggleTileLayer = function(onOff) {
	var vis = !onOff ? !(this.override > 0 || this.isInZoomLevel()) : onOff;
	var baseLayer = this.getManager().getControl('layerBase');
	
	if (vis) {
		baseLayer.enable();
	} else {
		baseLayer.disable();
	}
};

/**
 *
 * @method markerIconURL
 * @param {} color
 * @param {} alpha
 * @param {} symbol
 */
MControlMarkers.prototype.markerIconURL = function(color,alpha,symbol) {
	var server;

	if(this.options.use_flatbread) {
		// @CLEANUP Is this still used? 2015-06-10
		server = Moonshadow.server;
	} else {
		server = Moonshadow.markers;
	}

	return server + "/marker/"+symbol+"/"+color+"/"+alpha;
};

/**
 *
 * @method isInZoomLevel
 */
MControlMarkers.prototype.isInZoomLevel = function() {
	var currentZoom = this.getManager().getAdapter().getZoom();
	if (currentZoom >= this.options.zoom_level - 1) {
		return true;
	}

	return false;
};

/**
 *
 * @method adjustOverride
 * @param {} delta
 */
MControlMarkers.prototype.adjustOverride = function(delta) {
	var prev = this.override;
	this.override += delta;

	if (this.override < 0) {
		this.override = 0;
	}

	if (this.override == 0 && prev > 0) {
		this.notify();
	} else if(this.override > 0 && prev == 0) {
		this.forceBoundsEvent();
		this.notify();
	}		
};

/**
 *
 * @method isAcceptableColorBy
 */
MControlMarkers.prototype.isAcceptableColorBy = function() {
	return true;
};

/**
 *
 * @method getMarkerQuery
 */
MControlMarkers.prototype.getMarkerQuery = function() {
	var manager = this.getManager();
	
	//var dsId = manager.getDatasource().int_name;
	var colorControl = manager.getControl('colorbycontrol');
	var dsId = colorControl.getActiveDsId();
	
	var filtersControl = manager.getControl('filterscontrol');
	var filters = filtersControl.filtersToJSON(dsId);
	
	if (!filters) {
		filters = {};
	}

	//Check if universe filter operation id selected
	var filterOp = filtersControl.getFilterOperator();
	if (filterOp){
		filters['universe_filter_op'] = filterOp;
	}
	
	var adapter = manager.getAdapter();
	var bounds = adapter.getBounds();
	var adapCont = adapter.getContainer();

	var obj = {
		"query": "get_points_in_rectangle",
		"qid": "get_points_in_rectangle",
		"max_points": 2000,
		"ds": dsId,
		"filter": filters,
		"surround_radius": 0,
		"lat_s": bounds.swLat,
		"lat_n": bounds.neLat,
		"long_w": bounds.swLon,
		"long_e": bounds.neLon,
		"display_area": {
			"x": $(adapCont).innerWidth(),
			"y": $(adapCont).innerHeight()
		}
	};
	return obj;
};

/**
 *
 * @method switchToTiles
 */
MControlMarkers.prototype.switchToTiles = function() {
	this.clearMarkers();
	this.toggleTileLayer();
	this.closeInfoWindow();
};

MControlMarkers.prototype.switchToMarkers = function() {
	this.toggleTileLayer();
	this.updateMarkers("filterchange");
};

MControlMarkers.prototype.clearMarkers = function() {
	this.getManager().getAdapter().clearAllMarkers(this.markerMap);
	this.markerMap = {};
};

MControlMarkers.prototype.closeInfoWindow = function() {
	var infoController = Moonshadow.getManager().getControl("markerinfo");
	infoController && infoController.closeInfoWindow();
};

/**
 *
	 * @method onMarkerData
 * @param {} data
 * @param {} event
 */
MControlMarkers.prototype.onMarkerData = function(data, event) {
	if (!this.markersShowing) {
		return;
	}

	var markerMap = this.markerMap;
	var infoControler = Moonshadow.getManager().getControl("markerinfo");
	var dt = new Date().getTime();
	var thisMap = Moonshadow.getManager().getAdapter().map;
	var adapter = this.getManager().getAdapter();
	
	for(var i in data.values){
		var arrayKey = data.values[i].lat+''+data.values[i].lon;
		if(!markerMap[arrayKey]){
			var marker_info = {
				"position": adapter.latLng(
					data.values[i].lat,
					data.values[i].lon
				),
				"map": thisMap
			};
			markerMap[arrayKey] = {
				"marker": adapter.getMarker(marker_info),
				"dt": dt
			};
			if (data.values[i].t && data.values[i].t > 0){
				if (this.markerMap[arrayKey].marker.lsnr)
					adapter.removeMarkerLsnr(this.markerMap[arrayKey].marker);
				this.markerMap[arrayKey].marker.lsnr = null;
			}else{
				this.markerMap[arrayKey].marker.lsnr = adapter.addMarkerLsnr(
					this.markerMap[arrayKey],
					function(e) {
						infoControler && infoControler.getPointInfo(this.markerAttribs);
					}
				);
			}
		}else{
			markerMap[arrayKey].dt = dt;
		}

		if (!markerMap[arrayKey].marker) {
			break;
		}
		
		var colorbycontrol = this.getManager().getControl('colorbycontrol');
		var colorByDsId = colorbycontrol.getActiveDsId();

		var symbol = data.values[i].symbol || "__default";
		var markerAttribs = {
			"c": data.values[i].c,
			"k": data.values[i].k,
			"e": data.values[i].e || null,
			"t": data.values[i].t || '0',
			"la": data.values[i].lat,
			"lo": data.values[i].lon,
			"ds": colorByDsId,
			"id": arrayKey,
			"sy": symbol
		};
		this.markerMap[arrayKey].marker.markerAttribs = markerAttribs;
		
		if (infoControler && infoControler.infoWindowOpen &&
			infoControler.infoWindow.markerId == arrayKey &&
			(event == "filterchange" || event == "colorbychange") ){
			infoControler.getPointInfo(markerAttribs);
		}

		var alpha = 0;
		if(markerAttribs.t > 0){
			alpha = ((Math.round(markerAttribs.t * 126) - 126) * -1);
		}
		adapter.setMarkerIcon(this.markerMap[arrayKey], this.markerIconURL(data.values[i].c, alpha, symbol), 10, 34);
	}
	for(var i in markerMap){
		if(markerMap[i].dt != dt){
			if (!adapter.clearMarker(markerMap[i])) continue;
			if(infoControler && infoControler.infoWindow.markerId == i){
				infoControler.closeInfoWindow();
			}

			delete markerMap[i];
		}
	}
};

/**
 *
 * @method setCanvasserMarkers
 * @param {} markerInfo
 */
MControlMarkers.prototype.setCanvasserMarkers = function(markerInfo){
	var adapter = this.getManager().getAdapter();
	var canvasserMarkersArray = [];
	for(var i = 0, l = markerInfo.length; i < l; ++i){
		var cm = adapter.getMarker({
			"icon": this.markerIconURL(
				markerInfo[i].color, 1, "canvasser"
			),
			"iconDim": [20, 34],
			"iconAnchor": [10, 34],
			"position": adapter.latLng(markerInfo[i].lat, markerInfo[i].lon),
			"markerType": "canvasser",
			"markerId": "can_" + new Date().getTime()
		});
		canvasserMarkersArray.push(cm);
		adapter.setMarkerIcon({"marker": cm}, cm.icon, 10, 34);
	}
	return canvasserMarkersArray;
};

/**
 *
 * @method hideCanvasserMarkers
 * @param {} markerArray
 */
MControlMarkers.prototype.hideCanvasserMarkers = function(markerArray){
		var adapter = this.getManager().getAdapter();
		for(var i = 0, l = markerArray.length; i < l; ++i){
			adapter.clearMarker({"marker": markerArray[i]});
		}
		markerArray = [];
};

MControlMarkers.prototype.getMarkerById = function(markerId) {
	if(this.markerMap[markerId] && this.markerMap[markerId].marker) {
		return this.markerMap[markerId].marker;
	}
};

/**
 *
 * @class MControlCanvassingMarkers
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlCanvassingMarkers(options) {
	this.name = "canvassingmarkers";
	this.canvasserMarkers = {};
	this.houseMarkers = {};
	this.fieldsQueries = [];
	this.fieldsObj = {};
	this.refreshInterval = 60000;
	this.resultsProcessed = 0;
	this.canvassersInfo = [];
	this.housesInfo = [];
	this.canvassersShowing = true;
	this.housesShowing = true;
}

MControlCanvassingMarkers.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	init: function(manager){
		this.manager = manager;
	},
	isValid: function(surveyId){
		var surveyControl = this.getManager().getControl("surveys");
		if(!surveyControl){
			return false;
		}
		var canvasserFields = surveyControl.getMetaFieldsByType("canvasser", surveyId);
		if(!canvasserFields.length){
			return false;
		}
		return true;
	},
	control: function(surveyId){
		if(this.isValid(surveyId)){
			return this;
		}
	},
	/**
	 *
	 * @method onAjaxEvent
	 * @param {} event
	 * @param {} data
	 * @param {} ajax
	 */
	onAjaxEvent: function(event, data, ajax) {
		if(this.markersAreShowing()){
			if(this.fieldsQueries.length){
				this.getMarkerInfoAjax(ajax);
			}
		}
	},
	/**
	 *
	 * @method onAjaxResponse
	 * @param {} data
	 */
	onAjaxResponse: function(data) {
		var self = this;
		var filterControl = this.getManager().getControl("filters");
		var fieldOrder = {};
		var canvasserObj = {};
		var houseObj = {};
		var surveyId = data.qid;

		if (!data || data.result != "ok") {
			throw new Error(data.message || data.error ||
							"MControlCanvassingMarkers:onAjaxResponse");
			return false;
		}

		if (!data.values || !data.values.length) {
			return false;
		}
		
		if(!fieldOrder[surveyId]) {
			fieldOrder[surveyId] = [];
		}
		
		for (var i = 0, l = data.return_fields.length; i < l; ++i) {
			for (var p in this.fieldsObj[surveyId]) {
				if (this.fieldsObj[surveyId].hasOwnProperty(p) &&
					this.fieldsObj[surveyId][p] == data.return_fields[i]) {
					fieldOrder[surveyId].push(p);
				}
			}
		}
			
		if (fieldOrder[surveyId].length &&	this.fieldsObj.hasOwnProperty(surveyId)) {
			for(var i = 0, l = data.values.length; i < l; ++i) {
				if (!data.values[i].group_value.length)
					continue;
				
				var setVals = data.values[i].values;
				
				canvasserObj = {
					"canvasser": data.values[i].group_value,
					"pointInfo": {
						"addresses_visited": data.values[i].record_number,
						"last_ts": data.values[i].last,
						"first_ts": data.values[i].first
					}
				};

				for(var j = 0, ll = setVals.length; j < ll; ++j) {
					
					var setValItem = setVals[j];
					var iLat;
					var iLon;
					var houseLat;
					var houseLon;
					
					for(var k = 0, lll = setValItem.length; k < lll; ++k) {
						switch(fieldOrder[surveyId][k])	{
							case 'ilat':
								iLat = setValItem[k];
								break;
							case 'ilon':
								iLon = setValItem[k];
								break;
							case 'visited':
								var ts = parseInt(setValItem[k],10);
								if(!isNaN(ts)){
									canvasserObj.visited = ts;
								}
								break;
							case 'timestamp':
								var ts = parseInt(setValItem[k],10);
								if(!isNaN(ts)){
									canvasserObj.timestamp = ts;
								}
								break;
							case '__latitude':
								houseLat = setValItem[k];
								break;
							case '__longitude':
								houseLon = setValItem[k];
								break;
	
							default: break;
						}
						canvasserObj.pointInfo[fieldOrder[surveyId][k]] = setValItem[k];
					}
					
					// we shouldn't show canvasser icons with unknown lat & long
					if ((iLat === "") || (iLon === "")) {
						continue;
					}

					var latLon = Moonshadow.helpers.demercator(iLat, iLon);
					canvasserObj.lat = latLon[0];
					canvasserObj.lon = latLon[1];

					var dsId = this.getManager().getControl('colorbycontrol').getActiveDsId();

					canvasserObj.color = filterControl.getFilterColor(
						dsId,
						this.fieldsObj[surveyId]["Canvassers"],
						data.values[i].group_value
					) || Moonshadow.helpers.rw5(canvasserObj.canvasser);
					
					this.canvassersInfo.push($.extend({},canvasserObj));
					
					var houseLatLon = Moonshadow.helpers.demercator(houseLat, houseLon);
					canvasserObj.lat = houseLatLon[0];
					canvasserObj.lon = houseLatLon[1];
					this.housesInfo.push($.extend({},canvasserObj));
				}
			}
			
			++this.resultsProcessed;
			
			if(this.resultsProcessed === this.fieldsQueries.length) {
				if (this.canvassersShowing) 
					setCanvasserMarkers();
				if (this.housesShowing) 
					setHouseMarkers();
			}
		}

		function setCanvasserMarkers() {
			var canvassers = self.canvassersInfo,
				adapter = self.getManager().getAdapter(),
				markerControl = self.getManager().getControl("markers"),
				activeCanv = $(canvassers).map(function(index, item){
					return item.canvasser;
				}),
				i, l, canvasser, timestamp,	visited, position, color,
				pointInfo, cm;

			// clear out canvassers no longer active (i.e. filtered out)
			for (i in self.canvasserMarkers) {

				if(!self.canvasserMarkers.hasOwnProperty(i))
					continue;
				if($.inArray(i, activeCanv) == -1){
					adapter.closeInfoWindow(
						self.canvasserMarkers[i].infoBox,
						adapter.map
					);
					adapter.clearMarker({"marker": self.canvasserMarkers[i]});
					delete self.canvasserMarkers[i];
				}
			}

			// add markers
			for(i = 0, l = canvassers.length; i < l; ++i) {			
				canvasser = canvassers[i].canvasser;
				timestamp = canvassers[i].timestamp;
				visited = canvassers[i].visited;
				position = adapter.latLng(canvassers[i].lat, canvassers[i].lon);
				color = canvassers[i].color;
				pointInfo = canvassers[i].pointInfo;
								
				if (self.canvasserMarkers[canvasser]) {
					cm = self.canvasserMarkers[canvasser];

					if (cm.timestamp == timestamp &&
					   cm.visited == visited &&
					   cm.position.lat() == position.lat() &&
					   cm.position.lng() == position.lng() &&
					   cm.color == color)
						continue;
					
					if(visited < cm.visited)
						continue;
					
					cm.timestamp = timestamp;
					cm.visited = visited;
					cm.position = position;
					cm.color = color;
					cm.pointInfo = pointInfo;
					cm.setLocation(position);
					cm.setOptions({"icon": markerControl.markerIconURL(
						color, 1, "canvasser"
					)});

					if(cm.infoBox && cm.infoBox.getVisible()){
						self.markerInfoBox.apply(cm);
					}
				} else {
					cm = adapter.getMarker({
						"icon": markerControl.markerIconURL(
							color, 1, "canvasser"
						),
						"iconDim": [20, 34],
						"iconAnchor": [10, 34],
						"position": position,
						"markerType": "canvasser",
						"markerId": "can_" + new Date().getTime()
					});
					
					var m = {
						"marker": cm
					};
					
					m.marker.canvasser = canvasser;
					m.marker.position = position;
					m.marker.color = color;
					m.marker.timestamp = timestamp;
					m.marker.visited = visited;
					m.marker.infoBox = adapter.infoWindow();
					m.marker.pointInfo = pointInfo;
					
					m.marker.lsnr = adapter.addMarkerLsnr(
						m,
						self.markerInfoBox
					);

					var iconUrl = markerControl.markerIconURL(color, 1, "canvasser");
					adapter.setMarkerIcon(m, iconUrl, 10, 34);
				}

				self.canvasserMarkers[canvasser] = cm;
			}

			return true;
		}

		function setHouseMarkers() {
			var houses = self.housesInfo,
				adapter = self.getManager().getAdapter(),
				markerControl = self.getManager().getControl("markers"),
//				activeCanv = $(canvassers).map(function(index, item){
//					return item.canvasser;
//				}),
				i, l, house, timestamp,	visited, position, color,
				pointInfo, cm, canvasser;
				
			
			//console.log("self.houseMarkers = ", self.houseMarkers);

			// add markers
			for(i = 0, l = houses.length; i < l; ++i) {
				
				canvasser = houses[i].canvasser;
				timestamp = houses[i].timestamp;
				visited = houses[i].visited;
				position = adapter.latLng(houses[i].lat, houses[i].lon);
				color = houses[i].color;
				pointInfo = houses[i].pointInfo;
								
				if (self.houseMarkers[canvasser]) {
					cm = self.houseMarkers[canvasser];

					if (cm.timestamp == timestamp &&
					   cm.visited == visited &&
					   cm.position.lat() == position.lat() &&
					   cm.position.lng() == position.lng() &&
					   cm.color == color)
						continue;
					
					if(visited < cm.visited)
						continue;
					
					cm.timestamp = timestamp;
					cm.visited = visited;
					cm.position = position;
					cm.color = color;
					cm.pointInfo = pointInfo;
					cm.setLocation(position);
					cm.setOptions({"icon": markerControl.markerIconURL(
						color, 1, "house"
					)});
					if(cm.infoBox && cm.infoBox.getVisible()){
						self.markerInfoBox.apply(cm);
					}
				}else{
					cm = adapter.getMarker({
						"icon": markerControl.markerIconURL(
							color, 1, "house"
						),
						"iconDim": [20, 34],
						"iconAnchor": [10, 34],
						"position": position,
						"markerType": "canvasser",
						"markerId": "can_" + new Date().getTime()
					});
					
					var m = {
						"marker": cm
					};
					
					m.marker.canvasser = canvasser;
					m.marker.position = position;
					m.marker.color = color;
					m.marker.timestamp = timestamp;
					m.marker.visited = visited;
					m.marker.infoBox = adapter.infoWindow();
					m.marker.pointInfo = pointInfo;
					
					m.marker.lsnr = adapter.addMarkerLsnr(
						m,
						self.markerInfoBox
					);

					var iconUrl = markerControl.markerIconURL(color, 1, "house");
					adapter.setMarkerIcon(m, iconUrl, 10, 34);
				}
				self.houseMarkers[canvasser] = cm;
			}

			return true;
		}

		return true;
	},
	/**
	 *
	 * @method toggleRefreshTimer
	 * @param {} onOff
	 */
	toggleRefreshTimer: function(interval){
		//console.log("%c" + "toggleRefreshTimer", "color: red; font-weight:bold;");
		var self = this,
			ajax = new Moonshadow.Ajax();

		this.refreshInterval = interval || this.refreshInterval;

		if (interval) {
			clearInterval(this.refreshTimer);
			this.refreshTimer = setInterval(function(){
				if (self.markersAreShowing()) {

					self.getMarkerInfoAjax(ajax, function(data){
						self.onAjaxResponse(data);
					});

					ajax.execute();
				}
			}, interval);
		} else {
			clearInterval(this.refreshTimer);
		}
	},
	/**
	 *
	 * @method markerInfoBox
	 */
	markerInfoBox: function(){
		var markerInfoControl = Moonshadow.getManager().getControl("markerinfo");
		markerInfoControl.markerInfoBox.apply(this);
	},
	/**
	 *
	 * @method toggleMarkers
	 * @param onOff
	 * @param survey the specific survey you'd like to see. defaults to current QQQ
	 */
	toggleMarkers: function(onOff, survey){
		//console.log("%c" + "toggleMarkers", "color: red; font-weight:bold;");
		var self = this,
			ajax = new Moonshadow.Ajax();

		this.toggleRefreshTimer(this.refreshInterval);

		if(onOff){

			this.getFieldsQueries(survey, function(data) {

				self.getMarkerInfoAjax(ajax, function(data) {
					self.onAjaxResponse(data);
				});

				ajax.execute();
				
				self.getManager().addAjaxEventListener('filterchange', self);
				self.getManager().addAjaxEventListener('colorbychange', self);
			});

		} else {
			this.fieldsQueries = [];

			hideMarkers();
			
			this.getManager().removeAjaxEventListener('filterchange',this);
			this.getManager().removeAjaxEventListener('colorbychange',this);
		}

  		function hideMarkers() {
			var i, adapter = self.getManager().getAdapter();

			// handle canvasser markers
			for (i in self.canvasserMarkers) {
				if (!self.canvasserMarkers.hasOwnProperty(i)) {
					continue;
				}
				adapter.closeInfoWindow(self.canvasserMarkers[i].infoBox, adapter.map);
				adapter.clearMarker({"marker": self.canvasserMarkers[i]});
			}

			self.canvasserMarkers = {};

			// handle house markers
			for (i in self.houseMarkers) {
				if (!self.houseMarkers.hasOwnProperty(i)) {
					continue;
				}
				adapter.closeInfoWindow(self.houseMarkers[i].infoBox, adapter.map);
				adapter.clearMarker({"marker": self.houseMarkers[i]});
			}

			self.houseMarkers = {};
		}
	},
	/**
	 * @method notify
	 */
	notify: function() {
		//console.log("MControlCanvassingMarkers:notify");
		this.toggleMarkers(true);
	},

	/**
	 * This function first gets all of the fields in the survey.
	 * Then we add two fields to get the location of the last
	 * address visited.
	 *
	 * @method getFieldsQueries
	 * @param survey Survey to look for, can't be null.
	 * @param callback
	 */
	getFieldsQueries: function(survey, callback) {
		
		// memoization
		if(this.fieldsQueries.length){
			return callback(this.fieldsQueries);
		}
		
		// initialization of variables
		var self = this;
		var manager = this.getManager();
		var ds = manager.getDatasource();
		var dsName = ds.int_name;
		var stepsShown = 1;
		var fieldNames = [
			"z_canvasser",
			"z_status",
			"z_ilat", 
			"z_ilon", 
			"z_timestamp",
			"z_visited"
		];
		var displayFields = [];

		// error check
		if(!survey) {
			throw new Error("MControlCanvassingMarkers:getFieldsQueries" +
							" survey is null or undefined");
			return false;
		}

		var self = this;
		var onSuccess = function(resp){
			var fields;
  
			if(!resp || resp.result != "ok" ||
				!resp.surveys || !resp.surveys.length) {
					throw new Error(resp.message ||
						"MControlCanvassingMarkers:getFieldsQueries" +
						" problem with response");
					return false;
			}

			self.fieldsObj = {};
			fields = resp.surveys[0].fields;
			self.fieldsObj[survey] = {
				"__latitude": "__latitude",
				"__longitude": "__longitude"
			};

			for(var i = 0, l = fields.length; i < l; i += 1) {
				for(var k in fields[i]) {
					var isInList = $(fieldNames).filter(function(key, val){
						return k.search(val) > -1;
					}).length > 0;
	  
					if(isInList) {
						self.fieldsObj[survey][fields[i][k].ext_name] = k;
						if(fields[i][k].ext_name.search("z_canvasser") == -1) {
							displayFields.push({
								"int_name": k
							});
						}
					}
				}
			}
			
			var getFieldName = function(keyPart){
				for(var i in self.fieldsObj[survey]){
					if(self.fieldsObj[survey].hasOwnProperty(i)){
						if(self.fieldsObj[survey][i].search(keyPart) > -1)
							return self.fieldsObj[survey][i];
					}
				}
			};
			
			// the following are added to get the
			// location of the last street address
			displayFields.push({"int_name":"__latitude"},
					{"int_name":"__longitude"});

			self.fieldsQueries.push({
				"query": "get_fields_grouped_sorted_filter",
				"filter": {},
				"non_null": 1,
				"ds": dsName,
				"qid": survey,
				"limit_per_group": stepsShown,
				"group_field": getFieldName("z_canvasser"),
				"sort_field": getFieldName("z_visited"),
				"ascending": 0,
				"display_fields": displayFields
			});

			callback(self.fieldsQueries);

			return true;
		}
		
		new Moonshadow.Ajax({
			"url": "/surveys/fields/" + survey + "/" + fieldNames.join(","),
			"type": "GET",
			"execute": true,
			"onSuccess": onSuccess
		});

		return true;
	},
	/**
	 *
	 * @method getMarkerInfoAjax
	 * @param ajax
	 * @param callback
	 */
	getMarkerInfoAjax: function(ajax, callback){
		//console.log("%c" + "getMarkerInfoAjax", "color: red; font-weight:bold;");
		var manager = this.getManager();
		var filterControl = this.getManager().getControl("filterscontrol");

		var dsId = manager.getControl('colorbycontrol').getActiveDsId();
		var filters = filterControl.getFilters(dsId, {});

		var queries = $(this.fieldsQueries).map(function(index, item){
			item.filter = filters;
			return item
		});
		
		this.resultsProcessed = 0;
		this.canvassersInfo = [];
		this.housesInfo = [];

		for(var i = 0, l = queries.length; i < l; ++i){
			ajax.addQuery(queries[i], callback || this);
		}
	},

	/**
	 *
	 * @method canvasserRefreshControl
	 */
	canvasserRefreshControl: function(){
		var self = this;
		return $(self.ce("div"))
			.addClass("canvasser_interval")
			.append(
				"Canvasser Refresh Interval",
				$(self.ce("select"))
					.addClass("canvaser_refresh_interval")
					.append(
						$([{
								"name": "None",
								"value": 0
							},{
								"name": "30 Seconds",
								"value": 30000
							},{
								"name": "1 Minute",
								"value": 60000
							},{
								"name": "5 Minutes",
								"value": 300000
							},{
								"name": "10 Minutes",
								"value": 600000
							}]).map(function(index, interval){
								return $(self.ce("option"))
									.attr({
										"value": interval.value,
										"selected": (self.refreshInterval == interval.value)
									})
									.append(interval.name)
									.get(0);
						})			
					)
					.change({"self": self}, function(e){
						e.data.self.toggleRefreshTimer(this.value);
					})
			);
	},
	/**
	 *
	 * @method disabledInterval
	 */
	disabledInterval: function(){
		$(".canvaser_refresh_interval")
			.val(0)
			.attr("disabled", true);
		this.toggleRefreshTimer(0);
	},
	/**
	 *
	 * @method enabledInterval
	 */
	enabledInterval: function(){
		$(".canvaser_refresh_interval")
			.attr("disabled", false);
	},

	markersAreShowing: function(){
		return (this.showCanvassers || this.showHouses);
	}
}
Moonshadow.helpers.extend(MControlCanvassingMarkers, MControl);

/**
 *
 * @class MControlMarkerInfo
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MControlMarkerInfo(options) {
	this.name = "markerinfo";
	this.manager = null;
	this.container = false;
	this.infoWindow = null;
	this.infoWindowOpen = false;
	this.options = options || {};
}
MControlMarkerInfo.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	init: function(manager){
		this.manager = manager;
		this.infoWindow = this.manager.getAdapter().infoWindow();
		var caller = this;
		this.manager.addMapObserver('infowindowclosed', function(){
			caller.infoWindowOpen = false;
		});
	},
	/**
	 *
	 * @method getPointInfo
	 * @param {} markerAttribs
	 * @param {} format
	 */
	getPointInfo: function(markerAttribs, format){
		if(markerAttribs.e){
			var dataObj = {
				"result": "ok",
				"marker_format": "extended",
				"markerId": markerAttribs.id,
				"values": [{
					"level": "area",
					"data": markerAttribs.e
				}]
			};
			this.buildInfoWindow(dataObj, null, markerAttribs);
		}else{
			var ajax = new Moonshadow.Ajax();
			var caller = this;
			
			filter = {};
			var colorByControl = this.manager.getControl('colorbycontrol');
			var colorBy = colorByControl.getActiveColorBy();
			if(colorBy && colorBy.color != "__heatmap"){
				var filtersControl = this.manager.getControl('filterscontrol');
				filter = filtersControl.filtersToJSON(markerAttribs.ds);
			}
			
			var query = this.getPointInfoQuery(
				markerAttribs.ds,
				markerAttribs.k,
				filter
			);
			
			var formatType = this.getMarkerFormatType(markerAttribs.ds);
			if(formatType == "voters_table"){
				//temporary hack in case old voter table format still in attrs
				format = format || this.getFormatObject("censusviewer_premium");
			}else{
				format = format || this.getMarkerFormatObject(markerAttribs.ds);
			}
			
			if(format.table){
				query.query = "get_multi_row_table",
				query.multi_table_fields = [];
				if(format.table.fields){
					for(var i = 0,l = format.table.fields.length; i < l; ++i){
						var fld = {"field": format.table.fields[i].int_name};
						if(format.table.fields[i].buckets)
							fld.buckets = format.table.fields[i].buckets;
						query.multi_table_fields.push(fld);
					}
				}
				query.omit_zero_rows = format.table.omit_zero_rows === 1 ? 1 : 0;
			}
			
			ajax.addQuery(query, function(data){
				caller.buildInfoWindow(data, query, markerAttribs, format);
			});
			ajax.execute();
		}
	},
	/**
	 *
	 * @method getPointInfoQuery
	 * @param {} dsId
	 * @param {} k
	 * @param {} filter
	 */
	getPointInfoQuery: function(dsId, k, filter){
		return {
			"query": "get_point_info2",
			"ds": dsId,
			"k": k,
			"filter": filter || {}
		};
	},
	getRecordDetails: function(dsId, fieldName, value, data){
		new MControlEditData({
			"title": "Record Details",
			"fieldName": fieldName,
			"value": value,
			"id": "dataeditpanel_" + value.toString(),
			"dsId": dsId,
			"data": data
		});
	},
	/**
	 *
	 * @method getMarkerFormatType
	 * @param {} ds
	 */
	getMarkerFormatType: function(ds){
		var format = Moonshadow.getManager().getDatasource(ds).marker_format;
		if(typeof format == "string")
			return format;
		if(typeof format == "object"){
			if(format.type)
				return format.type;
		}
		return false;
	},
	/**
	 *
	 * @method getMarkerFormatObject
	 * @param {} ds
	 */
	getMarkerFormatObject: function(ds){
		var dsObj = Moonshadow.getManager().getDatasource(ds);
		if(!dsObj)
			return false;
		var format = dsObj.marker_format || false;
		if(typeof format == "string"){
			return this.getFormatObject(format);
		}
		if(typeof format == "object")
			return format;
		return false;
	},
	/**
	 *
	 * @method buildInfoWindow
	 * @param {} data
	 * @param {} query
	 * @param {} markerAttribs
	 * @param {} format
	 */
	buildInfoWindow: function(data, query, markerAttribs, format){
		if(data.result == "ok") {
			var markerId = markerAttribs.id;
			var adapter = this.getManager().getAdapter();
			var markerControl = this.getManager().getControl('markers');
			var marker = markerControl.getMarkerById(markerId);
			if(!marker)
				return false;

			var infoContent = document.createElement("div");
			infoContent.id = "info_" + markerId;
			data.infoContentid = infoContent.id;
			
			var caller = this;
			var ds = marker.markerAttribs.ds;
			var format = format || this.getMarkerFormatObject(ds);
			
			var tableData;
			var blockData;
			if(format.table){
				tableData = this.buildMultiRowData(format, data);
				if(!tableData)
					return false;
				blockData = this.buildBlockData(data.block_data, format, markerAttribs);
			}
			
			this.getInfoStruct(format, data, tableData, markerAttribs, blockData, function(iStruct){
				if(infoContent){
					infoContent.appendChild(iStruct);
					if (caller.infoWindowOpen) {
						caller.closeInfoWindow();
					}		
					
					caller.infoWindow.markerId = markerId;
					caller.openInfoWindow(marker, infoContent); 
					
					$(".infobox-info").on('touchmove touchstart touchended', function(e) {
						e.stopImmediatePropagation();
					});
					
					$(".infobox-close").on('click', function(e) {
						caller.closeInfoWindow();
					});

					$(".view_record_info_button").click({"dsId": ds, "caller": caller, "data": data}, function(e){
						var elem = $(this).parent().find(".view_record_info_value");
						var fieldName = $(elem).attr("name");
						var value = $(elem).val();
						var dsId = e.data.dsId;
						var data;
						if(fieldName == "dataValue"){
							data = e.data.data;
						}
						e.data.caller.getRecordDetails(dsId, fieldName, value, data);
					});
					
					$(".infoExpander").click(function(){
						var tagetPanel = this.id.replace("exp_","");
						$(this).toggleClass("infoExpanded");
						$(".disclosureTriangle").toggleClass("sprite-expander_down sprite-expander_right");
						$("#"+tagetPanel).toggleClass("hide");	
					});
					
					$(".infoExpander_blockData").click(function(){
						$(this).toggleClass("infoExpanded");
						$(".disclosureTriangle").toggleClass("sprite-expander_down sprite-expander_right");
						$(".point", this).toggleClass("hide");
					});
					
					$(".sortFunc").click({"control":caller,"markerAttribs":marker.markerAttribs, "format": format}, function(e){
						var control = e.data.control;
						var markerAttribs = e.data.markerAttribs
						var field = $("input[name='field']", this).val();
						var ds = $("input[name='ds']", this).val();
						var formatObj = e.data.format || control.getMarkerFormatObject(ds);
						if(!formatObj.table || !formatObj.table.fields)
							return false;
						var fieldList = formatObj.table && formatObj.table.fields;
						var newFieldList = [];
						var newField;
						for(var i = 0, l = fieldList.length; i < l; ++i){
							if(fieldList[i].int_name != field){
								newFieldList.push(fieldList[i]);
							}else{
								newField = fieldList[i];
							}
						}
						newFieldList.push(newField);
						formatObj.table.fields = newFieldList;
						control.getPointInfo(markerAttribs, formatObj);
					});
					
					if(tableData){
						$(".exportFunc").click({"control":caller, 
							"tableData": tableData.tableData, 
							"blockData": blockData,
							"ds": ds}, function(e){
							var manager = e.data.control.getManager();
							
							var datasourcesControl = manager.getControl('datasources');
							if (!datasourcesControl.hasReqAddons(e.data.ds)) {
								return manager.cvSubscriptionRequired();
							}

							e.data.control.exportInfo(e.data.tableData, e.data.blockData);
						});
					}
					
					$(".hip").mouseover({"control":caller}, function(e){
						e.data.control.hoverInfoPoint(this, "over");
					}).mouseout({"control":caller}, function(e){
						e.data.control.hoverInfoPoint(this, "out");
					});
					
					caller.infoWindowOpen = true;
				}
			});
		}
	},
	/**
	 *
	 * @method getInfoStruct
	 * @param {} format
	 * @param {} data
	 * @param {} tableData
 	 * @param {} markerAttribs
	 * @param {} blockData
	 * @param {} callback
	 */
	getInfoStruct: function(format, data, tableData, markerAttribs, blockData, callback){
		if(!format){
			return callback(this.dataDump(data));
		}
		if (data.values && data.values.length == 0) {
			var noData = document.createElement("div");
			noData.className = "infoWindow";
			var noDataTxt = document.createElement("div");
			noDataTxt.className = "no_data";
			noDataTxt.appendChild(document.createTextNode("* No data was found"));
			noData.appendChild(noDataTxt);
			return callback(noData);
		}
		var contentElem = document.createElement("div");
		contentElem.className = "infoWindow";
		var caller = this;
		if(tableData && blockData){
			return this.buildBlockDataExpander(blockData, function(infoExpander){
				infoExpander && $(contentElem).append(infoExpander);
				return callback(
					caller.buildMultiRowTable(
					tableData.tableData, 
					format, 
					data.ds, 
					data.header.fields, 
					tableData.totalPopulation, 
					contentElem)
				);
			});
		}
		this.processInfoLevel(format, data.values, contentElem, {}, data.infoContentid);
		callback(contentElem);
	},
	/**
	 *
	 * @method buildBlockData
	 * @param {} blockData
	 * @param {} format
	 * @param {} markerAttribs
	 */
	buildBlockData: function(blockData, format, markerAttribs){
		if(!blockData || !format.block_data)
			return false;
		
		var pointData = {};
		if(markerAttribs && markerAttribs.la)
			pointData["Latitude"] = markerAttribs.la;
		if(markerAttribs && markerAttribs.lo)
			pointData["Longitude"] = markerAttribs.lo;
		
		for(var i = 0, l = blockData.length; i < l; ++i){
			for(var k = 0, lll = format.block_data.length; k < lll; ++k){
				for(var j = 0, ll = blockData[i].length; j < ll; ++j){
					if(format.block_data[k].v.toLowerCase() == blockData[i][j].n.toLowerCase()){
						if(pointData[format.block_data[k].n]){
							if(pointData[format.block_data[k].n] == blockData[i][j].v)
								continue;
							pointData[format.block_data[k].n] += " / " + blockData[i][j].v
						}else{
							pointData[format.block_data[k].n] = blockData[i][j].v
						}
					}
				}
			}
		}
		return pointData;
	},
	/**
	 *
	 * @method buildBlockDataExpander
	 * @param {} pointData
	 * @param {} callback
	 */
	buildBlockDataExpander: function(pointData, callback){

		var expander = document.createElement("div");
		expander.className = "infoExpander_blockData";
		var disclosure = document.createElement("span");
		disclosure.className = "disclosureTriangle sprite-expander_right";
		expander.appendChild(disclosure);
		
		var expGenInfo = document.createElement("span");
		expGenInfo.className = "expGenInfo";
		expGenInfo.appendChild(document.createTextNode("Point Info"));
		expander.appendChild(expGenInfo);
		
		var point = document.createElement("div");
		point.className = "point hide";
		expander.appendChild(point);
	
		for(var i in pointData){
			if(pointData.hasOwnProperty(i)){
				var infoString = i + ": " + pointData[i];
				var pointInfo = document.createElement("div");
				pointInfo.appendChild(document.createTextNode(infoString));
				point.appendChild(pointInfo);
			}
		}
		callback(expander);
	},
	/**
	 *
	 * @method openInfoWindow
	 * @param {} marker
	 * @param {} infoContent
	 */
	openInfoWindow: function(marker, infoContent){
		var adapter = this.getManager().getAdapter();
		adapter.openInfoWindow(this.infoWindow, adapter.map, marker, infoContent);
	},
	/**
	 *
	 * @method closeInfoWindow
	 */
	closeInfoWindow: function(){
		var adapter = this.getManager().getAdapter();
		adapter.closeInfoWindow(this.infoWindow, adapter.map);
		this.infoWindowOpen = false;
	},
	/**
	 *
	 * @method processInfoLevel
	 * @param {} formatObj
	 * @param {} infoObject
	 * @param {} contentElem
	 * @param {} carryStrings
	 * @param {} infoContentif
	 * @param {} index
	 */
	processInfoLevel: function(formatObj, infoObject, contentElem, carryStrings, infoContentid, index){
		var formattedLayer = this.formatInfoLevel(infoObject, formatObj, carryStrings, index, infoContentid);
		if (formattedLayer && formattedLayer.length > 0){
			for(var m = 0; m < formattedLayer.length; ++m){
				if (formattedLayer[m] && formattedLayer[m].elem) {
					contentElem.appendChild(formattedLayer[m].elem);
				}
				if (!carryStrings[formattedLayer[m].level]) {
					carryStrings[formattedLayer[m].level] = [];
				}
				if (formattedLayer[m] && formattedLayer[m].carry){
					carryStrings[formattedLayer[m].level][m] = formattedLayer[m].carry;
				}
				if (formattedLayer[m] && formattedLayer[m].sub && formattedLayer[m].sub.length > 0){
					this.processInfoLevel(formatObj, formattedLayer[m].sub, contentElem, carryStrings, infoContentid, m);
				}
			}
		}
	},		
	/**
	 *
	 * @method formatInfoLevel
	 * @param {} levelArray
	 * @param {} formatObj
	 * @param {} carryStrings
	 * @param {} index
	 * @param {} infoContentid
	 */
	formatInfoLevel: function(levelArray, formatObj, carryStrings, index, infoContentid){
		var constructLink = function constructLink(){
				if(formatSubsetObj.f && formatSubsetObj.f.__linkParts){
					if (formatSubsetObj.f.__linkParts.pre)
							linkContructorObj.url += formatSubsetObj.f.__linkParts.pre;
					if(formatSubsetObj.f && formatSubsetObj.f.__product){
						linkContructorObj.url += formatSubsetObj.f.__product[levelArray[j].data[s].v];
					}else{
						linkContructorObj.url += levelArray[j].data[s].v;
					}
					if (formatSubsetObj.f.__linkParts.post)
							linkContructorObj.url += formatSubsetObj.f.__linkParts.post;
				}
				if (formatSubsetObj.f && formatSubsetObj.f.__targetForLink) {
					linkContructorObj.__targetForLink = levelArray[j].data[s].v;
					isTargetForLink = true;
				}
			},
			returnArray = [];
		if(levelArray && levelArray.length > 0){
			for(var j = 0; j < levelArray.length; ++j){
				var formatSubset = levelArray[j].level,
					kValue = levelArray[j].k,
					elemArray = [],
					expander = null,
					itemExpanderArray = [],
					itemInExpHide = false,
					expanderIndex = null,
					urlTargetArray = [],
					retObj = false;
				if (levelArray[j] && levelArray[j].sub){
					retObj = {};
					retObj.sub = levelArray[j].sub;
				}
				if (!formatObj[formatSubset]){
					if(retObj)
						returnArray.push(retObj);
					continue;
				}
				var linkContructorHolder = null,
					elemarrayIndex = null,
					linkContructorObj = null;
				for(var r = 0; r < formatObj[formatSubset].length; ++r){
					var isTargetForLink = false,
						formatSubsetObj = formatObj[formatSubset][r];
						concatLine = ""
					if (formatSubsetObj.v){
						for(var t = 0; t < formatSubsetObj.v.length; ++t){
							for(var s = 0; s < levelArray[j].data.length; ++s){
								if (formatSubsetObj.v == "construct_link"){
									linkContructorObj = {
										"url": formatSubsetObj.f.url
									};
								}
								if (formatSubsetObj.v[t].toLowerCase() == levelArray[j].data[s].n.toLowerCase() && 
										levelArray[j].data[s].v != undefined && 
										levelArray[j].data[s].v !== "" ){
									if(formatSubsetObj.f && formatSubsetObj.f.__filter){
										concatLine = levelArray[j].data[s];
										continue;
									}
									if(linkContructorObj){
										constructLink();
									}										
									var strSeparator = " ";
									if (formatSubsetObj.f && formatSubsetObj.f.__separator){
										if (formatSubsetObj.f.__separator[t] == "__empty"){
											strSeparator = "";
										}else{
											strSeparator = formatSubsetObj.f.__separator[t];
										}
									}
									concatLine += levelArray[j].data[s].v + strSeparator;
								}
							}
							if (formatSubsetObj.v == "level_format"){
								if (formatSubsetObj.f){
									if (formatSubsetObj.f.__expander){
										expander = {"is":true};
									}
									if (formatSubsetObj.n){
										expander.display = formatSubsetObj.n;
									}
								}
							}
						}
					}
						
					var processFormat = false;
					if(concatLine !== ""){
						processFormat = true;						
					}
					if(formatSubsetObj.f){
						if(formatSubsetObj.f.__stringRecvr){
							processFormat = true;
						}
						if(formatSubsetObj.f.__infoButton){
							processFormat = true;
						}
					}
						
					if (processFormat){
						var lineItem = document.createElement("div");
						var isStringOnly = false;
						var addcarryStrings = false;
						var urlIndex = null;
						var isURL = false;
						var isURLTarget = false;
						var isInfoButton = false;
						if (formatSubsetObj.f){
							if (formatSubsetObj.f.__filter){
								if(concatLine.v == formatSubsetObj.f.__filter){
									if(formatSubsetObj.f.__display){
										concatLine = formatSubsetObj.f.__display;
									}else{
										concatLine = concatLine.n;
									}
								}else{
									continue;
								}
							}
							if (formatSubsetObj.f.__class){
								$(lineItem).addClass(formatSubsetObj.f.__class);
							}
							if (formatSubsetObj.f.__parseInt){
								concatLine = isNaN(concatLine = parseInt(concatLine,10)) ? 0 : concatLine;
							}
							if (formatSubsetObj.f.__forceString){
								concatLine = concatLine + "";
							}
							if (formatSubsetObj.f.__numberCommas){
								concatLine = Moonshadow.helpers.numberCommas(concatLine);
							}
							if (formatSubsetObj.f.__money){
								concatLine = formatSubsetObj.f.__money + concatLine;
							}
							if (formatSubsetObj.f.__postPend){
								concatLine = concatLine + formatSubsetObj.f.__postPend;
							}
							if (formatSubsetObj.f.__phone){
								concatLine = "("+concatLine.substring(0,3)+") "+concatLine.substring(3,6)+"-"+concatLine.substring(6);
							}
							if (formatSubsetObj.f.__stringRecvr){
								addcarryStrings = formatSubsetObj.f.__stringRecvr;
							}
							if (formatSubsetObj.f.__stringSender){
								isStringOnly = formatSubsetObj.f.__stringSender;
							}
							if (formatSubsetObj.f.__hidden){
								$(lineItem).addClass("hide");
							}
							if (formatSubsetObj.f.__toLower){
								concatLine = concatLine.toLowerCase();
							}
							if (formatSubsetObj.f.__toUpper){
								concatLine = concatLine.toUpperCase();
							}
							if (formatSubsetObj.f.__infoButton){
								isInfoButton = true;
								
								var idValue = document.createElement("input");
								idValue.type = "hidden";
//								if(formatSubsetObj.f.__infoButton.use_k && kValue){
									idValue.value = kValue;
									idValue.name = "kvalue";
//								}else if(formatSubsetObj.f.__infoButton.use_data){
//									idValue.value = kValue;
//									idValue.name = "dataValue";
//								}else if(formatSubsetObj.v && formatSubsetObj.v.length){
//									idValue.value = concatLine.trim();
//									idValue.name = formatSubsetObj.v[0];
//								}
								
								idValue.className = "view_record_info_value";
								lineItem.appendChild(idValue);
								
								var infoButton = document.createElement("input");
								infoButton.className = "view_record_info_button";
								infoButton.type = "button";
								infoButton.value = formatSubsetObj.f.__infoButton.title;
								infoButton.id = "info_" + 
								lineItem.appendChild(infoButton);
								
								$(lineItem).addClass("view_record_info");
							}
							if (formatSubsetObj.f.__url){
								var url = concatLine;
								if(url.search(/;/) > -1){
									var urlsplit = url.replace(/\s/g,"").split(";");
									url = urlsplit[0];
								}
								if (url.search(/:\/\//g) < 0) 
									url = "http://" + url;
								var anchor = document.createElement("a");
								anchor.href = url;
								anchor.target = formatSubsetObj.f.__url.__target;
								lineItem.appendChild(anchor);
								if (!urlTargetArray[formatSubsetObj.f.__url.index])
									urlTargetArray[formatSubsetObj.f.__url.index] = {};
								urlTargetArray[formatSubsetObj.f.__url.index].a = lineItem;
								isURL = true;
							}
							if (formatSubsetObj.f.__urlTarget){
								if (!urlTargetArray[formatSubsetObj.f.__urlTarget])
									urlTargetArray[formatSubsetObj.f.__urlTarget] = {};
								urlTargetArray[formatSubsetObj.f.__urlTarget].n = concatLine;
								isURLTarget = formatSubsetObj.f.__urlTarget;
							}
							if (formatSubsetObj.f.__itemexpander){
								$(lineItem).addClass("infoExpander");
								if (!expanderIndex) 
									expanderIndex = Math.floor(Math.random()*(new Date().getTime()));
								lineItem.expandIndex = expanderIndex;
							}
							if (formatSubsetObj.f.__expander_hide){
								if (!expanderIndex) 
									expanderIndex = Math.floor(Math.random()*(new Date().getTime()));
								itemInExpHide = expanderIndex;
							}
						}
						if (formatSubsetObj.n){
							concatLine = formatSubsetObj.n + ": "+concatLine;
						}
						if (addcarryStrings && carryStrings && carryStrings[addcarryStrings.__indlvl] && carryStrings[addcarryStrings.__indlvl][index]) {
							if(carryStrings[addcarryStrings.__indlvl][index][addcarryStrings.__ind]){
								if (addcarryStrings.__pos == "start"){
									concatLine = carryStrings[addcarryStrings.__indlvl][index][addcarryStrings.__ind] + " " + concatLine;
								}
								if (addcarryStrings.__pos == "end"){
									concatLine = concatLine + " " + carryStrings[addcarryStrings.__indlvl][index][addcarryStrings.__ind];
								}
							}else{
								continue;
							}
						}
						if (isStringOnly){
							var sendCarry = [];
							sendCarry["index"] = isStringOnly;
							sendCarry["str"] = concatLine;
							elemArray.push(sendCarry);
						}else if(isURL){
							isURL = false;
							if(isURLTarget){
								elemArray.push({'URLTarget':isURLTarget});
								isURLTarget = false;
							}
						}else if(isURLTarget){
							elemArray.push({'URLTarget':isURLTarget});
							isURLTarget = false;
						}else if(itemInExpHide){
							if (!itemExpanderArray[itemInExpHide]) {
								itemExpanderArray[itemInExpHide] = document.createElement("div");
								$(itemExpanderArray[itemInExpHide]).addClass("hide");
								itemExpanderArray[itemInExpHide].id = "itemExp_"+itemInExpHide+"_"+infoContentid;
							}
							lineItem.appendChild(document.createTextNode(concatLine));
							itemExpanderArray[itemInExpHide].appendChild(lineItem);
							itemInExpHide = false;
						}else if(isInfoButton){
							elemArray.push(lineItem);
						}else{
							if(concatLine.replace(/\s/gi, '').length > 0){
								if(isTargetForLink){
									linkContructorHolder = lineItem;
									elemarrayIndex = elemArray.length;
									isTargetForLink = false;
								}else{
									lineItem.appendChild(document.createTextNode(concatLine));
								}
								elemArray.push(lineItem);
							}
						}
					}
				}
				if(linkContructorHolder){
					linkContructorHolder = document.createElement("div");
					var linkContructorHoldera = document.createElement("a");
					linkContructorHoldera.className = "clickable url";
					linkContructorHoldera.href = linkContructorObj.url;
					linkContructorHoldera.target = "_blank";
					linkContructorHoldera.appendChild(document.createTextNode(linkContructorObj.__targetForLink));
					linkContructorHolder.appendChild(linkContructorHoldera);
					elemArray.splice(elemarrayIndex, 1, linkContructorHolder);
				}
				
				if(!retObj)
					retObj = {};
				retObj.elem = document.createElement("div");
				
				if (levelArray[j]){
					if(levelArray[j].level){
						retObj.level = levelArray[j].level;
					}
				}

				if (elemArray.length > 0) {
					retObj.elem.className = levelArray[j].level;
					if (expander && expander.is) {
						retObj.elem.className += " hide";
						expander.id = "_"+Math.floor(Math.random()*(new Date().getTime()));
						retObj.elem.id = expander.id;
					}
					for(var u = 0; u < elemArray.length; ++u) { 
						if ($.type(elemArray[u]) == "array"){
							if (!retObj.carry) {
								retObj.carry = [];
							}
							retObj.carry[elemArray[u].index] = elemArray[u].str;
						}else if(elemArray[u].URLTarget){
							$(urlTargetArray[elemArray[u].URLTarget].a).children()[0].appendChild(document.createTextNode(urlTargetArray[elemArray[u].URLTarget].n));
							retObj.elem.appendChild(urlTargetArray[elemArray[u].URLTarget].a);
						}else if(elemArray[u].expandIndex){
							elemArray[u].id = "exp_"+elemArray[u].expandIndex;
							retObj.elem.appendChild(elemArray[u]);
							retObj.elem.appendChild(itemExpanderArray[elemArray[u].expandIndex]);
						}else{
							retObj.elem.appendChild(elemArray[u]);
						}
					}
					if (expander) {
						var expDiv = document.createElement("div");
						expDiv.className = "infoExpander";
						var disclosure = document.createElement("span");
						disclosure.className = "disclosureTriangle sprite-expander_right";
						expDiv.appendChild(disclosure);
						if (expander.display){
							var expSpan = document.createElement("span");
							expSpan.className = "expGenInfo";
							expSpan.appendChild(document.createTextNode(expander.display));
							expDiv.appendChild(expSpan);
						}
						expDiv.id = "exp_"+expander.id;
						expDiv.appendChild(retObj.elem);
						retObj.elem = expDiv;
					}
				}
				returnArray.push(retObj);
			}
		}
		return returnArray;
	},
	/**
	 *
	 * @method buildMultiRowData
	 * @param {} formatObj
	 * @param {} infoObject
	 */
	buildMultiRowData: function(formatObj, infoObject){
		if(!(infoObject && infoObject.rows && infoObject.header))
			return false;
		
		if(infoObject.rows.length && infoObject.header){
			
			if(infoObject.header[0])
				infoObject.header = infoObject.header[0];

			var totalPopulation = 0;
			var getTotalFromRow = function(row){
				var totalForRow = 0;
				for(var j = 0, ll = row.length; j < ll; ++j){
					totalForRow += row[j];
				}
				totalPopulation += totalForRow;
				return totalForRow;
			}
			
			//function for building the datatable
			var caller = this;
			var fields = infoObject.header.fields;
			var assembleData = function(data, tableData, depth, title){
				for(var j = 0, ll = data.length; j < ll; ++j){
					if(typeof data[j] == "object"){
						var nextTitle = title + " " + caller.hardCodedTranslator(fields[depth + 1].values[j]);
						assembleData(data[j], tableData, depth + 1, nextTitle);
					}else{
						//get total
						var total = getTotalFromRow(data);
						if(total != 0){
							//add in concat title
							data.splice(0, 0, title);
							tableData.push(data);
						}
						break;
					}
				}
			}
			
			var tableData = []; //store data for the table; an array of arrays
			var headerRow = fields[fields.length -1].values;
			headerRow.splice(0,0,"");
			tableData.push(headerRow); //adding the header values
			//each first level of the rows array is a new table row
			for(var i = 0, l = infoObject.rows.length; i < l; ++i){
				//each object in each element of the rows array is an array. Also pass in first part of title
				assembleData(infoObject.rows[i], tableData, 0, this.hardCodedTranslator(fields[0].values[i]));
			}
		}
		
		return {
			"tableData": tableData,
			"totalPopulation": totalPopulation
		};
	},
	/**
	 *
	 * @method buildMultiRowTable
	 * @param {} tableData
	 * @param {} formatObj
	 * @param {} ds
	 * @param {} fields
	 * @param {} totalPopulation
	 * @param {} contentElem
	 */
	buildMultiRowTable: function(tableData, formatObj, ds, fields, totalPopulation, contentElem){
		
		var formatFields = {}
		for(var i = 0, l = formatObj.table.fields.length; i < l; ++i){
			formatFields[this.hardCodedTranslator(formatObj.table.fields[i].ext_name)] = formatObj.table.fields[i].int_name;
		}

		var tableElem = document.createElement("table");
		tableElem.className = "census_table";
		var tableTrDescElem = document.createElement("tr");
		tableElem.appendChild(tableTrDescElem);
		var emptyTd = document.createElement("td");
		emptyTd.style.backgroundColor = "white";
		var sorter = document.createElement("td");
		var bgSorter = document.createElement("div");
		if (fields.length > 1){
			for(var i = 0, l = fields.length; i < l; ++i){
				var dispName = this.hardCodedTranslator(fields[i].name);
				var sortitem = document.createElement("a");
				sortitem.className = "clickable sortFunc";
				sortitem.appendChild(document.createTextNode(dispName));
				var sortfield = document.createElement("input");
				sortfield.name = "field";
				sortfield.type = "hidden";
				sortfield.value = formatFields[dispName];
				sortitem.appendChild(sortfield);
				var sortds = document.createElement("input");
				sortds.name = "ds";
				sortds.type = "hidden";
				sortds.value = ds;
				sortitem.appendChild(sortds);
				bgSorter.appendChild(sortitem);
			}
			sorter.appendChild(bgSorter);
			sorter.className = "bg_sorter";
		}
		tableTrDescElem.appendChild(sorter);

		var headerList = tableData[0];
		for(var i = 1, l = headerList.length; i < l; ++i){
			var newDescTd = document.createElement("td");
			newDescTd.className = "col_header colNum_"+ i ;
			newDescTd.id = "_"+headerList[i].replace(/\W/g, "");
			newDescTd.appendChild(document.createTextNode(this.hardCodedTranslator(headerList[i])));
			tableTrDescElem.appendChild(newDescTd);
		}
		
		var totalColTd = document.createElement("td");
		totalColTd.className = "col_total colNum_"+(headerList.length);
		totalColTd.id = "totalCol";
		totalColTd.appendChild(document.createTextNode("T"));
		totalColTd.appendChild(document.createElement("br"));
		totalColTd.appendChild(document.createTextNode("o"));
		totalColTd.appendChild(document.createElement("br"));
		totalColTd.appendChild(document.createTextNode("t"));
		tableTrDescElem.appendChild(totalColTd);
		var totalColPerTd = document.createElement("td");
		totalColPerTd.className = "col_percent colNum_"+(headerList.length + 1);
		totalColPerTd.id = "totalColPer";
		totalColPerTd.appendChild(document.createTextNode("%"));
		tableTrDescElem.appendChild(totalColPerTd);
		
		var totalsForCols = [0];
		for(var i = 1, l = tableData.length; i < l; ++i){
			var tableTrElem = document.createElement("tr");
			tableElem.appendChild(tableTrElem);
			var tableTrDescElem = document.createElement("td");
			tableTrDescElem.className = "row_header transparent";
			tableTrDescElem.id = "_"+tableData[i][0].replace(/\W/g, "");
			tableTrDescElem.style.minWidth = (parseInt(tableData[i][0].length,10) * 4) + "px";
			tableTrDescElem.appendChild(document.createTextNode(tableData[i][0]));
			tableTrElem.appendChild(tableTrDescElem);
			var totalForRow = 0;
			for(var j = 1, ll = tableData[i].length; j < ll; ++j){
				var tableTdElem = document.createElement("td");
				tableTdElem.className = "census_cell transparent colNum_"+j;
				if(!totalsForCols[j])
					totalsForCols[j] = 0;
				totalsForCols[j] += tableData[i][j];
				var hoverElem = document.createElement("div");
				tableTdElem.appendChild(hoverElem);
				hoverElem.appendChild(document.createTextNode(tableData[i][j]));
				totalForRow += parseInt(tableData[i][j],10);
				tableTdElem.className += " hip";
				tableTrElem.appendChild(tableTdElem);
			}

			var tableTdTotalElemDesc = document.createElement("td");
			tableTdTotalElemDesc.className = "cell_total transparent hip colNum_"+ (j);
			var hoverElem = document.createElement("div");
			hoverElem.appendChild(document.createTextNode(totalForRow));
			tableTdTotalElemDesc.appendChild(hoverElem);
			tableTrElem.appendChild(tableTdTotalElemDesc);
	
			var tableTdTotalPerElemDesc = document.createElement("td");
			tableTdTotalPerElemDesc.className = "cell_percent transparent hip colNum_"+(j +1);
			var hoverElem = document.createElement("div");
			hoverElem.appendChild(document.createTextNode(( Math.round((totalForRow / totalPopulation) * 100))) );
			tableTdTotalPerElemDesc.appendChild(hoverElem);
			tableTrElem.appendChild(tableTdTotalPerElemDesc);
		}
		
		var tableTrTotalElem = document.createElement("tr");
		tableElem.appendChild(tableTrTotalElem);
		var tableTrTotalElemDesc = document.createElement("td");
		tableTrTotalElemDesc.className = "total_row_header";
		tableTrTotalElemDesc.id = "totalRow";
		tableTrTotalElemDesc.appendChild(document.createTextNode("totals"));
		tableTrTotalElem.appendChild(tableTrTotalElemDesc);
		for(var i = 1, l = totalsForCols.length; i < l; ++i){
			var tableTdTotalElem = document.createElement("td");
			tableTdTotalElem.className = "total_cell hip colNum_"+i;
			var hoverElem = document.createElement("div");
			hoverElem.appendChild(document.createTextNode(totalsForCols[i]));
			tableTdTotalElem.appendChild(hoverElem);
			tableTrTotalElem.appendChild(tableTdTotalElem);
		}
		
		var tableTdTotalTotal = document.createElement("td");
		tableTdTotalTotal.className = "total_row_total_col hip colNum_"+ i;
		var hoverElem = document.createElement("div");
		hoverElem.appendChild(document.createTextNode(totalPopulation));
		tableTdTotalTotal.appendChild(hoverElem);
		tableTrTotalElem.appendChild(tableTdTotalTotal);
		tableTrTotalElem.appendChild(emptyTd.cloneNode(true));
	
		var tableTrTotalPercElem = document.createElement("tr");
		tableElem.appendChild(tableTrTotalPercElem);
		var tableTrTotalPercElemDesc = document.createElement("td");
		tableTrTotalPercElemDesc.className = "total_row_col_percent";
		tableTrTotalPercElemDesc.id = "totalRow";
		tableTrTotalPercElemDesc.appendChild(document.createTextNode("%"));
		tableTrTotalPercElem.appendChild(tableTrTotalPercElemDesc);
		
		for(var i = 1, l = totalsForCols.length; i < l; ++i){
			var tableTdTotalPercElem = document.createElement("td");
			tableTdTotalPercElem.className = "percent_row hip colNum_"+i;
			var hoverElem = document.createElement("div");
			hoverElem.appendChild(document.createTextNode(( Math.round((parseInt(totalsForCols[i]) / totalPopulation) * 100))));
			tableTdTotalPercElem.appendChild(hoverElem);
			tableTrTotalPercElem.appendChild(tableTdTotalPercElem);
		}
		tableTrTotalPercElem.appendChild(emptyTd.cloneNode(true));
		tableTrTotalPercElem.appendChild(emptyTd.cloneNode(true));
		contentElem.appendChild(tableElem);
		
		if (formatObj.table.show_export){
			var exportButton = document.createElement("input");
			exportButton.type = "button";
			exportButton.value = "Export";
			exportButton.className = "exportFunc right";
			contentElem.appendChild(exportButton);
		}
		
		return contentElem;
	},
	/**
	 *
	 * @method exportinfo
	 * @param {} exportData
	 * @param {} blockData
	 */
	exportInfo: function(exportData, blockData){
		
		var ce = function(type){
			return document.createElement(type);
		};
		
		var fileName;
		if(blockData){
			//construct file name from block info
		}
		
		var formObj = $(ce("form"))
			.attr({
				"method": "POST",
				"target": "_blank",
				"action": Moonshadow.getDataUrl("/export/pointdata")
			})
			.append(
				$(ce("input"))
					.attr({
						"type": "hidden",
						"name": "data",
						"value": JSON.stringify(exportData)
					}),
				$(ce("input"))
					.attr({
						"type": "hidden",
						"name": "filename",
						"value": ( fileName || "point_data" ) + ".csv"
					}),
				$(ce("input"))
					.attr({
						"type": "hidden",
						"name": "key",
						"value": Moonshadow.key
					}),
				$(ce("input"))
					.attr({
						"type": "hidden",
						"name": "user",
						"value": Moonshadow.user
					})
			);
		
		$(document.body)
			.append(
				formObj
			);
		
		$(formObj)
			.get(0)
			.submit();
	},
	/**
	 *
	 * @method hoverInfoPoint
	 * @param {} target
	 * @param {} mPos
	 */
	hoverInfoPoint: function(target, mPos){
		switch(mPos){
			case "over":
				var width = $(target).innerWidth();
				var height = $(target).innerHeight();
				var elemPos = $(target).position();
				if(!target.style.width)
					target.style.width = width+"px";
				if(!target.style.height)
					target.style.height = height+"px";
				var classes = target.className.split(" ");
				for(var i = 0; i < classes.length; ++i){
					var tmp = classes[i].split("_");
					if (tmp[0] == "colNum"){
						var colSet = $(".colNum_"+tmp[1]);
						if (colSet.length < 30)
							$(colSet).addClass("lightGray");
					}
				}
				$(target).addClass("hoverInfoPoint");
				$(target).parent().addClass("lightGray");
				var innerDiv = $(".hoverInfoPoint div")[0];
				var innerDivStr = innerDiv.innerHTML;
				innerDiv.style.top = (elemPos.top - 5) +"px";
				innerDiv.style.left = (elemPos.left - 5) +"px";
				var newWidth = width + 3;
				if(innerDivStr.length == 4 && newWidth < 42) newWidth = 42; 
				if(innerDivStr.length == 3 && newWidth < 31) newWidth = 31; 
				if(innerDivStr.length == 2 && newWidth < 28) newWidth = 28; 
				innerDiv.style.width = newWidth + "px";
				innerDiv.style.height = (height + 3) + "px";
				break;
			case "out":
			default:
				$(target).parent().removeClass("lightGray");
				var classes = target.className.split(" ");
				for(var i = 0; i < classes.length; ++i){
					var tmp = classes[i].split("_");
					if (tmp[0] == "colNum"){
						var colSet = $(".colNum_"+tmp[1]);
						if (colSet.length < 30)
							$(colSet).removeClass("lightGray");
					}
				}
				var innerDiv = $(".hoverInfoPoint div")[0];
				$(target).attr('style', '');
				$(innerDiv).attr('style', '')
				$(target).removeClass("hoverInfoPoint");
		}
	},
	/**
	 *
	 * @method markerInfoBox
	 */
	markerInfoBox: function(){
		var ce = function(type){
			return document.createElement(type);
		};
		
		var adapter = Moonshadow.getManager().getAdapter();
		adapter.closeInfoWindow(this.infoBox, adapter.map);
		
		var id = adapter.getInfoWindowId(this.infoBox);
		if (!id) {
			adapter.setInfoWindowId(this.infoBox, this.Id);
		}
			
		var self = this;
		adapter.openInfoWindow(
			this.infoBox,
			adapter.map, 
			this, 
			$(ce("div"))
				.addClass("canvasser_container")
				.addClass(this.Id)
				.append(
					$(ce("span"))
						.addClass("canvasser_name")
						.append(
							this.canvasser
						),
					$(ce("div"))
						.addClass("canvasser_info hide")
						.append(
							function(){
								if(self.visited)
									return $(ce("div"))
										.addClass("canvasser_ts")
										.append(
											"Timestamp: ", 
											Moonshadow.helpers.dateFromUTC(self.visited),
											" ",
											Moonshadow.helpers.timeSinceMidnightStandard(self.visited)
										)
								return "";
							}(),
							$(ce("div"))
								.addClass("canvasser_lat")
								.append(
									"Latitude: ", 
									this.position.latitude
								),
							$(ce("div"))
								.addClass("canvasser_lng")
								.append(
									"Longitude: ",
									this.position.longitude
								),
							$(ce("div"))
								.addClass("canvasser_point_info_number")
								.append(
									"Addresses Visited: ",
									this.pointInfo["addresses_visited"]
								),
							$(ce("div"))
								.addClass("canvasser_point_info_first")
								.append(
									"First Visited Time: ",
									Moonshadow.helpers.dateFromUTC(this.pointInfo["first_ts"]),
									" ",
									Moonshadow.helpers.timeSinceMidnightStandard(this.pointInfo["first_ts"])
								),
							$(ce("div"))
								.addClass("canvasser_point_info_last")
								.append(
									"Last Visited Time: ",
									Moonshadow.helpers.dateFromUTC(this.pointInfo["last_ts"]),
									" ",
									Moonshadow.helpers.timeSinceMidnightStandard(this.pointInfo["last_ts"])
								)
							)
				)
				.get(0)
		);
		if (this.infoBoxContainer){
			$(".canvasser_name", this.infoBoxContainer)
				.click({"self": this}, function(e){
					$(e.data.self.infoBoxContainer)
						.toggleClass("canvasser_infobox canvasser_infobox_expanded");
					$(".canvasser_info", e.data.self.infoBoxContainer)
						.toggleClass("hide");
				});
		}
	},
	/**
	 *
	 * @method dataDump
	 * @param {} infoObject
	 */
	dataDump: function(infoObject){
		var contentElem = document.createElement("div");
		contentElem.className = "infoWindow";
		var dump = function(contentElem, level, indent){
			for(var i = 0; i < level.length; ++i){ 
				if (level[i].level){
					var elem = document.createElement("div");
					elem.appendChild(document.createTextNode("level: "+level[i].level));
					elem.style.paddingLeft = parseInt(indent*10,10) + "px";
					elem.style.paddingTop = "5px";
					contentElem.appendChild(elem);
				}
				if (level[i].data){
					for(var j = 0; j < level[i].data.length; ++j){ 
						var elem = document.createElement("div");
						elem.appendChild(document.createTextNode(level[i].data[j].n+": "+level[i].data[j].v));
						contentElem.appendChild(elem);
						elem.style.paddingLeft = parseInt(indent*10,10) + "px";
						if (level[i].data[j].n.search(/__/g) > -1){
							elem.style.display = "none";
						}						
					} 
				}
				if (level[i].sub){
					dump(contentElem, level[i].sub, ++indent);
				}
			}
		} 
		dump(contentElem, infoObject.values, 0);
		return contentElem;
	},
	/**
	 *
	 * @method hardCodedTranslator
	 * @param {} text
 	 */
	hardCodedTranslator: function(text){
		switch(text){
			case "Likely Ethnicity":
				return "Race";
			case "F":
				return "Female";
			case "M":
				return "Male";
			case "Yes":
				return "Latino";
			case "No":
				return "Non Latino";
		}
		return text;
	},
	/**
	 *
	 * @method getFormatObject
	 * @param {} format
	 */
	getFormatObject: function(format){
		var formatObj; 
		switch(format){
			case "censusviewer_premium":
				formatObj = {
					"type":"censusviewer_premium",
					"table": {
						"omit_zero_rows": 1,
						"show_export": 1,
						"fields":[
							{
								"int_name": "Ethnic_Description",
								"ext_name": "Race"
							},
							{
								"int_name": "Voters_Gender",
								"ext_name": "Gender"
							},
							{
								"int_name": "Voters_Age",
								"ext_name": "Age",
								"buckets": [
									0,5,10,15,18,20,21,22,25,30,35,40,45,50,55,60,62,65,67,70,75,80,85
								]
							}
						]
					},
					"block_data":[
						{
							"v":"Residence_Addresses_City",
							"n":"City"
						},
						{
							"v":"Precinct",
							"n":"Precinct"
						},
						{
							"v":"County",
							"n":"County"
						},
						{
							"v":"zip",
							"n":"Zip"
						}
					],
				};
				break;
			case "census":
				formatObj = {
					"type":"census",
					"table": {
						"omit_zero_rows": 1,
						"show_export": 1,
						"fields":[
							{
								"int_name": "race",
								"ext_name": "Likely Ethnicity"
							},
							{
								"int_name": "latino",
								"ext_name": "Latino"
							},
							{
								"int_name": "gender",
								"ext_name": "Gender"
							},
							{
								"int_name": "age",
								"ext_name": "Age"
							}
						]
					},
					"block_data":[
						{
							"v":"PLACE",
							"n":"City"
						},
						{
							"v":"PLACE10",
							"n":"City"
						},
						{
							"v":"PLACE00",
							"n":"City"
						},
						{
							"v":"COUNTY",
							"n":"County"
						},
						{
							"v":"COUNTY10",
							"n":"County"
						},
						{
							"v":"COUNTY00",
							"n":"County"
						},
						{
							"v":"ZCTA5",
							"n":"Zip"
						},
						{
							"v":"ZCTA510",
							"n":"Zip"
						},
						{
							"v":"ZCTA500",
							"n":"Zip"
						}
					]
				};
				break;
			case "extended":
				formatObj = {
					"type":"extended",
					"area":[
						{
							"v":["city"],
							"n":"City"
						},
						{
							"v":["state" ],
							"n":"State"
						},
						{
							"v":["zip"],
							"n":"ZIP"
						},
						{
							"v":["County"],
							"n":"County"
						},
						{
							"v":["count"],
							"n":"Count"
						},
						{
							"v":["aum"],
							"n":"Total AUM",
							"f":{
								"__parseInt":1,
								"__forceString":1,
								"__numberCommas":1,
								"__money":"$"
							}
						}
						
					]
				};
				break;
			case "aiq":
				formatObj = {
					"type":"aiq",
					"point":[
						{
							"v":["city", 
								"state",
								"zip"
							],
							"f":{
								"__stringSender":1,
								"__separator":[", "," ","__empty"]
							}
						}
					],
					"address":[{
							"v":["address1", "address2"],
							"f":{
								"__stringRecvr":{
									"__ind":1,
									"__indlvl":"point",
									"__pos":"end"
								},
								"__stringSender":2
							}
						}
					],
					"firm":[
					{
						"v":["construct_link"],
						"f":{
							"url":"http://ria.meridian-iq.com/Search/ViewFirm.aspx?"
							}
						},
						{
							"v":["name"
							],
							"f":{
								"__targetForLink":1
							}
						},
						{
							"v":["rr_firm_name"]
						},
						{
							"f":{
								"__stringRecvr":{
									"__ind":2,
									"__indlvl":"address",
									"__pos":"end"
								}
							}
						},
						{
							"v":["phone"]
						},
						{
							"v":["aum"
							],
							"n":"Total AUM",
							"f":{
								"__parseInt":1,
								"__forceString":1,
								"__numberCommas":1,
								"__money":"$"
							}
						},
						{
							"v":["url"
							],
							"f":{
								"__url":{
									"index":1,
									"__target":"_blank"
								},
								"__urlTarget":1,
								"__toLower":1
							}
						},
						{
							"v":["id"],
							"f":{
								"__linkParts": {
									"pre": "&coyid=",
									"post": "&sid=0&stypeid=4&action=&tid=0"
								},
								"__hidden":1
							}
						},
						{
							"v":["product"
							],
							"f":{
								"__product": {
									"RIA": "1",
									"Trust": "2",
									"RR": "3"		
								},
								"__linkParts": {
									"pre": "&ds="
								},
								"__hidden":1
							}
						}
					]
				};
				break;				
			case "lnl":
			case "lal":
			default:
				formatObj = {
					"type":"lal",
					"point":[
						{
							"v":["level_format"],
							"n":"General Info",
							"f":{
								"__expander":1
							}
						},
						{
							"v":["Residence_Addresses_PrefixDirection",
								"Residence_Addresses_StreetName",
								"Residence_Addresses_Designator",
								"Residence_Addresses_SuffixDirection"
							],
							"f":{
								"__stringSender":1
							}
						},
						{
							"v":["Residence_Addresses_City", 
								"Residence_Addresses_State",
								"zip"
							],
							"f":{
								"__stringSender":2,
								"__separator":[", "," ","__empty"]
							}
						},
						{
							"v":["latitude",
								"longitude"
							],
							"n":"Lat/Lng"
						},
						{
							"v":["__latitude",
								"__longitude"
							],
							"n":"Lat/Lng"
						},
						{
							"v":["County"
							],
							"n":"County"
						},
						{
							"v":["US_Congressional_District"
							],
							"n":"Congr. Dist."
						},
						{
							"v":["State_Legislative_District"
							],
							"n":"St. Legis. Dist."
						},
						{
							"v":["Precinct"
							],
							"n":"Precinct"
						},
						{
							"v":["Township"
							],
							"n":"Township"
						},
						{
							"v":["Voters_FIPS"
							],
							"n":"Voters FIPS",
							"f":{
								"__hidden":1
							}
						}
					],
					"address":[{
							"v":["Residence_Addresses_HouseNumber"
							],
							"f":{
								"__stringRecvr":{
									"__ind":1,
									"__indlvl":"point",
									"__pos":"end"
								}
							}
						},
						{
							"f":{
								"__stringRecvr":{
									"__ind":2,
									"__indlvl":"point",
									"__pos":"end"
								}
							}
						}
					],
					"address_apt":[{
							"v":["Residence_Addresses_ApartmentNum"
							],
							"n":"Apt#"
						}
					],
					"residence":[{
							"v":["VoterTelephones_Phone10"
							],
							"n":"Phone",
							"f":{
								"__phone":1
							}
						}
					],
					"voter":[
//					    Temporary: This one is for DSs that have LALVOTERID 
//						{
//							"v":["LALVOTERID"],
//							"f":{
//								"__infoButton": {
//									"title": "View"
//								}
//							}
//						},
//						Good: this one needs to be used when QS 3.17.x is live
						{
							"f":{
								"__infoButton": {
									"title": "View",
									"use_k": true
								},
							}
						},
//						Temporary: this one takes the data given on the original request. Hacky 
//						{
//							"f":{
//								"__infoButton": {
//									"title": "View",
//									"use_data": true
//								},
//							}
//						},
						{
							"v":["Voters_FirstName",
								"Voters_MiddleName",
								"Voters_LastName"
							],
							"f":{
								"__class":"voterName"
							}
						},
						{
							"v":["Voters_Gender"
							],
							"n":"Gender"
						},
						{
							"v":["Parties_Description"
							],
							"n":"Party"
						},
						{
							"v":["Voters_BirthDate"
							],
							"n":"Birth Date"
						},
						{
							"v":["Voters_age"
							],
							"n":"age"
						},
						{
							"v":["Voters_OfficialRegDate"
							],
							"n":"Registration"
						},
						{
							"v":["Vote_Frequency"
							],
							"n":"Vote Frequency"
						},
						{
							"v":["liklihood_of_voting"
							],
							"n":"Vote Frequency"
						}
					]
				}
		}
		return formatObj;
	}
};
Moonshadow.helpers.extend(MControlMarkerInfo,MControl);


function MControlPhoneCampaigns(options) {
	this.name = 'phonecampaigns';
	this.manager = null;
	this.options = options || {};
	this.campaigns;
	this.statusCodes;
	this.wizard;
	this.introShown = false;
	this.campaignInitialized = false;
	
	this.remainingCredit;
	this.costPerAnswer;
	this.costPerMinute;
	this.avgSecondsPerQuestion;
	this.estimatedCost;
};

Moonshadow.helpers.extend(MControlPhoneCampaigns, MControl);

MControlPhoneCampaigns.prototype.init = function(manager) {
	this.manager = manager;
	if(this.remainingCredit == undefined){
		this.fetchRemainingCredit();
	}
};

MControlPhoneCampaigns.prototype.show = function(campaign, callback){
	this.wizard = new MUIWizardHelper(this.manager, this.panels(), 0, callback);
	if(campaign){
		this.initializeCampaign(campaign);
		this.campaignInitialized = true;
	}
};

MControlPhoneCampaigns.prototype.getRemainingCredit = function(){
	return this.remainingCredit;
};

MControlPhoneCampaigns.prototype.fetchRemainingCredit = function(callback){
	var self = this;
	return this.getCreditAmount(function(amount){
		self.remainingCredit = amount;
		self.manager.dataObservers.notify("creditfetched", amount);
		callback && callback(amount);
	});
};

MControlPhoneCampaigns.prototype.getCreditAmount = function(callback){
	new Moonshadow.Ajax({
		"url": "/phonecampaigns/getcredit",
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			callback(data.amount);
		}
	});
};

MControlPhoneCampaigns.prototype.canBeSubmitted = function(campaign, callback){	
	var self = this;
	this.getEstimatedCosts(campaign, false, function(estimatedCost){
		if(estimatedCost > self.remainingCredit){
			return callback({
				"valid": false,
				"message": "Number of available credits (" + self.remainingCredit + ") " +
					"does not meet the minimum estimated cost (" + estimatedCost + ")."
			});
		}
		callback({
			"valid": true
		});
	});
};

MControlPhoneCampaigns.prototype.getEstimatedCosts = function(campaign, refresh, callback){
	var self = this;
	if(!campaign.estimatedCost || refresh){
		var questionCount = this.questionCount(campaign.survey_id) || 0;
		var recordCount = campaign.total_records || 0;
		return this.fetchEstimatedCosts(campaign.id, questionCount, recordCount, function(estimate){
			if(self.costPerAnswer == undefined || self.costPerAnswer != estimate.costPerAnswer){
				self.costPerAnswer = estimate.costPerAnswer;
			}
			if(self.costPerMinute == undefined || self.costPerMinute != estimate.costPerMinute){
				self.costPerMinute = estimate.costPerMinute;
			}
			if(self.avgSecondsPerQuestion == undefined || self.avgSecondsPerQuestion != estimate.avgSecondsPerQuestion){
				self.avgSecondsPerQuestion = estimate.avgSecondsPerQuestion;
			}

			campaign.estimatedCost = estimate.estimatedCost;
			callback(campaign.estimatedCost);
		});
	}
	callback(campaign.estimatedCost);
};

MControlPhoneCampaigns.prototype.fetchEstimatedCosts = function(campaignId, questionCount, recordCount, callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/phonecampaigns/costs/" + campaignId,
		"payload": {
			"questioncount": questionCount,
			"recordcount": recordCount
		},
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			var estimate = {}
			if(data.result == "ok"){
				estimate.costPerAnswer = data.costPerAnswer;
				estimate.costPerMinute = data.costPerMinute;
				estimate.avgSecondsPerQuestion = data.avgSecondsPerQuestion;
				estimate.estimatedCost = data.estimatedCost;
			}
			callback(estimate);
		}
	});
};

MControlPhoneCampaigns.prototype.getSurvey = function(surveyId){
	var surveyControl = this.manager.getControl("surveys");
	return surveyControl.getSurveyByPropertyName("int_name", surveyId);
};

MControlPhoneCampaigns.prototype.questionCount = function(surveyId){
	var surveyControl = this.manager.getControl("surveys");
	return surveyControl.questionCount(surveyId);
};

MControlPhoneCampaigns.prototype.panels = function(){
	var _pclistMan = new MControlPhoneCampaignsList(this.manager);
	var _slistMan = new MControlListSurveys(this.manager, "phonecampaigns");
	
	return [{
		"id": "campaigns",
		"title":"Campaigns",
		"header": "Phone Campaigns : Campaigns List",
		"control": _pclistMan,
		"docs": {
			"callback": function(){
				_pclistMan.showIntroduction();
			},
			"icon": "sprite-info_shiny",
			"title": "Introduction"
		}
	},{
		"id": "surveys",
		"title":"Surveys",
		"header": "Phone Campaigns : Survey Management",
		"control": _slistMan,
		"docs": {
			"callback": function(){
				_pclistMan.showIntroduction();
			},
			"icon": "sprite-info_shiny",
			"title": "Introduction"
		}
	}];
};

MControlPhoneCampaigns.prototype.getPhoneCampExportFields = function(){
	var dsControl = this.manager.getControl("datasources");
	if(!dsControl.getFieldDetails("VoterTelephones_TelCellFlag", this.universe.datasource)){
		throw new Error("Cell phone boolean does not exist for this datasource");
	}
	return [{
		"int_name": "VoterTelephones_TelCellFlag"
	},{
		"int_name": "LALVOTERID"
	}]
};

MControlPhoneCampaigns.getPhoneOnlyFilters = function(){
	return {
		"VoterTelephones_TelCellFlag": {
			"values": {
				"False": {
					value: 1
				}
			}
		}
	};
};

MControlPhoneCampaigns.prototype.getCampaigns = function(refresh, callback){
	if(!this.campaigns || refresh === true){
		return this.fetchCampaigns(callback);
	}
	callback && callback(this.campaigns);
};

MControlPhoneCampaigns.prototype.fetchCampaigns = function(callback){
	var customer = this.manager.getOption("customer");
	var app = this.manager.getOption("app");
	var self = this;
	return new Moonshadow.Ajax({
		"url": "/phonecampaigns/customerapp/" + customer + "/" + app,
		"type": "GET",
		"execute": true,
		"onSuccess": function(data){
			self.campaigns = data.campaigns || [];
			callback && callback(self.campaigns);
		}
	});
};

MControlPhoneCampaigns.prototype.getStatusCodes = function(callback){
	if(!this.statusCodes){
		var self = this;
		return new Moonshadow.Ajax({
			"url": "/phonecampaigns/statuscodes",
			"type": "GET",
			"execute": true,
			"onSuccess": function(data){
				self.statusCodes = data.codes || [];
				callback && callback(self.statusCodes);
			}
		});
	}
	callback && callback(this.statusCodes);
};

MControlPhoneCampaigns.prototype.initializeCampaign = function(campaign){
	var listControl = this.wizard.getTabControl("campaigns");
	listControl.viewCampaign(campaign);
};

MControlPhoneCampaigns.prototype.submitCampaign = function(campaign, callback){
	campaign.status = 11;
	this.saveCampaign(campaign, callback);
};

MControlPhoneCampaigns.prototype.cancelCampaign = function(campaign, callback){
	campaign.status = -30;
	this.saveCampaign(campaign, callback);
};

MControlPhoneCampaigns.prototype.renewCampaign = function(campaign, callback){
	campaign.status = 0;
	this.saveCampaign(campaign, callback);
};

MControlPhoneCampaigns.prototype.saveCampaign = function(campaign, callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/phonecampaigns",
		"type": "POST",
		"execute": true,
		"payload": campaign,
		"onSuccess": function(data){
			self.manager.dataObservers.notify("campaignschanged", data.campaign);
			callback && callback(data.campaign);
		}
	});
};

MControlPhoneCampaigns.prototype.getCampaignsOfStatusRange = function(statusRange){
	if(!this.campaigns){
		return [];
	}
	var campaigns = [];
	for(var i = 0, l = this.campaigns.length; i < l; ++i){
		var campaign = this.campaigns[i];
		var statusA = statusRange[0];
		var statusB = statusRange[1];
		if((campaign.status >= statusA && campaign.status <= statusB) || $.inArray(campaign.status, statusRange) > -1){
			campaigns.push(this.campaigns[i]);
		}
	}
	return campaigns;
};

MControlPhoneCampaigns.prototype.getCampaign = function(campaignId){
	if(!this.campaigns){
		return [];
	}
	for(var i = 0, l = this.campaigns.length; i < l; ++i){
		if(this.campaigns[i].id == campaignId){
			return this.campaigns[i];
		}
	}
}

MControlPhoneCampaigns.prototype.getFinalCost = function(campaignId){
	var campaign = this.getCampaign(campaignId);
	if(campaign && campaign.details && campaign.details.importresults && campaign.details.importresults.deduction){
		return campaign.details.importresults.deduction.cost;
	}
};


function MControlPhoneCampaignsList(manager) {
	this.manager = manager;
	this.editPanel;
	this.sorter;
	this.surveys;
	this.statusCodes;
	this.activeControl = "all";
	this.creditReadout;
};

MControlPhoneCampaignsList._staticText = {
	"submit": "Submitting your campaign will send the information you have " +
		" supplied to our third party phone campaign partner. After they have " +
		" contacted you, you will no longer be able to edit the survey. Continue? ",
	"submitted": "Your request has been submitted. An email with your information has been sent to " +
		" a third-party service representative who will contact you to finalize and complete the process. ",
	"cancel": "Canceling will notify our third-party service representative automatically. Continue? ",
	"cancelBeforeSubmit": "Would you like to cancel this request? ",
	"newCampInstructions": "Creating a new phone survey/poll campaign starts with providing a few details by filling out the " +
		" following form. Required fields are marked with a red asterisk ( <b class='red'>*</b> ). Some fields have additional " +
		" information provided when clicking the red question mark ( <b class='red'>?</b> ) to the right.",
	"renew": "Renewing will allow you to make edits and resubmit a canceled campaign. Continue? ",
	"universeCheck": "You will need at least one universe to effectively use the phone campaigns interface.",
	"explain": {
		"costEstimate": "This is an estimate based on a number of assumptions and variables such as the number " +
			" of calls that will be answered, average length of calls, number of survey/poll questions answered etc. " +
			" This estimate is provided for the purpose of determining if you have enough credits to start the campaign " +
			" or if you will need to purchase additional credits to begin. <br> " +
			" * The cost per minute rate for audible questions: %cpm% cents <br>" +
			" * The cost per answered question by a respondent: %cpa% cents <br>" +
			" * The estimated average call length per question: %spq% seconds <br>",
		"callerId": "Some phone systems require the caller to have a caller ID phone number displayed to the recipient of a call. " +
			" If you do not wish to have your political campaign’s regular phone number displayed via caller ID then please " +
			" discuss other possible options with the third-party service representative. ",
		"remainingCredit": "To add more credit, please contact a Moonshadow representative. %st0% "
	},
	"intro": {
		"heading": "These are the steps required to create and implement your phone survey/poll campaign:",
		"list": [{
				"title": "Create a phone campaign:",
				"details": "Supply the detailed information needed to track your phone survey/poll campaign’s progress."
			},{
				"title": "Create a phone survey/poll:",
				"details": "Supply the specific questions and possible responses to your phone survey/poll."
			},{
				"title": "Make contact with a representative:",
				"details": "After you have submitted the required information in steps 1 and 2 above, you will be " +
					" contacted by a third-party service representative to complete the final details of your phone survey/poll order."
			},{
				"title": "Await the results:",
				"details": "Your phone survey/poll results will be processed and the responses will automatically " +
					" be added to the VoterMapping side panel."
		}],
		"legal": {
			"header": "Note: When creating your your phone survey/poll campaign be aware that you must comply with the rules, " +
				" regulations and legal guidelines published by the FCC at this link " +
				" <a href='https://apps.fcc.gov/edocs_public/attachmatch/DA-16-264A1.pdf' target='_blank'>" +
				" https://apps.fcc.gov/edocs_public/attachmatch/DA-16-264A1.pdf</a> and any other applicable federal, state and " +
				" local laws and regulations.  In addition, our third-party calling technology provider may also impose certain " +
				" restrictions which the third-party service representative will discuss with you if applicable."
		}
	}
};

MControlPhoneCampaignsList.prototype.checkIntro = function(hasCamps){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	if(!hasCamps && !phoneCampControl.introShown){
		this.showIntroduction(!phoneCampControl.campaignInitialized);
		phoneCampControl.introShown = true;
	}
};

MControlPhoneCampaignsList.prototype.showIntroduction = function(showAddButton, campaign){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var introPanel;
	var instrContent = $(ce("div"))
		.addClass("selectable")
		.append(
			$(ce("span"))
				.append(MControlPhoneCampaignsList._staticText.intro.heading),
			$(ce("ol"))
				.append(
					$.map(MControlPhoneCampaignsList._staticText.intro.list, function(item){
						return $(ce("li"))
							.append(
								$(ce("h3"))
									.append(
										item.title
									),
								$(ce("span"))
									.append(
										item.details
									)
							)
							.get(0);
					})
				),
			$(ce("span"))
				.append(MControlPhoneCampaignsList._staticText.intro.legal.header),
			showAddButton ? $(ce("div"))
				.addClass("phonecamp_intro_button")
				.append(
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Start a New Campaign"
						})
						.on("click", function(){
							self.newCampaign(campaign);
							introPanel.close();
						})
				) : ""
		);
	
	introPanel = new MUILayoverPanel({
		"id": "phone_campaign_instructions", 
		"content": instrContent,
		"title": "Phone Survey/Poll Campaign Introduction",
		"context": this,
		"fixed": false,
		"animate": true,
		"openNow": true,
		"minWidth": 550,
		"maxHeight": 700,
		"scrollable": true,
		"position": {
			"width": 800,
			"height": 500
		}
	});
};

MControlPhoneCampaignsList.prototype.onClose = function(callback){
	this.removeObservers();
	callback(true);
};

MControlPhoneCampaignsList.prototype.addObservers = function(){
	var self = this;
	this.manager.dataObservers.addObserver('campaignschanged', function(event, surveyId){
		self.reBuildList(true);
	}, this);
	this.manager.dataObservers.addObserver('creditfetched', function(){
		self.updateCreditAmount();
	}, this);
};

MControlPhoneCampaignsList.prototype.removeObservers = function(){
	this.manager.dataObservers.removeContext('campaignschanged', this);
	this.manager.dataObservers.removeContext('creditfetched', this);
};

MControlPhoneCampaignsList.prototype.getContent = function(callback){
	callback(
		this.buildPhoneCampsList(),
		this.buildPhoneCampsFooter()
	);
	var self = this;
	this.refreshSurveys(function(){
		self.addObservers();
		self.reBuildList(true);
		self.updateCreditAmount();
	});
};

MControlPhoneCampaignsList.prototype.updateCreditAmount = function(){
	var amount = this.getRemainingCredit();
	if(amount != undefined){
		$(this.creditReadout)
			.empty()
			.append(amount);
	}
};

MControlPhoneCampaignsList.prototype.buildPhoneCampsFooter = function(){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	this.creditReadout = $(ce("span")).append("...");
	var salesPhoneNumber = this.manager.getOption("contact_info.moonshadow.phone"); 
	return $(ce("div"))
		.addClass("camp_credit_readout")
		.append(
			"Available credit: ",
			this.creditReadout,
			$(ce("div"))
				.addClass("ms_question_button available_credit_question_button_adjustment clickable")
				.append("?")
				.on("click", function(){
					self.explain(null, "remainingCredit", [salesPhoneNumber]);
				})
		);
};

MControlPhoneCampaignsList.prototype.refreshSurveys = function(callback){
	var self = this;
	this.getSurveys(function(surveys){
		self.surveys = surveys;
		callback && callback();
	});
};

MControlPhoneCampaignsList.prototype.getSurveys = function(callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.getSurveysOfType("phonecampaigns", false, callback);
}

MControlPhoneCampaignsList.prototype.getAssignableSurveys = function(){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveysByProperties({
		"survey_type": "phonecampaigns",
		"deleted": false
	});
}

MControlPhoneCampaignsList.prototype.newSurvey = function(callback){
	var self = this;
	var surveyControl = new MControlEditSurvey(this.manager);
	surveyControl.newSurvey("phonecampaigns", function(survey){
		self.refreshSurveys(function(){
			callback && callback(survey);
		});
	});
};

MControlPhoneCampaignsList.prototype.reBuildList = function(refresh){
	var self = this;
	this.getStatusCodes(function(statusCodes){
		self.statusCodes = statusCodes;
		self.getCampaigns(refresh, function(campaigns){
			self.filterList(self.activeControl);
			self.checkIntro(campaigns.length);
		});
	});
};

MControlPhoneCampaignsList.prototype.getCampaigns = function(refresh, callback){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	phoneCampControl.getCampaigns(refresh, callback);
};

MControlPhoneCampaignsList.prototype.getStatusCodes = function(callback){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	phoneCampControl.getStatusCodes(callback);
};

MControlPhoneCampaignsList.prototype.getCampaignsOfStatusRange = function(statusRange){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	return phoneCampControl.getCampaignsOfStatusRange(statusRange);
};

MControlPhoneCampaignsList.prototype.getRemainingCredit = function(){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	return phoneCampControl.getRemainingCredit();
};

MControlPhoneCampaignsList.prototype.canBeSubmitted = function(campaign, callback){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	return phoneCampControl.canBeSubmitted(campaign, callback);
};

MControlPhoneCampaignsList.prototype.getEstimatedCosts = function(campaign, refresh, callback){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	return phoneCampControl.getEstimatedCosts(campaign, refresh, callback);
};

MControlPhoneCampaignsList.prototype.buildPhoneCampsList = function(){
	var ce = Moonshadow.helpers.ce;
	this.buildSorter();
	return [
		this.sorter.sorterCont.get(0),
		this.sorter.container.get(0)
	];
};

MControlPhoneCampaignsList.prototype.controlButtons = function(){
	var self = this;
	if(!this.buttons){
		this.buttons = [{
			"id": "all",
			"title": "All",
			"filter": true,
			"action": function(){
				self.filterList();
			}
		},{
			"id": "saved",
			"title": "Saved",
			"filter": true,
			"action": function(){
				self.filterList("saved");
			}
		},{
			"id": "processing",
			"title": "Processing",
			"filter": true,
			"action": function(){
				self.filterList("processing");
			}
		},{
			"id": "finished",
			"title": "Finished",
			"filter": true,
			"action": function(){
				self.filterList("finished");
			}
		},{
			"id": "other",
			"title": "Other",
			"filter": true,
			"action": function(){
				self.filterList("other");
			}
		},{
			"id": "new",
			"title": "New Campaign",
			"right": true,
			"filter": false,
			"action": function(){
				self.newCampaign();
			}
		}];
	};
	return this.buttons;
};

MControlPhoneCampaignsList.prototype.buildSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("campaign_list scrollable");
	
	var sorter = $(ce("div"))
		.addClass("campaign_list_columns");
	
	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".campaign_list_item",
		"sortFunctions": {
			"status": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_status", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_status", b).text().toLowerCase();
				var val1 = this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
				if(val1 == 0){
					return this.sortFunctions.campaign_name.apply(this, [a, b, 1]);
				}
				return val1;
			},
			"campaign_name": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_campaign_name", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_campaign_name", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			},
			"date_modified": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_date_modified", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_date_modified", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			},
			"date_created": function(a, b, sortorder){
				var avalue = $(".sortable_data_column_date_created", a).text().toLowerCase();
				var bvalue = $(".sortable_data_column_date_created", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			},
			"stringSort": MUIFilterableSorter.predefinedSorting.stringSort,
			"returnVal": MUIFilterableSorter.predefinedSorting.returnVal
		},
		"columnSettings": [{
	 		"value": "Status",
	 		"sortby": "status",
	 		"float": "right",
 		},{
	 		"value": "Date Modified",
	 		"sortby": "date_modified",
	 		"float": "right",
 		},{
	 		"value": "Date Created",
	 		"sortby": "date_created",
	 		"float": "right",
 		},{
	 		"spacer": "view_button",
	 		"float": "right",
 		},{
 			"spacer": "scroller_spacer",
 			"float": "right"
 		},{
	 		"value": "Campaign Name",
	 		"sortby": "campaign_name",
	 		"sortdefault": true
 		}],
		"sorterContainerClassName": "sortcampaigns",
		"sorterContainer": sorter,
		"columnDataContainer": container,
		"expandingContainer": true,
	});
	
	colsorter.makeColumnSorter(true);
	
	this.sorter = {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	}; 
};

MControlPhoneCampaignsList.prototype.fillList = function(campaigns){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var _button = function(title, callback, campaign){
		return $(ce("input"))
			.attr({
				"type": "button",
				"value": title
			})
			.on("click", function(){
				callback.call(self, campaign);
			});
	};

	$(this.sorter.container)
		.empty()
		.append(
			$.map(campaigns, function(campaign){
				var campObj = {
					"campaign_name": campaign.name,
					"view_button": $(ce("div"))
						.append(
							campaign.status === 0 
								? _button("Edit", self.editCampaign, campaign) 
								: _button("View", self.viewCampaign, campaign),
							campaign.status === 0 
								? _button("Submit", self.submitCampaign, campaign)
								: "",
							campaign.status === 10 || campaign.status === 11 
								? _button("Cancel", self.cancelCampaign, campaign)
								: "",
							campaign.status === -30 
								? _button("Renew", self.renewCampaign, campaign)
								: ""
						),
					"status": $(ce("span"))
						.attr({
							"title": self.statusCodes[campaign.status].description || "Unknown"
						})
						.append(self.statusCodes[campaign.status].name || "Unknown"),
					"date_modified": Moonshadow.helpers.hrDate(campaign.date_modified),
					"date_created": Moonshadow.helpers.hrDate(campaign.date_created)
				};
				return $(self.sorter.sorterObj.getDataRow(campObj).row).get(0)
			})
		);
	
	if(!campaigns.length){
		var stText = this.activeControl;
		if(stText == "all"){
			stText = "";
		}
		$(this.sorter.container)
			.append(
				$(ce("div"))
					.addClass("campaign_list_empty")
					.append("There are currently no "+stText+" campaigns.")
			)
	}
};

MControlPhoneCampaignsList.prototype.filterList = function(type){
	var statusRanges;
	switch(type){
		case "saved": 
			statusRanges = [0, 0];
			this.activeControl = "saved";
			break;
		case "processing":
			statusRanges = [10, 50];
			this.activeControl = "processing";
			break;
		case "finished":
			statusRanges = [60, 60];
			this.activeControl = "finished";
			break;
		case "other":
			statusRanges = [-50, -10];
			this.activeControl = "other";
			break;
		default:
			this.activeControl = "all";
			statusRanges = [-50, 60];
	}
	
	this.fillList(
		this.getCampaignsOfStatusRange(statusRanges)
	);
	
	this.sorter.sorterObj.refreshSort();
};

MControlPhoneCampaignsList.prototype.saveCampaign = function(panel, callback){
	var self = this;
	var info = this.gatherAndValidateFields(panel);
	if(info){
		var phoneCampControl = this.manager.getControl("phonecampaigns");
		return phoneCampControl.saveCampaign(info, callback);
	}
};

MControlPhoneCampaignsList.prototype.saveAndSubmit = function(panel, callback){
	var self = this;
	this.saveCampaign(panel, function(campaign){
		if(campaign){
			return self.submitCampaign(campaign, function(){
				callback(true);
			});
		}
		callback();
	});
};

MControlPhoneCampaignsList.prototype.submitCampaign = function(campaign, callback){
	var self = this;
	var displayConfirmation = function(){
		MUILayoverPanel.confirm({
			"title": "Submit Phone Campaign",
			"message": MControlPhoneCampaignsList._staticText.submit,
			"callback": function(res, id, hide){
				if(res){
					var phoneCampControl = self.manager.getControl("phonecampaigns");
					return phoneCampControl.submitCampaign(campaign, function(){
						MUILayoverPanel.alert({
							"message": MControlPhoneCampaignsList._staticText.submitted,
							"callback": function(r, i, h){
								h(); hide(); callback && callback();
							}
						});
					});
				}
				hide();
			}
		});
	};
	
	this.canBeSubmitted(campaign, function(results){
		if(!results.valid){
			return MUILayoverPanel.alert(results.message);
		}
		
		displayConfirmation();
	});
};

MControlPhoneCampaignsList.prototype.cancelCampaign = function(campaign, before, callback){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var _buttons = ["Yes", "No"];
	MUILayoverPanel.confirm({
		"title": "Cancel Phone Campaign Submission?",
		"message": before 
			? MControlPhoneCampaignsList._staticText.cancelBeforeSubmit
			: MControlPhoneCampaignsList._staticText.cancel,
		"buttons": _buttons,
		"callback": function(res, id, hide, buttonVal){
			var canceled = buttonVal == _buttons[0];
			if(canceled && !before){
				var phoneCampControl = self.manager.getControl("phonecampaigns");
				phoneCampControl.cancelCampaign(campaign, callback);
			}
			callback && callback(canceled);
			hide();
		}
	});
}

MControlPhoneCampaignsList.prototype.renewCampaign = function(campaign, callback){
	var self = this;
	MUILayoverPanel.confirm({
		"title": "Renew Phone Campaign?",
		"message": MControlPhoneCampaignsList._staticText.renew,
		"callback": function(res, id, hide){
			if(res){
				var phoneCampControl = self.manager.getControl("phonecampaigns");
				phoneCampControl.renewCampaign(campaign, callback);
			}
			hide();
		}
	});
}

MControlPhoneCampaignsList.prototype.gatherAndValidateFields = function(panel){
	var info = {};
	var messages = "";
	$(".invalid", panel).removeClass("invalid");
	
	var nameElem = $(".phone_campaign_name", panel);
	info.name = $(nameElem).val();
	if(!info.name){
		$(nameElem).addClass("invalid");
		messages += "<br>Please provide a name for the campaign.";
	}
	
	var universeIdElem = $(".phone_campaign_universe_id", panel);
	info.universe_id = $(universeIdElem).val();
	if(!info.universe_id){
		$(".campaign_chosen_universe", panel).addClass("invalid");
		messages += "<br>Please choose a target universe for the campaign.";
	}
	
	var surveyIdElem = $(".survey_id", panel);
	if(!surveyIdElem.length){
		messages += "<br>Please create a survey to present to the respondent.";
	}else{
		info.survey_id = $(surveyIdElem).val();
		if(info.survey_id == "Choose a Survey"){
			$(surveyIdElem).addClass("invalid");
			messages += "<br>Please choose a survey to present to the respondent.";
		}
	}

	//stored details validation and gathering
	info.details = {};
	
	var contactPhone = $(".contact_phone", panel).val();
	contactPhone && (info.details.contact_phone = contactPhone);
	
	var webSite = $(".website", panel).val();
	webSite && (info.details.website = webSite);
	
	var universeName = $(".phone_campaign_universe_name", panel).val();
	universeName && (info.details.universe_name = universeName);
	
	var launchDate = $(".launch_date", panel).val();
	launchDate && (info.details.launch_date = launchDate);
	
	var voiceGender = $(".voice_gender::checked", panel).val();
	voiceGender && (info.details.voice_gender = voiceGender);
	
	var contactName = $(".contact_name", panel);
	info.details.contact_name = $(contactName).val();
	if(!info.details.contact_name){
		$(contactName).addClass("invalid");
		messages += "<br>Please provide the name of the contact person in your organization.";
	}
	
	var callerIdElem = $(".caller_id_number", panel);
	info.details.caller_id_number = $(callerIdElem).val();
	if(!info.details.caller_id_number){
		$(callerIdElem).addClass("invalid");
		messages += "<br>Please provide a caller ID phone number for the campaign.";
	}
	
	var companyName = $(".company_name", panel);
	info.details.company_name = $(companyName).val();
	if(!info.details.company_name){
		$(companyName).addClass("invalid");
		messages += "<br>Please provide an identification for your organization.";
	}
	
	var contactEmail = $(".email_contact", panel);
	info.details.email = $(contactEmail).val();
	if(!info.details.email){
		$(contactEmail).addClass("invalid");
		messages += "<br>Please provide a contact email address.";
	}

	var voiceSource = $(".voice_source::checked", panel);
	info.details.voice_source = $(voiceSource).val();
	if(!info.details.voice_source){
		$(voiceSource).addClass("invalid");
		messages += "<br>Please provide a preference for the voice.";
	}
	
	if(messages){
		MUILayoverPanel.alert({
			"title": "Please correct the following issues:",
			"message": messages
		});
		return false;
	}
	
	info.details.survey_name = $(".survey_name", panel).val();
	info.description = $(".phone_campaign_desc", panel).val();
	info.total_records = parseInt($(".phone_campaign_total_records", panel).val(), 10);
	info.id =  $(".phone_campaign_id", panel).val();
	info.status = $(".phone_campaign_status", panel).val() || "0";
	return info;
};

MControlPhoneCampaignsList.prototype.viewCampaign = function(campaign){
	if(campaign.id == undefined){
		return this.newCampaign(campaign);
	}
	this.editCampaign(campaign, "view");
};

MControlPhoneCampaignsList.prototype.newCampaign = function(campaign){
	if(!this.hasUniversesCheck()){
		return;
	}
	this.editCampaign(campaign, "new");
};

MControlPhoneCampaignsList.prototype.hasUniversesCheck = function(){
	var universeFilterableControl = this.manager.getUniverseControl();
	var universeCount = universeFilterableControl.getNumChildren();
	if(!universeCount){
		MUILayoverPanel.alert({
			"title": "Note",
			"message": MControlPhoneCampaignsList._staticText.universeCheck
		});
		return false;
	}
	return true;
};

MControlPhoneCampaignsList.prototype.getUniverseInfo = function(universeId){
	var universeFilterableControl = this.manager.getUniverseControl();
	var universes = universeFilterableControl.getChildrenByAttribute("int_name", universeId);
	return universes[universeId];
};

MControlPhoneCampaignsList.prototype.chooseUniverse = function(callback){
	var ce = Moonshadow.helpers.ce;
	var universeFilterableControl = this.manager.getUniverseControl();
	
	var resultsPanel = $(ce("div"))
		.addClass("phone_campaign_universe_chooser_results scrollable");
	
	var buildResults = function(name){
		$(resultsPanel)
			.empty();
		var list;
		if(!name){
			list = universeFilterableControl.getLatestChildren();
		}else{
			list = universeFilterableControl.searchChildrenByNameBriefList(name, ["purchased", "path"]);
		}
		$(resultsPanel)
			.append(
				$.map(list, function(universe, id){
					return $(ce("div"))
						.addClass("phone_campaign_universe_chooser_item clickable")
						.append(
							$(ce("div"))
								.addClass("phone_campaign_universe_chooser_item_total")
								.append(universe.purchased),
							$(ce("div"))
								.addClass("phone_campaign_universe_chooser_item_path")
								.append((!universe.path || universe.path == "__default") ? "&nbsp;" : universe.path),
							$(ce("div"))
								.addClass("phone_campaign_universe_chooser_item_name")
								.append(universe.ext_name)
						)
						.on("click", function(){
							callback(universe);
							chooserLayover.close();
						})
						.get(0)
				})
			)
	};
	
	var fieldUi = MUIFormElements.textField("Type universe name to search", "", false, "phone_campaign_universe_chooser_search");
	var fieldInput = $(".phone_campaign_universe_chooser_search", fieldUi)
		.on("keyup", function(){
			buildResults(this.value);
		});
	
	var chooseUi = $(ce("div"))
		.addClass("phone_campaign_universe_chooser_panel")
		.append(
			fieldUi,
			$(ce("div"))
				.addClass("phone_campaign_universe_chooser_results_header")
				.append(
					$(ce("div"))
						.addClass("ms_text_field_small_label phone_campaign_universe_chooser_item_total_header")
						.append("Total Purchased"),
					$(ce("div"))
						.addClass("ms_text_field_small_label phone_campaign_universe_chooser_item_path_header")
						.append("Folder"),
					$(ce("div"))
						.addClass("ms_text_field_small_label phone_campaign_universe_chooser_item_name_header")
						.append("Universe Name")
				),
			resultsPanel
		);
	
	var chooserLayover = MUILayoverPanel.confirm({
		"title": "Choose a Universe",
		"message": chooseUi,
		"buttons": ["Cancel"],
		"onOpen": function(){
			$(fieldInput).focus();
			buildResults();
		}
	});
}

MControlPhoneCampaignsList.prototype.updateEstimateAndCredit = function(campaign){
	this.getEstimateAndCredit(campaign, true);
};

MControlPhoneCampaignsList.prototype.getEstimateAndCredit = function(campaign, refresh){
	var self = this;
	this.getEstimatedCosts(campaign, refresh, function(estimatedCost){
		campaign.estimatedCost = estimatedCost
		$(".campaign_estimated_cost", self.editPanel.container)
			.empty()
			.append(estimatedCost);
		$(".campaign_remaining_credit", self.editPanel.container)
			.empty()
			.append(self.getRemainingCredit());
	});
};

MControlPhoneCampaignsList.prototype.explainEstimate = function(campaign){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	var cpa = phoneCampControl.costPerAnswer;
	var cpm = phoneCampControl.costPerMinute;
	var spq = phoneCampControl.avgSecondsPerQuestion;
	var message = MControlPhoneCampaignsList._staticText.explain.costEstimate;
	message = message.replace("%cpa%", cpa);
	message = message.replace("%cpm%", cpm);
	message = message.replace("%spq%", spq);
	MUILayoverPanel.alert(message);
};

MControlPhoneCampaignsList.prototype.explain = function(campaign, key, strings){
	var phoneCampControl = this.manager.getControl("phonecampaigns");
	var message = MControlPhoneCampaignsList._staticText.explain[key];
	if(strings){
		for(var i = 0, l = strings.length; i < l; ++i){
			message = message.replace("%st" + i + "%", strings[i]);
		}
	}
	message && MUILayoverPanel.alert(message);
};

MControlPhoneCampaignsList.prototype.editCampaign = function(campaign, editType){
	if(campaign == undefined){
		campaign = {};
	}
	if(campaign.details == undefined){
		campaign.details = {};
	}
	
	var ce = Moonshadow.helpers.ce;
	var self = this;

	var editable = (campaign.status == undefined || campaign.status === 0) && editType != "view";
	
	var _name = function(){
		//title, value, required, className, events, attr, addClear
		return MUIFormElements.textField("Campaign Name:", campaign.name, true, "phone_campaign_name");
	};
	
	var _desc = function(){
		return MUIFormElements.textArea("Campaign Description:", campaign.description, false, "phone_campaign_desc");
	};
	
	var _surveyName = $(ce("input"))
		.addClass("survey_name")
		.attr({
			"type": "hidden",
			"name": "survey_name",
			"value": campaign.details.survey_name
		});
	
	var _surveySelect = function(selected){
		var surveys = self.getAssignableSurveys();
		
		if(surveys && surveys.length){
			
			var options = $.map(surveys, function(survey){
				return {
					"value": survey.int_name,
					"selected": (selected && selected == survey.int_name) || campaign.survey_id == survey.int_name,
					"name": survey.ext_name
				}
			}); 
				
			options.unshift({
				"name": "Choose a Survey"
			});
			
			return MUIFormElements.select("Survey:", options, true, "survey_id", {
				"change": function(){
					$(_surveyName).val($("option:selected", this).text());
					campaign.survey_id = this.value;
					self.updateEstimateAndCredit(campaign);
				}
			});
		}
		return "";
	}
	
	var _survey = _surveySelect();
	
	var _newsurvey = $(ce("div"))
		.addClass("edit_campaign_item")
		.append(
			$(ce("input"))
				.attr({
					"type": "button",
					"value": "Create a New Survey"
				})
				.on("click", function(){
					self.newSurvey(function(survey){
						$(_survey).replaceWith(_surveySelect(survey.int_name));
						$(_surveyName).val(survey.ext_name);
					});
				}),
			$(ce("br")),
			$(ce("br"))
		);
	
	var _universeId = $(ce("input"))
		.addClass("phone_campaign_universe_id")
		.attr({
			"type": "hidden",
			"name": "universe_id",
			"value": campaign.universe_id
		});
	
	var _universeName = $(ce("input"))
		.addClass("phone_campaign_universe_name")
		.attr({
			"type": "hidden",
			"name": "universe_name",
			"value": campaign.details.universe_name
		});
	
	var _totalRecords = $(ce("input"))
		.addClass("phone_campaign_total_records")
		.attr({
			"type": "hidden",
			"name": "total_records",
			"value": campaign.total_records
		});
	
	var universeChooser = function(){
		var universe = self.getUniverseInfo(campaign.universe_id);

		var fieldsUi = $(ce("div"))
			.addClass("phone_campaign_universe_chooser edit_campaign_item_fields");
		
		var fillUniverseInfoFields = function(universe){
			$(fieldsUi)
				.empty()
				.append(
					MUIFormElements.textReadout("Universe:", (universe && universe.ext_name) || "&nbsp;", true, "campaign_chosen_universe"),
					MUIFormElements.textReadout("Total Records:", (universe && universe.purchased) || "&nbsp;", false, "phone_campaign_total_records")
				);
		};
		fillUniverseInfoFields(universe);
		
		var cont = $(ce("div"))
			.addClass("phone_campaign_universe_chooser edit_campaign_item")
			.append(
				fieldsUi
			);
		
		if(editable){
			$(cont).append(
				$(ce("input"))
					.attr({
						"type": "button",
						"value": universe && universe.ext_name ? "Change Universe" : "Choose Universe"
					})
					.on("click", function(){
						self.chooseUniverse(function(universe){
							fillUniverseInfoFields(universe);
							$(_universeId).val(universe.int_name);
							$(_universeName).val(universe.ext_name);
							$(_totalRecords).val(universe.purchased);
							campaign.total_records = universe.purchased;
							self.updateEstimateAndCredit(campaign);
						});
					}),
				$(ce("br")),
				$(ce("br"))
			);	
		}

		return cont;
	};
	
	//stored details
	var customerInfo = this.manager.getOption("customer_details");
	var caller_id_number = campaign.details.caller_id_number
		|| (customerInfo && customerInfo.billing && customerInfo.billing.phone1);
	var contactPhone = campaign.details.contact_phone 
		|| (customerInfo && customerInfo.billing && customerInfo.billing.phone1);
	var email = campaign.details.email
		|| (customerInfo && customerInfo.email);
	var website = campaign.details.website || null;
	var launchDate = campaign.details.launch_date || null;
	var contactName = campaign.details.contact_name 
		|| (customerInfo && customerInfo.billing && customerInfo.billing.last_name) 
		? customerInfo.billing.first_name + " " + customerInfo.billing.last_name : null;
	var companyName = campaign.details.company_name || this.manager.getOption("customer_display");
	
	var voiceSource = campaign.details.voice_source || "rep";
	var voiceGender  = campaign.details.voice_gender || "male";
	
	var _callerId = function(){
		return MUIFormElements.elem({
			"type": "textField",
			"title": "Caller ID phone number:",
			"value": caller_id_number, 
			"required": true, 
			"className":"caller_id_number",
			"questionButton": {
				"events": {
					"click": function(){
						self.explain(campaign, "callerId");
					}
				}
			}
		});
	};
	
	var _email = function(){
		return MUIFormElements.textField("Email Address:", email, true, "email_contact");
	};

	var _contactPhone = function(){
		return MUIFormElements.textField("Phone #:", contactPhone, false, "contact_phone");
	};
	
	var _webSite = function(){
		return MUIFormElements.textField("Website:", website, false, "website");
	};
	
	var _launchDate = function(){
		var minDate = Moonshadow.helpers.hrDate(new Date(), true);
		return MUIFormElements.elem({
			"type": "dateField",
			"title": "Launch Date:", 
			"value": launchDate,
			"className": "launch_date",
			"minDate": minDate
		});
	};
	
	var _contactName = function(){
		return MUIFormElements.textField("Full Contact Name:", contactName, true, "contact_name");
	};
	
	var _companyName = function(){
		return MUIFormElements.textField("Organization Name:", companyName, true, "company_name");
	};
	
	var _voiceSource = function(){
		var list = [
			{
				"title": "I will create my own voice recording",
				"value": "user",
				"checked": voiceSource == "user"
			},
			{
				"title": "I want the third-party service representative to create the voice recording",
				"value": "rep",
				"checked": voiceSource == "rep"
			}
		];
		return MUIFormElements.radioButtons("Who will create the voice recording for your phone survey/poll?", 
			list, true, "voice_source", null, null, "voice_source");
	};
	
	var _voiceGender = function(){
		var list = [
			{
				"title": "Male",
				"value": "male",
				"checked": voiceGender == "male"
			},
			{
				"title": "Female",
				"value": "female",
				"checked": voiceGender == "female"
			}
		];
		return MUIFormElements.radioButtons("If you want the third-party service representative to create the voice recording, do you prefer a male or female voice?", 
			list, false, "voice_gender", null, null, "voice_gender");
	};
	
	var _costEstimate = function(){
		return MUIFormElements.elem({
			"type": "textReadout",
			"title": "Estimated Maximum Cost in Campaign Credits:",
			"value": "&nbsp;", 
			"required": false, 
			"className":"campaign_estimated_cost",
			"questionButton": {
				"events": {
					"click": function(){
						self.explainEstimate(campaign);
					}
				}
			}
		});
	};
	
	var _costs = function(){
		if(campaign.status != 60){
			return "";
		}
		var phoneCampControl = self.manager.getControl("phonecampaigns");
		var cost = phoneCampControl.getFinalCost(campaign.id);
		return MUIFormElements.textReadout("Actual Cost in Campaign Credit:", cost || "&nbsp;", false, "campaign_actual_cost");
	};
	
	var salesPhoneNumber = this.manager.getOption("contact_info.moonshadow.phone"); 
	
	var _remainingCredit = function(){
		return MUIFormElements.elem({
			"type": "textReadout",
			"title": "Remaining Campaign Credit:",
			"value": "&nbsp;", 
			"required": false, 
			"className":"campaign_remaining_credit",
			"questionButton": {
				"events": {
					"click": function(){
						self.explain(campaign, "remainingCredit", [salesPhoneNumber]);
					}
				}
			}
		});
	};
	
	var detailsUI;
	if(editType == "new"){
		detailsUI = $(ce("div"))
			.append(
				$(ce("div"))
					.addClass("phonecamp_content_header")
					.append(MControlPhoneCampaignsList._staticText.newCampInstructions),
				$(ce("ol"))
					.addClass("phonecamp_content_guided_list")
					.append(
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Enter a name and optional description for this phone survey/poll campaign:"), 
								_name(),
								_desc()
							),
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Click on “Choose Universe” to select a universe for this phone survey/poll campaign:"), 
								universeChooser()
							),
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Choose an existing survey from the pull-down list or click on “Create a New Survey” to create a new survey."), 
								_survey,
								_newsurvey,
								_costEstimate(),
								_remainingCredit()
							),
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Enter your organization’s name, a Caller ID phone number that will be displayed when survey/poll " +
								" respondents are called, and your organization’s website address."),
								_companyName(),
								_callerId(),
								_webSite()
							),
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Caller's voice:"),
								_voiceSource(),
								_voiceGender()
							),
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Contact details for any questions from Moonshadow or the third-party service representative regarding this phone survey/poll:"),
								_contactName(),
								_email(),
								_contactPhone()
							),
						$(ce("li"))
							.append(
								$(ce("span"))
									.append("Choose a launch date or leave blank if you wish to discuss with a representative first."), 
								_launchDate()
							),
						$(ce("li"))
							.append(
								"Submit your campaign by clicking the “Save/Submit” button or save your progress to be completed later by clicking on the “Save” button."
							)
					)
			);
	}else{
		detailsUI = $(ce("div"))
			.addClass("phonecamp_content_edit_container")
			.append(
				_name(), _desc(), universeChooser(), _survey, editable ? _newsurvey : "", _costEstimate(),
				_costs(), _remainingCredit(), _companyName(), _callerId(), _webSite(), _voiceSource(), 
				_voiceGender(), _contactName(),	_email(), _contactPhone(), _launchDate()
			);
	}
	
	var campaignDetailsUI = $(ce("div"))
		.addClass("phonecamp_content_container scrollable")
		.append(
			campaign.id ? $(ce("input"))
				.addClass("phone_campaign_id")
				.attr({
					"type": "hidden",
					"name": "id",
					"value": campaign.id
				}) : "",
			$(ce("input"))
				.addClass("phone_campaign_status")
				.attr({
					"type": "hidden",
					"name": "status",
					"value": campaign.status !== undefined ? campaign.status : 0
				}),
			_universeId,
			_universeName,
			_surveyName,
			_totalRecords,
			detailsUI
		);

	if(editable){
		campaignDetailsUI.append(
			$(ce("div"))
				.addClass("phonecamp_content_container_submit")
				.append(
					campaign && $(ce("input"))
						.attr({
							"type": "button",
							"value": "Cancel"
						})
						.on("click", function(){
							self.cancelCampaign(campaign, (!campaign.status || campaign.status == 10 || campaign.status == 11), function(canceled){
								if(canceled){
									self.editPanel.close();
								}
							});
						}),
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Save"
						})
						.on("click", function(){
							self.saveCampaign(campaignDetailsUI, function(){
								self.editPanel.close();
							});
						}),
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Save / Submit"
						})
						.on("click", function(){
							self.saveAndSubmit(campaignDetailsUI, function(){
								self.editPanel.close();
							});
						})
				)
		);
	}

	if(!editType){
		editType = "edit";
	}
	
	var title = "Edit Phone Survey/Poll Campaign: " + campaign.name;
	if(editType == "view"){
		title = "View Phone Survey/Poll Campaign: " + campaign.name;
		$(campaignDetailsUI).addClass("disabled_gray");
		$("input, textarea, select", campaignDetailsUI).attr({
			"disabled": true
		});
	}
	if(editType == "new"){
		title = "Create New Phone Survey/Poll Campaign";
	}
	
	this.editPanel = new MUILayoverPanel({
		"id": "edit_campaign", 
		"content": campaignDetailsUI,
		"title": title,
		"onClose": function(callback){
			callback(true);
		},
		"onOpen": function(){
			self.getEstimateAndCredit(campaign);
		},
		"context": this,
		"fixed": false,
		"animate": true,
		"openNow": true,
		"minWidth": 550,
		"maxHeight": 700,
		"position": {
			"width": 800,
			"height": 500
		},
		"docs": {
			"callback": function(){
				self.showIntroduction();
			},
			"icon": "sprite-info_shiny",
			"title": "Introduction"
		}
	});
};



function MControlTriplets(options) {
	this.name = "triplets";
	this.position = 6;
	this.manager = null;
	this.options = options || {};
	this.transactionId = 0;
}

MControlTriplets.prototype = new MControl;

MControlTriplets.prototype.init = function(manager) {
	this.manager = manager;

	this.show();
};

/**
 * Get all values, color, counts for a filterable
 *
 * @method getTriplets
 */
MControlTriplets.prototype.getTriplets = function(pairs, callback) {
	var datasourceControl = this.manager.getControl('datasources');
	var colorsControl = this.manager.getControl('colors');
	var countsControl = this.manager.getControl('countsmodel');

	var triplets = {};

	for (var i = 0, l = pairs.length; i < l; i++) {
		var pair = pairs[i];
		var dsId = pair[0];
		var path = pair[1];
	
		var values = datasourceControl.getValues(dsId, path);
		if (!values) {
			throw new Error('Values not found');
		}
		
		var colors = colorsControl.getColorsForField(dsId, path);

		var triplet = {
			'id': [dsId, path].join(':'),
			'triplets': []
		};

		for (var ii = 0, ll = values.length; ii < ll; ii++) {
			var value = values[ii];

			triplet.triplets.push({
				'value': value,
				'color': colors[value],
				'count': null
			});
		}

		if (!triplets[dsId]) {
			triplets[dsId] = {};
		}
	
		triplets[dsId][path] = triplet;
	}

	var onCounts = function(response) {
		if (response.result !== 'ok') {
			callback(new Error('Problem getting triplet count data'));
		}

		var dsId = response.ds;
		var stats = response.stats;
		for (var i = 0, l = stats.length; i < l; i++) {
			var stat = stats[i];
			var result = stat.filter_result;
			var path = stat.filter_tree.slice();

			var pathString = [];
			
			for (var ii = 0, ll = path.length; ii < ll; ii++) {
				pathString.push(path[ii].join('|'));
			}

			pathString.push(stat.filter_name);
			pathString = pathString.join('|');
			
			var triplet = triplets[dsId][pathString];
			for (var ii = 0, ll = triplet.triplets.length; ii < ll; ii++) {
				var t = triplet.triplets[ii];
				t.count = result[t.value] || 0;
			}						
		}

		var results = [];

		for (var dsId in triplets) {
			var dsTriplets = triplets[dsId];
			for (var path in dsTriplets) {
				var triplet = dsTriplets[path];

				for (var i = 0, l = triplet.triplets.length; i < l; i++) {
					if (triplet.triplets[i].count === null) {
						return;
					}
				}

				results.push(triplet);
			}
		}

		

		callback(null, results);
	};

	countsControl.getCountsForPairs(pairs, onCounts, this);
};

/**
 *
 * @method show
 */
MControlTriplets.prototype.show = function() {};

/**
 *
 * @method hide
 */
MControlTriplets.prototype.hide = function() {};

MControlTriplets.prototype.processListener = function(dsId, path, listener, context) {
	return {
		'ds': dsId,
		'field': path,
		'listener': listener,
		'context': context
	};
};

MControlTriplets.prototype.isAlreadyListening = function(listener) {
	if (!this.datasources[listener.ds]) {
		return false;
	}

	if (!this.datasources[listener.ds][listener.field]) {
		return false;
	}

	var listeners = this.datasources[listener.ds][listener.field];
	for(var i = 0, l = listeners.length; i < l; i++) {
		var item = listeners[i];

		if (this.compareListeners(item, listener)) {
			return true;
		}
	}

	return false;
};

MControlTriplets.prototype.compareListeners = function(a, b) {
	return (a.ds === b.ds && a.field === b.field && a.listener === b.listener 
			&& a.context === b.context);
};
/**
 * Control for showing stats
 *
 * @class MControlStatsUI
 * @module Moonshadow.Controls
 * @extends MControl
 * @constrcutor
 */ 
function MControlStatsUI() {
	this.name = 'statsui';
	this.position = 6;
	this.options = {};

	this.container = false;
	this.manager = null;
};

MControlStatsUI.prototype.init = function(manager) {
	this.manager = manager;

	this.container = this.buildUI();

	this.manager.getAdapter().addControlToMap(this, true);
};

MControlStatsUI.prototype.buildUI = function() {
	var container = document.createElement('div');
	container.className = 'statsuicontrol';
	container.id = this.name;

	var listHead = document.createElement('div');
	listHead.className = 'list-head';
	
	var headType = document.createElement('div');
	headType.className = 'column type';
	headType.appendChild(document.createTextNode('Query'));

	var headEphemeris = document.createElement('div');
	headEphemeris.className = 'column ephemeris';
	headEphemeris.appendChild(document.createTextNode('Ephemeris'));

	var headLatency = document.createElement('div');
	headLatency.className = 'column latency';
	headLatency.appendChild(document.createTextNode('Latency'));


	listHead.appendChild(headType);
	listHead.appendChild(headEphemeris);
	listHead.appendChild(headLatency);

	container.appendChild(listHead);
	
	var statsList = document.createElement('div');
	statsList.className = 'list';

	container.appendChild(statsList);

	return container;
};		

MControlStatsUI.prototype.onStats = function(event, data) {
	var requestTime = data.requestTime;
	var queries = data.queries;
	var list = $('.statsuicontrol .list')[0];

	for (var i = 0, l = queries.length; i < l; i++) {
		var query = queries[i];
		var item = this.buildListItem(requestTime, query.type, query.time);		
		list.appendChild(item);
	}

	list.scrollTop = list.scrollHeight;
};

MControlStatsUI.prototype.buildListItem = function(requestTime, queryType, 
												   queryTime) {
	var item = document.createElement('div');
	item.className = 'item';

	var typeText = queryType;

	var columnType = document.createElement('div');
	columnType.className = 'column type';
	columnType.setAttribute('title', typeText);
	columnType.appendChild(document.createTextNode(typeText));
	
	var ephemerisText = [queryTime.toFixed(2), 'ms'].join(' ');

	var columnEphemeris = document.createElement('div');
	columnEphemeris.className = 'column ephemeris';
	columnEphemeris.appendChild(document.createTextNode(ephemerisText));

	var latency = requestTime;
	var latencyText = [latency.toFixed(2), 'ms'].join(' ')

	var columnLatency = document.createElement('div');
	columnLatency.className = 'column latency';
	columnLatency.appendChild(document.createTextNode(latencyText));

	item.appendChild(columnType)
	item.appendChild(columnEphemeris)
	item.appendChild(columnLatency);

	return item;
};

MControlStatsUI.prototype.onCloseButtonClick = function() {
	this.hide();
};

MControlStatsUI.prototype.isShown = function() {
	return this.container.style.display === 'block';
};

MControlStatsUI.prototype.show = function() {
	this.container.style.display = 'block';

	var statsHandler = this.manager.getStatsHandler();
	statsHandler.addListener(this.onStats, this);
};

MControlStatsUI.prototype.hide = function() {
	this.container.style.display = 'none';

	$('.statsuicontrol .list').empty();

	var statsHandler = this.manager.getStatsHandler();
	statsHandler.removeListener(this.onStats, this);
};







function MControlSurveyAssignment(manager) {
	this.manager = manager;
	this.sorter;
	this.displayLoading = true;
	this.openPanel;
	this.docs = {
		"url": Moonshadow.gg_tutorials,
		"icon": "sprite-tutorial tut_icon",
		"title": "Ground Game Tutorials"
	};
};

MControlSurveyAssignment.prototype.getContent = function(callback){
	callback(this.buildUniverseList());
	var self = this;
	this.getUniverses(function(universes){
		self.fillList(universes);
		if(self.openPanel){
			self.openPanel.loadIndicator(false);
		}
	});
};

MControlSurveyAssignment.prototype.buildSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("survey_list_universe scrollable");
	
	var sorter = $(ce("div"))
		.addClass("universe_list_columns");
	
	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".survey_list_universe_item",
		"sortFunctions": {
			"universe_name": function(a, b, sortorder){
				var avalue = $(".survey_universe_display_name", a).text().toLowerCase();
				var bvalue = $(".survey_universe_display_name", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
			},
			"stringSort": MUIFilterableSorter.predefinedSorting.stringSort,
			"returnVal": MUIFilterableSorter.predefinedSorting.returnVal
		},
		"columnSettings": [{
	 		"value": "List Name",
	 		"sortby": "universe_name",
	 		"sortdefault": true
		}],
		"sorterContainerClassName": "sortsurveyuniverses",
		"sorterContainer": sorter,
		"columnDataContainer": container,
		"expandingContainer": true,
	});
	
	colsorter.makeColumnSorter(true);
	
	this.sorter = {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	}; 
};

MControlSurveyAssignment.prototype.buildSubPanelSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("assign_survey scrollable");
	
	var sorter = $(ce("div"))
		.addClass("assign_survey_list_columns");
	
	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".assign_survey_item",
		"sortFunctions": {
			"assigned_listsusers": function(a, b, sortorder){
	 			var aIsChecked = $("input", a).get(0).checked ? 
	 				0 : ($("input", a).get(0).disabled ? 2 : 1);
	 			var bIsChecked = $("input", b).get(0).checked ? 
	 				0 : ($("input", b).get(0).disabled ? 2 : 1);
	 			var retVal = this.sortFunctions.returnVal.apply(this, [aIsChecked, bIsChecked, sortorder]);
	 			if(retVal == 0){
	 				return this.sortFunctions.username_listsusers.apply(this, [a, b, 1]);
	 			}
	 			return retVal; 
	 		},
	 		"username_listsusers": function(a, b, sortorder){
	 			var avalue = $("span", a).text().toLowerCase();
				var bvalue = $("span", b).text().toLowerCase();
				return this.sortFunctions.stringSort.apply(this, [avalue, bvalue, sortorder]);
	 		},
			"stringSort": MUIFilterableSorter.predefinedSorting.stringSort,
			"returnVal": MUIFilterableSorter.predefinedSorting.returnVal
		},
		"columnSettings": [{
	 		"value": "",
	 		"sortby": "assigned_listsusers",
	 		"float": "left"
		},{
	 		"value": "Survey Name",
	 		"sortby": "username_listsusers",
	 		"sortdefault": true
		}],
		"sorterContainerClassName": "sortuniverseassignment",
		"sorterContainer": sorter,
		"columnDataContainer": container,
		"expandingContainer": true,
	});
	
	colsorter.makeColumnSorter(true);
		
	return {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	}; 
};

MControlSurveyAssignment.prototype.buildUniverseList = function(){
	var ce = Moonshadow.helpers.ce;
	this.buildSorter();
	return [
		this.sorter.sorterCont.get(0),
		this.sorter.container.get(0)
	];
};

MControlSurveyAssignment.prototype.getLiveSurveys = function(){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getLiveSurveys();
};

MControlSurveyAssignment.prototype.refreshSort = function(){
	this.sorter && this.sorter.sorterObj && this.sorter.sorterObj.refreshSort();
};

MControlSurveyAssignment.prototype.getUniverses = function(callback){
	var universeControl = this.manager.getUniverseControl();
	var self = this;
	callback($(universeControl.getAllUniversesArray()).filter(function(index, universe){
		if(self.manager.getOption("user") != universe.owner){
			return false;
		}
		return true;
	}));
};

MControlSurveyAssignment.prototype.expandUniverseSection = function(universeId){
	var assignPanel = $("#universe_assign_" +  universeId, this.sorter.container);
	$(".survey_expander", assignPanel).click();
	$(this.sorter.container).scrollTop(
		$(assignPanel).position().top
	);
};

MControlSurveyAssignment.messages = {
	"notUniverseOwner": "\n\rThis universe was assigned to you by the " +
			" user who created it and cannot be modified. To assign/unassign it, contact " +
			" the universe owner: "
};

MControlSurveyAssignment.prototype.fillList = function(universes){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	
	var liveSurveys = self.getLiveSurveys();
	
	this.sorter.container.append(
		$.map(universes, function(universe, key){
			
			var colSorter = self.buildSubPanelSorter();
			return $(ce("div"))
				.attr({
					"id": "universe_assign_" +  universe.int_name
				})
				.addClass("survey_list_universe_item")
				.append(
					$(ce("span"))
						.addClass("survey_expander survey_left_col clickable sprite-expander_right")
						.click(self.expandDetails),
					$(ce("span"))
						.addClass("survey_float_col clickable")
						.append(
							$(ce("span"))
								.addClass("survey_universe_display_name")
								.attr({"title": universe.ext_name})
								.append(
									universe.ext_name
								)
						)
						.click(self.expandDetails),
					$(ce("div"))
						.addClass("hide survey_universe_details item_details")
						.append(
							$(ce("span"))
								.addClass("assign_survey_heading")
								.append("surveys:"),
								
							colSorter.sorterCont,
							$(colSorter.container)
							
								.addClass("assign_survey is_resizable scrollable")
								.append(
									liveSurveys.length ? 
										$(liveSurveys)
											.map(function(index, survey){
												return $(ce("div"))
													.addClass("assign_survey_item")
													.append(
														$(ce("input"))
															.attr({
																"type": "checkbox",
																"value": survey.int_name,
																"checked": universe.getSurveys() &&
																	$.inArray(survey.int_name, universe.getSurveys()) > -1
															})
															.on("click", function(e){
																var selectedSurveys = $("input[type='checkbox']:checked", 
																	$(this).closest(".survey_universe_details")).map(
																		function(key, item){
																			return item.value;
																		}
																	)
																	.toArray();
																universe.assignSurveys(selectedSurveys, null);
															}),
														$(ce("span"))
															.addClass("survey_name_span")
															.append(survey.ext_name)
													)
													.get(0);
										}) :
									$(ce("div"))
										.addClass("survey_list_empty")
										.append("There are currently no live surveys to assign!")
								)
						)
				)
				.get(0);
		})
	);
	
	this.refreshSort();
};

MControlSurveyAssignment.prototype.expandDetails = function(){
	var getExp = function(elem){
		if($(elem).hasClass("survey_expander"))
			return elem;
		var sibs = $(elem).siblings();
		for(var i = 0, l = sibs.length; i < l; ++i){
			if($(sibs[i]).hasClass("survey_expander"))
				return sibs[i];
		}
		return getExp($(elem).parent());
	};
	var exp = getExp(this);
	var targ = $(".item_details", $(exp).parent());
	if($(targ).hasClass("hide")){
		$(exp)
			.removeClass("sprite-expander_right")
			.addClass("sprite-expander_down")
		$(targ).removeClass("hide");
		var resizer = $(".is_resizable", targ);
		if(resizer.length){
			$(resizer).resizable({
				"handles": "s"
			});
		}
	}else{
		$(exp)
			.addClass("sprite-expander_right")
			.removeClass("sprite-expander_down")
		$(targ).addClass("hide");
		var resizer = $(".is_resizable", targ);
		if(resizer.length){
			$(resizer).resizable("destroy");
		}
	}
};



function MControlEditData(settings) {

	if(!settings.id){
		settings.id = "dataeditpanel_" + (new Date().getTime());
	}
	
	var exists = MUILayoverPanel.get(settings.id);
	if(exists){
		return exists.bringToFront();
	}
	
	this.id = settings.id;
	this.title = settings.title;
	this.fieldName = settings.fieldName;
	this.dsId = settings.dsId;
	this.value = settings.value;
	
	this.dirtyFields = {};
	this.manager = Moonshadow.getManager();
	this.makeEditPanel();
	
	this.parsedData;
	var self = this;
	
	this._initFields(this.dsId, function(){
		self.editPanel.open(function(){
			self.editPanel.loadIndicator(true);
			if(settings.data){
				self.buildData(settings.data);
			}else{
				self.getRecordDetails(function(data){
					self.buildData(data);
				})
			}
		});
	});
};

MControlEditData.prototype = new MControl;

MControlEditData.fieldSet = {};
MControlEditData.prototype._initFields = function(dsId, callback){
	
	var dsControl = this.getManager().getControl("datasources");
	var datasource = dsControl.getById(dsId);
	
	if(MControlEditData.fieldSet[dsId] && MControlEditData.fieldSet[dsId].fetched == datasource.fetched){
		return callback();
	}

	// @HACK
	//if(!Moonshadow.getManager().getOptions().datasources[0]["export"].voter_details)
	//	Moonshadow.getManager().getOptions().datasources[0]["export"].voter_details = [{"int_name":"Voters_FirstName"},{"int_name":"Voters_MiddleName"},{"int_name":"Voters_LastName"},{"ext_name":"Voters Name Suffix","int_name":"Voters_NameSuffix"},{"int_name":"VoterTelephones_Phone10"},{"int_name":"VoterTelephones_TelCellFlag"},{"int_name":"Parties_Description"},{"int_name":"Voters_Age"},{"int_name":"Voters_AgeRange"},{"int_name":"Voters_BirthDate"},{"int_name":"Voters_CalculatedRegDate"},{"int_name":"Voters_OfficialRegDate"},{"int_name":"Voters_Gender"},{"int_name":"MaritalStatus_Description"},{"int_name":"Vote_Frequency"},{"ext_name":"Broad Ethnic Groupings","int_name":"EthnicGroups_EthnicGroup1Desc"},{"int_name":"Ethnic_Description"},{"ext_name":"Hispanic Country Origin","int_name":"CommercialDataLL_Hispanic_Country_Origin"},{"int_name":"Religions_Description"},{"int_name":"Residence_Addresses_AddressLine"},{"int_name":"Residence_Addresses_ExtraAddressLine"},{"int_name":"Residence_Addresses_City"},{"ext_name":"Zip","int_name":"zip"},{"ext_name":"Zip Plus 4","int_name":"Residence_Addresses_ZipPlus4"},{"int_name":"Mailing_Addresses_AddressLine"},{"int_name":"Mailing_Addresses_ExtraAddressLine"},{"int_name":"Mailing_Addresses_City"},{"int_name":"Mailing_Addresses_State"},{"int_name":"Mailing_Addresses_Zip"},{"ext_name":"Mailing Addresses ZipPlus4","int_name":"Mailing_Addresses_ZipPlus4"},{"int_name":"2011_NEW_Congressional_District"},{"int_name":"2011_NEW_State_Senate_District"},{"int_name":"2011_NEW_State_House_District"},{"int_name":"City"},{"int_name":"County"},{"int_name":"Precinct"},{"int_name":"School_District"},{"ext_name":"CensusTract","int_name":"TRACT_FULL10"},{"ext_name":"CensusBlockGroup","int_name":"BLKGRP10"},{"ext_name":"CensusBlock","int_name":"BLOCK10"},{"int_name":"ncc_cable_zones_long"},{"int_name":"ncc_cable_zones_short"},{"ext_name":"nielsen dma long","int_name":"nielsen_dma_long"},{"ext_name":"nielsen dma short","int_name":"nielsen_dma_short"},{"int_name":"Education"},{"ext_name":"Estimated Median Income","int_name":"EstimatedMedianIncome"},{"int_name":"EstimatedIncome"},{"ext_name":"Net Worth","int_name":"CommercialDataLL_Net_Worth"},{"ext_name":"Investor","int_name":"CommercialDataLL_Investor"},{"int_name":"Occupation"},{"int_name":"OccupationIndustry"},{"int_name":"PresenceOfChildrenCode"},{"ext_name":"Household Composition","int_name":"HHComposition"},{"int_name":"EstHomeValue"},{"int_name":"EstHomeValue"},{"ext_name":"Veteran","int_name":"CommercialDataLL_Veteran"},{"ext_name":"Business Owner","int_name":"CommercialDataLL_Business_Owner"},{"ext_name":"Gun Owner","int_name":"CommercialDataLL_Gun_Owner"},{"ext_name":"Home Office","int_name":"CommercialDataLL_Home_Office"},{"ext_name":"Home Owner or Renter","int_name":"HomeOwnerRenter"},{"ext_name":"Home Purchase Price","int_name":"HomePurchasePrice"},{"int_name":"HomePurchaseDate"},{"int_name":"DwellingType"},{"int_name":"Residence_Families_HHCount"},{"int_name":"Residence_HHGender_Description"},{"int_name":"Residence_HHParties_Description"},{"ext_name":"Household Primary Language","int_name":"CommercialDataLL_Household_Primary_Language"},{"int_name":"ISPSA"},{"int_name":"LALVOTERID"},{"int_name":"Voters_StateVoterID"},{"int_name":"Voters_CountyVoterID"},{"regex_match":{"case-sensitive":1,"pattern":"General_.*"},"type":"filter"},{"regex_match":{"case-sensitive":1,"pattern":"Primary_.*"},"type":"filter"},{"regex_match":{"case-sensitive":1,"pattern":"PRI_BLT_.*"},"type":"filter"},{"regex_match":{"case-sensitive":1,"pattern":"Local_or_Municipal_.*"},"type":"filter"},{"regex_match":{"case-sensitive":1,"pattern":"Special_.*"},"type":"filter"},{"regex_match":{"case-sensitive":1,"pattern":"earlyvoting_general_.*"},"type":"filter"},{"regex_match":{"case-sensitive":1,"pattern":"earlyvoting_primary_.*"},"type":"filter"},{"ext_name":"Donates to Animal Welfare","int_name":"CommercialDataLL_Donates_to_Animal_Welfare"},{"ext_name":"Donates to Arts and Culture","int_name":"CommercialDataLL_Donates_to_Arts_and_Culture"},{"ext_name":"Donates to Childrens Causes","int_name":"CommercialDataLL_Donates_to_Childrens_Causes"},{"ext_name":"Donates to Conservative Causes","int_name":"CommercialDataLL_Donates_to_Conservative_Causes"},{"ext_name":"Donates to Healthcare","int_name":"CommercialDataLL_Donates_to_Healthcare"},{"ext_name":"Donates to International Aid Causes","int_name":"CommercialDataLL_Donates_to_International_Aid_Causes"},{"ext_name":"Donates to Liberal Causes","int_name":"CommercialDataLL_Donates_to_Liberal_Causes"},{"ext_name":"Donates to Local Community","int_name":"CommercialDataLL_Donates_to_Local_Community"},{"ext_name":"Donates to Veterans Causes","int_name":"CommercialDataLL_Donates_to_Veterans_Causes"},{"ext_name":"Donates to Wildlife Preservation","int_name":"CommercialDataLL_Donates_to_Wildlife_Preservation"},{"int_name":"DonatesEnvironmentCauseInHome"},{"int_name":"DonatesToCharityInHome"},{"int_name":"PoliticalContributerInHome"},{"int_name":"ReligiousContributorInHome"},{"int_name":"FECDonors_AvgDonation"},{"int_name":"FECDonors_AvgDonation_Range"},{"int_name":"FECDonors_LastDonationDate"},{"int_name":"FECDonors_NumberOfDonations"},{"int_name":"FECDonors_PrimaryRecipientOfContributions"},{"int_name":"FECDonors_TotalDonationsAmount"},{"int_name":"FECDonors_TotalDonationsAmt_Range"},{"ext_name":"Affordable Care_Act","int_name":"CommercialDataLL_Affordable_Care_Act"},{"ext_name":"Antiques Collector in Household","int_name":"CommercialDataLL_Collector_Antiques_In_Household"},{"ext_name":"Arts Collector in Household","int_name":"CommercialDataLL_Collector_Arts_In_Household"},{"ext_name":"Avid Collector in Household","int_name":"CommercialDataLL_Collector_Avid_In_Household"},{"ext_name":"Books Audio Reading in Household","int_name":"CommercialDataLL_Reading_Audio_Books_In_Household"},{"ext_name":"Buyer of Antiques in Household","int_name":"CommercialDataLL_Buyer_Antiques_In_Household"},{"ext_name":"Buyer of Art in Household","int_name":"CommercialDataLL_Buyer_Art_In_Household"},{"ext_name":"Cat Owner","int_name":"CommercialDataLL_PetOwner_Cat"},{"ext_name":"Church Attendee","int_name":"CommercialDataLL_Church_Attendee"},{"ext_name":"Coins Collector in Household","int_name":"CommercialDataLL_Collector_Coins_In_Household"},{"int_name":"CommercialDataLL_Pro_Choice"},{"int_name":"CommercialDataLL_Pro_Life"},{"ext_name":"Computer Owner In Home","int_name":"ComputerOwnerInHome"},{"ext_name":"Culinary Interest Magazine In Home","int_name":"CulinaryInterestMagazineInHome"},{"ext_name":"Do It Yourselfer Magazine In Home","int_name":"DoItYourselferMagazineInHome"},{"ext_name":"Dog Owner","int_name":"CommercialDataLL_PetOwner_Dog"},{"ext_name":"Family Magazine In Home","int_name":"FamilyMagazineInHome"},{"ext_name":"Female Oriented Magazine In Home","int_name":"FemaleOrientedMagazineInHome"},{"ext_name":"Fiction Science Reading in Household","int_name":"CommercialDataLL_Reading_Science_Fiction_In_Household"},{"ext_name":"Financial Magazine In Home","int_name":"FinancialMagazineInHome"},{"ext_name":"Gardening Magazine In Home","int_name":"GardeningMagazineInHome"},{"ext_name":"Gay Marriage","int_name":"CommercialDataLL_Gay_Marriage"},{"ext_name":"General Collector in Household","int_name":"CommercialDataLL_Collector_General_In_Household"},{"ext_name":"General Reading in Household","int_name":"CommercialDataLL_Reading_General_In_Household"},{"ext_name":"Gun Control","int_name":"CommercialDataLL_Gun_Control"},{"ext_name":"Health Fitness Magazine In Home","int_name":"HealthFitnessMagazineInHome"},{"ext_name":"Horse Owner","int_name":"CommercialDataLL_PetOwner_Horse"},{"ext_name":"Immigration Loosen Restrictions","int_name":"CommercialDataLL_Immigration_Loosen_Restrictions"},{"ext_name":"Interest in Auto Work in Household","int_name":"CommercialDataLL_Interest_in_Auto_Work_In_Household"},{"ext_name":"Interest in Automotive Parts Accessories in Household","int_name":"CommercialDataLL_Interest_in_Automotive_Parts_Accessories_In_Household"},{"ext_name":"Interest in Aviation in Household","int_name":"CommercialDataLL_Interest_in_Aviation_In_Household"},{"ext_name":"Interest in BoardGames Puzzles in Household","int_name":"CommercialDataLL_Interest_in_BoardGames_Puzzles_In_Household"},{"ext_name":"Interest in Boating Sailing in Household","int_name":"CommercialDataLL_Interest_in_Boating_Sailing_In_Household"},{"ext_name":"Interest in Camping Hiking in Household","int_name":"CommercialDataLL_Interest_in_Camping_Hiking_In_Household"},{"ext_name":"Interest in Cooking General in Household","int_name":"CommercialDataLL_Interest_in_Cooking_General_In_Household"},{"ext_name":"Interest in Cooking Gourmet in Household","int_name":"CommercialDataLL_Interest_in_Cooking_Gourmet_In_Household"},{"ext_name":"Interest in Crafts in Household","int_name":"CommercialDataLL_Interest_in_Crafts_In_Household"},{"ext_name":"Interest in Current Affairs Politics In Household","int_name":"CommercialDataLL_Interest_in_Current_Affairs_Politics_In_Household"},{"ext_name":"Interest in Education Online in Household","int_name":"CommercialDataLL_Interest_in_Education_Online_In_Household"},{"ext_name":"Interest in Electronic Gaming in Household","int_name":"CommercialDataLL_Interest_in_Electronic_Gaming_In_Household"},{"ext_name":"Interest in Exercise Aerobic in Household","int_name":"CommercialDataLL_Interest_in_Exercise_Aerobic_In_Household"},{"ext_name":"Interest in Exercise Health in Household","int_name":"CommercialDataLL_Interest_in_Exercise_Health_In_Household"},{"ext_name":"Interest in Exercise Running Jogging in Household","int_name":"CommercialDataLL_Interest_in_Exercise_Running_Jogging_In_Household"},{"ext_name":"Interest in Exercise Walking in Household","int_name":"CommercialDataLL_Interest_in_Exercise_Walking_In_Household"},{"ext_name":"Interest in Fishing in Household","int_name":"CommercialDataLL_Interest_in_Fishing_In_Household"},{"ext_name":"Interest in Food Wines in Household","int_name":"CommercialDataLL_Interest_in_Food_Wines_In_Household"},{"ext_name":"Interest in Foods Natural in Household","int_name":"CommercialDataLL_Interest_in_Foods_Natural_In_Household"},{"ext_name":"Interest in Gaming Casino in Household","int_name":"CommercialDataLL_Interest_in_Gaming_Casino_In_Household"},{"ext_name":"Interest in Gardening in Household","int_name":"CommercialDataLL_Interest_in_Gardening_In_Household"},{"ext_name":"Interest in Golf in Household","int_name":"CommercialDataLL_Interest_in_Golf_In_Household"},{"ext_name":"Interest in History Military in Household","int_name":"CommercialDataLL_Interest_in_History_Military_In_Household"},{"ext_name":"Interest in Home Furnishings in Household","int_name":"CommercialDataLL_Interest_in_Home_Furnishings_In_Household"},{"ext_name":"Interest in Home Improvement in Household","int_name":"CommercialDataLL_Interest_in_Home_Improvement_In_Household"},{"ext_name":"Interest in Home Repair in Household","int_name":"CommercialDataLL_Interest_in_Home_Repair_In_Household"},{"ext_name":"Interest in House Plants in Household","int_name":"CommercialDataLL_Interest_in_House_Plants_In_Household"},{"ext_name":"Interest in Hunting in Household","int_name":"CommercialDataLL_Interest_in_Hunting_In_Household"},{"ext_name":"Interest in Motorcycling in Household","int_name":"CommercialDataLL_Interest_in_Motorcycling_In_Household"},{"ext_name":"Interest in Musical Instruments in Household","int_name":"CommercialDataLL_Interest_in_Musical_Instruments_In_Household"},{"ext_name":"Interest in Nascar in Household","int_name":"CommercialDataLL_Interest_in_Nascar_In_Household"},{"ext_name":"Interest in Photography in Household","int_name":"CommercialDataLL_Interest_in_Photography_In_Household"},{"ext_name":"Interest in Photography Video in Household","int_name":"CommercialDataLL_Interest_in_Photography_Video_In_Household"},{"ext_name":"Interest in Religious Inspirational in Household","int_name":"CommercialDataLL_Interest_in_Religious_Inspirational_In_Household"},{"ext_name":"Interest in Science Space in Household","int_name":"CommercialDataLL_Interest_in_Science_Space_In_Household"},{"ext_name":"Interest in Scuba Diving in Household","int_name":"CommercialDataLL_Interest_in_Scuba_Diving_In_Household"},{"ext_name":"Interest in Sewing Knitting in Household","int_name":"CommercialDataLL_Interest_in_Sewing_Knitting_In_Household"},{"ext_name":"Interest in Shooting in Household","int_name":"CommercialDataLL_Interest_in_Shooting_In_Household"},{"ext_name":"Interest in Smoking in Household","int_name":"CommercialDataLL_Interest_in_Smoking_In_Household"},{"ext_name":"Interest in Snow Skiing in Household","int_name":"CommercialDataLL_Interest_in_Snow_Skiing_In_Household"},{"ext_name":"Interest in SpectatorSports Auto Racing in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_Auto_Racing_In_Household"},{"ext_name":"Interest in SpectatorSports Baseball in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_Baseball_In_Household"},{"ext_name":"Interest in SpectatorSports Basketball in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_Basketball_In_Household"},{"ext_name":"Interest in SpectatorSports Football in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_Football_In_Household"},{"ext_name":"Interest in SpectatorSports Hockey in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_Hockey_In_Household"},{"ext_name":"Interest in SpectatorSports on TV in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_on_TV_In_Household"},{"ext_name":"Interest in SpectatorSports Soccer in Household","int_name":"CommercialDataLL_Interest_in_SpectatorSports_Soccer_In_Household"},{"ext_name":"Interest in Sports Leisure in Household","int_name":"CommercialDataLL_Interest_in_Sports_Leisure_In_Household"},{"ext_name":"Interest in Sweepstakes Contests in Household","int_name":"CommercialDataLL_Interest_in_Sweepstakes_Contests_In_Household"},{"ext_name":"Interest in Tennis in Household","int_name":"CommercialDataLL_Interest_in_Tennis_In_Household"},{"ext_name":"Interest in the Arts in Household","int_name":"CommercialDataLL_Interest_in_the_Arts_In_Household"},{"ext_name":"Interest in Theater Performing Arts in Household","int_name":"CommercialDataLL_Interest_in_Theater_Performing_Arts_In_Household"},{"ext_name":"Interest in Travel Cruise in Household","int_name":"CommercialDataLL_Interest_in_Travel_Cruise_In_Household"},{"ext_name":"Interest in Travel Domestic in Household","int_name":"CommercialDataLL_Interest_in_Travel_Domestic_In_Household"},{"ext_name":"Interest in Travel International in Household","int_name":"CommercialDataLL_Interest_in_Travel_International_In_Household"},{"ext_name":"Interest in Woodworking in Household","int_name":"CommercialDataLL_Interest_in_Woodworking_In_Household"},{"ext_name":"Lawsuit Damages Should be Limited","int_name":"CommercialDataLL_Lawsuit_Damages_Should_be_Limited"},{"ext_name":"Magazines Reading in Household","int_name":"CommercialDataLL_Reading_Magazines_In_Household"},{"ext_name":"Military Collector in Household","int_name":"CommercialDataLL_Collector_Military_In_Household"},{"int_name":"MosaicZ4"},{"ext_name":"Other Pet Owner","int_name":"CommercialDataLL_PetOwner_Other"},{"int_name":"PresenceOfChildrenCode"},{"ext_name":"Privatize Social Security","int_name":"CommercialDataLL_Privatize_Social_Security"},{"ext_name":"Property Type","int_name":"PropertyType"},{"ext_name":"Religious Magazine In Home","int_name":"ReligiousMagazineInHome"},{"ext_name":"Religious Reading in Household","int_name":"CommercialDataLL_Reading_Religious_In_Household"},{"ext_name":"School Choice","int_name":"CommercialDataLL_School_Choice"},{"ext_name":"Social Views","int_name":"CommercialDataLL_Social_Views"},{"ext_name":"Sports Collector in Household","int_name":"CommercialDataLL_Collector_Sports_In_Household"},{"ext_name":"Stamps Collector in Household","int_name":"CommercialDataLL_Collector_Stamps_In_Household"},{"ext_name":"Support for Conservative Judges","int_name":"CommercialDataLL_Election_of_Conservative_Judges"},{"ext_name":"Taxes Raise","int_name":"CommercialDataLL_Taxes_Raise"},{"ext_name":"Upscale Buyer In Home","int_name":"UpscaleBuyerInHome"},{"ext_name":"Upscale Female Buyer In Home","int_name":"UpscaleFemaleBuyerInHome"},{"ext_name":"Upscale Male Buyer In Home","int_name":"UpscaleMaleBuyerInHome"}];
	//END HACK
	
	var dsFields = datasource.fields;
	
	var filterableDs = this.manager.getDatasource(dsId);
	var exportsFields = filterableDs["export"];
	if(!exportsFields){
		throw new Error("No field lists");
	}
	
	var detailsFields = exportsFields.voter_details;
	if(!detailsFields){
		throw new Error("Voter details field list not present");
	}
	
	var regFields = function(reg){
		var regFieldOrder = [];
		for(var f in dsFields){
			if(!dsFields.hasOwnProperty(f)){
				continue;
			}
			
			var year = f.replace(reg.pattern.replace(".*", ""), "");
			var rExp = new RegExp(
				"^" + reg.pattern, 
				reg["case-sensitive"] === 1? "" : "i"
			);
			
			if(f.search(rExp) > -1){
				var item = {
					"int_name": f,
					"ext_name": dsFields[f].ext_name + (year ? " " + year : "")
				};
				if(year){
					item.year = year;
				}
				regFieldOrder.push(item);
			}
		}
		
		return regFieldOrder.sort(function(a, b){
			if(!a.year){
				return 1;
			}
			var aparts = a.year.split("-");
			var bparts = b.year.split("-");
			for(var i = 0, l = 2; i < l; ++i){
				if(aparts[i] > bparts[i]){
					return 1;
				}else if(aparts[i] < bparts[i]){
					return -1
				}
			}
		});
	};
	
	var returnFields = [];
	for(var i = 0, l = detailsFields.length; i < l; ++i){
		var eF = detailsFields[i];
		var reg = eF.regex_match;
		if(reg){
			returnFields = returnFields.concat(regFields(reg));
			continue;
		}

		var n = eF.int_name;
		if(!eF.ext_name && (dsFields[n] && dsFields[n].ext_name)){
			eF.ext_name = dsFields[n].ext_name;
		}
		
		returnFields.push(eF);
	}
	
	var setFieldSet = function(){
		MControlEditData.fieldSet[dsId] = {
			"fetched": datasource.fetched,
			"fields": returnFields
		};
	};
	
	var self = this;
	var surveyControl = this.manager.getControl("surveys");
	if(surveyControl){
		return surveyControl.getSurveysFields(null, false, function(surveyFields){
			returnFields = returnFields.concat(surveyFields);
			setFieldSet();
			callback();
		});
	}
	
	setFieldSet();
	callback();
}

MControlEditData.prototype.editingEnabled = function(){
	return false;
};

MControlEditData.prototype._getValue = function(){
	var value;
	try{
		value = JSON.parse(this.value);
	}catch(e){
		value = this.value;
	}
	return value;
};

MControlEditData.prototype.getInfoAtLevelQuery = function(){
	return {
		"query": "get_info_at_level",
		"k_level": "voter",
		"ds": this.dsId,
		"k": this._getValue()
	}
};

MControlEditData.prototype.getRecordQuery = function(){
	var value = this._getValue();
	var filter = {};
	filter[this.fieldName] = {
		"value": value
	}
	
	if(this.fieldName == "LALVOTERID"){
		value = parseInt(value.replace(/[a-zA-Z]/g, ""), 10);
		filter[this.fieldName] = {
			"to": value,
            "from": value,
            "unknown": 0
		}
	}
	
	return {
		"query": "get_record_info",
		"ds": this.dsId,
		"fields": this.fields,
		"filter": filter,
		"fieldSet": this.fieldSet,
		"max_tree_level": 5
	};
};

MControlEditData.prototype.getRecordDetails = function(callback){
	var ajax = new Moonshadow.Ajax();
	
	var query;
	if(this.fieldName == "kvalue"){
		query = this.getInfoAtLevelQuery();
	}else{
		query = this.getRecordQuery();
	}
	
	ajax.addQuery(query, callback);
	ajax.execute();
};

MControlEditData.prototype.makeEditPanel = function(){
	var panH = 600;
	var panT = 100;
	var wH = $(window).height() - 100;
	if(panH > wH){
		panH = wH;
		panT = 10;
	}
	if(panH < 300){
		panH = 300;
	}
	if(!this.editPanel){
		this.editPanel = new MUILayoverPanel({
			"id": this.id,
			"title": this.title || "Data Viewer",
			"animate": true,
			"fixed": false,
			"resizeAlso": ".dataview_container",
			"onClose": this.closeEditor,
			"context": this,
			"position": {
				"top": panT, 
				"width": 800,
				"height": panH
			},
			"modal": false
		});
	}
};

MControlEditData.prototype.closeEditor = function(hide, context){
	context.cancelAllEdits(hide);
};

MControlEditData.prototype._isDirty = function(name){
	if(!name){
		return Moonshadow.helpers.objCount(this.dirtyFields) > 0;
	}
	return !!this.dirtyFields[name];
};

MControlEditData.prototype._enableDisableCancelSave = function(){
	var uiC = this._getUIControls();
	$(uiC.save)
		.attr({
			"disabled": !this._isDirty()
		});
	$(uiC.cancel)
		.attr({
			"disabled": !($(".dataview_input_container:not(.hide)", this.content).length)
		});
};

MControlEditData.prototype._makeDirty = function(elem, value){
	var name = elem.name;
	var dirtyindicator = this._getUITargets(elem).dirtyindicator;
	$(dirtyindicator).empty().append("*");
	this.dirtyFields[name] = value || true;
	this._enableDisableCancelSave();
}

MControlEditData.prototype._makeClean = function(elem, name){
	var dirtyindicator = this._getUITargets(elem).dirtyindicator;
	$(dirtyindicator).empty();
	delete this.dirtyFields[name];
	this._enableDisableCancelSave();
}

MControlEditData.prototype._getOriginalValue = function(name){
	return this.dirtyFields[name] || false;
}

MControlEditData.prototype._refreshTable = function(){
	$(".dataview_itemcontainer tr:not(.hide):not(.dataview_controls_head)", this.content)
		.removeAttr("style")
		.filter(function(index){
			return index % 2 === 1;
		})
		.css({
			"background-color": "lightgray"
		});
};

MControlEditData.prototype._showHideEmpty = function(show){
	var allTrs = $(".dataview_itemcontainer tr:not(.dataview_controls_head)")
		.removeAttr("style class");
	
	if(!show){
		$(allTrs).filter(function(index, item){
			return !$(".dataview_value", item).text();
		})
		.addClass("hide");
	}
	this._refreshTable();
};

MControlEditData.prototype.buildData = function(data){
	var results = data.results || data.values;
	if(!results || !results.length){
		this.displayNoRecordsMessage("There is no data available for this record");
		this.editPanel.close();
		return false;
	}
	
	this.parsedData = this._flattenData(results);
	this.content = this._prepContent(this.parsedData);

	this.editPanel.set("content", this.content);
	this._refreshTable();
	this.editPanel.loadIndicator(false);
};

MControlEditData.prototype.displayNoRecordsMessage = function(message){
	MUILayoverPanel.alert(message);
};

MControlEditData.prototype.createDataTable =  function(parsedData, forPrint, hideEmpty, editingEnabled){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	return $(ce("table"))
		.addClass("dataview_itemcontainer")
		.addClass(forPrint ? "to_printer" : "")
		.append(
			$(ce("thead"))
				.append(
					$(ce("tr"))
						.addClass("dataview_controls_head")
						.append(
							$(ce("th"))
								.append("Field Name"),
							$(ce("th")),
							$(ce("th"))
								.addClass("dataview_recorddata_head")
								.append("Record Data"),
							function(){
								if(editingEnabled){
									return $(ce("th"))
										.addClass("dataview_edit_head")
										.append("Edit")
								}
								return "";
							}()
						)
				),
			$(ce("tbody"))
				.append(
					$(parsedData).map(function(key, item){
						return $(ce("tr"))
							.addClass(!item.value && hideEmpty && "hide")
							.append(
								$(ce("td"))
									.addClass("dataview_info")
									.append(
										$(ce("label"))
											.addClass("dataview_label")
											.append(item.ext_name || Moonshadow.helpers.capitalize(item.int_name.replace(/_/g," ")))
									),
								$(ce("td"))
									.addClass("dataview_dirtyindicator_container")
									.append(
										$(ce("span"))
											.addClass("dataview_dirtyindicator")
									),
								$(ce("td"))
									.addClass()
									.append(
										$(ce("span"))
											.addClass("dataview_value")
											.append(item.value),
										function(){
											if(editingEnabled){
												return $(ce("span"))
													.addClass("dataview_input_container hide")
													.append(
														$(ce("input"))
															.addClass("dataview_input")
															.attr({
																"type": "text",
																"name": item.int_name,
																"value": item.value
															})
															.on("change, keydown", {"self": self, "ov": item.value}, function(e){
																var originalVal = e.data.ov;
																if(this.value === originalVal || e.data.self._isDirty(this.name))
																	return;
																e.data.self._makeDirty(this, originalVal);
															})
													)
											}
											return "";
										}()
									),
								function(){
									if(editingEnabled){
										return $(ce("td"))
											.addClass("dataview_editbutton_container")
											.append(
												$(ce("input"))
													.addClass("dataview_editbutton")
													.attr({
														"type": "button",
														"value": "Edit"
													})
													.on("click", {"self": self, "name": item.int_name}, function(e){
														e.data.self._cancelEdits(e.data.name, this);
													})
											);
									}
									return "";
								}()
								
							)
							.get(0);
					})
				)
		);
};

MControlEditData.prototype._prepContent = function(parsedData){
	
	var editingEnabled = this.editingEnabled();
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var dataTable = this.createDataTable(parsedData, false, true, editingEnabled);
	
	var controls = $(ce("div"))
		.append(
			$(ce("div"))
				.addClass("dataview_controlpanel")
				.append(
					$(ce("div"))
						.addClass("dataview_control_right")
						.append(
							function(){
								if(editingEnabled){
									return $(ce("input"))
										.addClass("cancel_all_edits")
										.attr({
											"type": "button",
											"value": "Cancel Edits",
											"disabled": true
										})
										.on("click", function(){
											self.cancelAllEdits();
										});
								}
								return "";
							}(),
							function(){
								if(editingEnabled){
									return $(ce("input"))
										.addClass("save_edits")
										.attr({
											"type": "button",
											"value": "Save Edits",
											"disabled": true
										})
										.on("click", function(){
											self.saveEdits();
										});
								}
								return "";
							}(),
							$(ce("input"))
								.addClass("csv_export_information")
								.attr({
									"type": "button",
									"value": "Export as CSV"
								})
								.on("click", function(){
									self.csvExport();
								}),
							$(ce("input"))
								.addClass("print_information")
								.attr({
									"type": "button",
									"value": "Send to Printer"
								})
								.on("click", function(){
									self.sendToPrinter();
								})
						),
					$(ce("div"))
						.addClass("dataview_control_left")
						.append(
							$(ce("span"))
								.append("Hide empty values"),
							$(ce("input"))
								.addClass("hide_empty_items")
								.attr({
									"type": "checkbox",
									"title": "Hide/Show empty values",
									"checked": true
								})
								.on("change", function(){
									self._showHideEmpty(!this.checked);
								})
						),
					$(ce("div"))
						.addClass("clear")
				),
			$(ce("div"))
				.addClass("dataview_container scrollable")
				.append(dataTable)
		);
	
	$("input[type='button']", controls)
		.on("click", function(){
			this.blur();
		})
	
	return controls;
};

MControlEditData.prototype.sendToPrinter =  function(){
	
	$(".send_to_printer_frame", this.editPanel.container)
		.remove();
	
	var hideEmpty = !!$(".hide_empty_items").attr("checked") ? true : false;
	
	var ce = Moonshadow.helpers.ce;
	var name = this._getDocName();
	
	var printerFrame = $(ce("iframe"))
		.attr({
			"id": name,
			"name": name
		})
		.addClass("send_to_printer_frame hide")
		.get(0);
	
	$(this.editPanel.container)
		.append(printerFrame);
	
	var self = this;
	setTimeout(function(){
		
		$(printerFrame.contentDocument.head)
			.append(
				$("link, title").map(function(a, b){
					return $(b).clone().get(0);
				})
			);
	
		$(printerFrame.contentDocument.body)
			.append(
				self.createDataTable(self.parsedData, true, hideEmpty)
			);
		
		setTimeout(function(){
			printerFrame.contentWindow.print();
		}, 1000);
		
		
	}, 1000);
};

MControlEditData.prototype._getDocName = function(){
	var fname = $("input[name='Voters_LastName']").val() || "";
	var lname = $("input[name='Voters_FirstName']").val() || "";
	var date = new Date().getTime()
	var filename = (fname + "_" + lname + "_" + date).replace(/\W/g, "").toLowerCase();
	return filename;
};

MControlEditData.prototype.csvExport = function(){
	if(!this.parsedData){
		return;
	}
	
	var filename = this._getDocName();
	var hideEmpty = !!$(".hide_empty_items").attr("checked") ? 1 : 0;
	var ce = Moonshadow.helpers.ce;
	var form = $(ce("form"))
		.attr({
			"action": "/marker/export",
			"method": "POST",
			"target": "_blank"
		})
		.append(
			$(ce("input"))
				.attr({
					"type": "hidden",
					"name": "data",
					"value": JSON.stringify(this.parsedData)
				}),
			$(ce("input"))
				.attr({
					"type": "hidden",
					"name": "filename",
					"value": filename
				}),
			$(ce("input"))
				.attr({
					"type": "hidden",
					"name": "hide_empty",
					"value": hideEmpty
				})
		);
	
	$(this.editPanel.container)
		.append(form);
	form.submit();
	$(form).remove();
};

MControlEditData.prototype._getUIControls = function(){
	return {
		"cancel": $(".cancel_all_edits", this.content),
		"save": $(".save_edits", this.content)
	}
};

MControlEditData.prototype._getUITargets = function(elem){
	var targetEdit = $(elem).closest("tr");
	return {
		"container": targetEdit, 
		"label": $(".dataview_label", targetEdit),
		"dirtyindicator": $(".dataview_dirtyindicator", targetEdit),
		"value": $(".dataview_value", targetEdit),
		"input": $(".dataview_input", targetEdit),
		"editbutton": $(".dataview_editbutton", targetEdit)
	};
};

MControlEditData.prototype._cancelEdits = function(name, elem){
	
	var self = this;
	var cancelEdits = function(){
		var input = self._getUITargets(elem).input;
		$(input).val(
			self._getOriginalValue(name) || ""
		);
		self._editField(elem);
		self._makeClean(elem, name);
	};
	
	if(this._isDirty(name)){
		return MUILayoverPanel.confirm({
			"title": "Discard Changes",
			"message": "Edits have not been saved. Discard changes for this feild?",
			"closeText": "Discard",
			"callback": function(res, id, hide){
				if(res){
					cancelEdits();
				}
				hide();
			}
		});
	}
	this._editField(elem);
};

MControlEditData.prototype._editField = function(button){
	var targetEdit = $(button).closest("tr");
	if(button.value == "Edit"){
		button.value = "Cancel";
		$(".dataview_value", targetEdit).addClass("hide");
		$(".dataview_input_container", targetEdit).removeClass("hide");
		$(".dataview_input", targetEdit).focus()
	}else{
		button.value = "Edit";
		$(".dataview_value", targetEdit).removeClass("hide");
		$(".dataview_input_container", targetEdit).addClass("hide");
	}
	this._enableDisableCancelSave();
};

MControlEditData.prototype.saveEdits = function(){
	var self = this;
	if(this._isDirty()){
		MUILayoverPanel.confirm({
			"title": "Confirm: Save All Changes",
			"message": "Save all changes and continue?",
			"closeText": "Save All",
			"callback": function(res, id, hide){
				if(res){
					//@HACK
					self.dirtyFields = {};
					self.cancelAllEdits();
					// END HACK
				}
				hide();
			}
		});
	}
};

MControlEditData.prototype.cancelAllEdits = function(callback){
	var self = this;
	var cancelAll = function(hide){
		$("input[value='Cancel']", self.content).map(function(index, button){
			var input = self._getUITargets(button).input;
			var name = $(input).attr("name");
			if(self._isDirty(name)){
				$(input).val(
					self._getOriginalValue(name) || ""
				);
			}
			self._editField(button);
			self._makeClean(button, name);
		});
		callback && callback();
		hide && hide();
	};
	
	if(this._isDirty()){
		return MUILayoverPanel.confirm({
			"title": "Confirm: Discard All Changes",
			"message": "Edits have not been saved. Discard all changes?",
			"closeText": "Discard All",
			"callback": function(res, id, hide){
				if(res){
					return cancelAll(hide);
				}
				hide();
			}
		});
	}else{
		cancelAll(callback);
	}
};

MControlEditData.prototype._flattenData = function(data){
	var flatData = {};
	var self = this;
	var parseLoop = function(data, depth){
		for(var i = 0, len = data.length; i < len; ++i){
			var s = data[i].sub;
			var d = data[i].data;
			var l = data[i].level;
			var k = data[i].k;
			if(l && l == "voter" && k && k != self.value){
				continue;
			}
			if(d && d.length){
				for(var ii = 0, ll = d.length; ii < ll; ++ii){
					var item = {
						"int_name": d[ii].n,
						"value": d[ii].v,
						"level": l,
						"leveldepth": depth
					}
					flatData[d[ii].n] = item;
				}
			}
			if(s && s.length){
				parseLoop(s, ++depth);
			}
		}
	};
	
	parseLoop(data, 0);
	
	var fieldSet = MControlEditData.fieldSet[this.dsId].fields;
	var returnData = [];
	for(var i = 0, l = fieldSet.length; i < l; ++i){
		var dataum = flatData[fieldSet[i].int_name];
		if(dataum){
			dataum.ext_name = fieldSet[i].ext_name;
			if(dataum.value && fieldSet[i].format){
				if(fieldSet[i].format == "latitude"){
					dataum.value = Moonshadow.helpers.demercateLat(dataum.value);
				}
				if(fieldSet[i].format == "longitude"){
					dataum.value = Moonshadow.helpers.demercateLon(dataum.value);
				}
			}
			returnData.push(dataum);
		}else{
			Moonshadow.log(fieldSet[i].int_name, " not returned");
		}
	}
	
	return returnData;
};

/**
 * Control for managing routing mode
 * 
 * @class MControlRouting
 * @constructor
 * @extends MControl
 * @param {Object} options Control options
 */
function MControlRouting(options) {
    this.options = options || {};
    this.manager = null;
    this.adapter = null;

    this.name = 'routing';
	this.position = 3;
	this.container = null;

	this.universe = null;
	this.route = null;
	this.polyline = null;

	this.overKValue = false;
	this.aKey = false;
	this.rKey = false;
	this.mouseOverMode = 0;
	this.addKeyCode = 69;
	this.removeKeyCode = 82;
	this.dragging = -1;
	this.neighbors = [];

	this.observers = new Moonshadow.Observer();
	this.wasSidePanelOpen = null;

	this.unroutedColor = 'b8b8b8';
	this.routedColor = '00FF00';
	this.streetColorOdd = 'ffff00';
	this.streetColorEven = 'ffff99';

	this.overColor = '99CCFF';
	this.overColorMarker = '336699';

	this.defaultListColor = 'FFFFFF';
	this.lineColor = '00ff00';

};

/**
 * General control init function
 *
 * @private
 * @method init
 * @param {MManager} manager Instance of MManager
 */
MControlRouting.prototype.init = function(manager) {
    this.manager = manager;
    this.adapter = manager.getAdapter();

	this.createUI();

	this.adapter.addControlToMap(manager.getControl(this.name));
};

/**
 * Call to being routing
 *
 * @method beginRouting
 * @param {MFilterableUniverse} universe Universe we are routing
 */
MControlRouting.prototype.beginRouting = function(universe) {
	if (!(universe instanceof MFilterableUniverseItem)) {
		throw new Error('Invalid universe');
	}

	var self = this;	

	if (this.universe) {
		if (this.polyline) {
			this.polyline.hide();
			this.polyline = null;
		}

		this.removeMarkers();
		this.removeAddresses();
	}

	this.universe = universe;

	this.disableOtherControls(function() {
		self.route = new MDataRoute(universe);
		self.route.loadRoute(function(error) {
			self.addMarkers();
			// Add route to polyline and address list
			var home = self.route.getStart();
			var end = self.route.getEnd();
			while ((home = self.route.getNextHome(home)) !== end) {
				home.marker.setIcon(self.getMarkerIconUrl(self.routedColor));
				self.polyline.addPoint(home.latLng);
				self.addAddressToList(home);
			}

			self.ready();
		});

		self.neighbors = [];

		self.polyline = self.createPolyline();

		// Listen for "add" key being held down
		self.bindKeyboardListeners();

		// Pan to universe
		universe.panTo.panTo();

		// Update side panel height
		self.onResize();

		// Show side list
		$(self.routeName).text(universe.ext_name);
		$(self.loading).show();
		self.container.style.display = 'block';

		// Listen for map resize so we can resize the address list
		self.manager.addMapObserver('resize', self.onResize, self);

		// Let the other controls, or at least the ones that care, know we are routing	
		self.observers.notify('routingbegin');
	});
};

/** 
 * Call to end routing
 * 
 * @method endRouting
 */
MControlRouting.prototype.endRouting = function() {
	// Disable polyline
	if (this.polyline) {
		this.polyline.hide();
		this.polyline = null;
	}

	this.universe = null;

	this.enableOtherControls();

	// Stop listening for "add" key
	this.unbindKeyboardListeners();

	this.removeMarkers();
	this.removeAddresses();

	// Hide side list
	this.container.style.display = 'none';

	this.route = null;
	this.neighbors = [];

	// Unbind resize listener
	this.manager.removeMapObserver('resize', this.onResize, this);

	var controlPosition = $('#topRightControls');
	controlPosition[0].style.height = 'auto';

	// Let the other controls, or at least the ones that care, know we are done
	this.observers.notify('routingend');
};

/**
 * Call when ready to route 
 *
 * @method ready
 * @private
 */
MControlRouting.prototype.ready = function() {
	$(this.loading).hide();
	$(this.addressList).show();
	
	var entry = $('div.list-item', this.addressList).last();
	if (entry.length) {
		this.scrollAddressListTo(entry);
	}

	this.updateProgress();
};

/**
 * Add markers for homes to the map
 *
 * @method addMarkers
 * @private 
 */
MControlRouting.prototype.addMarkers = function() {
	var homes = this.route.getAllHomes();

	for(var key in homes) {
		var home = homes[key];

		var marker = this.createMarker(home.latLng, this.unroutedColor);
		marker.setMetadata('id', home.kValue);
		home.marker = marker;
		marker.show();
	}
}

/**
 * Create the route polyline
 * 
 * @method createPolyline
 * @private
 * @return {MMapPolyline}
 */
MControlRouting.prototype.createPolyline = function() {
	var polyline = new MMapPolyline(this.manager, {});
	polyline.hidePointMarkers();
	polyline.setMidMarkerUri('/images/midpoint_green.png');
	polyline.setMidLineColor('#' + this.lineColor);
	polyline.setLineColor('#' + this.lineColor);
	polyline.addEventListener('middragstart', this.onMidDragStart, this);
	polyline.addEventListener('middragend', this.onMidDragEnd, this);
	polyline.overrideMidPointInsertion(this.onMidInsert, this);
	polyline.setEditable();
	polyline.show();
	
	return polyline;
};

/**
 * Disable all controls not needed for routing
 *
 * @method disableOtherControls
 * @private
 * @param {Function} callback
 */
MControlRouting.prototype.disableOtherControls = function(callback) {
	// Disable layers, markers and shapes
	this.manager.getControl('markers').disable();
	this.manager.getControl('shape').disable();
	this.manager.getControl('layerBase').disable();
	this.manager.getControl('layerMesh').disable();
	this.manager.getControl('layerMask').disable();
	this.manager.getControl('layerRegion').disable();

	// Hide counts display
	var counts = this.manager.getControl('datacounts');
	if (counts) {
		counts.hide();
	}	

	// Close side panel
	var sidePanel = this.manager.getControl('sidepanel');
	if (sidePanel) {
		this.wasSidePanelOpen = sidePanel.isOpen();
		sidePanel.hide(true, false, callback);
		sidePanel.lock();
	}
};

/**
 * Enable controls that were disabled while in routing mode
 *
 * @method enableOtherControls
 * @private
 */
MControlRouting.prototype.enableOtherControls = function() {
	// Enable layers, markers and shapes
	this.manager.getControl('markers').enable();
	this.manager.getControl('shape').enable();
	this.manager.getControl('layerBase').enable();
	this.manager.getControl('layerMesh').enable();
	this.manager.getControl('layerMask').enable();
	this.manager.getControl('layerRegion').enable();

	// Show counts display
	var counts = this.manager.getControl('datacounts');
	if (counts) {
		counts.show();
	}	

	var sidePanel = this.manager.getControl('sidepanel');
	if (sidePanel) {
		// Reopen sidepanel if it was open before entering routing mode
		sidePanel.unlock();

		if (this.wasSidePanelOpen) {		
			this.manager.getControl('sidepanel').show();
		}
	}
};

/**
 * Bind keyboard event listeners
 * 
 * We listen for keyup and keydown so that we know when shift and alt
 * are held down
 *
 * @method bindKeyboardListeners
 * @private
 */
MControlRouting.prototype.bindKeyboardListeners = function() {
	// Bind map listeners
	
	this.manager.dataObservers.addObserver('keydown_69', this.onKeyEvent, this);
	this.manager.dataObservers.addObserver('keyup_69', this.onKeyEvent, this);
	
	this.manager.dataObservers.addObserver('keydown_82', this.onKeyEvent, this);
	this.manager.dataObservers.addObserver('keyup_82', this.onKeyEvent, this);
	
//	this.keyDownHandle = this.adapter.addMapListener('keydown', this, this.onKeyEvent);
//	this.keyUpHandle = this.adapter.addMapListener('keyup', this, this.onKeyEvent);
};

/**
 * Unbind keyboard event listeners
 * 
 * @method unbindKeyboardListeners
 * @private
 */
MControlRouting.prototype.unbindKeyboardListeners = function() {
	this.manager.dataObservers.removeObserver('keydown_69', this.onKeyEvent, this);
	this.manager.dataObservers.removeObserver('keyup_69', this.onKeyEvent, this);
	this.manager.dataObservers.removeObserver('keydown_82', this.onKeyEvent, this);
	this.manager.dataObservers.removeObserver('keyup_82', this.onKeyEvent, this);
	
//	this.adapter.removeMapListener(this.keyDownHandle);
//	this.adapter.removeMapListener(this.keyUpHandle);
};

/**
 * Update the progress text below address list
 * 
 * @method updateProgress
 */
MControlRouting.prototype.updateProgress = function() {
	var routed = this.route.getNumRouted();
	var total = this.route.getNumHomes();
	var complete = routed / total * 100;
	$(this.progress).text(routed + ' out of ' + total + ' homes routed (' +
						  complete.toPrecision(3) + '%)');
};

/**
 * Remove all home markers from map
 *
 * @method removeMarkers
 * @private
 */
MControlRouting.prototype.removeMarkers = function() {
	var homes = this.route.getAllHomes();
	for (var i in homes) {
		if (homes[i].marker) {
			homes[i].marker.hide();
			homes[i].marker = null;
		}
	}
};

/**
 * Set all markers to unrouted color
 *
 * @method resetMarkers
 * @private
 */
MControlRouting.prototype.resetMarkers = function() {
	var homes = this.route.getAllHomes();
	for (var i in homes) {
		if (homes[i].marker) {
			homes[i].marker.setIcon(this.getMarkerIconUrl(this.unroutedColor));
		}
	}
};

/**
 * Remove all address from address list
 * 
 * @method removeAddresses
 * @private
 */
MControlRouting.prototype.removeAddresses = function() {
	var homes = this.route.getAllHomes();
	for (var i in homes) {
		if (homes[i].listEntry) {
			this.addressList.removeChild(homes[i].listEntry);
			homes[i].listEntry = null;
		}
	}	
};

/**
 * Create a home marker to display on map
 *
 * @method createMarker
 * @private
 * @param {Home} point The home to create marker for
 * @param {String} color Hex color without #
 * @return {MMapMarker} Marker for the home
 */
MControlRouting.prototype.createMarker = function(point, color) {
	var marker = new MMapMarker(this.manager, point, {
		icon: this.getMarkerIconUrl(color),
		zIndex: 7000
	});

	// Bind event listeners
	marker.addEventListener('mouseover', this.onMarkerOver, this);
	marker.addEventListener('mouseout', this.onMarkerOut, this);
	marker.addEventListener('rightclick', this.onMarkerRightClick, this);

	marker.show();

	return marker;
};

/**
 * Get url for marker
 * 
 * @method getMarkerIconUrl
 * @private
 * @return {Url} The url for the marker
 */
MControlRouting.prototype.getMarkerIconUrl = function(color) {
	return Moonshadow.markers + '/marker/__default/' + color + '/0';
};

/**
 * Event handler for keyup and keydown
 *
 * @method onKeyEvent
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onKeyEvent = function(event, details) {
	var onDown = details.type === 'keydown';
	var keyCode = details.keyCode;

	if (keyCode === this.addKeyCode) {
		this.mouseOverMode = onDown ? 1 : (this.rKey) ? -1 : 0;
		this.aKey = onDown;
	} else if (keyCode === this.removeKeyCode) {
		this.mouseOverMode = onDown ? -1 : (this.aKey) ? 1 : 0;
		this.rKey = onDown;
	} else if (!this.rKey && !this.aKey) {
		this.mouseOverMode = 0;
	}

	if (this.overKValue) {
		this.performAddOrRemove(this.overKValue);
	}
};

/**
 * Event handler for mousing over a marker
 *
 * @method onMarkerOver
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onMarkerOver = function(event, marker) {
	var kValue = marker.getMetadata('id');
	this.overKValue = kValue;

	var point = this.route.getHome(kValue);
	this.updateNeighbors(point.street);

	marker.setMetadata('prevIcon', marker.getIcon());
	marker.setIcon(this.getMarkerIconUrl(this.overColorMarker));

	// Highlight entry in list
	if (point.listEntry) {
		point.listEntry.style.backgroundColor = '#' + this.overColor;

		var entry = $(point.listEntry);
		this.scrollAddressListTo(entry);
	}
	
	if (this.dragging !== -1 && !this.route.isKValueInRoute(kValue)) {
		this.insert(this.dragging + 1, kValue);
		this.polyline.abortMidDrag(this.dragging);
		this.dragging = -1;
		this.updateSpaceConstraints(point);
	} else {
		this.performAddOrRemove(kValue);
	}
};

/**
 * Event handler for mousing out of a marker
 *
 * @method onMarkerOut
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onMarkerOut = function(event, marker) {
	var kValue = marker.getMetadata('id');
	var point =  this.route.getHome(kValue);

	this.overKValue = null;

	var prevIcon = marker.getMetadata('prevIcon');
	if (prevIcon) {
		marker.setIcon(prevIcon);
		marker.setMetadata('prevIcon', null);
	} else {
		marker.setIcon(this.getMarkerIconUrl(this.unroutedColor));
	}

	// Unhightlight entry in list
	if (point.listEntry) {
		point.listEntry.style.backgroundColor = '#' + this.defaultListColor;
	}
};

/**
 * Event handler for right clicking on marker
 *
 * @method onMarkerRightClick
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onMarkerRightClick = function(event, marker) {
	var kValue = marker.getMetadata('id');
	this.remove(kValue);
};

/**
 * Event handler for start of mid marker (polyline) drag
 *
 * @method onMidDragStart
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onMidDragStart = function(event, marker) {
	this.dragging = this.polyline.getMidMarkerPos(marker);
};

/**
 * Event handler for end of mid marker (polyline) drag
 *
 * @method onMidDragEnd
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onMidDragEnd = function(event, marker) {
	this.dragging = -1;
};

/**
 * Event handler for right clicking on marker
 *
 * This is present so we can do nothing on mid point inserts events
 *
 * @method onMidInsert
 * @param {String} event Event id
 * @param {Objcet} details Event details
 */
MControlRouting.prototype.onMidInsert = function(event, marker) {};

/**
 * Bind an event listner
 * 
 * @method addEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MControlRouting.prototype.addEventListener = function(event, listener, context) {
	this.observers.addObserver(event, listener, context);
};

/**
 * Unbind an event listener
 *
 * @method removeEventListener
 * @param {String} event The event id
 * @param {Function} listener Function to call when event happens
 * @param {Object} context Context to use for function when called
 */
MControlRouting.prototype.removeEventListener = function(event, listener, context) {
	this.observers.removeObserver(event, listener, context);
};

/**
 * Helper function for add/remove to/from route operations
 *
 * @method preformAddOrRemove
 * @param {Number} kValue KValue of home
 */
MControlRouting.prototype.performAddOrRemove = function(kValue) {
	var inRoute = this.route.isKValueInRoute(kValue)
	if (this.mouseOverMode > 0 && !inRoute) {
		this.add(kValue);
	} else if (this.mouseOverMode < 0 && inRoute) {
		this.remove(kValue);
	}
};

/**
 * Adds home to route and updates polyine, markers, and address list
 *
 * @method add
 * @param {Number} kValue KValue of home
 * @return {Boolean} True if home was add, true if nothing changed
 */
MControlRouting.prototype.add = function(kValue) {
	// Get the point
	var point = this.route.getHome(kValue);
	var latLng = point.marker.getPoint();

	// If point has already been added, remove it and readd
	if (this.route.isHomeInRoute(point)) {
		throw new Error('This should not happen');
	}

	// Add point ot the polyline
	this.polyline.addPoint(latLng);
	
	var prevIcon = point.marker.getMetadata('prevIcon');
	if (prevIcon) {
		point.marker.setMetadata('prevIcon', this.getMarkerIconUrl(this.routedColor));
	} else {
	 	point.marker.setIcon(this.getMarkerIconUrl(this.routedColor));
	}

	this.route.append(point);
	this.addAddressToList(point);

	var entry = $(point.listEntry);
	this.scrollAddressListTo(entry);

	this.updateProgress();

	return true;
};

/**
 * Removes home from route and updates polyine and markers
 *
 * @method remove
 * @param {Number} kValue KValue of home
 * @return {Boolean} True if home was removed, true if nothing changed
 */
MControlRouting.prototype.remove = function(kValue) {
	var point = this.route.getHome(kValue);	
	var latLng = point.marker.getPoint();

	if (!this.route.isHomeInRoute(point)) {
		return false;
	}

	// Remove point from polyline
	this.polyline.removePoint(this.polyline.getFirstIndex(latLng));

	if (this.route.isKValueInHomes(kValue, this.neighbors)) {
		var houseColor = this.streetColorOdd;
		if (this.route.isKValueHouseNumberEven(kValue)) {
			houseColor =  this.streetColorEven;
		}

		var color = this.getMarkerIconUrl(houseColor);

		point.marker.setIcon(color);
		point.marker.setMetadata('prevIcon', color);
	} else {
		point.marker.setIcon(this.getMarkerIconUrl(this.unroutedColor));
		point.marker.setMetadata('prevIcon', null);
	}

	this.route.remove(point);
	this.removeAddressFromList(point);
	this.updateProgress();

	return true;
};

/**
 * Inserts home into route and updates polyine and markers
 *
 * @method insert
 * @param {Number} kValue KValue of home
 * @return {Boolean} True if home was inserted, true if nothing changed
 */
MControlRouting.prototype.insert = function(index, kValue) {
	// Get the point and it it too the polyline
	var point = this.route.getHome(kValue);
	var latLng = point.marker.getPoint();

	// If point has been added, then don't bother removing it
	if (this.route.isHomeInRoute(point)) {
		this.route.remove(point);
		this.polyline.removePoint(this.polyline.getFirstIndex(latLng));
	}

	// Add point to polyline
	this.polyline.insertPoint(index, latLng);

	var prevIcon = point.marker.getMetadata('prevIcon');
	if (prevIcon) {
		point.marker.setMetadata('prevIcon', this.getMarkerIconUrl(this.routedColor));
	} else {
	 	point.marker.setIcon(this.getMarkerIconUrl(this.routedColor));
	}
	
	var before = this.route.getHomeByIndex(index);
	if (before !== -1) {
		this.route.insertBefore(before, point);
		this.insertAddressIntoList(point);
	} else {
		this.route.append(point);
		this.addAddressToList(point);

		var entry = $(point.listEntry);
		this.scrollAddressListTo(entry);
	}

	this.updateProgress();

	return true;
};

/**
 * Scroll the address list to an entry
 *
 * @method scrollAddressListTo
 * @param {DOMElement} entry Node in list to scroll to
 */
MControlRouting.prototype.scrollAddressListTo = function(entry) {
	var list = $(this.addressList);
	var scrollPosition = list.scrollTop();
	var entryPosition = entry.position().top;
	list.scrollTop(scrollPosition + entryPosition);
};

/**
 * Call to see if mid marker needs to be hidden
 *
 * @method updateSpaceConstraints
 * @param {Home} home Home to check for space constraints
 */
MControlRouting.prototype.updateSpaceConstraints = function(home) {
	// If point is odd (it's out of space)
	// Prevent dragging (adding of homes);
	if (home.sequence & 1) {
		var index = this.route.getIndexoByHome(home);
		if (index != -1) {
			this.polyline.hideMidMarker(index);
			this.polyline.hideMidMarker(index - 1);
		}
	}
};

/**
 * Update neighbors (houses on same street) 
 *
 * This function maintains a list of houses that are on the same 
 * street as the last marker to be moused over
 *
 * @method updateNeighbors
 * @param {String} street The name of the street
 */
MControlRouting.prototype.updateNeighbors = function(street) {
	var neighbors = this.neighbors || [];
	// Set all previous homes to their previous color
	for (var i = 0, l = neighbors.length; i < l; i++) {
		var neighbor = neighbors[i];
		if (!this.route.isHomeInRoute(neighbor)) {
			neighbor.marker.setIcon(this.getMarkerIconUrl(this.unroutedColor));
		}
	}

	neighbors = this.route.getHomesByStreet(street);

	// Set all neighboring homes to the street color
	for (var i = 0, l = neighbors.length; i < l; i++) {
		var neighbor = neighbors[i];
		if (!this.route.isHomeInRoute(neighbor)) {
			var houseColor = this.streetColorOdd;
			if (this.route.isKValueHouseNumberEven(neighbor.kValue)) {
				houseColor =  this.streetColorEven;
			}

			neighbor.marker.setIcon(this.getMarkerIconUrl(houseColor));
		}
	}

	this.neighbors = neighbors;
};

/**
 * Creates ui (mostly the address list)
 *
 * @method createUI
 * @private
 */
MControlRouting.prototype.createUI = function() {
	var container = document.createElement('div');
	container.id = 'routingcontainer';
	container.style	.display = 'none';

	var header = document.createElement('div');
	header.className = 'header';

	var routeName = document.createElement('div');
	routeName.className = 'route-name';
	header.appendChild(routeName);
	this.routeName = routeName;

	var helpText = document.createElement('div');
	helpText.className = 'help';
	helpText.appendChild(document.createTextNode(
		'Tap the "E" key to Add. Tap the "R" key to Remove'
	));
	
	header.appendChild(helpText);
	container.appendChild(header);

	var loading = document.createElement('div');
	loading.className = 'loading';
	this.loading = loading;

	var addressList = document.createElement('div');
	addressList.className = 'addresses';
	addressList.style.display = 'none';

	var self = this;
	$(addressList).sortable({
		'cursor': 'move',
		'stop': function(event, ui) {
			var index = ui.item.index();
			var item = ui.item[0]
			var kValue = item.kValue;
		
			var current = self.route.getHome(kValue);
			var target = self.route.getHomeByIndex(index);
			if (self.route.outOfSpace(target)) {
				$(this).sortable("cancel");
				$(current.listEntry).css("background-color", "#FFFF00")
					.animate({"backgroundColor": "#FFFFFF"}, 500);
			} else {
				self.insert(index, kValue);
				self.updateSpaceConstraints(self.route.getHome(kValue));
				$(current.listEntry).css("background-color", "#66FF00")
					.animate({"backgroundColor": "#FFFFFF"}, 500);
			}
		}
	});
	$(addressList).disableSelection();

	this.addressList = addressList;

	container.appendChild(loading);
	container.appendChild(addressList);

	var footer = document.createElement('div');
	footer.className = 'footer';

	var progress = document.createElement('div');
	progress.className = 'progress';
	footer.appendChild(progress);
	this.progress = progress;

	var clearButton = document.createElement('input');
	clearButton.type = 'button';
	clearButton.className = 'restart';
	clearButton.value = 'Clear Route';

	$(clearButton).click({self: this}, this.onClearClicked);

	var exitButton = document.createElement('input');
	exitButton.type = 'button';
	exitButton.className = 'exit';
	exitButton.value = 'Exit Routing Mode';

	$(exitButton).click({self: this}, this.onExitClicked);

	footer.appendChild(clearButton);
	footer.appendChild(exitButton);
	container.appendChild(footer);

	this.container = container;
};

/**
 * Event handler for map resize
 * 
 * @method onResize
 */
MControlRouting.prototype.onResize = function() {
	var map = $('#mapcontainer');
	var controlPosition = $('#topRightControls');
	controlPosition.height(map.height() - 50);
};

/**
 * Adds home to address list
 *
 * @method addAddressToList
 * @param {Home} point Home to add to list
 */
MControlRouting.prototype.addAddressToList = function(point) {
	if (!point.listEntry) {
		point.listEntry = this.createListEntry(point);
	}

	if (this.overKValue === point.kValue) {
		point.listEntry.style.backgroundColor = '#' + this.overColor;
	}

	this.addressList.appendChild(point.listEntry);
};

/**
 * Remove home frmo address list
 *
 * @method removeAddressFromList
 * @param {Home} point Home to remove from list
 */
MControlRouting.prototype.removeAddressFromList = function(point) {
	if (!point.listEntry) {
		return false;
	}

	this.addressList.removeChild(point.listEntry);
	point.listEntry = null;
};

/**
 * Insert address in to address list
 *
 * @method insertAddressIntoList
 * @param {Home} point Home to insert
 */
MControlRouting.prototype.insertAddressIntoList = function(point) {
	if (!point.listEntry) {
		point.listEntry = this.createListEntry(point);
	}

	if (this.route.isFirstHome(point)) {
		this.addressList.insertBefore(point.listEntry, this.addressList.firstChild);
	} else if (this.route.isLastHome(point)) {
		this.addressList.appendChild(point.listEntry);
	} else {
		var next = this.route.getNextHome(point);
		this.addressList.insertBefore(point.listEntry, next.listEntry);
	}
};

/**
 * Create address list entry for a home
 *
 * @method createListEntry
 * @param {Home} point Home to create entry for
 * @return {DOMElement} The DOMElement to insert in to address list
 */
MControlRouting.prototype.createListEntry = function(point) {
	var container = document.createElement('div');
	container.className = 'list-item';
	container.kValue = point.kValue;

	$(container).mouseenter({'kValue': point.kValue, 'self': this}, 
							function(event) {
		var self = event.data.self;
		var kValue = event.data.kValue;
		self.overKValue = kValue;

		this.style.backgroundColor = '#' + self.overColor;

		var home = self.route.getHome(kValue);
		home.marker.setIcon(self.getMarkerIconUrl(self.overColorMarker));
	});

	$(container).mouseleave({'kValue': point.kValue, 'self': this}, 
							function(event) {
		var self = event.data.self;
		var kValue = event.data.kValue;
		self.overKValue = null;

		this.style.backgroundColor = '#' + self.defaultListColor;

		var home = self.route.getHome(kValue);
		home.marker.setIcon(self.getMarkerIconUrl(self.routedColor));
	});

	var handle = document.createElement('span');
	handle.className = 'ui-icon ui-icon-arrowthick-2-n-s handle';	
	
	container.appendChild(handle);

	var label = document.createElement('span');
	label.className = 'address';
	label.appendChild(document.createTextNode(point.address));

	var details = document.createElement('span');
	details.className = 'details';

	var numDoors = 0;
	var totalVoters = 0;
	$.each(point.units, function(key, value) {
		numDoors++;
		totalVoters += value;
	});

	var detailsText = '(' + numDoors + ' doors)';
	details.appendChild(document.createTextNode(detailsText));

	container.appendChild(label);

	if (numDoors > 1) {
		container.appendChild(details);
	}

	var remove = document.createElement('span');
	remove.className = 'ui-icon ui-icon-closethick remove clickable';	

	$(remove).click({'kValue': point.kValue, 'self': this}, function(event) {
		event.data.self.overKValue = null;
		event.data.self.remove(event.data.kValue);
	});
	
	container.appendChild(remove);
	
	return container;
};

/**
 * Event handler for clear list being clicked
 *
 * @method onClearClicked
 * @param {Object} event Event details
 */
MControlRouting.prototype.onClearClicked = function(event) {
	var self = event.data.self;
	if (!self.universe) {
		throw new Error('Universe is not set');
	}
	MUILayoverPanel.confirm({
		"message": "Are you sure you want to clear this route?",
		"callback": function(res, id, hide){
			if(res){
				self.route.clear(function(error, result) {
					if (error) {
						throw error;
					}

					self.polyline.hide();
					self.polyline = self.createPolyline();

					self.resetMarkers();
					self.removeAddresses();
					self.updateProgress();
				});
			}
			hide();
		}
	});
};

/**
 * On exit routing mode event handler
 * 
 * @method onExitClicked
 * @param {Object} event Event details
 */
MControlRouting.prototype.onExitClicked = function(event) {
	var self = event.data.self;
	var routed = self.route.getNumRouted();
	var total = self.route.getNumHomes();
	// If any address routed and route not complete, show warning.
	MUILayoverPanel.confirm({
		"message": "This route is not complete. Are you sure you want to leave it partially routed?",
		"callback": function(res, id, hide){
			if(res){
				self.manager.getControl('routing').endRouting();
			}
			hide();
		}
	});
};

Moonshadow.helpers.extend(MControlRouting, MControl);
/*

 Some terminology:

 viewport - what you see.  the bars visible on screen.  the bars
 outside of what is visible are in the "chart" but not the viewport.
 they can be moved into the viewport by panning.

 chart - is all of the rendered bars.  even those outside of what is
 visible (the "viewport").

 row - the data for each int_name colored by is returned in a row.
 for example, if you're coloring by canvasser and there are 5
 canvassers, you'll get 5 rows back in the data (assuming all goes
 well).

 the difference between the viewport and chart is an important one to
 grok.

 the chartStartDate and chartEndDate are used to determine where to
 start binning and where to end.

 some notes:

 there are two important ranges
 1) the ranges of dates within which we render data
 2) the range of data that one bar (or "bin") represents

 */

/**
*
* @method MControlTemporal
* @extends MControl
* @constructor
* @param {} options
*/
function MControlTemporal (options) {

	// system
	this.name = "temporal";
	this.position = 3;
	this.manager = null;
	this.container = false;
	this.options = options || {};
	this.values = {};
	this.ui = {};
	this.filterable = {};
	this.datasourceId = null;
	this.colorBy = null;
	this.colors = null;

	// state
	this.processingShow = false;
	this.processingZoom = false;
	this.liveMode = false;

	// algorithmic parameters - chart
	this.getTableSliceString = "minutes";
	this.WEEK = 604800;
	this.min = 1370080000000;
	this.max = 4455344000000;
	this.from = 0;
	this.to = 0;
	this.xDelta = 0;
	this.chartStartDate = 0;
	this.chartEndDate = 0;
	this.midnightInSecs = 0;
	this.timePerBar = 0;
	this.rows = [];
	this.timestamps = [];
	this.bins = [];
	this.slicedData = [];
	this.zoomScale = 0;
	this.xAxis = undefined;
	this.yAxis = undefined;
	this.barWidth = 6,
	this.barMargin = 2,
	this.xaxisHeight = 20,
	this.margin = {top: 5, right: 5, bottom: 14, left:3},
	this.chartBuffersPerSide = 1;
	this.maxY = 0; // this gives us the upper bounds of the Y axis
	this.yHeader = 1.1; // used to add extra value to y axis for display purposes
	this.yHeightScalor = .85; // used to limit y axis drawing too high
	this.xScale = undefined;
	this.yScale = undefined;

	// algorithmic parameters - live mode
	this.liveModeTimeIntervalMin = 2; // in minutes
	this.liveModeTimeInterval = this.liveModeTimeIntervalMin * 60 * 1000; // in milliseconds
	// unused	this.liveModeDepth = 24 * 60 * 60 * 1000; // in milliseconds
}

MControlTemporal.prototype = {

	/* lifecycle  */

	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	init: function(manager) {
		this.manager = manager;
		this.manager.addMapObserver('openTemporal', this.show, this);
		this.manager.addMapObserver('updateTemporal', this.onFilterableChange, this);
		this.manager.addMapObserver('closeTemporal', this.hide, this);
	},

	/**
	 *
	 * @method show
	 * @param {} event
	 * @param {} data
	 */
	show: function(event, data) {
		var that = this;

		this.xScale = d3.time.scale()
			.domain([this.min, this.max])
			.rangeRound([0, this.divWidth() -
						 this.margin.right -
						 this.margin.left - 3]);

		if (!this.processingShow) {
			this.processingShow = true;

			if (!(this.surveyId === undefined)) {
				if ((this.surveyId != data.surveyId) ||
					(this.callerIntName != data.intName)) {

					this.clearData();
				} 
			}

			this.disableMarkers();

			this.filterable = data.filterable;
			this.surveyId = data.surveyId;
			this.callerIntName = data.int_name;

			this.from = this.filterable.getDateForStart();
			this.to = this.filterable.getDateForEnd();

			// this builds the control.
			if(this.container === false) {
				this.buildUI();
				this.manager.getAdapter().addControlToMap(this, true);
			} else {
				this.updateDateAndTimeField("start", this.from.getTime());
				this.updateDateAndTimeField("end", this.to.getTime());
			}

			this.bindListeners();
			this.getDataAndBuildChart();
			this.container.style.display = "block";
			this.processingShow = false;
		}
	},
	bindListeners: function observe() {
		this.manager.addMapObserver(['before_panel_open',
									 'before_panel_close',
									 'panel_resize'],
									this.beforeResize, this);

		this.manager.addMapObserver('resize', this.duringResize, this);

		this.manager.addMapObserver(['panel_stop',
									 'panel_change'],
									this.duringResize, this);

		this.manager.addMapObserver('changecountscope',
									this.countScopeChanged,
									this);

		this.manager.addAjaxEventListener('filterchange',this);
		this.manager.addAjaxEventListener('colorbychange',this);
		this.manager.addAjaxEventListener('resize', this);

		if (this.countScope() === "viewport") {
			this.manager.addAjaxEventListener('bounds', this);
		}
	},
	buildUI: function() {
		var container = document.createElement("div");
		container.id = "temporal-container";
		$('.temporal-container').width(this.divWidth());
		this.container = container;

		var histogramContainer = this.buildHistogramContainer();
		container.appendChild(histogramContainer);

		var bottomControls = document.createElement("div");
		bottomControls.id = "bottom-controls";

		bottomControls.appendChild(this.buildFilter("Start", "from"));
		bottomControls.appendChild(this.buildLabelAndValue("One Bar ~ ", this.timePerBar + " minutes"));
		
		
		var markerControl = Moonshadow.getManager().getControl('canvassingmarkers').control(this.surveyId);
		if(markerControl){
			bottomControls.appendChild(this.buildLiveModeButton());
		}
		
		bottomControls.appendChild(this.buildFilter("End", "to"));
		bottomControls.appendChild(this.buildSettingsButton());
		container.appendChild(bottomControls);

	},
	countScope: function() {
		return this.manager.getControl('countsmodel').countScope;
	},
	countScopeChanged: function(event, data) {
		if (data.scope === "global") {
			this.manager.removeAjaxEventListener('bounds', this);
		} else {
			this.manager.addAjaxEventListener('bounds', this);
		}
	},
	duringResize: function() {
		var timer = 0, that = this;

		// i don't like this getting called all the time, but it's
		// simplest for now.
		$('.histogram-container').empty();

		clearTimeout(timer);
		timer = setTimeout(function() {
			that.resizeChart();
		}, 150);
	},
	beforeResize: function() {
		$('.histogram-container').empty();
	},
	resizeChart: function() {
		if (this.rows.length != 0) {
			this.xScale.rangeRound([0, this.divWidth() -
									this.margin.right -
									this.margin.left - 3]);
			this.sliceData();
		} else {
			$(".histogram-container").text("NO DATA");
		}
	},
	afterResize: function() {
		this.resizeChart();
	},
	clearData: function() {
		this.rows = [];
		this.timestamps = [];

		this.manager.mapObservers.notify('temporalClosed', {
			start: this.from.getTime() / 1000,
			end: this.to.getTime() / 1000
		});
	},
	hide: function() {
		this.clearData();
		this.manager.removeAjaxEventListener('filterchange', this);
		this.manager.removeAjaxEventListener('colorbychange', this);
		this.manager.removeAjaxEventListener('bounds', this);
		this.manager.removeAjaxEventListener('resize', this);
		this.enableMarkers();
		this.exitLiveMode();
		if (this.container) {
			this.container.style.display = "none";
		}
		this.manager.mapObservers.notify('temporalClosed', {
			start: this.from.getTime() / 1000,
			end: this.to.getTime() / 1000
		});
	},
	onFilterableChange: function() {
		var dates = this.filterable.getUIDates();
		this.setUIDates(dates[0], dates[1]);
	},

	/* ui */
	buildFilter: function(label, name) {
		var container = this.buildFilterContainer(label, name);

		var date = this.buildDateField(name);
		container.appendChild(date);

		this.ui[name + "_date"] = date;

		var time = this.buildTimeField(name, date);
		container.appendChild(time);

		this.ui[name + "_time"] = time;

		return container;
	},
	buildLabelAndValue: function(labelText, valueText) {
		var container = document.createElement("div");
		var label = document.createElement("span");
		var value = document.createElement("span");

		container.className = 'time_per_bar';
		label.className = "time_per_bar_label";
		label.appendChild(document.createTextNode(labelText));
		container.appendChild(label);
		value.className = "time_per_bar_value";
		value.appendChild(document.createTextNode(valueText));
		container.appendChild(value);

		return container;
	},
	buildLiveModeButton: function() {
		var container = document.createElement("div");
		var label = document.createElement("span");

		container.className = 'live_mode clickable temporal_button';
		label.className = 'live_mode_label';
		label.appendChild(document.createTextNode("start live mode"));
		container.appendChild(label);

		$(container).click({"self":this}, function(event) {
			var that = event.data.self, element = $(this);

			if (that.liveMode) {
				that.exitLiveMode();
			} else {
				that.enterLiveMode();
			}
		});

		return container;
	},
	buildFilterContainer: function(labelText, name) {
		var container = document.createElement("div");
		container.className = name + '_filter';

		var label = document.createElement("span");
		label.className = "label";
		label.appendChild(document.createTextNode(labelText));
		container.appendChild(label);

		return container;
	},
	buildDateField: function (fieldType) {
		var dateField = document.createElement("input");

		dateField.type = "text";
		dateField.readOnly = true;

		var value
		if (fieldType === 'from') {
			value = this.filterable.getDateValueForStart();
		} else {
			value = this.filterable.getDateValueForEnd();
		}

		dateField.value = value;
		
		var timeClassString = "." + fieldType + "_time";

		return $(dateField)
			.addClass("clickable temporal_button")
			.addClass(fieldType + "_date date_field")
			.data({
				"filter":this,
				"name": fieldType,
				"type":"date"
			})
			.datepicker({
				"changeMonth":true,
				"changeYear":true,
				"maxDate":"1/1/2037",
				"minDate":"1/1/1971",
				"yearRange": "1971:2037"
			})
			.change({
					"self":this, 
					"pickerClass":timeClassString
				},
				function(event) {
					var self = event.data.self;
	
					// If time isn't filled out, then set
					// it to midnight truth be told, this
					// can probably be deleted because we
					// auto fill the date & time with the
					// min & max
	
					var picker = $(event.data.pickerClass, event.data.self.container);
					if (!picker.timepicker().val()) {
						picker.attr({'readonly':false}).removeClass("field_disabled");
						picker.timepicker('setTime', '00:00');
					}
	
					self.processDateOrTimeField(this);
				}
			)
			.get(0);
	},
	buildTimeField: function (fieldType, dateField) {
		var timeField = document.createElement("input");
		var value;
		timeField.type = "text";

		// setting the value for fromTime is a touch tricky because we
		// must assume that the page could be reloaded so it has to be
		// calculated from persistent data which means that we have to
		// calculate it from fromDate's value.

		if (!dateField.value) {
			timeField.readOnly = true;
			$(timeField).addClass("field_disabled");
		}

		$(timeField).data({
			"filter": this,
			"name": fieldType,
			"type": "time"
		});
		$(timeField).timepicker({
			'disableTextInput': true,
			'scrollDefaulttime' : true
		});

		$(timeField).addClass(fieldType +
							  "_time time_field clickable temporal_button");

		//var filter = this.filterable.getFilterValue();

		//if (filter && filter[fieldType]) {
		//	value = Moonshadow.helpers.timeSinceMidnight(filter[fieldType]);
		//} else {
			if (fieldType === "from") {
				value = this.filterable.getTimeValueForStart();
				//value = Moonshadow.helpers.timeSinceMidnight(this.min / 1000);
			} else {
				//value = Moonshadow.helpers.timeSinceMidnight(this.max / 1000);
				value = this.filterable.getTimeValueForEnd();
			}
		//}

		$(timeField).timepicker('setTime', value);

		$(timeField).change({"self": this}, function(event) {
			var self = event.data.self;

			self.processDateOrTimeField(this);
		});

		return timeField;
	},
	buildHistogramContainer: function() {
		var histogramContainer = document.createElement("div");

		histogramContainer.className = "histogram-container";
		$('.histogram-container').width(this.divWidth());

		return histogramContainer;
	},
	buildCloseButton: function() {
		var closeButtonWrapper = document.createElement("div");
		var closeButton = document.createElement("div");

		closeButtonWrapper.className = "histogram_close_button_wrapper";
		closeButton.className = "sprite-close_x clickable temporal_button";

		closeButtonWrapper.appendChild(closeButton);

		$(closeButton).click({"self":this}, function(event) {
			var that = event.data.self;

			that.hide();

		});

		return closeButtonWrapper;
	},
	buildSettingsButton: function() {
		var that = this,
			container = document.createElement("div"),
			containerDiv = $(container);

		container.className = "temporal_settings sprite-settingsSmall clickable temporal_button";
		containerDiv.click(function () {
			var list = $('.temporal_settings_list');

			// toggle
			if (list.length != 0) {
				if (list[0].style.display === "block" ||
					list[0].style.display === "") {
					list[0].style.display = "none";
				} else {
					list[0].style.display = "block";
				}
			} else {
				buildList();
			}

			function buildList() {
				var list = document.createElement("div"),
					toggleHouses = document.createElement("div"),
					toggleCanvassers = document.createElement("div"),
					mainContainer = $("#maincontainer");
				list.className = "temporal_settings_list clickable floating option-list";

				list.style.right = mainContainer.outerWidth() -
					containerDiv.offset().left +
					containerDiv.outerWidth() - 35 + "px";
				list.style.top = containerDiv.offset().top -
					containerDiv.outerHeight() - 36 + "px";

				toggleHouses.className = "clickable opt";
				toggleHouses.appendChild(document.createTextNode("Hide Houses"));
				$(toggleHouses).click(function () {

					// this should probably all get moved into the
					// 'canvassingmarkers' control and we should just
					// emit an event.
					
					var markerControl = Moonshadow.getManager().getControl('canvassingmarkers').control(that.surveyId);
					if(!markerControl){
						return;
					}
					if (markerControl.housesShowing) {
						// hide houses
						this.textContent = "Show Houses";
						markerControl.housesShowing = false;
					} else {
						// show houses
						this.textContent = "Hide Houses";
						markerControl.housesShowing = true;
					}
					markerControl.toggleMarkers(false);
					markerControl.toggleMarkers(true, that.surveyId);
				});

				toggleCanvassers.className = "clickable opt";
				toggleCanvassers.appendChild(document.createTextNode("Hide Canvassers"));
				$(toggleCanvassers).click(function () {

					// this should probably all get moved into the
					// 'canvassingmarkers' control and we should just
					// emit an event.

					var markerControl = Moonshadow.getManager().getControl('canvassingmarkers').control(that.surveyId);
					if(!markerControl){
						return;
					}
					if (markerControl.canvassersShowing) {
						// hide canvassers
						this.textContent = "Show Canvassers";
						markerControl.canvassersShowing = false;
					} else {
						// show canvassers
						this.textContent = "Hide Canvassers";
						markerControl.canvassersShowing = true;
					}
					markerControl.toggleMarkers(false);
					markerControl.toggleMarkers(true, that.surveyId);
				});

				list.appendChild(toggleHouses);
				list.appendChild(toggleCanvassers);

				mainContainer[0].appendChild(list);
			}
		});
		this.settings = container;

		return container;
	},

	updateTimePerBarDisplay: function() {
		var units = " minutes",
			newValue = this.timePerBar;

		/*
		 newvalue / 1000 = seconds
		 / 60 = minutes
		 / 60 = hours
		 / 24 = days

		 > 2 days, round # of days
		 < 2 days, round # of hours
		 < 2 hours, round # of minutes

		 */

		if ((newValue /= (1000 * 60)) > 120) {
			units = " hours";
			if ((newValue /= 60) > 48) {
				units = " days";
				newValue /= 24;
			}
		}
		$('.time_per_bar_value').text(Math.round(newValue) + units);
	},
	updateDateAndTimeField: function(fieldType, datetime) {
		var dateSel = (fieldType === "end") ? ".to_date" : ".from_date",
			timeSel = (fieldType === "end") ? ".to_time" : ".from_time";
		if (typeof datetime === "number") {
			datetime = new Date(datetime);
		}
		$(timeSel).timepicker("setTime", datetime);
		$(dateSel).datepicker("setDate", datetime);
	},

	/* ui.. "functions".. hmm. */
	divWidth: function() {
		return parseInt(d3.select('#mapcontainer').style('width'), 10) * .8;
	},

	/* chart */
	updateColorByAndColors: function () {
		var colorByControl = this.manager.getControl('colorbycontrol');
		var colorBy = colorByControl.getActiveColorBy();		
		this.colorBy = colorBy.color;
		this.colors = colorBy.colors;
	},
	getDataAndBuildChart: function() {
		var ajax = new Moonshadow.Ajax(), now;
		this.updateColorByAndColors();
		ajax.addQuery(this.getTableQuery(), this.processQueryResults, this);
		now = new Date();
		this.queryStart = +now;
		ajax.execute();
	},
	getTableQuery: function(from, to) {
		var bounds;
		var dsId = this.filterable.getDatasource().int_name;
		var fieldId = this.filterable.int_name;

		var localDate = new Date();
		var row = this.colorBy;
		if(row == "__heatmap"){
			row = "__total";
		}
		var timezoneOffset = localDate.getTimezoneOffset() * 60;
		var filtersControl = this.manager.getControl('filterscontrol');
		//var filters = filtersControl.getFilters(dsId, {});

		var query = {
			"query": "get_table",
			"dirty_only": false,
			"omit_zero_rows": 1,
			"omit_zero_columns": 1,
			"ds": dsId,
			"table_settings": {
				"rows": row,
				"columns": [
					{
						"field": fieldId,
						"bucket_info": {
							"time_slice": this.getTableSliceString,
							"tz_offset": timezoneOffset,
							"display_timeslice_human_readable": 0
						}
					}
				]
			}
		//	"filter": filters
		};

		if (this.countScope() === "viewport") {
			bounds = this.manager.getAdapter().getBounds();
			query.lat_s = bounds.swLat;
			query.lat_n = bounds.neLat;
			query.long_w = bounds.swLon;
			query.long_e = bounds.neLon;
		}

		return query;
	},
	processQueryResults: function(data) {
		var viewPortWidthAsTime, now = new Date(), that = this,
			errorMessage = "MControlTemporal.js: get_table query failed: ";

		if (data.result == "fail") {
			errorMessage += data.message;
			throw new Error(errorMessage);
			return false;
		}

		if (data.rows.length === 0) {
			$(".histogram-container").text("NO DATA");
			return false;
		}

		this.rows = data.rows;
		this.timestamps = data.header[0].fields[0].values;

		viewPortWidthAsTime = (this.to.getTime() / 1000) - (this.from.getTime() / 1000);

		this.chartStartDate = this.from.getTime() - viewPortWidthAsTime;
		this.chartEndDate = this.to.getTime() + viewPortWidthAsTime;

		// So, the xScale. Clearly it's a huge part of the
		// chart. Thing is, we don't always want to be setting the
		// xScale when we get results from a query.
		// But, we don't want to always reset an extant xScale. If
		// we're in liveMode, we shouldn't set the xScale because
		// we're not displaying ... wait a sec.
		if (!this.liveMode || !(this.countScope() === "viewport")) {
			setxScale();
		}

		this.timePerBar = +this.xScale.invert(this.barWidth + this.barMargin)
			- +this.xScale.invert(0);

		this.updateTimePerBarDisplay();

		hopefullyFillInMissingColors();

		this.binData();

		function setxScale() {
			that.xScale = d3.time.scale()
				.domain([that.from.getTime() , that.to.getTime()])
				.rangeRound([0, that.divWidth() -
							 that.margin.right -
							 that.margin.left - 3]);
		}

		function hopefullyFillInMissingColors() {
			var i, rows = that.rows;
			// this function is a (another) bandage on the corpse of
			// the way coloring works in our application

			for (i = 0; i < rows.length; i += 1) {
				if (that.colors[rows[i].name] === undefined) {

					// we have to have the array index reference an
					// object because we might get colors from
					// Moonshadow.*.color[sS|By]() and we need to
					// match their format.
					that.colors[rows[i].name] = {
						value: Moonshadow.helpers.rw5(rows[i].name)
					};
				}
			}
		}

		return true;
	},

	binData: function(rightmostBin) {
		var that = this,
			timevalues = this.timestamps,
			rows = this.rows,
			total = timevalues.length,
			i, j, startingIndex, _value, _maxY = 0,
			bins = [], datum = {}, currentBin = 0,
			step = (rightmostBin || timestamp(total - 1)) - this.timePerBar,
			then = new Date(), now;

		this.maxY = 0;

		makeTheFirstBin();

		// go through data in reverse order, for live mode's sake.
		// that is, we need to bin from the most recent time
		for (i = total - 2; i >= 0; i -= 1) {
			if (timestamp(i) > step) {
				// for each row, put its value in the bin
				for (j = 0; j < rows.length; j++) {

					_value = rows[j].values[i];
					bins[j].values[currentBin].value += _value;

					_maxY += _value;

				}
			} else {

				findCurrentStep(timestamp(i));
				createANewBin(i);

				// keep track of the maximum value for the y-range for
				// the chart
				if (this.maxY < _maxY) this.maxY = _maxY;
				_maxY = 0;
			}
		}
		function createANewBin(index) {

			for (j = 0; j < rows.length; j++) {

				datum.timestamp = step;
				datum.value = rows[j].values[index];
				_maxY += datum.value;

				bins[j].values.push($.extend({},datum));
			}

			currentBin += 1;
			return true;
		}
		function findCurrentStep(t) {
			while (t < step) {
				step -= that.timePerBar;
			}
		}
		function timestamp(i) {
			return timevalues[i] * 1000;
		}
		function makeTheFirstBin() {
			// we have to initialize things - as opposed to letting
			// the body of the function do all the work.  the reason
			// is that we need to include the row's int_name as a
			// property on the result object (bins)
			var intNameObject = {};

			// first of all, the first datum may not be at step 0
			if (timestamp(total -1) < step) {
				findCurrentStep(timestamp(total - 1));
			}

			// fill the results array,
			// one per row
			for (j = 0; j < rows.length; j++) {

				datum.timestamp = timevalues[total - 1] * 1000;
				datum.value = rows[j].values[total - 1];
				_maxY += datum.value;

				intNameObject.name = rows[j].name;
				intNameObject.values = [];
				intNameObject.values.push($.extend({},datum));
				bins.push($.extend({},intNameObject));
			}
		}

		// check the last value for _maxY
		if (this.maxY < _maxY) this.maxY = _maxY;

		this.bins = bins;

		now = new Date();
		this.sliceData();
		return true;
	},
	sliceData: function() {
		var i, j, slicedData = [], tempObject = {},
			currentTimestamp, bins = this.bins,
			then = new Date(), now;

		$('.histogram-container').empty();

		// initialize the results array
		for (i = 0; i < bins.length; i += 1) {

			tempObject.name = bins[i].name;
			tempObject.values = [];
			slicedData.push($.extend({},tempObject));
		}

		for (i = 0; i < bins[0].values.length; i++) {
			currentTimestamp = bins[0].values[i].timestamp;

			// if this timevalue is between the chart start and end date..
			if	((currentTimestamp) <= this.chartEndDate) {
				if ((currentTimestamp) >= this.chartStartDate) {

					for (j = 0; j < slicedData.length; j += 1) {

						slicedData[j].values.push($.extend({},bins[j].values[i]));
					}

				} else {
					i = bins[0].values.length; // break out of loop
				}
			}
		}

		now = new Date();
		this.drawChart(slicedData);
	},
	drawChart: function(data) {
		var that = this,
			histogramContainer = d3.select(".histogram-container"),
			histogramContainerWidth = parseInt(histogramContainer.style('width'), 10),
			histogramContainerHeight = parseInt(histogramContainer.style('height'), 10),
			width = histogramContainerWidth,
			height = histogramContainerHeight,
			layers, xScale, yScale,
			then = new Date(), now;


		// the following builds the stack function which will tranform our data
		// note that .values generates the data that is passed to .x and .y
		// that's why i used "d" for .values and "dd" for .x and .y - they are
		// different
		this.stack = d3.layout.stack()
			.values(function (d) { return d.values; })
			.x(function (dd) { return dd.timestamp; })
			.y(function (dd) { return dd.value; });

		layers = this.stack(data);

		yScale = d3.scale.linear()
			.domain([0, this.maxY * this.yHeader])
			.rangeRound([0, height * this.yHeightScalor]);

		this.xAxis = d3.svg.axis()
			.scale(this.xScale)
			.tickSize(-height + this.margin.bottom)
			.outerTickSize(0)
			.tickPadding(3);

		this.yAxis = d3.svg.axis()
			.scale(yScale)
			.orient('left')
			.tickPadding(0);

		var zoom = d3.behavior.zoom()
				.x(this.xScale)
				.y(yScale)
				.scaleExtent([0.5, 2])
				.on("zoom", zoomFunction(this))
				.on("zoomend", zoomEndFunction(this));

		var svg = histogramContainer.append("svg")
				.attr('class', 'chart')
				.attr('width', width)
				.attr('height', height)
				.call(zoom)
				.append('g')
				.attr('transform', 'translate(' + this.margin.left  + ' , ' +
					  (height - this.margin.bottom) + ')');

		var clipPath = svg.append("clipPath")
				.attr("id", "clip")
				.append("rect")
				.attr("x", 0)
				.attr("y", (-height + this.margin.bottom + this.margin.top))
				.attr("width", width)
				.attr("height", height - this.margin.bottom - this.margin.top);

		var chartBody = svg.append("g")
				.attr("clip-path", "url(#clip)");

		// add a group for each layer
		var nameGroups = chartBody.selectAll("g.name")
				.data(layers)
				.enter().append("svg:g")
				.attr("class", "nameGroup")
				.style("fill", function(d,i) {
					var color = (that.colors[d.name]) ?
							that.colors[d.name].value :
							Moonshadow.helpers.rw5(d.name);
					return "#" + color;
				});

		var rect = nameGroups.selectAll("rect")
				.data(function (d) { return d.values; })
				.enter().append("svg:rect")
				.attr("class", "stackedBar")
				.attr("x", function (d) { return that.xScale(d.timestamp); })
				.attr("y", function (d) { return -yScale(d.y0) - yScale(d.y); })
				.attr("width", this.barWidth)
				.attr("height",function (d) { return +yScale(d.y); });

		svg.append('g')
			.attr('class', 'x axis')
			.call(this.xAxis);

		// Add y-axis rules.
		var rule = svg.selectAll("g.rule")
				.data(yScale.ticks(5))
				.enter().append("svg:g")
				.attr("class", "rule")
				.attr("transform", function(d) {
					return "translate(0," + -yScale(d) + ")";
				});

		rule.append("svg:line")
			.attr("x2", width) // - this.margin.left - this.margin.right)
			.style("stroke", "#d3d3d3")
			.style("stroke-opacity", function(d) { return d ? .7 : null; });

		rule.append("svg:text")
			.attr("dy", ".35em")
			.attr("font-size","12px")
			.attr("text-anchor", "left")
			.text(d3.format(",d"));

		this.processingZoom = false;

		now = new Date();

		function zoomFunction(scope) {
			return function() {
				var that = scope;

				that.exitLiveMode();

				// really, all this function does, besides the
				// superficial animation is capture these variables.
				that.xDelta = d3.event.translate[0];
				that.zoomScale = d3.event.scale;

				// the following two calls are just to give the user
				// some initial feedback that they zoomed in.  they
				// don't change any data, just the vector graphics.

				// zoom the xAxis
				svg.select(".x.axis").call(that.xAxis);

				// zoom the bars
				svg.selectAll(".stackedBar").attr("transform", "translate(" +
												  that.xDelta + ",0)scale(" +
												  that.zoomScale + ", 1)");
			};
		}
		function zoomEndFunction(scope) {
			return function() {
				var that = scope,
					viewPortStartDate = +that.xScale.domain()[0],
					viewPortEndDate = +that.xScale.domain()[1],
					viewPortWidthAsTime = viewPortEndDate - viewPortStartDate,
					chartStartDateFromViewport = viewPortStartDate -
						(viewPortWidthAsTime * that.chartBuffersPerSide),
					chartEndDateFromViewport = viewPortEndDate +
						(viewPortWidthAsTime * that.chartBuffersPerSide);

				if (!that.processingZoom) {

					that.chartStartDate = chartStartDateFromViewport;
					that.chartEndDate = chartEndDateFromViewport;
					that.processingZoom = true;

					if (that.zoomScale !== 1) { // zooming, not panning
						// because D3 rescales the xScale we need to
						// recalculate how much time each bin
						// represents
						that.timePerBar = +that.xScale.invert(
							that.barWidth + that.barMargin) - +that.xScale.invert(0);
						that.updateTimePerBarDisplay();
						that.binData();
					} else {
						that.sliceData();
					}
				}
			};
		}
	},
	maxBarsOnScreen: function() {
		return (parseInt(d3.select(".histogram-container").style('width'), 10) * .9) / 
			(this.barWidth + this.barMargin);
	},
	enterLiveMode: function() {
		var that = this,
			viewportWidth = this.liveModeTimeInterval * this.maxBarsOnScreen(),
			now = new Date(),
			element = $('.live_mode');

		this.liveMode = true;
		element.text("stop live mode");
		element.css('background-color', 'lightgreen');
		$('.temporal_settings').css('display', 'block');

		this.refreshTimer = setInterval(liveModeLoop, this.liveModeTimeInterval);

		this.timePerBar =  that.liveModeTimeInterval;
		this.updateTimePerBarDisplay();

		setChartVariables(now);

		toggleMarkers();

		// we need to handle the case where it's a new survey with no
		// data. only bin data if there is data
		if (this.rows.length != 0) {
			this.binData(+now);
		}

		function toggleMarkers() {
			var markerControl = that.manager.getControl("canvassingmarkers").control(that.surveyId);
			if(markerControl){
				markerControl.toggleMarkers(true, that.surveyId);
			}
		}
		function setChartVariables(now) {
			that.from = new Date(now.getTime() - viewportWidth);
			that.to = now;

			that.xScale.domain([that.from.getTime(), that.to.getTime()]);

			that.chartStartDate = +now - (viewportWidth * 2);
			that.chartEndDate = +now;

			that.updateDateAndTimeField("end", now);
		}
		function liveModeLoop() {
			var ajax = new Moonshadow.Ajax(),
				nowInSecs = Math.round(+now / 1000),
				midnight = new Date(now.getFullYear(),
									now.getMonth(),
									now.getDate());

			that.midnightInSecs = midnight / 1000;


			now = new Date();
			ajax.addQuery(that.getTableQuery(that.midnightInSecs, nowInSecs),
						  validateData, that);
			ajax.execute();

			function validateData(data) {
				setChartVariables(now);

				if (data.rows && data.rows.length != 0) {
					processData(data);
				}
			}

			function processData(data) {
				var i = 0, j = 0, numberToDelete = 0, newData = [],
					storedData = [], mergedRows = [], tempRow = {}, 
					newTimestamps = data.header[0].fields[0].values,
					storedTimestamps = that.timestamps,
					cutIndex = that.timestamps.length,
					matchedIndex = 0, additionalZeros = 0;

				now = new Date();

				//
				// first, timestamps
				//

				// find the index > today at midnight
				while(storedTimestamps[cutIndex - 1] > that.midnightInSecs) {
					cutIndex -= 1;
				}

				// get the amount of entries past today at midnight
				numberToDelete = storedTimestamps.length - cutIndex;

				// put the new timestamp values at the end of the stored ones
				storedTimestamps.splice(cutIndex, numberToDelete);
				that.timestamps = storedTimestamps.concat(newTimestamps);

				//
				// then, rows
				//

				// 1. extend each row in that.rows
				// while putting them into mergedRows

				if (that.rows.length != 0) {

				additionalZeros = that.timestamps.length -
					that.rows[0].values.length;

					for (i = 0; i < that.rows.length; i += 1) {
						
						for (j = 0; j < additionalZeros; j += 1) {
							that.rows[i].values.push(0);
						}
						
						tempRow.name = that.rows[i].name;
						tempRow.row_id = that.rows[i].row_id;
						tempRow.values = that.rows[i].values;
						
						mergedRows.push($.extend({},tempRow));
					}
				}
				
				// 2. put data.rows into merged rows

				for (i = 0; i < data.rows.length; i += 1) {
					
					matchedIndex = newDataFoundInStoredDataAtIndex(i);
					
					if (matchedIndex !== false) {

						newData = data.rows[i].values;
						storedData = mergedRows[matchedIndex].values;
						storedData.splice(cutIndex, numberToDelete);
						mergedRows[matchedIndex].values =
							storedData.concat(newData);

					} else {

						// fill zeros
						for (j = 0; j < cutIndex; j += 1) {
							data.rows[i].values.unshift(0);
						}

						// then push onto mergedRows

						tempRow.name = data.rows[i].name;
						tempRow.row_id = data.rows[i].row_id;
						tempRow.values = data.rows[i].values;

						mergedRows.push($.extend({},tempRow));
					}
				}

				that.rows = mergedRows;

				function newDataFoundInStoredDataAtIndex(index) {
					var k = 0;

					if (mergedRows.length === 0) {
						return false;
					}

					for (k = 0; k < mergedRows.length; k += 1) {
						if (data.rows[index].row_id === mergedRows[k].row_id) {
							return k;
						}
					}

					return false;
				}

				that.binData(+now);
			}
		}
	},
	exitLiveMode: function() {
		
		var element = $('.live_mode');
		element.text("start live mode");
		element.css('background-color', 'white');
		$('.temporal_settings').css ('display', 'none');
		$('.temporal_settings_list').css('display', 'none');

		this.liveMode = false;
		clearInterval(this.refreshTimer);
		
		var markerControl = this.manager.getControl("canvassingmarkers");
		if(markerControl){
			markerControl.toggleMarkers(false);
		}
	},

	/* functionality */
	processDateOrTimeField: function(field) {
		var fieldType = field.className;
		var fromDate = $(this.ui['from_date']).val();
		var fromTime = $(this.ui['from_time']).timepicker('getSecondsFromMidnight');

		var toDate = $(this.ui['to_date']).val();
		var toTime = $(this.ui['to_time']).timepicker('getSecondsFromMidnight');

		var from = new Date(new Date(fromDate).getTime() + fromTime * 1000);
		var to = new Date(new Date(toDate).getTime() + toTime * 1000);

		if (from >= to) {
			return MUILayoverPanel.alert("The END date/time needs to be greater than the START date/time.");
		}

		this.from = from;
		this.to = to;

		this.filterable.setDates(this.from, this.to);

		// This deals with an annoying problem related to datepicker not reopening
		$(field).blur();
	},
	setUIDates: function(from, to) {
		this.updateDateAndTimeField('start', from);
		this.updateDateAndTimeField('end', to);
	},
	onAjaxEvent: function(event, data, ajax) {
		var ds = this.getManager().getDatasource().int_name;
		var eventsToWatch = ['filterchange', 'colorbychange', 'bounds', 'resize'];

		if (event === 'colorbychange') {
			if (this.datasourceId != ds) {
				this.unbindCountListener(this.datasourceId);
				this.datasourceId = ds;
				this.bindCountListener(this.datasourceId);
			}
		}

		if ($.inArray(event, eventsToWatch) !== -1) {
			$('.histogram-container').empty();

			this.updateColorByAndColors();

			ajax.addQuery(this.getTableQuery(), this.processQueryResults, this);
		}
	},
	bindCountListener: function(ds) {
		var details = {
			'ds': ds,
			'field': 'totals',
			'listener': this.updateCounts,
			'context': this
		};
	},
	unbindCountListener: function(ds) {
		var details = {
			'ds': ds,
			'field': 'totals',
			'listener': this.updateCounts,
			'context': this
		};
	},
	updateCounts: function() {
		// stub, clearly
	},
	enableMarkers: function() {
		var markers = this.manager.getControl('markers');
		if (markers) {
			markers.enable();
		}
	},
	disableMarkers: function() {
		var markers = this.manager.getControl('markers');
		if (markers) {
			markers.disable();
		}
	}
};
Moonshadow.helpers.extend(MControlTemporal,MControl);


function MControlGroundGame(options) {
	this.name = "groundgame";
	this.manager = null;
	this.options = options || {};
	this.wizard;
};

Moonshadow.helpers.extend(MControlGroundGame, MControl);

MControlGroundGame.prototype.init = function(manager) {
	this.manager = manager;
};

MControlGroundGame.prototype.show = function(tab, callback){
	this.wizard = new MUIWizardHelper(this.manager, this.panels(), tab, callback);
};

MControlGroundGame.prototype.panels = function(){
	return [{
		"id": "surveys",
		"title":"Surveys",
		"header": "Ground Game Management : Survey Management",
		"control": new MControlListSurveys(this.manager, "groundgame"),
		"docs": {
			"url": Moonshadow.gg_tutorials,
			"icon": "sprite-tutorial tut_icon",
			"title": "Ground Game Tutorials"
		}
	},{
		"id": "lists",
		"title": "Walking Lists",
		"header": "Ground Game Management : Assign Surveys to Walking Lists",
		"control": new MControlSurveyAssignment(this.manager),
		"docs": {
			"url": Moonshadow.gg_tutorials,
			"icon": "sprite-tutorial tut_icon",
			"title": "Ground Game Tutorials"
		}
	},{
		"id": "users",
		"title": "User Assignment",
		"header": "Ground Game Management : Assign Walking Lists to Users",
		"control": new MControlListAssignment(this.manager),
		"docs": {
			"url": Moonshadow.gg_tutorials,
			"icon": "sprite-tutorial tut_icon",
			"title": "Ground Game Tutorials"
		}
	}];
};

MControlGroundGame.prototype.switchUserAssignmentContent = function(type){
	this.wizard.getTabControl("users").switchContent(type);
};

MControlGroundGame.prototype.expandUserAssignmentSection = function(universeId){
	this.wizard.getTabControl("users").expandUserAssignmentSection(universeId);
};

MControlGroundGame.prototype.expandUniverseSection = function(universeId){
	this.wizard.getTabControl("lists").expandUniverseSection(universeId);
};


function MControlFacebookPolls(options) {
	this.name = "fbpolls";
	this.manager = null;
	this.options = options || {};
	this.wizard;
};

Moonshadow.helpers.extend(MControlFacebookPolls, MControl);

MControlFacebookPolls.prototype.init = function(manager) {
	this.manager = manager;
};

MControlFacebookPolls.prototype.show = function(tab, callback){
	this.wizard = new MUIWizardHelper(this.manager, this.panels(), tab, callback);
};

MControlFacebookPolls.prototype.panels = function(){
	return [
	{
		"id": "surveys",
		"title":"Surveys",
		"header": "Facebook Polls Management : Survey Management",
		"control": new MControlListSurveys(this.manager, "facebookpoll")
	},{
		"id": "campaigns",
		"title":"Campaigns",
		"header": "Facebook Polls Management : Poll Campaigns",
		"control": new MControlFacebookPollCampaigns(this.manager)
	}];
};

MControlFacebookPolls.viewAggregateResults = function(survey_id, fbpageids, show_global){

	var ce = Moonshadow.helpers.ce;
	var defaultChartOptions = {
		"titleTextStyle": {
			"fontSize": 14
		},
		"backgroundColor": "#EEEEEE",
		"width": 500,
		"height": 200,
		"is3D": true
	};
	
	var buildPie = function(title, data){
		var pie = $(ce("div"))
			.addClass("msfb_results_graph")
			.get(0);
		
		var pchart = new google.visualization.PieChart(pie);
		pchart.draw(
			google.visualization.arrayToDataTable(data), 
			{
				"title": title,
				"titleTextStyle": defaultChartOptions.titleTextStyle,
				"backgroundColor": defaultChartOptions.backgroundColor,
				"width": defaultChartOptions.width,
				"height": defaultChartOptions.height,
				"is3D": defaultChartOptions.is3D,
				"legend": defaultChartOptions.legend,
				"chartArea": defaultChartOptions.chartArea
			}
		);
		return pie;
	};
	
	var formatResultArray = function(options){
		var resultArray = [
			["Choice", "Count"]
		];
		var total = 0;
		for(var ii in options){
			var value = options[ii];
			total += value;
			resultArray.push([ii, value]);
		}
		if(total == 0){
			return false;
		}
		return resultArray;
	};
	
	var buildTitle = function(title){
		var chars = title.length;
		var width = 750;
		if((width / 10) < chars){
			var titleArray = title.split(" ");
			var tempArray = titleArray.slice();
			var breakAt = Math.floor(titleArray.length * (Math.floor(width / 10) / chars));
			for(var i = 0, l = tempArray.length; i < l; ++i){
				if(i == 0 || i == tempArray.length - 1){
					continue;
				}
				if(i % breakAt == 0){
					titleArray.splice(i, 1, "\n");
				}
			}
			return titleArray.join(" ");
		}
		return title;
	};
	
	var emptyPie = function(title){
		return $(ce("div"))
			.addClass("msfb_empty_results")
			.append(
				$(ce("span"))
					.addClass("msfb_empty_results_title")
					.append(title),
				$(ce("span"))
					.addClass("msfb_empty_results_message")
					.append("There are no results yet gathered for this question.")
			)
			.get(0)
	};
	
	var panel;
	var placePies = function(){
		$(".msfb_pies_container", panel.container)
			.empty()
			.append(
				function(){
					if(!pies.length){
						return $(ce("p"))
							.addClass("italic")
							.append(
								"No results to show."
							);
					}
					return "";
				}(),
				$.map(pies, function(pie){
					return $(pie).get(0);
				})
			)
	};
	
	var displayResults = function(){
		panel = new MUILayoverPanel({
			"content": $(ce("div"))
				.addClass("msfb_content")
				.append(
					$(ce("table"))
						.addClass("msfb_content_table")
						.append(
							$(ce("tr"))
								.append(
									$(ce("td"))
										.addClass("msfb_page_container_cell")
										.append(buildPageControl()),
									$(ce("td"))
										.append(
											$(ce("div"))
												.addClass("msfb_pies_container")
										)
								)
						)
				),
			"title": "Aggregate Poll Results",
			"fixed": false,
			"animate": true,
			"minWidth": 550,
			"maxHeight": 800,
			"position": {
				"width": 750,
				"height": 500
			},
			"scrollable": true,
			"onOpen": function(){
				placePies();
			}
		});
		
		panel.open();
	};
	
	var calculatedResultStruct;
	var resultStruct;
	var pies = [];
	var pages = [];
	
	var calculateResults = function(resultsPerPages, pageIds){
		if(pageIds != undefined && pageIds.length == 0){
			return;
		}
		calculatedResultStruct = {};
		for(var survey in resultsPerPages){
			var pageResult = resultsPerPages[survey];
			for(var pageId in pageResult){
				if(pageIds != undefined && $.inArray(pageId, pageIds) == -1){
					continue;
				}
				var results = pageResult[pageId];
				for(var questionId in results){
					var q = results[questionId];
					if(!calculatedResultStruct[questionId]){
						calculatedResultStruct[questionId] = {};
					}
					for(var opt in q.options){
						if(!calculatedResultStruct[questionId][opt]){
							calculatedResultStruct[questionId][opt] = 0;
						}
						calculatedResultStruct[questionId][opt] += q.options[opt];
					}
				}
			}
		}
	};
	
	var redrawPies = function(){
		var checkedPages = $(".msfb_pagecontrol_item input::checked").map(function(i, elem){
			return elem.value;
		}).toArray();
		calculateResults(resultStruct, checkedPages);
		buildResultPies(checkedPages);
		placePies();
	};
	
	var buildPageControl = function(){
		var control = $(ce("div"))
			.addClass("msfb_pagecontrol")
			.append(
				$(ce("p")).append(
					$(ce("b")).append("Pages having results for this poll:")
				)
			);
		
		for(var survey in resultStruct){
			var pageResult = resultStruct[survey];
			for(var pageId in pageResult){
				var pageInfo = MControlFacebookPollCampaigns.getPageDetails(pageId, pages);
				var name = pageInfo ? pageInfo.fullname : pageId;
				$(control)
					.append(
						$(ce("label"))
							.addClass("msfb_pagecontrol_item")
							.attr({
								"for": "pagedetails_" + pageId
							})
							.append(
								$(ce("input"))
									.attr({
										"type": "checkbox",
										"value": pageId,
										"id": "pagedetails_" + pageId,
										"checked": true
									})
									.on("change", function(){
										redrawPies();
									})," ",
								name
							)
					)
			}
		}
		return control;
	}
	
	var buildResultPies = function(pageIds){
		pies = [];
		if(pageIds != undefined && pageIds.length == 0){
			return;
		}
		for(var survey in resultStruct){
			var pageResult = resultStruct[survey];
			for(var pageId in pageResult){
				var results = pageResult[pageId];
				for(var questionId in results){
					var q = results[questionId];
					var title = buildTitle(q.ext_name);
					var formatted = formatResultArray(calculatedResultStruct[questionId]);
					if(!formatted){
						pies.push(emptyPie(title));
						continue;
					}
					pies.push(buildPie(title, formatted));
				}
				break;
			}
		}
	};
	
	var getResultStruct = function(callback){
		if(!calculatedResultStruct || !resultStruct){
			return new Moonshadow.Ajax({
				"url": "/fbpollsmanagement/pollresults/" + survey_id,
				"type": "POST",
				"execute": true,
				"payload": {
					"fbpageids": fbpageids,
					"show_global": show_global
				},
				"onSuccess": function(response){
					resultStruct = response.results;
					calculateResults(resultStruct);
					callback();
				}
			});
		}
		callback();
	};
	
	getResultStruct(function(){
		var _continue = function(){
			buildResultPies();
			displayResults();
		};
		if(!pages.length){
			return MControlFacebookPollCampaigns.getPages(function(_pages){
				pages = _pages;
				_continue();
			});
		}
		_continue();
	});
};

function MControlFacebookPollCampaigns(manager){
	this.manager = manager;
	this.container;
	this.campaigns;
	this.buttons;
	this.pages;
	this.sorter;
	this.editPanel;
	this.activeControl = "all";
};

MControlFacebookPollCampaigns.prototype.getContent = function(callback){
	var ce = Moonshadow.helpers.ce;
	this.container = $(ce("div"))
		.addClass("fbpollcampaigns");
	
	this.buildSorter();
	$(this.container)
		.append(
			this.sorter.sorterObj.ui,
			this.sorter.container
		);
	
	this.refreshCampaignList();
	callback(this.container);
};

MControlFacebookPollCampaigns.staticText = {
	"header_text": "Here you will fill out options for your poll. Required fields are marked with a red asterisk ( <b class='red'>*</b> ). ",
	"choose_survey": "Choose the survey that will appear on your Facebook page. If you don't have any here, click the Surveys tab above and click \"New Survey\".",
	"show_results": "You have the option to show the aggregate results after a user takes your poll.",
	"allow_redo": "This option will present the user with the ability to resubmit their answers to your poll. Note: this does not add results, but " +
		"changes the previously submitted results by this user. ",
	"allow_review": "This option presents the user with a link they can click to see the poll results whether they have taken the poll or not.",
	"facebook_pageid": "This is where you choose which Facebook page will display the poll you have chosen. If you don't have any Facebook " +
		" pages listed in the dropdown, click \"Connect to Facebook\" from the Campaign tab.",
	"facebook_sharelink": "When you are ready to promote your poll, post this link to insure that both desktop and mobile respondents will be able to participate.",
	"facebook_pluginsnippet": "This code can be used to embed your poll on a web page. It will ask the respondent to log into Facebook first, if they do not have " +
		" an active session. ",
	"active": "This option allows you to activate/deactive your poll. If there is no active poll, respondents will see a \"Coming Soon\" message.",
	"available_to": "Here are all the applications in which your survey is available. To add more, click the \"Surveys\" tab and choose \"Copy to Application\" " +
		" in the dropdown for youe poll.",
	"is_dirty": "You have unsaved changes. Discard all changes and close?",
	"missing_items": "Please fill out all the required fields to continue.",
	"make_new_active": "The page %fullname% currently has an active survey. Do you wish to make this survey active instead? ",
	"delete_campaign": "Delete this Facebook poll campaign? Note: if this is currently your active poll, respondents will see a " +
		" \"Coming Soon\" message after deletion. This action will not delete the survey or the responses already gathered. ",
	"cancel_campaign": "Cancel creation of Facebook poll campaign? ",
	"campaign_title": "This will be the title shown when previewing your poll before it's posted on Facebook.",
	"campaign_name": "This name is for your reference only. It will be shown in your list of campaigns in the Campaigns tab.",
	"addtofacebook_text": "<p>To add a Facebook page to this list, start by clicking the \"Add to Facebook\" button. You need to have a page already created on " +
		" Facebook and be an administrator for that page. You are able to add as many pages as you have registered in Facebook, however, it's advisable to add them one " +
		" at a time.</p><p>Once you add a page, you should then type in a name for the page next to it's numeric ID. You can only remove a page from this list if " +
		" there are no campaigns currently set to use that page.</p><p>If you remove the Groundgame Social Polls application from Facebook, you can add it again with the " +
		" \"Add to Facebook\" button.</p>"
};

MControlFacebookPollCampaigns.prototype.addToFBPage = function(){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	return $(ce("iframe"))
		.css({
			"margin": 0,
			"padding": 0,
			"border": 0,
			"width": "1px",
			"height": "1px"
		})
		.attr({
			"src": "/fbpollsmanagement/addpage"
		})
		.get(0);
};

MControlFacebookPollCampaigns.prototype.newCampaign = function(){
	return {
		"customername": this.manager.getOption("customer"),
		"appname": this.manager.getOption("app"),
		"active": true,
		"options": {
			"show_results": true,
			"allow_redo": false,
			"allow_review": false,
			"show_global": false
		},
		"dirty": true
	};
};

MControlFacebookPollCampaigns.prototype.isDirty = function(campaign){
	if(campaign.dirty == undefined){
		var hash = $.md5(JSON.stringify(campaign));
		campaign.hash = hash;
		campaign.dirty = false;
		return this.toggleSave(campaign);
	}
	var campHash = campaign.hash;
	delete campaign.hash;
	delete campaign.dirty;
	var hash = $.md5(JSON.stringify(campaign));
	campaign.dirty = (hash != campHash);
	campaign.hash = campHash;
	this.toggleSave(campaign);
}

MControlFacebookPollCampaigns.prototype.toggleSave = function(campaign){
	$(".fbpollcampaign_save_button", this.editPanel.container)
		.attr({
			"disabled": !campaign.dirty
		});
	if(this.editPanel){
		this.editPanel.showIsDirty(campaign.dirty);
	}
};

MControlFacebookPollCampaigns.prototype.saveCampaign = function(campaign){
	var self = this;
	
	var save = function(){
		new Moonshadow.Ajax({
			"url": "/fbpollsmanagement/savepoll",
			"type": "POST",
			"payload": {"campaign": campaign},
			"onSuccess": function(response){
				if(response.result == "ok"){
					delete campaign.hash;
					delete campaign.dirty;
					self.isDirty(campaign);
					self.refreshCampaignList();
				}
			},
			"execute": true
		});
	};
	
	var valid;
	campaign.appname = this.manager.getOption("app");
	if(!(valid = this.validateCampaign(campaign))){
		return MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.missing_items);
	}
	
	if(!campaign.active){
		return save();
	}
	new Moonshadow.Ajax({
		"url": "/fbpollsmanagement/hasactive/" + campaign.fbpageid,
		"type": "GET",
		"onSuccess": function(response){
			if(response.result == "ok" && response.poll && response.poll.poll_id != campaign.poll_id){
				var page = self.getPageDetails(campaign.fbpageid);
				return MUILayoverPanel.confirm({
					"message": MControlFacebookPollCampaigns.staticText.make_new_active.replace("%fullname%", page.fullname),
					"callback": function(res, id, close, buttonText){
						if(res){
							save();
						}
						close();
					}
				});
			}
			save();
		},
		"execute": true
	});
};

MControlFacebookPollCampaigns.prototype.validateValue = function(value){
	var invalidStrings = {
		"Choose Survey": true,
		"No Surveys To Choose From": true,
		"No Facebook Pages to Choose From": true,
		"Choose Facebook Page": true
	};
	return value != undefined && value.length > 0 && !invalidStrings[value];
};

MControlFacebookPollCampaigns.prototype.validateCampaign = function(campaign){
	var required = $(".required", this.editPanel.container);
	var valid = true;
	for(var i = 0, l = required.length; i < l; ++i){
		var reqVal = $(required[i]).val();
		if(!this.validateValue(reqVal)){
			$(required[i]).addClass("invalid");
			valid = false;
		}
	}
	return valid;
};

MControlFacebookPollCampaigns.prototype.addAppToBFButton = function(){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	return $(ce("input"))
		.addClass("fbpollcampaign_addtopage")
		.attr({
			"type": "button",
			"value": "Add to Facebook"
		})
		.on("click", function(){
			$("iframe")[0].contentWindow.postMessage("addtofacebook", "*")
		});
};

MControlFacebookPollCampaigns.prototype.editFBPollCampaign = function(campaign){
	this.newFBPollCampaign(JSON.parse(JSON.stringify(campaign)));
};

MControlFacebookPollCampaigns.prototype.getPageDetails = function(fbpageid){
	return MControlFacebookPollCampaigns.getPageDetails(fbpageid, this.pages);
};

MControlFacebookPollCampaigns.getPageDetails = function(fbpageid, pages){
	for(var i = 0, l = pages.length; i < l; ++i){
		if(pages[i].fbpageid == fbpageid){
			return pages[i];
		}
	}
};

MControlFacebookPollCampaigns.prototype.newFBPollCampaign = function(campaign){
	if(!campaign){
		campaign = this.newCampaign();
	}
	
	var self = this;
	this.getPages(function(pages){
		self.getFBSurveys(function(surveys){
			self.editPanel = new MUILayoverPanel({
				"id": "edit_fbpoll_campaign", 
				"content": self.buildCampaignDetails(campaign, surveys, pages),
				"footer": self.buildCampaignFooter(campaign),
				"title": "Edit Facebook Poll Campaign",
				"fixed": false,
				"animate": true,
				"minWidth": 550,
				"maxHeight": 700,
				"scrollable": true,
				"position": {
					"width": 800,
					"height": 500
				},
				"onClose": function(callback){
					if(campaign.dirty){
						return MUILayoverPanel.confirm({
							"message": MControlFacebookPollCampaigns.staticText.is_dirty,
							"modal": true,
							"callback": function(response, id, hide){
								if(response){
									callback(response);
								}
								hide();
							}
						});
					}
					callback();
				},
				"onOpen": function(){
					self.isDirty(campaign);
				}
			});
			self.editPanel.open();
		});
	});
};

MControlFacebookPollCampaigns.prototype.getCampaign = function(poll_id){
	for(var i = 0, l = this.campaigns.length; i < l; ++i){
		if(this.campaigns[i].poll_id == poll_id){
			return this.campaigns[i];
		}
	}
};

MControlFacebookPollCampaigns.prototype.getShareLink = function(pageid, type){
	var base = this.manager.getOption("fbsharelink");
	switch(type){
		case "share": 
			return base + "/socialpolls/" + pageid;
		case "plugin":
			return base + "/" + pageid;
	}
};

MControlFacebookPollCampaigns.prototype.buildCampaignFooter = function(campaign){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	return $(ce("div"))
		.addClass("fbpollcampaign_details_footer")
		.append(
			$(ce("input"))
				.attr({
					"type": "button",
					"value": "Delete Campaign"
				})
				.on("click", function(){
					var message = MControlFacebookPollCampaigns.staticText.cancel_campaign;
					if(campaign.poll_id){
						message = MControlFacebookPollCampaigns.staticText.delete_campaign;
					}
					return MUILayoverPanel.confirm({
						"message": message,
						"callback": function(res, id, close){
							if(res){
								campaign.dirty = false;
								self.deleteCampaign(campaign);
								self.editPanel && self.editPanel.close();
							}
							close();									
						}
					});
				}),
			$(ce("input"))
				.addClass("fbpollcampaign_save_button")
				.attr({
					"type": "button",
					"value": "Save Campaign",
				})
				.on("click", function(){
					self.saveCampaign(campaign);
				}),
			$(ce("input"))
				.attr({
					"type": "button",
					"value": "Close"
				})
				.on("click", function(){
					self.editPanel && self.editPanel.close();
				})
		);
};

MControlFacebookPollCampaigns.prototype.buildCampaignDetails = function(campaign, surveys, pages){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	
	var buildCodeSnippet = function(link){
		return $(ce("pre"))
			.addClass("fbpollcampaign_plugin_snippet")
			.append(
				"&lt;iframe \n" +
				"   style=\"border: 0; width: 320px; height: 400px;\" \n" +
				"   src=\"" + link + "\"\n" +
				"&gt;&lt;/iframe&gt;"
			)
	};
	
	return $(ce("div"))
		.addClass("fbpollcampaign_details")
		.append(
			$(ce("div"))
				.addClass("fbpollcampaign_details_header")
				.append(MControlFacebookPollCampaigns.staticText.header_text),
			MUIFormElements.elem({
				"type": "textField", "title": "Campaign Name", "className": "fbpollcampaign_name required",
				"value": campaign.options.name || "",
				"events": {
					"change": function(){
						$(this).removeClass("invalid");
						if(this.value && this.value != campaign.options.name){
							campaign.options.name = this.value;
						}
						self.isDirty(campaign);
					}
				},
				"questionButton": {
					"events": {
						"click": function(){
							MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.campaign_name);
						}
					}
				}
			}),
			MUIFormElements.elem({
				"type": "textField", "title": "Campaign Title", "className": "fbpollcampaign_title",
				"value": campaign.options.title || "",
				"events": {
					"change": function(){
						$(this).removeClass("invalid");
						if(this.value && this.value != campaign.options.title){
							campaign.options.title = this.value;
						}
						self.isDirty(campaign);
					}
				},
				"questionButton": {
					"events": {
						"click": function(){
							MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.campaign_title);
						}
					}
				}
			}),
			MUIFormElements.elem({
				"type": "select", "title": "Survey", "required": true, "className": "fbpollcampaign_survey required", "valueName": "name",
				"events": {
					"change": function(){
						$(this).removeClass("invalid");
						if(this.value != "Choose Survey"){
							campaign.survey_id = this.value;
							campaign.survey_name = $("option:selected", this).text();
						}
						self.updateAttached(this.value);
						self.isDirty(campaign);
					}
				},
				"options": function(){
					if((!surveys || !surveys.length) && !campaign.survey_id){
						return [{
							"selected": true,
							"name": "No Surveys To Choose From",
							"disabled": true
						}]
					}
					var hasCopy = false;
					var options = $.map(surveys, function(survey){
						if(campaign.survey_id == survey.int_name){
							hasCopy = true;
						}
						return {
							"value": survey.int_name,
							"selected": campaign.survey_id == survey.int_name,
							"title": survey.ext_name + " (" + survey.appname + ")",
							"name": survey.ext_name + " (" + survey.appname + ")"
						}
					});
					if(campaign.survey_id && !hasCopy){
						options.unshift({
							"value": campaign.survey_id,
							"selected": true,
							"title": campaign.survey_name + " (" + campaign.survey_appname + ")",
							"name": campaign.survey_name + " (" + campaign.survey_appname + ")"
						});
					}
					options.unshift({
						"selected": !campaign.survey_id,
						"name": "Choose Survey",
						"disabled": true
					});
					
					return options;
				}(),
				"questionButton": {
					"events": {
						"click": function(){
							MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.choose_survey);
						}
					}
				}
			}),
			MUIFormElements.elem({
				"type": "select", "title": "Facebook Page", "required": true, "className": "fbpollcampaign_fbpageid required", "valueName": "fbpageid",
				"events": {
					"change": function(){
						$(this).removeClass("invalid");
						if(this.value != "Choose Survey"){
							campaign.fbpageid = this.value;
							$(".fbpollcampaign_sharelink", self.editPanel.container)
								.trigger("update");
							$(".fbpollcampaign_pluginsnippet", self.editPanel.container)
								.trigger("update");
						}
						self.isDirty(campaign);
					}
				},
				"options": function(){
					if(!pages || !pages.length){
						return [{
							"selected": true,
							"name": "No Facebook Pages to Choose From",
							"disabled": true
						}]
					}
					var options = $.map(pages, function(page){
						return {
							"value": page.fbpageid,
							"selected": campaign.fbpageid == page.fbpageid,
							"title": page.fullname,
							"name": page.fullname
						}
					});
					options.unshift({
						"selected": !campaign.fbpageid,
						"name": "Choose Facebook Page",
						"disabled": true
					});
					return options;
				}(),
				"questionButton": {
					"events": {
						"click": function(){
							MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.facebook_pageid);
						}
					}
				}
			}),
			MUIFormElements.elem({
				"type": "checkBox", "title": "Active", "valueName": "active", "value": "active", 
				"attr": {
					"checked": campaign.active
				},
				"events": {
					"change": function(){
						campaign.active = this.checked;
						self.isDirty(campaign);
					}
				},
				"questionButton": {
					"events": {
						"click": function(){
							MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.active);
						}
					}
				}
			}),
			$(ce("div"))
				.addClass("fbpollcampaign_options")
				.append(
					$(ce("span"))
						.addClass("fbpollcampaign_options_header")
						.append("Campaign options:"),
					MUIFormElements.elem({
						"type": "checkBox", "title": "Show overall poll results after submit", "valueName": "show_results", "value": "show_results", 
						"events": {
							"change": function(){
								campaign.options.show_results = this.checked;
								var sub = $(".fbpollcampaign_suboption_show_global", self.editPanel.container);
								if(this.checked){
									$(sub).fadeIn();
								}else{
									$(sub).fadeOut();
								}
								self.isDirty(campaign);
							}
						},
						"attr": {
							"checked": campaign.options.show_results == undefined ? true : campaign.options.show_results
						},
						"questionButton": {
							"events": {
								"click": function(){
									MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.show_results);
								}
							}
						}
					}),
					$(ce("div"))
						.addClass("fbpollcampaign_suboption fbpollcampaign_suboption_show_global")
						.css({
							"display": campaign.options.show_results == true ? "block" : "none"
						})
						.append(
							MUIFormElements.elem({
								"type": "radioButtons",
								"title": "When displaying results to the respondent... ",
								"valueName": "show_global",
								"options": [{
									"title": "Show results only for the page specified above",
									"value": "false",
									"checked": campaign.options.show_global == undefined || campaign.options.show_global == false
								},{
									"title": "Show results for all pages that use this survey",
									"value": "true",
									"checked": campaign.options.show_global == true
								}],
								"events": {
									"change": function(){
										campaign.options.show_global = this.value == "true" ? true : false;
										self.isDirty(campaign);
									}
								}
							})
						),
					MUIFormElements.elem({
						"type": "checkBox", "title": "Allow respondents to resubmit poll multiple times", "valueName": "allow_redo", "value": "allow_redo", 
						"events": {
							"change": function(){
								campaign.options.allow_redo = this.checked;
								self.isDirty(campaign);
							}
						},
						"attr": {
							"checked": campaign.options.allow_redo
						},
						"questionButton": {
							"events": {
								"click": function(){
									MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.allow_redo);
								}
							}
						}
					}),
					MUIFormElements.elem({
						"type": "checkBox", "title": "Allow respondents to review poll results before taking", "valueName": "allow_review", "value": "allow_review", 
						"events": {
							"change": function(){
								campaign.options.allow_review = this.checked;
								self.isDirty(campaign);
							}
						},
						"attr": {
							"checked": campaign.options.allow_review
						},
						"questionButton": {
							"events": {
								"click": function(){
									MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.allow_review);
								}
							}
						}
					})
				),
				MUIFormElements.elem({
					"type": "textField", "title": "Poll Share Link", "className": "fbpollcampaign_sharelink",
					"ghost": campaign.fbpageid == undefined ? "Choose a Facebook Page above to get a share link" : false,
					"attr": {
						"readonly": true
					},
					"value": campaign.fbpageid != undefined ? this.getShareLink(campaign.fbpageid, "share") : "",
					"events": {
						"click": function(){
							this.select();
						},
						"update": function(){
							var pageid = $(".fbpollcampaign_fbpageid", self.editPanel.container).val();
							if(self.validateValue(pageid)){
								this.value = self.getShareLink(pageid, "share");
								$(this).removeClass("ms_textfield_ghosted");
								return;
							}
							this.value = "";
						}
					},
					"questionButton": {
						"events": {
							"click": function(){
								MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.facebook_sharelink);
							}
						}
					}
				}),
				MUIFormElements.elem({
					"type": "textAreaReadout", "title": "Plugin Snippet", "className": "fbpollcampaign_pluginsnippet",
					"value": buildCodeSnippet(this.getShareLink(campaign.fbpageid, "plugin")),
					"events": {
						"click": function(){
							Moonshadow.helpers.selectRange($(".fbpollcampaign_pluginsnippet", self.editPanel.container));
						},
						"update": function(){
							var pageid = $(".fbpollcampaign_fbpageid", self.editPanel.container).val();
							var container = $(".fbpollcampaign_pluginsnippet", self.editPanel.container);
							$(container).empty();
							if(self.validateValue(pageid)){
								return $(container)
									.append(buildCodeSnippet(self.getShareLink(pageid, "plugin")));
							}
						}
					},
					"questionButton": {
						"events": {
							"click": function(){
								MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.facebook_pluginsnippet);
							}
						}
					}
				}),
				$(ce("div"))
					.addClass("fbpollcampaign_attached_apps_container")
					.append(this.displayAttached(campaign.surveyStruct))
		);
};

MControlFacebookPollCampaigns.prototype.deleteCampaign = function(campaign){
	if(!campaign.poll_id){
		return;
	}
	var self = this;
	new Moonshadow.Ajax({
		"url": "/fbpollsmanagement/deletepoll/" + campaign.poll_id,
		"type": "GET",
		"onSuccess": function(response){
			if(response.result == "ok"){
				self.refreshCampaignList();
			}
		},
		"execute": true
	});
};

MControlFacebookPollCampaigns.prototype.updateAttached = function(survey_id){
	$(".fbpollcampaign_attached_apps_container", this.editPanel.container)
		.empty()
		.append(
			this.displayAttached(
				this.getSurveyByID(survey_id)
			)
		);
};

MControlFacebookPollCampaigns.prototype.displayAttached = function(survey){
	var ce = Moonshadow.helpers.ce;
	if(survey && survey.attached && survey.attached.length){
		return $(ce("div"))
			.addClass("fbpollcampaign_options")
			.append(
				$(ce("span"))
					.addClass("fbpollcampaign_options_header")
					.append(
						"Applications this survey available to:"
					),
				$(ce("div"))
					.addClass("ms_question_button clickable")
					.append("?")
					.on("click", function(){
						MUILayoverPanel.alert(MControlFacebookPollCampaigns.staticText.available_to);
					}),
				$(ce("div"))
					.addClass("fbpollcampaign_attached_apps")
					.append(
						$.map(survey.attached, function(app){
							return $(ce("span"))
								.addClass("fbpollcampaign_attached_app")
								.append(app.description)
								.get(0)
						})
					)
			);
	}
	return "";
};

MControlFacebookPollCampaigns.prototype.getFBPollCampaigns = function(refresh, callback){
	if(!this.campaigns || refresh){
		var self = this;
		return new Moonshadow.Ajax({
			"url": "/fbpollsmanagement/campaigns",
			"type": "GET",
			"onSuccess": function(response){
				self.campaigns = response.campaigns || [];
				callback(self.campaigns);
			},
			"execute": true
		});
	}
	callback(this.campaigns);
};


MControlFacebookPollCampaigns.prototype.getFBSurveys = function(callback){
	var surveyManager = this.manager.getControl("surveys");
	surveyManager.getSurveysOfTypes(true, ["facebookpoll"], callback);
};

MControlFacebookPollCampaigns.prototype.getSurveyByID = function(id){
	var surveyManager = this.manager.getControl("surveys");
	return surveyManager.getSurveyByPropertyName("int_name", id);
};

MControlFacebookPollCampaigns.prototype.getButton = function(id){
	if(this.buttons && this.buttons.length){
		for(var i = 0, l = this.buttons.length; i < l; ++i){
			if(this.buttons[i].id == id && this.buttons[i].elem){
				return this.buttons[i].elem;
			}
		}
	}
};

MControlFacebookPollCampaigns.prototype.controlButtons = function(){
	var self = this;
	if(!this.buttons){		
		this.buttons = [
			{
				"id": "connect",
				"title": "Connect to Facebook",
				"right": true,
				"filter": false,
				"action": function(){
					self.facebookConnect();
				}
			},
			{
				"id": "newcamp",
				"title": "New Campaign",
				"right": true,
				"filter": false,
				"action": function(){
					self.newFBPollCampaign()
				}
			}
		];
	};
	return this.buttons;
};

MControlFacebookPollCampaigns.prototype.getPages = function(callback){
	var self = this;
	MControlFacebookPollCampaigns.getPages(function(pages){
		self.pages = pages;
		callback(pages);
	});
};

MControlFacebookPollCampaigns.getPages = function(callback){
	new Moonshadow.Ajax({
		"url": "/fbpollsmanagement/getpages",
		"type": "GET",
		"onSuccess": function(response){
			callback(response.pages || []);
		},
		"execute": true
	});
};

MControlFacebookPollCampaigns.prototype.emptyPagePanel = function(){
	var ce = Moonshadow.helpers.ce;
	return $(ce("div"))
		.addClass("fbpollcampaign_page_panel_empty")
		.append("No Facebook pages registered. Click \"Add to Facebook\" below.");
};

MControlFacebookPollCampaigns.prototype.fillPagePanel = function(panel, pages){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	$(panel) 
		.empty()
		.append(
			!pages.length && this.emptyPagePanel(),
			$.map(pages, function(page, index){
				var pageContainer;
				pageContainer = $(ce("div"))
					.addClass("fbpollcampaign_page_item")
					.append(
						$(ce("div"))
							.addClass("fbpollcampaign_page_item_left")
							.append(
								MUIFormElements.textField(function(){
									if(index == 0){
										return "Page Name";
									}
									return "&nbsp;";
								}(), page.pagename, false, "fbpollcampaign_page_item_name", {
									"change onClear": function(){
										var val = $(this).val();
										if(val == "Type page name..."){
											val = null;
										}
										self.updatePageName(page, val);
									}
								}, null, "pagename", true, "Type page name...")
							),
						$(ce("div"))
							.addClass("fbpollcampaign_page_item_right")
							.append(
								MUIFormElements.elem({
									"type": "textReadout",
									"title": function(){
										if(index == 0){
											return "Page ID Number";
										}
										return "&nbsp;";
									}(),
									"value": page.fbpageid,
									"className": "fbpollcampaign_page_item_pageid",
									"controlButton": $(ce("div"))
										.addClass("ms_question_button clickable")
										.append("x")
										.on("click", function(){
											if(page.inuse > 0){
												return MUILayoverPanel.alert("This page is currently in use and cannot be removed at this time.")
											}
											self.deletePage(page.fbpageid, panel, function(){
												$(pageContainer).remove();
											});
										})
								})
							)
					)
					.get(0);
				return pageContainer;
			})
		);
};

MControlFacebookPollCampaigns.prototype.deletePage = function(fbpageid, panel, callback){
	var self = this;
	new Moonshadow.Ajax({
		"url": "/fbpollsmanagement/deletepage/" + fbpageid,
		"type": "GET",
		"execute": true,
		"onSuccess": function(response){
			callback && callback();
			if(!response || !response.pages || !response.pages.length){
				$(panel).empty()
					.append(self.emptyPagePanel());
			}
		},
		"onFail": function(){}
	});
};

MControlFacebookPollCampaigns.prototype.facebookConnect = function(){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	var panel = $(ce("div"))
		.addClass("fbpollcampaign_page_panel scrollable")
		.get(0);
	
	var addedEvent = function(eventName, event){
		if(event.data && event.data.pages){
			self.fillPagePanel(panel, event.data.pages);
		}
		if(event.data && event.data.error){
			MUILayoverPanel.alert(
				"There was a problem with your request: " + 
				event.data.error
			);
		}
	};
	
	this.manager.addWindowObserver("message", addedEvent, this);

	var helpButton = $(ce("input"))
		.attr({
			"value": "Help",
			"type": "button"
		})
		.on("click", function(){
			MUILayoverPanel.alert(
				MControlFacebookPollCampaigns.staticText.addtofacebook_text
			);
		});
	
	this.getPages(function(pages){
		self.fillPagePanel(panel, pages);
		MUILayoverPanel.alert({
			"title": "Facebook Page Management",
			"buttons": [helpButton, self.addAppToBFButton(), "Close"],
			"message": [panel, self.addToFBPage()],
			"position": {
				"width": 500
			},
			"callback": function(res, id, close){
				self.manager.removeWindowObserver("message", addedEvent, self);
				self.refreshCampaignList();
				close();
			}
		});
	});
};

MControlFacebookPollCampaigns.prototype.updatePageName = function(pageinfo, newpagename){
	if(newpagename != pageinfo.pagename){
		this.pages = null;
		
		pageinfo.pagename = newpagename;
		
		var payload = {};
		payload[pageinfo.fbpageid] = pageinfo.pagename
		new Moonshadow.Ajax({
			"url": "/fbpollsmanagement/savepages",
			"type": "POST",
			"payload": {"pages": payload},
			"execute": true
		});
	}
};

MControlFacebookPollCampaigns.prototype.refreshCampaignList = function(){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var pageIds = {};
	this.getPages(function(pages){
		self.getFBSurveys(function(surveys){
			$(self.sorter.container).empty();
			
			$(self.getButton("newcamp"))
				.attr({
					"disabled": true
				});
			
			$(self.getButton("connect"))
				.attr({
					"disabled": true
				});

			if(!surveys.length){
				return $(self.sorter.container)
					.append(
						$(ce("div"))
							.addClass("fbcampaign_list_empty")
							.append("There are currently no surveys created. Click the Surveys tab above to create one and then finalize it.")
					);
			}
			
			$(self.getButton("connect"))
				.attr({
					"disabled": false
				});
				
			if(!pages.length){
				return $(self.sorter.container)
					.append(
						$(ce("div"))
							.addClass("fbcampaign_list_empty")
							.append("There are currently no Facebook pages registered. Click \"Connect to Facebook\" above to get started.")
					);
			}
			
			$(self.getButton("newcamp"))
				.attr({
					"disabled": false
				});
			
			self.getFBPollCampaigns(true, function(campaigns){
				for(var i = 0, l = pages.length; i < l; ++i){
					pageIds[pages[i].fbpageid] = pages[i];
				}
				
				$(self.sorter.container)
					.append(
						function(){
							if(!campaigns || !campaigns.length){
								return $(ce("div"))
									.addClass("fbcampaign_list_empty")
									.append("There are currently no poll campaigns. Press \"New Campaign\" to create one.");
							}
							
							return $.map(campaigns, function(campaign){
								if(!campaign.options){
									campaign.options = {};
								}
								var pageName = "";
								if(pageIds[campaign.fbpageid]){
									var p = pageIds[campaign.fbpageid];
									pageName = p.pagename && p.pagename.length ? p.pagename : p.fbpageid
								}
									
								return self.sorter.sorterObj.getDataRow({
									"label": campaign.options.name,
									"survey_name": campaign.survey_name,
									"fbpageid": pageName,
									"active": $(ce("input"))
										.attr({
											"type": "checkbox",
											"checked" : campaign.active,
											"disabled": true
										}),
									"edit_campaign": $(ce("input"))
										.attr({
											"type": "button",
											"value": "Edit"
										})
										.on("click", function(){
											self.editFBPollCampaign(
												self.getCampaign(campaign.poll_id)
											);
										})
								}).row;
							});
						}()
					);
				 self.sorter.sorterObj.refreshSort();
			});
		});
	});
};

MControlFacebookPollCampaigns.prototype.buildSorter = function(){
	var ce = Moonshadow.helpers.ce;
	
	var container = $(ce("div"))
		.addClass("fbcampaign_list scrollable");
	
	var sorter = $(ce("div"))
		.addClass("fbcampaign_list_columns");

	var stringSort = function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.returnVal(
			$(a).text().toLowerCase().replace(/\W/g, ""), 
			$(b).text().toLowerCase().replace(/\W/g, ""), 
			sortOrder
		);
	};
	
	var colsorter = new MUIFilterableSorter({
		"sortCriteriaClass": ".fbcampaign_list_item",
		"sortFunctions": {
			"label": function(a, b, sortOrder){
				return stringSort(
					$(".sortable_data_column_label", a), 
					$(".sortable_data_column_label", b), 
					sortOrder
				);
			},
			"survey_name": function(a, b, sortOrder){
				return stringSort(
					$(".sortable_data_column_survey_name", a), 
					$(".sortable_data_column_survey_name", b), 
					sortOrder
				);
			},
			"fbpageid": function(a, b, sortOrder){
				return stringSort(
					$(".sortable_data_column_fbpageid", a), 
					$(".sortable_data_column_fbpageid", b), 
					sortOrder
				);
			},
			"active": function(a, b, sortOrder){
				return MUIFilterableSorter.predefinedSorting.checkboxBool(".sortable_data_column_active input", a, b, sortOrder);
			}
		},
		"columnSettings": [{
			"title": "Campaign Name",
			"value": "Campaign Name",
			"sortdefault": true,
			"sortby": "label"
		},{
			"title": "Survey",
			"value": "Survey",
			"sortby": "survey_name"
		},{
			"title": "Facebook Page",
			"value": "Facebook Page",
			"float": "right",			
			"sortby": "fbpageid"
		},{
			"title": "Active",
			"value": "Active",
			"float": "right",
			"sortby": "active"
		},{
			"spacer": "edit_campaign",
			"float": "right"
		},{
			"spacer": "scroll_spacer",
			"float": "right"
		}],
		"sorterContainerClassName": "sortcampaigns",
		"sorterContainer": sorter,
		"columnDataContainer": container
	});
	
	colsorter.makeColumnSorter(true);
	
	this.sorter = {
		"container": container,
		"sorterCont": sorter,
		"sorterObj": colsorter
	};
};



/**
 * Class that handles recovering deleted universes
 *
 * @class MControlUniveres
 * @constructor
 * @extends MControl
 * 
 */
function MControlZombieUniverses(manager, dsId) {
	this.name = 'zombiecontrol';
	this.manager = manager || null;
	this.zombies = [];
	this.colsorter;
	this.ui;
	this.dsId = dsId;
	this.sortBy = "date_deleted";
	this.sortOrder = -1;
	this.pageNumber = 1;
	this.itemsPerPage = 25;
	this.pageButtons;
	this.toolsPanel;
	this.filterString;
	this.filteredResults = false;
	this.lastSelected;
};


/**
 * Build interface
 * 
 * @method buildUi
 */
MControlZombieUniverses.prototype.buildUi = function(active) {
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	if(!this.ui){
		var bulkTools = $(ce("div"))
			.addClass("zombies_bulk_tools")
			.append(
				$(ce("input"))
					.addClass("zombie_bulk_select")
					.attr({
						"id": "zombie_bulk_select",
						"type": "checkbox"
					})
					.on("click", function(){
						self.selectPage(this.checked);
						self.refreshButtons(this);
					})
					.on("focus", function(){
						this.blur();
					}),
				$(ce("label"))
					.attr({
						"for": "zombie_bulk_select"
					})
					.append("Select all universes on this page."),
				$(ce("div"))
					.addClass("zombie_tools_button_panel")
					.append(
						$(ce("div"))
							.addClass("zombie_filters clickable")
							.append(
								$(ce("div"))
									.addClass("sprite-search")
							)
							.attr({
								"title": "Search Deleted Universes"
							})
							.on("click", function(){
								self.displayFilterPanel();
							}),
						$(ce("input"))
							.addClass("unselect_all_zombies")
							.attr({
								"type": "button",
								"value": "Unselect All",
								"disabled": true
							})
							.on("click", function(){
								self.unselectAllZombies();
								self.refreshButtons();
							})
							.on("focus", function(){
								this.blur();
							}),
						$(ce("input"))
							.addClass("recover_selected_zombies")
							.attr({
								"type": "button",
								"value": "Recover Selected (0)",
								"disabled": true
							})
							.on("click", function(){
								self.recoverSelectedUniversesPrompt();
							})
							.on("focus", function(){
								this.blur();
							})
					)
			);
		
		this.pageButtons = $(ce("div"))
			.addClass("zombies_page_turner")
			.append(
				$(ce("div"))
					.addClass("zombies_page_down")
					.append("next >>")
					.on("click", function(){
						if(!$(this).hasClass("clickable")){
							return;
						}
						self.nextPage(true);
						self.updatePageReadout();
					}),
				$(ce("div"))
					.addClass("zombies_page_up")
					.append("<< previous")
					.on("click", function(){
						if(!$(this).hasClass("clickable")){
							return;
						}
						self.nextPage(false);
						self.updatePageReadout();
					}),
				$(ce("div"))
					.addClass("zombies_page_number_selector")
					.append(
						"page: ",
						$(ce("span"))
							.addClass("zombies_page_number_readout clickable")
							.append(this.pageNumber)
							.on("click", function(){
								$(".zombies_page_number_readout, .zombies_page_number_input", $(this).parent())
									.toggleClass("hide");
								$(".zombies_page_number_input", $(this).parent())
									.get(0)
									.focus();
							}),
						$(ce("input"))
							.addClass("zombies_page_number_input hide")
							.attr({
								"type": "number",
								"value": this.pageNumber
							})
							.on("change", function(e){
								self.changePage(parseInt(this.value, 10));
								self.updatePageReadout();
							})
							.on("blur", function(){
								$(".zombies_page_number_readout, .zombies_page_number_input", $(this).parent())
									.toggleClass("hide");
							})
					)
				
			);

		var colDataContainer = $(ce("div"))
			.addClass("zombies_list scrollable");
		
		this.ui = $(ce("div"))
			.addClass("universe_tools_content zombies_recovery_panel")
			.addClass(!active ? "hide" : null)
			.append(
				$(ce("div"))
					.addClass("right")
					.append(
						"Total deleted universes: ",
						$(ce("span"))
							.addClass("total_zombie_count")
							.append(this.zombies.length)
					),
				$(ce("div"))
					.addClass("universe_tools_content_header readout_bigger")
					.append("Recover Deleted Universes"),
				$(ce("div"))
					.addClass("universe_tools_content_header")
					.append("Note: Universes can only be recovered for up to approximately one week from deletion date."),
				bulkTools,
				$(ce("div"))
					.addClass("zombies_list_columnsorter")
					.append(
						this.buildColumnSorter(colDataContainer)
					),
				$(ce("div"))
					.addClass("zombies_list_panel")
					.append(colDataContainer),
				this.pageButtons
			);
	}
	
	this.updatePageReadout();
	return this.ui;
};

MControlZombieUniverses.prototype.getZombies = function(){
	if(this.filteredResults){
		this.setColumnSorterSource(this.filteredResults);
		return this.filteredResults;
	}
	this.setColumnSorterSource(this.zombies);
	return this.zombies;
};

MControlZombieUniverses.prototype.setZombies = function(zombies){
	this.zombies = zombies;
};

MControlZombieUniverses.prototype.closeFilterPanel = function(){
	if(this.filterPanel){
		this.filterPanel.close();
		this.filterPanel = null;
	}
};

MControlZombieUniverses.prototype.displayFilterPanel = function(){
	if(this.filterPanel){
		return this.closeFilterPanel();
	}
	
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	var textInput = MUIFormElements.elem({
		"type": "textField",
		"addClear": true,
		"events": {
			"onClear": function(){
				self.clearFilter();
			},
			"keyup": function(e){
				if(e.which == 27){
					return self.closeFilterPanel();
				}
				self.filterString = this.value;
				self.filterZombies();
			}
		}
	});
	
	var message = $(ce("div"))
		.addClass("filter_zombies_panel")
		.append(
			$(ce("span"))
				.append("Type a universe name or ID to search:"),
			textInput
		);
	
	var parentPosition = this.toolsPanel.getCurrentPosition();
	
	this.filterPanel = new MUILayoverPanel.alert({
		"title": "Search Deleted Universes",
		"closeText": "Close",
		"modal": false,
		"fixed": false,
		"position": {
			"top": parentPosition.top,
			"left": parentPosition.left + parentPosition.width + 10
		},
		"onOpen": function(){
			$("input", textInput).get(0).focus();
		},
		"onClose": function(hide){
			self.filterPanel = null;
			self.clearFilter();
			hide();
		},
		"message": message
	});
};

MControlZombieUniverses.prototype.filterZombies = function(){
	var value = this.filterString;
	if(value && value.length){
		var zombieResults = this.zombies;
		zombieResults = $(zombieResults).filter(function(index, zombie){
			return zombie.ext_name.toLowerCase().indexOf(value.toLowerCase()) > -1 ||
				zombie.int_name.toLowerCase().indexOf(value.toLowerCase()) > -1;
		}).toArray();
		this.filteredResults = zombieResults;
		return this.buildZombieList();
	}
	return this.clearFilter();
};

MControlZombieUniverses.prototype.clearFilter = function(){
	this.filteredResults = false;
	this.filterString = null;
	this.buildZombieList();
};

MControlZombieUniverses.prototype.buildColumnSorter = function(colDataContainer){
	var self = this;
	
	this.colsorter = new MUIFilterableSorter({
		"sortFunctions": this.itemSortFunctions,
		"columnSettings": this.sortColumns,
		"columnDataContainer": colDataContainer,
		"sortOrder": -1,
		"sortCriteriaClass": ".zombie_universe",
		"sortType": "array",
		"callback": function(){
			self.buildZombieList();
		}
	});

	this.colsorter.makeColumnSorter(true);
	return this.colsorter.ui;
};

MControlZombieUniverses.prototype.setColumnSorterSource = function(zombies){
	this.colsorter.sortableArray = zombies;
};

MControlZombieUniverses.prototype.sortZombies = function(zombies){
	zombies.sort(
		this.itemSortFunctions[this.sortBy]
	);
	if(this.sortOrder == -1){
		zombies.reverse();
	}
};

MControlZombieUniverses.prototype.nextPage = function(upDown){
	if(upDown){
		upDown = 1;
	}else{
		upDown = -1;
	}
	var value = this.pageNumber;
	value = value + (1 * upDown);
	this.changePage(value);
};

MControlZombieUniverses.prototype.changePage = function(value){
	if(!value){
		value = this.pageNumber;
	}
	value = this.verifyPageNumber(value);
	if(value != this.pageNumber){
		this.pageNumber = value;
		this.buildZombieList();
	}
	return value;
}

MControlZombieUniverses.prototype.verifyPageNumber = function(value){
	if(value < 1){
		value = 1;
	}
	
	var max = this.getMaxPages();
	if(value > max){
		value = max;
	}
	return value;
};

MControlZombieUniverses.prototype.getMaxPages = function(){
	var plus = 1;
	var zombies = this.getZombies();
	if(zombies.length % this.itemsPerPage === 0){
		plus = 0;
	}
	return parseInt(zombies.length / this.itemsPerPage, 10) + plus;
};

MControlZombieUniverses.prototype.updatePageReadout = function(){
	if(!this.pageButtons){
		return;
	}
	
	this.changePage();
	
	$(".total_zombie_count", this.ui)
		.empty()
		.append(this.zombies.length)
	
	if(this.getZombies().length <= this.itemsPerPage){
		$(this.pageButtons)
			.addClass("hide");
	}else{
		$(this.pageButtons)
			.removeClass("hide");
	}
	
	if(this.pageNumber == 1){
		$(".zombies_page_up", this.pageButtons)
			.removeClass("clickable");
	}else{
		$(".zombies_page_up", this.pageButtons)
			.addClass("clickable");
	}
	
	var max = this.getMaxPages();
	if(this.pageNumber == max){
		$(".zombies_page_down", this.pageButtons)
			.removeClass("clickable");
	}else{
		$(".zombies_page_down", this.pageButtons)
			.addClass("clickable");
	}

	$(".zombies_page_number_readout", this.pageButtons)
		.empty()
		.append(this.pageNumber, " / ", max);
	
	$(".zombies_page_number_input", this.pageButtons)
		.val(this.pageNumber);
	
	this.refreshButtons();
};

MControlZombieUniverses.prototype.init = function(toolsPanel){
	this.toolsPanel = toolsPanel;
	if(this.toolsPanel.onClose){
		var onClose = this.toolsPanel.onClose;
	}
	var self = this;
	this.toolsPanel.onClose = function(hide){
		self.closeFilterPanel();
		if(onClose){
			return onClose.apply(null, arguments);
		}
		hide();
	}
	this.refreshZombieList();
};

MControlZombieUniverses.prototype.refreshZombieList = function(){
	var self = this;
	this.loading(true);
	this.fetchZombies(function(){
		self.filterZombies();
		self.loading(false);
	});
}; 

MControlZombieUniverses.prototype.fetchZombies = function(callback){
	var self = this;
	var universeControl = this.manager.getControl("universecontrol");
	universeControl.getDeletedUniverses(this.dsId, function(zombies){
		self.setZombies(zombies);
		self.sortZombies(zombies);
		callback && callback(zombies);
	});
};

MControlZombieUniverses.prototype.buildZombieList = function(){
	var self = this;
	$(".zombie_universe", this.ui)
		.remove();
	this.preparePage(function(zombies){
		$(".zombies_list", this.ui)
			.append(
				$.map(zombies, function(v){
					return $(v.ui).get(0);
				})
			);
		self.updatePageReadout();
	});
};

MControlZombieUniverses.prototype.emptyListMessage = function(){
	var zombies = this.getZombies();
	var list = $(".zombies_list", this.ui);
	$(list).removeClass("empty_zombie_list empty_filtered_zombie_list");
	if(zombies.length == 0){
		$(list).addClass("empty_zombie_list");
		if(this.filteredResults){
			$(list).addClass("empty_filtered_zombie_list");
		}
	}
};

MControlZombieUniverses.prototype.preparePage = function(callback){
	var prepped = [];
	var zombies = this.getZombies();
	for(var i = 0, l = zombies.length; i < l; ++i){
		if(i < (this.pageNumber * this.itemsPerPage) && 
				i >= (this.pageNumber * this.itemsPerPage) - this.itemsPerPage){
			
			var zombie = zombies[i];
			if(!zombie.ui){
				zombie.ui = this.buildZombieRow(zombie);
			}
			this.bindZombieActions(zombie);
			prepped.push(zombie);
		}
	}
	callback(prepped);
};

MControlZombieUniverses.prototype.bindZombieActions = function(zombie){
	var self = this;
	$(zombie.selector)
		.unbind()
		.on("click", function(e){
			if(e.shiftKey){
				var ls = self.getLastSelected();
				if(ls && (ls == this || ls.checked !== this.checked)) {
					return self.setLastSelected(this);
				}
				e.stopImmediatePropagation();
				e.preventDefault();
				self.multiSelect(this);
			}
		})
		.on("change", function(){
			zombie.selected = this.checked;
			self.setLastSelected(this);
			self.refreshButtons();
		})
		.on("check", function(){
			this.checked = true;
			zombie.selected = this.checked;
		})
		.on("uncheck", function(){
			this.checked = false
			zombie.selected = false;
		})
		.on("toggle", function(){
			this.checked = !this.checked;
			zombie.selected = this.checked;
		})
		.on("focus", function(){
			this.blur();
		});
		
	$(".recover_zombie_button", zombie.ui)
		.unbind()
		.on("click", function(){
			self.recoverSingleUniversesPrompt(zombie)
		});
};


MControlZombieUniverses.prototype.getLastSelected = function(){
	return this.lastSelected;
};

MControlZombieUniverses.prototype.setLastSelected = function(lastSelected){
	this.lastSelected = lastSelected;
};

MControlZombieUniverses.prototype.multiSelect = function(checkbox){

	var ls = this.getLastSelected();
	var selected = checkbox.checked;
	
	var selectSelf = function(callback){
		setTimeout(function(){
			$(checkbox).attr({
					"checked": selected
				})
				.trigger("change");
		}, 0);
		callback && callback();
	};
	
	if(!ls){
		return selectSelf();
	}
	
	var zombies = this.getZombies();
	var toSelect;
	$.each(zombies, function(index, zombie){
		
		var box = $(zombie.selector);
		var value = box.val();
		
		if(checkbox.value === value){
			if(toSelect === undefined){
				toSelect = [];
				return true;
			}
			return false;
		}
		if(ls.value === value){
			if(toSelect === undefined){
				toSelect = [];
				return true;
			}
			return false;
		}
		if(toSelect && zombie.selected !== selected){
			toSelect.push(zombie);
		}
	});

	if(toSelect){
		for(var i = 0, l = toSelect.length; i < l; ++i){
			var zombie = toSelect[i];
			zombie.selected = selected;
			$(zombie.selector)
				.attr({
					"checked": selected
				});
		}
	}

	var self = this;
	selectSelf(function(){
		self.setLastSelected(checkbox);
	});
};

MControlZombieUniverses.prototype.loading = function(onOff){
	if(this.filterPanel){
		this.filterPanel.loadIndicator(onOff);
	}
	if(this.toolsPanel){
		this.toolsPanel.loadIndicator(onOff);
	}
};

MControlZombieUniverses.prototype.unCheckBulkSelect = function(){
	$(".zombie_bulk_select", this.ui)
		.attr({
			"checked": false
		});
};

MControlZombieUniverses.prototype.selectPage = function(checked){
	$(".zombie_selected", this.ui)
		.trigger(checked ? "check" : "uncheck");
};

MControlZombieUniverses.prototype.refreshButtons = function(element){
	if(!element || element.id != "zombie_bulk_select"){
		this.unCheckBulkSelect();
	}
	var count = this.getSelectedZombiesCount();
	this.unselectButton(count);
	this.recoverButton(count);
	this.emptyListMessage();
};

MControlZombieUniverses.prototype.unselectButton = function(count){
	$(".unselect_all_zombies", this.ui)
		.attr({
			"disabled": !(count > 0)
		});
};

MControlZombieUniverses.prototype.recoverButton = function(count){
	$(".recover_selected_zombies", this.ui)
		.attr({
			"value": "Recover Selected (" + count + ")",
			"disabled": !(count > 0)
		});
};

MControlZombieUniverses.prototype.unselectAllZombies = function(){
	var zombies = this.getSelectedZombies();
	for(var i = 0, l = zombies.length; i < l; ++i){
		zombies[i].selected = false;
		$(zombies[i].selector)
			.attr({
				"checked": false
			});
	}
};

MControlZombieUniverses.prototype.getSelectedZombies = function(){
	var checked = [];
	for(var i = 0, l = this.zombies.length; i < l; ++i){
		this.zombies[i].selected && checked.push(this.zombies[i]);
	}
	return checked;
};

MControlZombieUniverses.prototype.getSelectedZombiesCount = function(){
	return this.getSelectedZombies().length;
};

MControlZombieUniverses.prototype.recoverUniverses = function(zombies, callback){
	if(!zombies.length){
		return;
	}
	var self = this;
	var universeControl = this.manager.getControl("universecontrol");
	universeControl.recoverUniverses(zombies, function(){
		self.removeZombies(zombies);
		self.refreshZombieList();
		self.manager.getUniverseControl().refreshListFromServer(callback);
	});
};

MControlZombieUniverses.prototype.removeZombies = function(zombies){
	for(var i = 0, l = zombies.length; i < l; ++i){
		$(zombies[i].ui).remove();
	}
};

MControlZombieUniverses.prototype.recoverSingleUniversesPrompt = function(zombie){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	MUILayoverPanel.confirm({
		"title": "Recover Universe",
		"titleIcon": "sprite-recover",
		"closeText": "Recover",
		"modal": true,
		"callback": function(response, id, hide){
			if(response === true){
				self.loading(true);
				self.recoverUniverses([zombie], function(){
					self.loading(false);
				});
			}
			hide();
		},
		"message": $(ce("div"))
			.addClass("single_zombie_recover_message")
			.append('Recover universe "' + zombie.ext_name + '"?')
			.append(' All recovered universes will be moved to the "Recovered" folder.')
	});
};

MControlZombieUniverses.prototype.recoverSelectedUniversesPrompt = function(){
	var zombies = this.getSelectedZombies();
	if(!zombies.length){
		return;
	}
	var message = 'Recover these selected universes? All recovered universes will be moved to the "Recovered" folder.';
	var self = this;
	this.recoverUniversesPrompt(message, zombies, function(confirm){
		self.recoverUniverses(zombies, function(){
			self.loading(false);
		});
	})
};	
	
MControlZombieUniverses.prototype.recoverUniversesPrompt = function(message, zombies, callback){
	var self = this;
	var ce = Moonshadow.helpers.ce;

	var recoverList = $(ce("ul"))
		.addClass("bulk_recover_list");
	
	for(var i = 0, l = zombies.length; i < l; ++i){
		$(recoverList)
			.append(
				$(ce("li"))
					.append(zombies[i].ext_name)
					.get(0)
			);
	}

	MUILayoverPanel.confirm({
		"title": "Recover Universes",
		"titleIcon": "sprite-recover",
		"closeText": "Recover",
		"modal": true,
		"callback": function(response, id, hide){
			if(response === true){
				self.loading(true);
				callback && callback(confirm);
			}
			hide();
		},
		"message": function(){
			return 	$(ce("div"))
				.append(
					message, 
					recoverList
				)
		}()
	});
};

MControlZombieUniverses.prototype.buildZombieRow = function(zombie){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	zombie.selector = $(ce("input"))
		.addClass("zombie_selected")
		.attr({
			"type": "checkbox",
			"title": "Select " + zombie.ext_name,
			"value": zombie.int_name,
			"checked": zombie.selected
		});
	
	var rd = this.colsorter.getDataRow({
		"selected": zombie.selector,
		"cardinality": Moonshadow.helpers.numberCommas(zombie.cardinality),
		"label": zombie.ext_name,
		"description": zombie.description,
		"date_deleted": function(){
			var dd = new Date(zombie.modified_time * 1000);
			return Moonshadow.helpers.hrDate(dd, true);
		}(),
		"universeid": "(" + zombie.int_name + ")",
		"recover_zombie": function(){
			return $(ce("div"))
				.addClass("recover_zombie_button clickable")
				.attr({
					"title": "Recover single universe (" + zombie.ext_name + ")"
				})
				.append(
					$(ce("div"))
						.addClass("sprite-recover")
				)
		}()
			
	});
	
	return $(rd.row)
		.addClass("selectable");
};

MControlZombieUniverses.prototype.sortColumns = [{
		"title": "Selected",
		"sortby": "selected",
		"float": "left"
	},{
		"title": "Universe Name",
		"value": "Universe Name",
		"sortby": "label"
	},{
		"title": "Universe Description",
		"value": "Universe Description",
		"sortby": "description"
	},{
		"title": "Universe ID",
		"value": "Universe ID",
		"sortby": "universeid",
		"float": "right"
	},{
		"title": "Record Count",
		"value": "Count",
		"sortby": "cardinality",
		"float": "right"
	},{
		"title": "Date Deleted",
		"value": "Deleted",
		"sortby": "date_deleted",
		"float": "right",
		"sortdefault": true
	},{
		"spacer": "recover_zombie",
		"float": "right"
	}
];

MControlZombieUniverses.prototype.itemSortFunctions = {
	"selected": function(a, b, sortOrder){
		var aBool = a.selected;
		var bBool = b.selected;
		var retVal = MUIFilterableSorter.predefinedSorting.returnBool(aBool, bBool, sortOrder);
		if(retVal === 0){
			return this.sortFunctions["label"](a, b, sortOrder);
		}
		return retVal;
	},
	"cardinality": function(a, b, sortOrder){
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(a.cardinality, b.cardinality, sortOrder);
		if(retVal === 0){
			return this.sortFunctions["label"](a, b, sortOrder);
		}
		return retVal;
	},
	"universeid": function(a, b, sortOrder){
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(a.int_name, b.int_name, sortOrder);
		if(retVal === 0){
			return this.sortFunctions["label"](a, b, sortOrder);
		}
		return retVal; 
	},
	"label": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.returnVal(
			a.ext_name.toLowerCase().replace(/\W/g, ""), 
			b.ext_name.toLowerCase().replace(/\W/g, ""), 
			sortOrder
		);
	},
	"description": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.returnVal(
			a.description.toLowerCase().replace(/\W/g, ""), 
			b.description.toLowerCase().replace(/\W/g, ""), 
			sortOrder
		);
	},
	"date_deleted": function(a, b, sortOrder){
		var aVal = new Date(a.modified_time * 1000);
		var bVal = new Date(b.modified_time * 1000);
		var retVal = aVal - bVal;
		if(sortOrder){
			retVal = retVal * sortOrder
		}
		return retVal;
	}
};

/**
 *
 * @method MPanelContentCard
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MPanelContentStateInfo(options) {
	this.name = "stateinfo";
	this.childOf = "sidepanel";
	this.parent = null;
	this.position = options.position || 1;
	this.fixed = true;
	this.container = null;
	this.manager = null;
	this.options = options || {};
	this.ui = {};
	this.stateInfo;
	this.dateUpdated;
};

MPanelContentStateInfo.prototype = new MControl;

MPanelContentStateInfo.enabled = function(){
	stateInfo = Moonshadow.getManager().getOption("stateinfo");
	return !!stateInfo && !!stateInfo.description;
};

/**
*
* @method init
*/
MPanelContentStateInfo.prototype.init = function() {

	this.manager = this.getManager();
	this.stateInfo = this.manager.getOption("stateinfo");
	
	if(!this.stateInfo || !this.stateInfo.description){
		return;
	}
	
	this.makeInfoButton(this.checkNew());
	
	this.container = document.createElement("div");
	this.container.className = "state_info";
	this.container.id = this.name;

	
	this.container.appendChild(this.ui.infoButton);
	this.getParent().addControl(this);
};

MPanelContentStateInfo.prototype.checkNew = function(){
	var lastOpened = this.manager.getOption("user_settings.stateinfo_read");
	if(lastOpened){
		lastOpened = new Date(lastOpened);
	}
	
	this.dateUpdated = new Date(this.stateInfo.date_modified);
	return !lastOpened || this.dateUpdated > lastOpened;
};

/**
*
* @method makeInfoButton
* @param {Boolean} isNew
*/
MPanelContentStateInfo.prototype.makeInfoButton = function(isNew){
	var ce = Moonshadow.helpers.ce;
	
	this.ui.infoButton = $(ce("div"))
		.addClass("state_info_button clickable")
		.on("click", {"self": this}, function(e){
			var self = e.data.self;
			if(self.checkNew()){
				self.manager.setOption("user_settings.stateinfo_read", new Date());
				self.manager.getControl("usersettings").saveUserSettings();
			}
			self.markNew(false);
			self.openStateInfoPanel();
		})
		.get(0);
	
	this.markNew(isNew);
};

/**
*
* @method markNew
* @param {Boolean} isNew
*/
MPanelContentStateInfo.prototype.markNew = function(isNew){
	$(this.ui.infoButton)
		.empty()
		.append("About")
		.append(isNew && " (New)")
		.addClass(isNew && "new")
		.removeClass(!isNew && "new")
};

/**
 *
 * @method openStateInfoPanel
 */
MPanelContentStateInfo.prototype.openStateInfoPanel = function(){
	var appDisplay = this.manager.getOption("app_display");
	var _stateInfoPanel = new MUILayoverPanel({
		"id": "stateinfo",
		"content": this.buildStateInfoPanel(), 
		"title": "General Info About " + appDisplay,
		"animate": true,
		"fixed": false,
		"position": {
			"width": 800,
			"height": 600
		}
	});
	_stateInfoPanel.open();
};

/**
 *
 * @method buildStateInfoPanel
 */
MPanelContentStateInfo.prototype.buildStateInfoPanel = function(){
	var ce = Moonshadow.helpers.ce;
	return $(ce("div"))
		.addClass("state_info_panel scrollable")
		.append(
			$(ce("div"))
				.addClass("state_info_last_updated")
				.append(
					$(ce("label"))
						.append("Last Updated:"),
					$(ce("span"))
						.append(this.dateUpdated.toString())
				),
			$(ce("div"))
				.addClass("state_info_content")
				.append(
					this.stateInfo.description
				)
		);
};


/**
 *
 * @method MPanelContentCard
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MPanelContentCart(options) {
	this.name = "cartcontrol";
	this.childOf = "sidepanel";
	this.parent = null;
	this.position = options.position || 1;
	this.fixed = true;
	this.container = null;
	this.manager = null;
	this.options = options || this.getManager().getOption("cart", {});
	this.ui = {};
	this.buttonGray = true;
	this.buttonSpinning = false;
	this.prePurchased = false;
	this.disabledMessage;
};

MPanelContentCart.prototype = new MControl;

/**
*
* @method init
*/
MPanelContentCart.prototype.init = function() {
	this.parent = this.getParent();
	this.manager = this.getManager();
	
	if(this.cartDisabled()){
		return false;
	}

	this.makeCartButton();
	
	this.container = document.createElement("div");
	this.container.className = "universe_cart";
	this.container.id = this.name;
	this.container.appendChild(this.ui.purchaseButton);

	this.parent.addControl(this);
	
	var cp = this.getCartPanel();
	
	var self = this;
	this.manager.addMapObserver("puchasesdisabled", function(event, message){
		self.disableCart(true, message);
	}, this);
	
	this.manager.addMapObserver("universesuiloaded", function() {
		if(cp.checkPrePurchased()){
			self.showHideCartButton(false)
			self.disableCart(true);
		}
	}, this);
	
	if(cp){
		return cp.verifyPurchases(function(enabled){
			enabled && self.enableCartButton();
		});
	}

	this.disableCart(true);
};

MPanelContentCart.prototype.cartDisabled = function(){
	var cp = this.getCartPanel();
	if(!cp){
		return true;
	}
	
	return cp.cartDisabled();
};

/**
*
* @method makeCartButton
*/
MPanelContentCart.prototype.makeCartButton = function(){
	var ce = Moonshadow.helpers.ce;
	
	this.ui.purchaseButton = $(ce("div"))
		.addClass("purchase cart_disabled")
		.append(
			$(ce("div"))
				.addClass("spinner"),
			$(ce("span"))
				.addClass("cart_count")
				.append("Cart (0)")
				.attr({
					"title": "No items in your cart"
				})
		)
		.on("click", {"self": this}, function(e){
			var self = e.data.self;
			self.openCartPanel();
		})
		.get(0);
};

/**
*
* @method enableCartButton
*/
MPanelContentCart.prototype.enableCartButton = function(){
	this.manager.dataObservers.addObserver('itemsincartchanged', this.updateCartCount, this);
	this.updateCartCount();
	this.purchaseButtonWait(false);
};

/**
*
* @method grayOutButton
* @param {Boolean} gray
*/
MPanelContentCart.prototype.grayOutButton = function(gray){
	this.buttonGray = gray;
	if(gray){
		$(this.ui.purchaseButton).removeClass("clickable").addClass("cart_disabled");
	}else{
		$(this.ui.purchaseButton).removeClass("cart_disabled").addClass("clickable");
	}
};

/**
 *
 * @method spinButton
 * @param {Boolean} onOff
 */
MPanelContentCart.prototype.spinButton = function(onOff){
	this.buttonSpinning = onOff;
	if (onOff){
		$(".spinner", this.ui.purchaseButton).removeClass("hide");
	}else{
		$(".spinner", this.ui.purchaseButton).addClass("hide");
	}
};

/**
 *
 * @method getCardPanel
 */
MPanelContentCart.prototype.getCartPanel = function(){
	if(this.manager.shouldControlBeLoaded("MControlCart")){
		return this.manager.getControl("cartpanel");
	}
	return false;
};
	
/**
 *
 * @method openCardPanel
 */
MPanelContentCart.prototype.openCartPanel = function(){
	if(this.cartDisabled()){
		return this.cartDisabledMessage();
	}
	
	var self = this;
	var o = function(){
		self.purchaseButtonWait(false);
		self.manager.removeMapObserver("purchases_verified", o);
	};
	
	if (!this.buttonGray && this.getNumCartItems() > 0) {
		this.manager.addMapObserver("purchases_verified", o);
		var cp = this.getCartPanel();
		if(cp){
			this.purchaseButtonWait(true);
			cp.show();
		}
	}
};
	
/**
 *
 * @method purchaseButtonWait
 * @param {Boolean} onOff
 */
MPanelContentCart.prototype.purchaseButtonWait = function(onOff){
	this.spinButton(onOff);
	this.grayOutButton(onOff);
};

/**
 * 
 * @method hideCartButton
 * @param {Boolean} disable
 */
MPanelContentCart.prototype.showHideCartButton = function(onOff){
	$(this.container)
		.removeClass(onOff ? "hide" : "")
		.addClass(onOff ? "" : "hide");
};

/**
 * 
 * @method disableCart
 * @param {Boolean} disable
 * @param {String} message
 */
MPanelContentCart.prototype.disableCart = function(disable, message){
	var cp = this.getCartPanel();
	cp.disabled = disable;
	
	var univ = this.manager.getUniverseControl();
	var purch = this.manager.getFilterableControl("__universes", "__purchased");
	if(message){
		this.disabledMessage = message;
	}
	if(disable){
		this.grayOutButton(true);
		this.spinButton(false);
		$(".cart_count", this.ui.purchaseButton)
			.empty()
			.append("Disabled")
			.attr({
				"title": message ? message : "Disabled"
			})
		univ && univ.enableDisablePurchasing(false);
		purch && purch.enableDisablePurchasingDocs(false);
	}else{
		this.updateCartCount();
		univ && univ.enableDisablePurchasing(true);
		purch && purch.enableDisablePurchasingDocs(true);
	}
};

/**
 *
 * @method getNumUniverses
 * @param {} inPurchaseStates
 */
MPanelContentCart.prototype.getNumUniverses = function(inPurchaseStates){
	var num = 0;
	var univControl = this.manager.getUniverseControl();
	if(univControl){
		num = univControl.getNumChildren(inPurchaseStates);
	}
	return num;
};

/**
*
* @method getNumCartItems
*/
MPanelContentCart.prototype.getNumCartItems = function(){
	return this.getNumUniverses([10, 20]);
};


/**
 *
 * @method updateCartCount
 */
MPanelContentCart.prototype.updateCartCount = function() {
	if(this.disabled)
		return false;
	var number = this.getNumCartItems();
	if(!this.buttonSpinning){
		this.grayOutButton(!number > 0 ? 1 : 0);
	}
	$(".cart_count", this.ui.purchaseButton)
		.empty()
		.append("Cart (" +number+ ")")
		.attr({
			"title": (number > 0 ? number : "No") + " item" + (number > 1 ? "s" : "") + " in your cart"
		})
};
	
/**
 *
 * @method cartDisabledMessage
 * @param {Function} callback
 */
MPanelContentCart.prototype.cartDisabledMessage = function(){
	MUILayoverPanel.alert({
		"title": "Purchasing Disabled",
		"message": this.disabledMessage || "Purchasing has been temporarily disabled due to technical " +
					"difficulties or maintenance. Please try again later."
	});
};

/*
 * Filter control
 * @class MPanelContentFiltersV3
 * @extends MControl
 * @module Moonshadow.Controls.SidePanel
 * @author Ryan Olds ryan@moonshadowmobile.com
 * @copyright (c) 2012 Moonshadow Mobile - info@moonshadowmobile.com
 * @version 3.0
 * @constructor
 * @param {} options
 */
function MPanelContentFilterV3(options) {
	this.name = "filters"; // Control name
	this.childOf = "sidepanel"; // control parent
	this.position = options.position || 40;
	this.options = options || {}; // Control options

	// @CLEANUP is this needed?
	if(typeof this.options.meshDefaultColor !== "undefined" && this.options.meshDefaultColor === 0) {
		this.options.meshDefaultColor = "000000";
	}

	this.container = false; // Container for the entire control
	this.childContainer = null; // Container for the controls children

	this.eventObservers = new Moonshadow.Observer();

	this.datasources = {};
	this.datasourceLookup = [];

	this.currentColorBy = null;
	this.viewAllButton = null;
};

MPanelContentFilterV3.prototype = {
	init: function() {
		if(this.getParent() != null) {
			var mainDiv = document.createElement("div");
			mainDiv.className = this.name + " content-item";
			mainDiv.id = this.name;

			this.container = mainDiv;

			var loading = document.createElement("div");
			loading.id = this.name + "_loading";
			loading.className = this.name + "_loading loading";
			loading.appendChild(document.createTextNode("Loading..."));

			var loadingGif = document.createElement("div");
			loadingGif.className = "activity working inline";
			loading.appendChild(loadingGif);

			var menus = document.createElement("div");
			menus.className = this.name + "_menu menu";
			menus.id = this.name + "_menu";
			menus.style.display = "none";

			var body = document.createElement("div");
			body.className = this.name + "_body body";
			body.id = this.name + "_body";

			this.childContainer = body;

			this.container.appendChild(menus);
			this.container.appendChild(loading);
			this.container.appendChild(this.childContainer);

			this.getParent().addControl(this);
			this.show();
			
			this.setUpDatasources();
			
			this.getManager().addMapObserver("filtersloaded", this.autoExpandBranches, this);
			this.getManager().addMapObserver('loaded', this.getStructure, this);
		}
	},
	setUpDatasources: function(){
		var manager = this.getManager();
		var appDisplayName = manager.getOption("app_display");
		
		this.datasources = {
			'__search': this.getFilterable({
				'int_name': '__search',
				'ext_name': 'Search',
				'dtype': 'datasource',
				'dsIndex': -7
				}, this),
			'__clearselections': this.getFilterable({
				'int_name': '__clearselections',
				'dtype': 'datasource',
				'dsIndex': -6
				}, this),
			'__spreadsheets': this.getFilterable({
				'int_name': '__spreadsheets',
				'ext_name': 'Spreadsheets',
				'dtype': 'datasource',
				'dsIndex': -4
				}, this),
			'__top': this.getFilterable({
				'int_name': '__top',
				'ext_name': 'Map Controls',
				'dtype': 'datasource',
				'dsIndex': -3
				}, this),
			'__universes': this.getFilterable({
				'int_name': '__universes',
				'ext_name': this.getOption('universe_ext_name', 'Universes'),
				'dtype': 'datasource',
				'dsIndex': -2
				}, this),
			'__divider': this.getFilterable({
				'int_name': '__divider',
				'ext_name': 'Data Sources',
				'dtype': 'datasource',
				'dsIndex': -1
				}, this)
		};
		
		this.datasources['__search'].filterables['__search'] = this.getFilterable({
			int_name:'__search',
			ext_name:'Search',
			dtype:'search'
		}, this.datasources['__search']);
		
		
		var enabledReportTypes = MFilterableReports.getEnabledTypes();
		if(enabledReportTypes.length){
			var reportsExtName = "";
			for(var i = 0, l = enabledReportTypes.length; i < l; ++i){
				if(i != 0){
					if(i == enabledReportTypes.length -1){
						reportsExtName += " and "; 
					}else{
						reportsExtName += ", "
					}
				}
				reportsExtName += enabledReportTypes[i].name;
			}

			this.datasources['__reports'] = this.getFilterable({
				'int_name': '__reports',
				'ext_name': reportsExtName,
				'dtype': 'datasource',
				'dsIndex': -5
			}, this);
			
			var reportqueue = manager.getControl("reportqueue");
			this.datasources['__reports'].filterables['__reports'] = this.getFilterable({
				int_name:'__reports',
				dtype:'reports',
				values: reportqueue.getReportsByAttribute("report_layout", ["visual", "image"], true)
			},this.datasources['__reports']);
		}
		
		this.datasources['__spreadsheets'].filterables['__spreadsheets'] = this.getFilterable({
			int_name:'__spreadsheets',
			ext_name:'Spreadsheets',
			dtype:'spreadsheets'
		}, this.datasources['__spreadsheets']);

		if(manager.getOption('universes')) {
			var datasources = manager.getControl('datasources');
			var ds = datasources.getByIndex(0);
			var dsId = ds.id;

			var universesControl = manager.getControl('universecontrol');
			var userUniverses = universesControl.getUniverses(dsId);
			var universes = [];
			for (var uId in userUniverses) {
				universes.push(userUniverses[uId]);
			}

			var purchasedUniverse = universesControl.getPurchased(dsId);
			if(purchasedUniverse){
				purchasedUniverse.dtype = "purchaseditem";
			}
			
			var unpurchasedUniverse = universesControl.getUnpurchased(dsId);
			if(unpurchasedUniverse){
				unpurchasedUniverse.dtype = "purchaseditem";
			}

			var purchasedValues = [purchasedUniverse, unpurchasedUniverse];

			var usfs = this.datasources['__universes'].filterables;
			usfs['__universes'] = this.getFilterable({
				int_name:'__universes',
				ext_name:'Universes',
				dtype:'universes',
				values: userUniverses
			},this.datasources['__universes']);

			if(this.getOption('purchased', true)) {
				usfs['__purchased'] = this.getFilterable({
					int_name:'__purchased',
					ext_name:'Purchased',
					dtype:'purchased',
					values: purchasedValues
				}, this.datasources['__universes']);
			}
			
			if(this.exportsEnabled()) {
				usfs['__downloads'] = this.getFilterable({
					int_name:'__downloads',
					ext_name:'Exports',
					dtype:'downloads'
				},this.datasources['__universes']);
			}
		}

		var displayMeshes = manager.getOption('display_meshes', []);
		var availableMeshes = manager.getOption('available_meshes', []);
		if(availableMeshes.length > 0) {
			var meshes = [];
			$.each(availableMeshes, function(k, v) {
				var ischecked = false;
				if(displayMeshes && displayMeshes.length > 0) {
					$.each(displayMeshes, function(a,b)  {
						if (v.int_name == b.int_name) {
							ischecked = (b.checked) ? true : false;
							return false;
						}
					});
				}

				meshes.push({
					'int_name': v.int_name,
					'ext_name': v.ext_name,
					'dtype': 'mesh',
					'checked': ischecked
				});
			});

			this.datasources['__top'].filterables['__meshes'] = this.getFilterable({
 				int_name: '__boundry',
 				ext_name: 'Boundaries',
 				dtype: 'meshes',
 				values: meshes
			}, this.datasources['__top']);
		}

		if(manager.getOption("polygons")) {
			this.datasources["__top"].filterables["__polygon"] = this.getFilterable({
				int_name:"__polygons",
				ext_name:"Shapes",
				dtype:"shapes"
			},this.datasources["__top"]);
		}
		
		var mapOptions = manager.getOption("mapoptions");
		if(mapOptions) {
			this.datasources["__top"].filterables["__mapoptions"] = this.getFilterable({
				int_name:"__mapoptions",
				ext_name:"Map Options",
				dtype:"mapoptions",
				options: mapOptions
			},this.datasources["__top"]);
		}
	},
	exportsEnabled: function(){
		var show = false;
		
		//if at least one datasource has an exports definition
		var datasources = this.getManager().getOption("datasources");
		for(var i = 0, l = datasources.length; i < l; ++i){
			if(datasources[i]["export"]){
				show = true;
				break;
			}
		} 
		
		//not if logged in as a read-only user
		if(this.getManager().getOption("user_details.user_type") == "read-only")
			show = false;

		//not available for censusviewer apps
		if(this.getManager().getOption("app_details.type") == "censusviewer")
			show = false;
		
		return show;
	},
	getAutoExpandOptions: function(dsId) {
		var autoExpandPathsOptions = this.getManager().getOption("autoexpand", []);
		for(i = 0, l = autoExpandPathsOptions.length; i < l; ++i){
			if(autoExpandPathsOptions[i].ds == dsId){
				return autoExpandPathsOptions[i];
			}
		}
	},
	autoExpandBranches: function() {
		var manager = this.getManager();
		var autoExpandPaths = [];
		
		var datasources = manager.getOption("datasources");

		var colorByControl = manager.getControl("colorbycontrol");
		var colorBy = colorByControl.getActiveColorBy();

		for(var i = 0, l = datasources.length; i < l; ++i){
			var dsId = datasources[i].int_name;

			if (colorByControl.getActiveDsId() == dsId) {
				var autoExpandPathsOptions = this.getAutoExpandOptions(dsId);

				if (colorBy) {
					autoExpandPaths.push({
						"ds": dsId,
						"path": colorBy.treePath
					});
				} else if(autoExpandPathsOptions.length) {
					autoExpandPaths.push(autoExpandPathsOptions);
				}
			}
		}

		var toggler = function(p, f){
			if($.type(p) == "object"){
				//to support app attrs autoexpand
				for(var i in p){
					if(!p.hasOwnProperty(i))
						continue;
					if(i == "values"){
						toggler(p[i], f);
					}
					f[i] && f[i].toggle(true, function(filterable){
						if(filterable.children){
							toggler(p[i], filterable.children);
						}
					});
				}
			}
			if($.type(p) == "array"){
				for(var i = 0, l = p.length; i < l; ++i){
					f[p[i]] && f[p[i]].toggle(true, function(filterable){
						if(filterable.children){
							toggler(p, filterable.children);
						}
					});
				}
			}
		};

		for(var i = 0, l = autoExpandPaths.length; i < l; ++i){
			var ds = this.getDatasource(autoExpandPaths[i].ds);
			if(ds && ds.filterables){
				if(autoExpandPaths[i].path){
					toggler(autoExpandPaths[i].path, ds.filterables);
				}
			}
		}
	},
	onClearFilters: function(){
		var manager = this.getManager();
		if(manager.getOption("neutered") == 1) {
			return false;
		}
		
		var filters = manager.getControl('filterscontrol');
		filters.clearAllFilters();
		
		this.clearFilters();
	},
	clearFilters: function() {
		$.each(this.datasources, function(k, v) {
			v.clearFilters(true);
		});

		this.getManager().mapObservers.notify("filterreset");
	},
	updateFilterCounts: function(branch){
		if(!branch){
			branch = this.datasources;
		}
		for(var i in branch){
			if(!branch.hasOwnProperty(i))
				continue;
			var f = branch[i];
			
			if(f.updateFilterState){
				f.updateFilterState();
			}else if(f.updateFilterCount){
				f.updateFilterCount(f.ui && f.ui.handle);
			}
			
			if(!($.isEmptyObject(f.filterables))){
				this.updateFilterCounts(f.filterables);
			}else if(!($.isEmptyObject(f.children))){
				this.updateFilterCounts(f.children);
			}
		}
	},
	resetColors: function() {
		var self = this;

		// @CLEARNUP is this used anymore?
		if (Moonshadow.getManager().getOption("neutered") == 1) {
			return false;
		}

		$.each(this.datasources, function(id, ds) {
			ds.resetColors();
		});
	},
	pruneTree: function(f,b) {
		$.each(b,function(k,v) {
			if(typeof b[k] == "object" && k != "__variables") {
				if(!f(f,b[k])) delete b[k]; // Delete the item if it has 0 children
			} else if(k == "__variables") {
				var keepVar = false;
				$.each(b[k],function(k,v) {
					if(typeof v.values != "undefined") {
						if(f(f,v.values)) {
							keepVar = true;
							return false;
						}
					}
				});

				if(!keepVar) delete b[k];
			}
		});

		var j = false;
		$.each(b,function(k,v) { j = true;return false; }); // Check for children. We only need to find one

		return (j) ? true : false;
	},
	setColorBy: function(colorBy){
		this.currentColorBy = colorBy;
	},
	getColorBy: function() {
		return this.currentColorBy;
	},
	getColorByIntName: function() {
		var colorBy = this.getColorBy();
		return (colorBy == null) ? undefined : colorBy.int_name;
	},
	changeColorBy: function(colorByElement) {
 		if(Moonshadow.getManager().getOption("neutered") == 1) {
			return false;
		}

		var manager = this.getManager();
		var colorByControl = manager.getControl('colorbycontrol');
		var filterable = $(colorByElement).data("filter");
		var filterableDS = filterable.getDatasource();
		var dsId = filterableDS.int_name;
		
		if(dsId != manager.getDatasource().int_name) {
			filterableDS.setSelected();
		}
		
		var colorByUniverse = false;
		var colors;
		if (dsId == "__universes") {
			//@TODO this only works with DS in position 1
			var datasource = this.getManager().getDatasource();
			dsId = datasource.int_name;
			colorByUniverse = true;
			colors = {};
		} else {
			filterableDS.setSelected();
		}
		
		var activeColorBy = colorByControl.getActiveColorBy();
		var activeDsId = colorByControl.getActiveDsId();
		
		if(filterable.int_name != activeColorBy.color
				|| dsId != activeDsId
				|| colorByUniverse) {
			
			// Remove all child indicators for previous colorby
			if(this.getColorBy()) {
				this.getColorBy().setChildBy(false);
			}

			// Set new color by
			this.setColorBy(filterable);
			// Add Child indicators
			filterable.setChildBy(true);
			
			$.each($(".filterable .color-by"),function(k,v) {
				$(v).removeClass("colored");
			});

			$(colorByElement).addClass("colored");

			var dataPath = filterable.getDataPath();
			var treePath = filterable.getTreePath();

			
			colorByControl.setColorBy(dsId, filterable.int_name, colors, dataPath,
									  treePath);
			
			colorByControl.setActiveColorBy(dsId);
		}
	},
	sendColors: function(filterable) {
		if(Moonshadow.getManager().getOption("neutered") == 1) {
			return false;
		}

		var filterableDS = filterable.getDatasource();

		// Notify filterable's ds of the color change
		var ajax = new Moonshadow.Ajax();
		filterableDS.onAjaxEvent("_filterable_color_changed", {
			'filterable': filterable
		}, ajax);

		var colorBy = this.getColorBy();

		if(colorBy && filterable.int_name === colorBy.int_name 
		 		&& filterableDS.int_name === this.getManager().getDatasource().int_name) {

			this.getManager().getControl('colorbycontrol').changeColorByAjax({
				"color": filterable.int_name,
				"colors": filterable.getColors(),
				"treePath": Moonshadow.helpers.arrayToObjPath(filterable.treePath, {}),
				"dataPath": filterable.dataPath,
				"ds": filterableDS.int_name
			}, ajax);
		}

		ajax.execute();
	},
	getStructure: function(forceAjax) { // never passed a parameter
		var dsControl = this.getManager().getControl('datasources');
		var datasources = dsControl.getAll();

		for (var id in datasources) {
			var ds = datasources[id];
		
			this.datasources[ds.id] = this.getFilterable(ds, this);
			this.datasourceLookup.push(this.datasources[ds.id]);
		}

		this.buildUI();
		this.getManager().mapObservers.notify("filtersloaded");
	},
	getFilterableLookup: function() {
		if(typeof this.getFilterableLookup.lookup == "undefined") // Check if already generated
			this.getFilterableLookup.lookup = { // Save as a static value of this function
				"selection": MFilterableItemCollection,
				"submenu": MFilterableCollection,
				"selector": MFilterableCollection,
				"electioncollection": MFilterableElectionCollection,
				"boolean": MFilterableBool,
				"item": MFilterableItem,
				"datasource": MDatasource,
				"purchased": MFilterablePurchased,
				"purchaseditem": MFilterablePurchasedItem,
				"universes": MFilterableUniverses,
				"universeitem": MFilterableUniverseItem,
				"shapes":	MFilterableShapes,
				"mapoptions": MFilterableMapOptions,
				"shapeitem": MFilterableShapeItem,
				"mesh": MFilterableMeshItem,
				"meshes":MFilterableMeshes,
				"date": MFilterableDate,
				"int": MFilterableInt,
				"timestamp": MFilterableDateTime,
				"heatmap": MFilterableHeatMap,
				"rangebool": MFilterableRangeBool,
				"rangebool_collection": MFilterableRangeBoolCollection,
				"rangebool_item": MFilterableRangeBoolItem,
				"elections": MFilterableElections,
				"election": MFilterableElection,
				"filter_group": MFilterableVoterHistory,
				"heatmapitem": MFilterableHeatMapItem,
				"separator": MFilterableSeparator,
				"collection": MFilterableGroup,
				"downloads": MFilterableDownloads,
				"search": MFilterableSearch,
				"spreadsheets": MFilterableSpreadsheets,
				"reports": MFilterableReports
			};

		return this.getFilterableLookup.lookup;
	},
	getItemByTreePath: function(ds, treePath){
		var i = 0;
		var r = function(tree){
			var t = tree.children[treePath[i]];
			if(!t){
				return false;
			}
			if(t.getTreePath().join() == treePath.join()){
				return t;
			}
			if(t && t.children){
				++i;
				return r(t);
			}
		}
		return r(this.datasources[ds]);
	},
	getFilterable: function(branch, parent) {
		var lookup = this.getFilterableLookup();

		if(typeof lookup[branch.dtype] == "undefined" )
			throw("No such type("+$.toJSON(branch)+")");

		return new lookup[branch.dtype](branch,parent);
	},
	getDatasource: function(id) {
		if(id === undefined) {
			throw new Error("control.getDatasource requires an id");
		}

		return (typeof id === "number") ? this.datasourceLookup[id] : this.datasources[id];
	},
	getFilterColor: function(dsIntName, int_name, value){
		var ds = this.getDatasource(dsIntName);
		if(ds.colors && ds.colors.values){
			var branch = this.getBranchWithID(ds.colors.values, int_name);
			if(branch && branch.values){
				for(var i in branch.values){
					if(branch.values.hasOwnProperty(i)){
						if(i == value)
							return branch.values[i].value;
					}
				}
			}
		}
		return false;
	},
	getBranchWithID: function(tree, int_name){
		if (int_name && tree){
			var recurse = function(branch){
				if ($.type(branch) == "array"){
					for(var i = 0, l = branch.length; i < l; ++i){
						if(branch[i] == int_name)
							return branch[i];
						if(branch[i].values){
							return recurse(branch[i].values);
						}
					}
				}
				if ($.type(branch) == "object"){
					for(var i in branch){
						if(branch.hasOwnProperty(i)){
							if(i == int_name)
								return branch[i];
							if(branch[i].values){
								return recurse(branch[i].values);
							}
						}
					}
				}
			};
			return recurse(tree);
		}
	},
	reBuildCollections: function(dsId){
		//specifically for rebuilding menus after survey finalization
		
		//get struct
		var dsCont = this.getManager().getControl("datasources");
		var dsObj = dsCont.getById(dsId);
		
		//get filterable ds control
		var filterableDs = this.getDatasource(dsId);
		
		var validCollectionIds = {};
		
		//add new collections
		for(var i = 0, l = dsObj.struct.length; i < l; ++i){
			if(dsObj.struct[i].ctype == "collection"){
				validCollectionIds[dsObj.struct[i].int_name] = 1;
				var int_name = dsObj.struct[i].int_name;
				if(!filterableDs.filterables[int_name]){
					//item in struct does not have a matching filterable. Generate
					var fObj = this.getFilterable(dsObj.struct[i], filterableDs);
					filterableDs.filterables[int_name] = fObj;
					fObj.generateColor = true;
					fObj.buildUI();
				}
			}
		}
		//remove old collections
		for(var i in filterableDs.filterables){
			if(!filterableDs.filterables.hasOwnProperty(i)){
				continue;
			}
			if(filterableDs.filterables[i].ctype == "collection"){
				if(!validCollectionIds[filterableDs.filterables[i].int_name]){
					filterableDs.filterables[i].removeUI();
					delete filterableDs.filterables[i];
				}
			}
		}
	},
	purchasingEnabled: function(){
		var manager = this.getManager();
		var cartcontrol = manager.getControl("cartpanel");
		if(!cartcontrol){
			return false;
		}
		return !cartcontrol.cartDisabled();
	},
	buildUI: function() {
		var manager = this.getManager();
		var currentDS = manager.getDatasource().int_name
		var currentDSIntName = currentDS.int_name;

		//reorder DSs based on dsIndex
		var dss = $.map(this.datasources, function(item){
			return item;
		}).sort(function(a, b){
			var indexA = a.dsIndex || 0;
			var indexB = b.dsIndex || 0;
			return indexA - indexB
		});
		
		// Loop each of the DSs
		$.each(dss, function(index, dsObj) {
			if (dsObj.hidden) {
				return;
			}

			if(!dsObj.container) {
				dsObj.buildUI(); // build the UI for the DS
			}

			// Loop each of the newly created filterables
			$.each(dsObj.filterables,function(filterableId,filterableObj) {
				filterableObj.buildUI(); // Build all of the filterables
			});
		});
		
		$("#filters_loading").css("display","none");
		$("#filters_menu").css("display","block");
	},
	getScopeControl: function(){
		var control = false;
		var ds = this.getManager().getControl("filters").datasources["__top"];
		if(ds && ds.filterables["__mapoptions"]) {
			control = ds.filterables["__mapoptions"];
		}
		return control;
	},
	getScopeBounds: function(queryObj) {
		var control = this.getScopeControl();
		if(control)
			control.getScopeBounds(queryObj);
	},
	buildSensitivityWarning: function(warnings) {
		var ce = Moonshadow.helpers.ce;
		var manager = this.getManager();
		return $(warnings).map(function(index, item){
			var textcolor = item.textcolor || "black";
			var panelcolor = item.panelcolor || "pink";
			var bordercolor = item.bordercolor || "red";
			var showCloser = item.show_closer === true ? true : false;
			return $(ce("div"))
				.addClass("warning_dialog")
				.css({
					"color": textcolor,
					"background-color": panelcolor,
					"border-color": bordercolor
				})
				.append(
					item.text,
					showCloser && (function(){
						return $(ce("input"))
							.attr({
								"type": "button",
								"value": "Do not show this message"
							})
							.click({"caller": self, "info": item}, function(e){
								$(this).closest(".warning_dialog").remove();
								var warningType = "user_settings.warningDialogsClosed." + 
									e.data.info.fieldName + "." +
									e.data.info.warningName;
								manager.setOption(warningType, true);
								manager.getControl("usersettings").saveUserSettings();
							})
					}())
				)
				.get(0);
		});
	},
	notify: function(event) {},
	show: function() {},
	hide: function() {}
};
Moonshadow.helpers.extend(MPanelContentFilterV3,MControl);

/**
 *
 * @class MPanelContentInfo
 * @extends MControl
 * @constructor
 * @module Moonshadow.Controls.SidePanel
 * @param {} options
 */
function MPanelContentInfo(options) {
	this.name = "info";
	this.childOf = "sidepanel";
	this.parent = null;
	this.container = null;
	this.manager = null;
	this.options = options || {};
	this.position = options.position || 10;	
};

MPanelContentInfo.prototype = {
	/**
	 *
	 * @method init
	 */
	init: function() {
	this.parent = this.getParent();
	
	if(this.parent != null) {
		this.manager = this.getParent().getManager();
	   
		this.container = document.createElement("div");
		this.container.className = this.name + " content-item";
		this.container.id = this.name;
				
		var allContainers = {};
		
		if(this.options.content){
			if(this.options.content){
				var contElem = document.createElement("div");
				contElem.className = "info_content";
				$(contElem).append(this.options.content).get(0);
				allContainers["content"] = contElem;
			}
		}
		
		if(this.options.links){
			$.each(this.options.links,function(k,v) {
	
				if(v.href){
					var a = document.createElement("a");
					a.href = v.href;
					a.target = v.target || "_blank";
				}
			
				if(v.label){
					if(a){
						a.appendChild(document.createTextNode(v.label));
					}else{
						var span = document.createElement("span");
						span.appendChild(document.createTextNode(v.label));
					}
				}
				
				if(v.img){
					var img = document.createElement("img");
					img.src = v.img;
					if(a){
						a.appendChild(img);
					}
				}
				
				if(v.text){
					var text = document.createElement("span");
					text.appendChild(document.createTextNode(v.text));
				}
				
				var contName = "body";
				if(v.container){
					contName = v.container;
				}
				
				if(v.className){
					contName = v.className;
				}
				
				if(!allContainers[contName]){
					allContainers[contName] = document.createElement("div");
					allContainers[contName].className = contName;
				}
							
				if(a)
					allContainers[contName].appendChild(a);
				if(span && !a)
					allContainers[contName].appendChild(span);
				if(img && !a)
					allContainers[contName].appendChild(img);
				if(text)
					allContainers[contName].appendChild(text);
				
			});	
		}
		
		/**
	 	 *
		 * @method clearDiv
		 */
		var clearDiv = function(){
			var clear = document.createElement("div");
			clear.className = "clear";
			return clear; 
		};
		
		var elemArray = [];
		var index = 0;
		for(var i in allContainers){
			if(allContainers.hasOwnProperty(i)){
				if(i == "body"){
					var header = document.createElement("div");
					header.className = this.name + "_header header";
					header.id = this.name + "_header";	
					header.appendChild(document.createTextNode("Links & Information"));
					elemArray[index] = header;
					++index;
				}
				allContainers[i].appendChild(clearDiv());
				elemArray[index] = allContainers[i];
				++index;
			}
		}
		
		for(i = 0, l = elemArray.length; i < l; ++i){
			$(this.container).append(elemArray[i]);
		}
		
		this.parent.addControl(this);
		this.show();
		
		this.init = function() {};
	}	
	},
	/**
	 *
	 * @method notify
	 */
	notify: function() {

	},
	/**
	 *
	 * @method show
	 */
	show: function() {

	},
	/**
	 *
	 * @method hide
	 */
	hide: function() { 

	}
};
Moonshadow.helpers.extend(MPanelContentInfo,MControl);

/**
 *
 * @method MPanelContentManagement
 * @extends MControl
 * @constructor 
 * @param {} options
 */
function MPanelContentManagement(options) {
	this.name = "appmanagement";
	this.childOf = "sidepanel";
	this.parent = null;
	this.position = options.position || 38;
	this.container = null;
	this.manager = null;
	this.options = options || {};
	this.ui = {};
	this.stypes = {};
};

MPanelContentManagement.prototype = {
	/**
	 *
	 * @method init
	 */
	init: function() {
		this.parent = this.getParent();
	
		if(this.parent != null) {
			this.manager = this.getParent().getManager();
			
			if(this.manager.getOption('enable_management') === true){
				this.buildUI();
				this.parent.addControl(this);
				this.init = function() {};
			}
		}
	},
	/**
	 *
	 * @method buildUI
	 */
	buildUI: function() {
		
		var ui = this.ui;
		this.ui.instrucText = {
			"select": "Make selections below",
			"disabled": "Filter management disabled; please make selections below.",
			"locked": "Filter management locked; click to unlock.",
			"unlocked": "Filter management unlocked; click to lock.",
			"save": "Click the Save button to save the selections."
		};
		
		var container = document.createElement("div");
		container.className = this.name + " content-item";
		container.id = this.name;
		
		this.ui.header = document.createElement("div");
		this.ui.header.className = "appmanagement_header";
		this.ui.header.id = "appmanagement_header";
		
		this.ui.handle = document.createElement("div");
		this.ui.handle.className = "header_handle clickable";
		this.ui.handle.control = this.control;
		$(this.ui.handle).data("target",this);
		$(this.ui.handle).click(function() { 
			$(this).data("target").toggle(); 
		});
		
		this.ui.expander = document.createElement("div");
		this.ui.expander.className = "appmanagement_expander expander expanded";
		this.ui.handle.appendChild(this.ui.expander);
		
		this.ui.headerText = document.createElement('div');
		this.ui.headerText.className = "header_label";
		this.ui.headerText.appendChild(document.createTextNode("Application Management"));
		this.ui.handle.appendChild(this.ui.headerText);
		
		this.ui.header.appendChild(this.ui.handle);

		this.ui.body = document.createElement("div");
		this.ui.body.className = "appmanagement_body body";
		
		var appmanagement_info = document.createElement("div");
		appmanagement_info.className = "appmanagement_info"; 
		
		var appmanagement_info_span = document.createElement("span");
		appmanagement_info_span.appendChild(document.createTextNode(Moonshadow.helpers.capitalize("Current Admin User: "+this.getManager().getOption("admin_user"))));
		this.ui.body.appendChild(appmanagement_info_span);
				
		this.ui.saveButton = document.createElement("input");
		this.ui.saveButton.type = "button";
		this.ui.saveButton.value = "Save";
		this.ui.saveButton.className = "appmanagement_save";
		$(this.ui.saveButton)
			.attr({"disabled": "disabled"})
			.click({"control":this},function(e){
				MUILayoverPanel.confirm({
					"message": "Saving filters requires the system to restart the application. You and all other users will be logged out. Proceed?",
					"callback": function(res, id, hide){
						if(res){
							e.data.control.ui.lock.toggle(0);
							e.data.control.ui.saveButton.enable(0);
							e.data.control.ui.instructions.setText(e.data.control.ui.instrucText.locked);
							e.data.control.sendSelections();
						}
						hide();
					}
				});
			}
		);
		this.ui.saveButton.enable = function(onOff){
			if(onOff == null){
				if(this.disabled){
					onOff = 1; //enable
				}else{
					onOff = 0; //disable
				}
			}
			if(onOff){
				$(this).removeAttr("disabled");
			}else{
				$(this).attr({"disabled": "disabled"})
			}

		}
		appmanagement_info.appendChild(this.ui.saveButton);
		
		this.ui.cancelButton = document.createElement("input");
		this.ui.cancelButton.type = "button";
		this.ui.cancelButton.value = "Cancel/Return";
		this.ui.cancelButton.className = "appmanagement_save";
		$(this.ui.cancelButton).click({"control":this},function(e){
			e.data.control.returnWithMessage("Action canceled. Subset filters not saved.");
		});
		appmanagement_info.appendChild(this.ui.cancelButton);
		
		this.ui.lock = document.createElement("div");
		this.ui.lock.title = this.ui.instrucText.disabled;
		this.ui.lock.className = "appmanagement_lock disabled";
		this.ui.lock.appendChild(document.createTextNode("Locked"));
		this.ui.lock.disabled = true;
		$(this.ui.lock).click({"control":this},function(e){
			var control = e.data.control;
			var ui = control.ui;
			var lock = ui.lock;
			var saveButton = ui.saveButton;
			var instructions = ui.instructions;
			var instrucText = ui.instrucText
			
			lock.toggle();
			saveButton.enable(lock.locked ? 0 : 1);
			if(lock.locked){
				instructions.setText(instrucText.locked);
			}else{
				instructions.setText(instrucText.save);
			}
		});
		this.ui.lock.enable = function(onOff){
			if(onOff == null){
				if($(this).hasClass("disabled")){
					onOff = 1; //enable
				}else{
					onOff = 0; //disable
				}
			}
			if(onOff === 0){
				this.title = ui.instrucText.disabled;
				this.disabled = true;
				$(this).removeClass("clickable");
				return $(this).addClass("disabled");
			}
			this.title = ui.instrucText.locked;
			this.disabled = false;
			$(this).addClass("clickable");
			$(this).removeClass("disabled");
		};
		this.ui.lock.toggle = function(onOff){
			if(onOff === undefined){
				if($(this).hasClass("unlocked")){
					onOff = 0; //lock
				}else{
					onOff = 1; //unlock
				}
			}
			if(onOff === 0){
				this.title = ui.instrucText.locked;
				$(this).addClass("clickable");
				this.locked = true;
				$(this).removeClass("unlocked");
				$(this).text("Locked");
				return;
			}
			this.title = ui.instrucText.unlocked;
			$(this).addClass("clickable");
			$(this).addClass("unlocked");
			this.locked = false;
			$(this).text("Unlocked");
		};
		appmanagement_info.appendChild(this.ui.lock);
		
		this.ui.body.appendChild(appmanagement_info);
		
		this.ui.instructions = document.createElement("div");
		this.ui.instructions.className = "appmanagement_instructs";
		$(this.ui.instructions).append(this.ui.instrucText.disabled);
		this.ui.instructions.setText = function(text){
			$(this).empty().append(text);
		};
		this.ui.body.appendChild(this.ui.instructions);
		
		container.appendChild(this.ui.header);
		container.appendChild(this.ui.body);
		
		this.container = container;
		this.getManager().addMapObserver("filterchange",this);
		
		this.getManager().addMapObserver("loaded",(function() {
			// @FILTERREFACTOR What is this?
			this.notify('filterchange');
		}),this);
		
		this.getManager().addMapObserver("filtersloaded",function(){
			//seems to be needed in FF 3
			// @FILTERREFACTOR What is this?
			this.notify('filterchange'); 
		},this);
		
	},
	/**
	 *
	 * @method returnWithMessage
	 * @param {} messageTxt
	 */
	returnWithMessage: function(messageTxt){
		var customer = this.getManager().getOption('customer');
		var appname = this.getManager().getOption("app");
		
		var returnForm = document.createElement("form");
		returnForm.action = "/management/customer/"+customer
		returnForm.method = "POST";
		
		var message = document.createElement("input");
		message.type = "hidden";
		message.name = "message";
		message.value = messageTxt;
		returnForm.appendChild(message);
		
		var messageinfo = document.createElement("input");
		messageinfo.type = "hidden";
		messageinfo.name = "messageinfo";
		messageinfo.value = JSON.stringify({
			"customer": customer,
			"appname": appname
		});
		returnForm.appendChild(messageinfo);
		
		document.body.appendChild(returnForm);
		returnForm.submit();
	},
	/**
	 *
	 * @method toggleEnabled
	 * @method onOff
	 */
	toggleEnabled: function(onOff){
		if(onOff === undefined){
			if(this.ui.lock.disabled){
				onOff = 1; //enable
			}else{
				onOff = 0; //disable
			}
		}
		if(onOff === 0){
			this.ui.lock.toggle(0);
			this.ui.lock.enable(0)
			return this.ui.instructions.setText(this.ui.instrucText.disabled);
		}
		this.ui.lock.toggle(0);
		this.ui.lock.enable(1)
		return this.ui.instructions.setText(this.ui.instrucText.locked);
		
	},
	/**
	 *
	 * @method toggle
	 */
	toggle: function() {
		if($(this.ui.expander).hasClass("expanded")) {
			this.ui.body.style.display = "none";
			$(this.ui.expander).removeClass("expanded");
			$(this.container).removeClass("_expanded");
		} else {
			this.ui.body.style.display = "block";
			$(this.ui.expander).addClass("expanded");
			$(this.container).addClass("_expanded");
		}

		//this.getManager().mapObservers.notify('filterabletoggle', this);
	},
	/**
	 *
	 * @method sendSelections
	 * @param {} callback
	 */
	sendSelections: function(callback){
		
		var manager = this.getManager();
		var caller = this;
		
		var obj = {
			"customer": manager.getOption("customer"),
			"app": manager.getOption("app"),
			"ovrds": []
		}
		
		var datasourceControl = manager.getControl('datasources');
		var filterscontrol = manager.getControl("filterscontrol");
		var datasources = datasourceControl.getAll();
		for (var dsId in datasources) {
			var dsSel = caller.getSelectionObj(dsId);
			if(dsSel){
				obj.ovrds.push({
					"ds" : datasources[dsId].set_name,
					"override" : {
						"underlying_filter": dsSel
					}
				});
			}
		}
				
		var caller = this;
		var ajaxParamsObject = {
			url: "/customerapp/datasourceoverride",
			cache: false,
			type: "POST",
			data: "data="+JSON.stringify(obj),
			dataType: "json",
			success: function(data) {
				if(data.result == "ok"){
					caller.returnWithMessage(
						"Subset filters for customer " + caller.getManager().getOption('customer') + 
						" and application " + caller.getManager().getOption('app') + " have been successfully saved."
					);
				}else{
					caller.returnWithMessage(
						"Problem saving subset filters for customer " + caller.getManager().getOption('customer') + 
						" and application " + caller.getManager().getOption('app') + ". " + JSON.stringify(data)
					);
				}
			}
		};
		$.ajax(ajaxParamsObject);
	},
	/**
	 *
	 * @method areSelections
	 */
	areSelections: function(){
		var manager = this.getManager();
		var datasourceControl = manager.getControl('datasources');
		var filterscontrol = manager.getControl("filterscontrol");
		var datasources = datasourceControl.getAll();
		var hasSelections = false;
		for (var dsId in datasources) {
			var filters = filterscontrol.getFilters(dsId);
			hasSelections = !$.isEmptyObject(filters);
		}
		return hasSelections;
	},
	/**
	 *
	 * @method notify
	 * @param {} event
	 */
	notify: function(event){
		if(event == "filterchange") {
			if (this.areSelections()){
				this.toggleEnabled(1);
			}else{
				this.toggleEnabled(0);
			}
		}
	},
	/**
	 *
	 * @method getSelectionObj
	 * @param ds
	 */
	getSelectionObj: function(ds){
		var filterControl = this.getManager().getControl("filterscontrol");
		return $.extend(true, {}, filterControl.filtersToJSON(ds));
	}
};
Moonshadow.helpers.extend(MPanelContentManagement,MControl);


function MFilterable(branch,parent) {}

MFilterable.prototype = {
	init: function(branch, parent) {
		this.parent = parent || null;
		this.ext_name = branch.ext_name || branch.int_name;
		this.int_name = branch.int_name;
		this.dtype = branch.dtype;
		this.ctype = branch.ctype;
		
		this.ui = {}; // Storage for ui Elements
		this.sortableChildren = []; //keeping each child in sortable array
		
		this.acceptableTableCol = branch.tablecol || 0;
		this.acceptableTableRow = branch.spreadsheet_row || 0;
		this.tableColSelected = false;
		
		this.sensitivityWarnings = branch.sensitivityWarnings || this.getDatasource().getSensitivityWarnings(this.int_name);

		this.viewOnly = this.getDatasource().viewOnly;
		
		this.hasUnknowns = (typeof branch.unknown != "undefined" && branch.unknown == 1) ? true : false;
		this.noColor = (branch.noColor) ? true : false;		
		this.color_by = (typeof branch.color_by != "undefined" &&
						 branch.color_by == 0) ? false : true;
		this.filter_by = (typeof branch.filter_by != "undefined" &&
						  branch.filter_by == 0) ? false : true;
		this.generateColor = branch.generateColor || parent.generateColor || false;
		this.columnsRefreshed = false;
		
		if(branch.ds){
			this.ds = branch.ds;
		}
		
		this.defaultSort = this.getDatasource().defaultSort || {
			"column": "label",
			"sortOrder": 1
		};

		if(typeof branch.filterRef != "undefined") {
			this.filterRef = branch.filterRef;
		}

		this.setupDataPath();
		this.setupTreePath();
	},
	getChildrenHeader: function() {
		var header = document.createElement('div');
		header.className = 'children-header';		
		this.addColumnSorter(header);
		return header;
	},
	addColumnSorter: function(childrenHeader) {	//override this to customize 
		this.setUpColumnSorter();
		this.makeColumnSorterWithArray(
			this.sortList.opts,
			this.sortList.areaClass,
			childrenHeader, null,
			this.sortList.sortOrder, null, 
			this.sortList.sortFunctions,
			this.sortableChildren,
			this.sortList.itemFetch
		);
	},
	setUpColumnSorter: function(){
		this.sortList = this.getSortListOptions();
		this.largeList = false;
		if(this.values && this.values.length > 200){
			this.largeList = true;
			$(this.childContainer).addClass("with_pager");
			var self = this;
			this.sortList.itemFetch = function(id){
				return self.getChildById(id);
			}
			this.sortList.sortFunctions = {
				"filter": MUIFilterableSorter.predefinedSorting.filterFromObject,
				"sscols": MUIFilterableSorter.predefinedSorting.sscolsFromObject,
				"color": MUIFilterableSorter.predefinedSorting.colorFromObject,
				"label": MUIFilterableSorter.predefinedSorting.labelFromObject,
				"row_count": MUIFilterableSorter.predefinedSorting.filteredTotalFromObject,
				"row_total": MUIFilterableSorter.predefinedSorting.totalFromObject,
				"row_perc": MUIFilterableSorter.predefinedSorting.percentFromObject,
				"total_count": MUIFilterableSorter.predefinedSorting.totalFromObject,
				"total_perc": MUIFilterableSorter.predefinedSorting.percentFromObject
			}
		}
		
		if(MUIGradientPicker.enabled() && MUIGradientPicker.isGradientable(this)){
			var gradientControl = this.getControl().getManager().getControl('gradient');
			this.sortList.opts.unshift({
				"control": gradientControl.getOpenIcon(this),
				"float": "left"
			});
		}else{
			this.sortList.opts.unshift({
				"title": "Color",
				"sortby": "color",
				"float": "left",
				"sortdefault": false
			});
		}

		// Set the default sorting order based on datasource attributes
		this.setSortDefaultForSortList();
	},
	getSortListOptions: function(){
		return {
			"areaClass": "sortfilters",
			"sortOrder": 1,
			"opts": [
				{
					"title": "Marked Filers",
					"sortby": "filter",
					"float": "left",
					"sortdefault": false // defaults to false, because we process later
				},
				{
					"title": "Selected Spreadsheet Columns",
					"sortby": "sscols",
					"float": "left",
					"sortdefault": false
				},
				{
					"title": "Row Count",
					"sortby": "row_count",
					"float": "right",
					"sortdefault": false
				},
				{
					"title": "Row Total",
					"sortby": "row_total",
					"float": "right",
					"sortdefault": false
				},
				{
					"title": "Row Percent",
					"sortby": "row_perc",
					"float": "right",
					"sortdefault": false
				},
				{
					"title": "Total Count",
					"sortby": "total_count",
					"float": "right",
					"sortdefault": false
				},
				{
					"title": "Total Percent",
					"sortby": "total_perc",
					"float": "right",
					"sortdefault": false
				},
				{
					"title": "Name",
					"sortby": "label",
					"sortdefault": false
				}
			]
		};
	},
	setSortDefaultForSortList: function () {
		var opts = this.sortList.opts;
		var len = opts.length;
		var defaultSortColumn = this.defaultSort.column;
		this.sortList.sortOrder = this.defaultSort.sortOrder;
		for(var i = 0; i < len; i++) {
			var opt = opts[i];
			if(opt.sortby === defaultSortColumn) {
				opts[i].sortdefault = true;
				return
			}
		}
	},
	sortValues: function(values) {
		return values.sort(Moonshadow.helpers.naturalSort);
	},
	attach: function(branch) {
		if(typeof branch[this.int_name] != "object") {
			branch[this.int_name] = {};
		}

		var subBranch = branch[this.int_name];

		if(typeof subBranch.values != "object") {
			subBranch.values = {};
		}

		return subBranch;
	},
	setupColors: function() {
		var manager = this.getControl().getManager();
		var ds = this.getDatasource();
		var path = this.getDataPath();
		var value = path.pop();
		
		var colors = manager.getControl('colors');
		
		if(this.generateColor){
			colors.addDefaultColor(ds.int_name, path.join('|'), value);
		}
		
		this.color = colors.getColorForValue(ds.int_name, path.join('|'), value);
	},
	getControl: function() {
		var parent = this;
		while(typeof parent.parent != "undefined") {
			parent = parent.parent;
		}

		this.getControl = function() { return parent; };
		return parent;
	},
	getParent: function() {
		return this.parent;
	},
	getDatasource: function() {
		var parent = this;
		while(typeof parent.isDS == "undefined" &&
			  typeof parent.parent != "undefined") {
			parent = parent.parent;
		}

		this.getDatasource = function() { return parent };
		return parent;
	},
	buildUI: function() {},
	removeUI: function(){
		if(this.container){
			$(this.container).remove();
		}
	},
	hideSection: function(){
		var control = this.getControl();
		var manager = control.getManager();
		var datasourcesControl = manager.getControl('datasources');
		var dsId = this.getDatasource().int_name;
		var container = this.childContainer;
		
		container.style.display = "none";
		this.expander.className = this.expander.className.replace(" expanded","");
		
		$.each(this.values, function(k,v) {
			if(v.itsFilterable != undefined &&
			   v.itsFilterable.childContainer.children.length > 0) {
				v.itsFilterable.toggleValues();
			}
		});
		
		$(container).empty();
		if (this.getShowStats()) {
			this.removeOpenFilterables();
		}
		
		this.getDatasource().trackBranches(false, this);
		manager.getControl('colors').removeListener(
			dsId, this.getDataPath(), null, this.onColorsChange, this
		);
	},
	filtersLoadingIndicator: function(onOff, processed, total){
		if(this.largeList){
			if(!this.filtersLoadingIcon){
				this.filtersLoadingIcon = document.createElement('div');
				this.filtersLoadingIcon.className = "filter_loading_indicator";
			}
			if(onOff === true){
				$(this.ui.handle)
					.prepend(this.filtersLoadingIcon);
			}
			if(processed != undefined && total != undefined){
				$(this.filtersLoadingIcon)
					.empty()
					.append(processed," of ", total);
			}
			if(onOff === false){
				$(this.filtersLoadingIcon).remove();
			}
		}
	},
	showSection: function(callback){
		var control = this.getControl();
		var manager = control.getManager();
		var datasourcesControl = manager.getControl('datasources');
		var dsId = this.getDatasource().int_name;
		var container = this.childContainer;
		
		if(typeof this.buildChildren == "function") {
			this.childContainer.appendChild(this.buildChildren());
		}

		if(this.getShowStats() && !this.viewOnly) {
			this.childContainer.appendChild(
				this.getChildrenHeader()
			);
			
		} else if (this.dtype === 'heatmap') {
			var header = document.createElement('div');
			header.className = 'children-header';

			if(MUIGradientPicker.enabled()){
				var gradientControl = manager.getControl('gradient');
				header.appendChild(
					$(gradientControl.getOpenIcon(this))
						.addClass("no_sorter")
						.get(0)
				);
			}
			
			this.childContainer.appendChild(header);
		}
		
		if (this.sensitivityWarnings) {
			$(this.childContainer)
				.prepend(
					control.buildSensitivityWarning(
						this.sensitivityWarnings
					)
				);
		}
	
		var self = this;		
		this.processValues(function(){
			self.buildChildUIs();
			self.expander.className += " expanded";
			container.style.display = "block";
	
			// Notify Google analytics
			if(manager.ga) {
				manager.ga.notify('expanded', self.int_name);
			}
			
			self.getDatasource().trackBranches(true, self);
			
			if (self.ctype !== 'collection') {
				manager.getControl('colors').addListener(
					dsId, self.getDataPath(), null, self.onColorsChange, self
				);
			}
			
			if(self.countChildren() <= 1 && self.colsorter){
				self.colsorter.hideColSorter();
			}
			
			callback && callback(self);
		});
	},
	toggle: function(isAuto, callback) {
		// This function only opens if this.value has values - Overide this 
		// for custom behavior
		if(typeof this.values == "undefined" || this.values.length == 0) {
			return callback && callback(this);
		}
		
		if(this.processingValues){
			return callback && callback(this);
		}
		
//		if(isAuto && this.values.length > 100){
//			return false;
//		}
	
		if(this.childContainer == undefined){
			return callback && callback(this);
		}
	
		var control = this.getControl();
		var manager = control.getManager();
		var datasourcesControl = manager.getControl('datasources');
		var dsId = this.getDatasource().int_name;

		var container = this.childContainer;
		this.columnsRefreshed = false;
		
		//remove children and listeners if open
		if(container.children.length > 0) {
			this.hideSection();
			return callback && callback(this);
		}

		this.showSection(callback);
	},
	buildChildUIs: function(){
		var children = this.sortableChildren;
		for(var i = 0, l = children.length; i < l; ++i){
			var child = this.getChildById(children[i]);
			$(child.container).remove();
		}
		
		if(this.largeList && this.colsorter){
			var pageNumber = this.colsorter.sortablePageNumber || 0;
			var itemsPerPage = this.colsorter.maxSortableItems || 50;
			var startIndex = (pageNumber * itemsPerPage);
			children = this.sortableChildren.slice(startIndex, startIndex + itemsPerPage);
		}

		for(var i = 0, l = children.length; i < l; ++i){
			var child = this.getChildById(children[i]);
			if(child.buildUI){
				child.buildUI();
			}
		}
		
		if (this.getShowStats() && !this.viewOnly) {
			this.addOpenFilterables();
		}
	},
	getShowStats: function() {
		return false;
	},
	onColorsChange: function() {
		var self = this;

		$.each(this.values, function(k, v) {
			if ($.inArray(v.dtype, ['selector']) !== -1) {
				return;
			}

			var id = (typeof v === 'string') ? v : v.int_name;
			self.children[id].updateColorFromModel();
		});
	},
	processHandler: function(value){
		if(typeof value == "string") {
			value = {
				"int_name": value,
				"ext_name": value,
				"dtype": "item"
			};
		}

		if(this.children[value.int_name] == undefined) {
			this.children[value.int_name] = this.getControl().getFilterable(value, this);
			this.sortableChildren.push(value.int_name);
		}
	},
	processValues: function(callback) {
		if(this.values == undefined || !this.values.length) {
			return callback();
		}
		
		if(this.processingValues){
			return;
		}

		var self = this;
		var maxtime = 100;
		var delay = 20;
		var queue = this.values.slice();
		var totalValues = this.values.length;
		this.processingValues = true;
		this.filtersLoadingIndicator(true);
		
		setTimeout(function(){
			var endtime = +new Date() + maxtime;
			do {
				self.processHandler(queue.shift())
				self.filtersLoadingIndicator(null, totalValues - queue.length, totalValues);
			} while (queue.length > 0 && endtime > +new Date());
			
			if (queue.length > 0) {
				setTimeout(arguments.callee, delay);
		    } else {
		    	self.filtersLoadingIndicator(false, totalValues, totalValues);
		    	self.processingValues = false;
		    	callback();
		    }
		}, delay);
	},
	updateFilterCount: function(handle) {
		if(this.hasFilters < 1) {
			$(".filter-count", handle).empty();
			$(handle).removeClass('has-filters');
		} else {
			var has = this.hasFilters;
			$.each($(".filter-count", handle), function(k,v) {
				$(v).empty();
				v.appendChild(document.createTextNode("("+has+")"));
			});

			$(handle).addClass('has-filters');
		}
		this.checkFilterCount();
	},
	updateFilterState: function() {
		var filterValue = this.getFilterValue();
		
		if(filterValue && this.checkbox) {
			this.checkbox.checked = !!filterValue.value;

			if(this.checkbox.checked) {
				$(this.label).addClass('selected');
			} else {
				$(this.label).removeClass('selected');
			}
		}

		this.hasFilters = this.countFilters();

		if(this.ui.handle) {
			this.updateFilterCount(this.ui.handle);
		}
	},
	isIntNameInArray: function(arr, key) {
		var found = false;
		$.each(arr, function(k, v) {
			if(typeof v === 'string' && v === key) {
				found = true;
			}

			if(typeof v === 'object' && v.int_name && v.int_name === key) {
				found = true;
			}
	
			if(found) {
				return false;;
			}
		});
		return found;
	},
	getFilterValue: function(defaultValue) {
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		return filters.getFilter(dsId, this.getDataPath().join('|'), defaultValue);
	},
	setFilterValue: function(filter) {
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		filters.setFilter(dsId, this.getDataPath().join('|'), filter);
	},
	_setFilterValue: function(filter) {
		//set value, but don't trigger event
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		filters.setFilterValue(dsId, this.getDataPath().join('|'), filter);
	},
	clearFilterValue: function() {
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		filters.clearFilter(dsId, this.getDataPath().join('|'));
	},
	_clearFilterValue: function() {
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		filters.clearFilterValue(dsId, this.getDataPath().join('|'));
	},
	notifyFilterChanges: function(){
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		filters.notifyFilterChanges([dsId]);
	},
	getDeclarationValue: function() {
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath();
		var decId = path.shift();

		var filters = this.getFiltersControl();
		return filters.getDeclaration(dsId, decId, path.join('|'));
	},
	setDeclarationValue: function(value) {
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath();
		var decId = path.shift();

		var dec = {
			'int_name': decId,
			'op': 'count_filters'
		}

		var filters = this.getFiltersControl();
		filters.setDeclaration(dsId, dec, path.join('|'), value);
	},
	clearDeclarationValue: function() {
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath();
		var decId = path.shift();

		var filters = this.getFiltersControl();
		filters.clearDeclaration(dsId, decId, path.join('|'));
	},
	clearDeclaration: function() {
		var dsId = this.getDatasource().int_name;
		var decId = this.getDataPath().shift();

		var filters = this.getFiltersControl();
		filters.clearDeclaration(dsId, decId);
	},
	getDatasourcesControl: function() {
		return this.getControl().getManager().getControl('datasources');
	},
	getFiltersControl: function() {
		return this.getControl().getManager().getControl('filterscontrol');
	},
	getColorsControl: function() {
		return this.getControl().getManager().getControl('colors');
	},
	getUniversesControl: function() {
		return this.getControl().getManager().getControl('universescontrol');
	},
	getCountsControl: function() {
		return this.getControl().getManager().getControl('countsmodel');
	},	
	countFilters: function() {
		var dsId = this.getDatasource().int_name;
		var filters = this.getFiltersControl();
		return filters.countFilters(dsId, this.getDataPath().join('|'));
	},
	countLeaves: function(branch, visitChildren) {
		// Default visit children to true
		if(typeof visitChildren === 'undefined') {
			visitChildren = true;
		}

		var total = 0;

		var caller = this;
		var toFromAlreadyCounted = false;
		$.each(branch, function(k,v) {
			if(typeof v == 'object') {
				if(visitChildren && k !== '__universes') {
					total += caller.countLeaves(v);
				}
			} else {
				if(k === 'suffix') {
					return true;
				}

				if(k === 'to' || k === 'from') {
					if(toFromAlreadyCounted) {
						return true;
					}

					toFromAlreadyCounted = true;
				}

				total++;
			}
		});

		return total;
	},
	clearFilters: function() {
		this.hasFilters = 0;
		if (typeof this.ui.handle != "undefined") {
			$(this.ui.handle).removeClass("has-filters");
		}

		// @CLEANUP we should have an overridden function for this
		if (typeof this.clearSpecificFilter == "function") {
			this.clearSpecificFilter();
		}

		if (typeof this.children != "undefined") {
			$.each(this.children, function(k, v) {
				v.clearFilters();
			});
		}
		
		this.clearLastChecked();
	},
	clearLastChecked: function(filter){
		this.lastChecked && (this.lastChecked = null);
		if(this.parent.clearLastChecked){
			this.parent.clearLastChecked(filter);
		}
	},
	filtersHaveValue: function(infilters){
		if (typeof this.parent.dsIndex != "number") return false;
		var ds = this.getControl().getDatasource(this.parent.dsIndex);
		if (!ds.filters ||
			!ds.filters.values ||
			!ds.filters.values[this.int_name] ||
			!ds.filters.values[this.int_name].values)
				return false;
		var allFilters = this.getControl().getDatasource(this.parent.dsIndex).filters.values[this.int_name].values;
		var hasValue = {val: false};
		var reCurs = function(infilters, allFilters, hasValue){
			$.each(infilters, function(k,v) {
				for(var i in allFilters){
					if (i == k){
						if (allFilters[i].value && allFilters[i].value == 1)
							hasValue.val = true;
						if (v.values && allFilters[i].values)
							reCurs(v.values, allFilters[i].values, hasValue);
					}
				}

			});
		}
		reCurs(infilters, allFilters, hasValue);
		return hasValue.val;
	},
	getGradient: function() {
		var colors = this.getColorsControl();
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');

		return colors.getGradientForField(dsId, path);
	},
	setGradient: function(gradient, save) {
		var colors = this.getColorsControl();
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');

		return colors.setGradientForField(dsId, path, gradient, save);
	},
	getColors: function() {
		var colors = this.getColorsControl();
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');

		return colors.getColorsForField(dsId, path);
	},
	setChildColors: function(colors) {
		var colorsControl = this.getColorsControl();
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');

		colorsControl.setColorsForField(dsId, path, colors);

		this.updateChildColorsFromModel();
	},
	setColorsWithGradient: function(gradient, colorModel) {
		var colorsControl = this.getColorsControl();

		var numNeeded = this.values.length;
		var gradientColors = colorsControl.getGradientColors(gradient, colorModel,
															 numNeeded);
		var colors = this.getColors();
		
		var list = this.childContainer.children;
		
		var i = 0;
		$.each(this.sortableChildren, function(index, value) {
			colors[value] = gradientColors[i];
			i++;
		});

		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');
		colorsControl.setColorsForField(dsId, path, colors);

		this.updateChildColorsFromModel();
	},
	getChildById: function(id){
		return this.children[id];
	},
	updateChildColorsFromModel: function() {
		$.each(this.children, function(index, value) {
			value.updateColorFromModel();
		});	
	},
	addOpenFilterables: function() {
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');
	
		var counts = this.getCountsControl();
		counts.addCounted(dsId, path, this.updateCounts, this, false);
		this.getControl().getManager().mapObservers.notify('filterabletoggle', this);
	},
	removeOpenFilterables: function() {
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath().join('|');
	
		var counts = this.getCountsControl();
		counts.removeCounted(dsId, path, this.updateCounts, this, false);
	},
	getCountsMode: function() {
		var countsControl = this.getControl().getManager().getControl('countsmodel');
		return countsControl.getCountsMode(this.getDatasource().int_name);
	},
	updateCounts: function(dsId, path, data, maximum) {
		if(typeof this.children != 'undefined') {
			$.each(this.children, function(k, v) {
				var itemData = data[v.int_name];

				var amount = (itemData) ? itemData :
					(maximum instanceof Array) ? [0, 0] : 0;
				
				v.updateCount(amount, maximum);
			});
		}

		if(this.columnsRefreshed === false){
			this.colsorter && this.colsorter.refreshSort();
			this.columnsRefreshed = true;
		}
	},
	updateCount: function(amount, maximum) {
		var mode = this.getCountsMode();

		this.filteredCountTotal = null;
		this.countTotal = null;
		this.countPerc = null;
		
		if (mode === 'row') {
			if (!(amount instanceof Array)) {
				throw new Error('Expected more data when updating counts');
			}

			var filtered = parseInt(amount[0] || '0', 10);
			var unfiltered = parseInt(amount[1] || '0', 10);
			var percentage = filtered / unfiltered * 100;

			this.filteredCountTotal = filtered;
			this.countTotal = unfiltered;
			this.countPerc = percentage;
			
			this.updateRowCounts(filtered, unfiltered, percentage);
		} else {
			// If not an array, then we only got filtered counts
			var filtered = parseInt(amount || '0', 10);
			var filteredTotal = parseInt(maximum, 10);
			var filteredPerc = (filtered / filteredTotal) * 100;
			if (isNaN(filteredPerc)) {
				filteredPerc = 0;
			}

			this.countTotal = filtered;
			this.countPerc = filteredPerc;
			
			this.updateTotalCounts(filtered, filteredPerc);
		}
	},
	updateRowCounts: function(selected, total, percent) {
		if(!this.container){
			return;
		}
		
		var uiCount = this.container.querySelector('.row-group > .count');
		var uiTotal = this.container.querySelector('.row-group > .total');
		var uiPercent = this.container.querySelector('.row-group > .perc');

		if (uiCount && typeof selected === "number") {
			var countOpts = {
				'numberOfDecimals': 0,
				'decimalSeparator': '.',
				'thousandSeparator': ','
			};

			var countFormatted = $().number_format(selected, countOpts);
			uiCount.innerHTML = countFormatted;
			uiCount.title = 'Number of Selected People in row "'+ this.getLabelText() +
				'": ' + countFormatted;
		}

		if (uiTotal && typeof total === "number") {
			var countOpts = {
				'numberOfDecimals': 0,
				'decimalSeparator': '.',
				'thousandSeparator': ','
			};

			var totalFormatted = $().number_format(total, countOpts);
			uiTotal.innerHTML = totalFormatted;
			uiTotal.title = 'Total Number of People in row "' + this.getLabelText() +
				'": ' + totalFormatted;
		}

		if (uiPercent && typeof percent === "number") {
			var percOpts = {
				'numberOfDecimals': 3,
				'decimalSeparator': '.',
				'thousandSeparator': ','
			};

			// Drop .0 on 100.0%
			if (percent === 100) {
				percOpts.numberOfDecimals = 0;
			}

			var percentFormatted = $().number_format(percent, percOpts) + '%';

			if (percent < 10) {
				percentFormatted = '0' + percentFormatted;
			}

			uiPercent.innerHTML = percentFormatted;

			// Drop .0 on 100.0%
			if (percent === 100) {
				percOpts.numberOfDecimals = 0;
			} else {
				percOpts.numberOfDecimals = 6;
			}

			var titleFormattedPercentage = $().number_format(percent, percOpts) + '%';
			uiPercent.title = 'Selected People as a percentage of Total Number of ' + 
				'People in row "' + this.getLabelText() + '": ' + titleFormattedPercentage;
		}
	},
	updateTotalCounts: function(count, percent) {
		if(!this.container){
			return;
		}
		
		var uiCount = this.container.querySelector('.total-group > .count');
		var uiPercent = this.container.querySelector('.total-group > .perc');

		if (uiCount && typeof count === "number") {
			var countOpts = {
				'numberOfDecimals': 0,
				'decimalSeparator': '.',
				'thousandSeparator': ','
			};

			var countFormatted = $().number_format(count, countOpts);
			uiCount.innerHTML = countFormatted;
			uiCount.title = 'Number of Selected People in row "' + this.getLabelText() +
				'": ' + countFormatted;
		}

		if (uiPercent && typeof percent === "number") {
			var percOpts = {
				'numberOfDecimals': 3,
				'decimalSeparator': '.',
				'thousandSeparator': ','
			};

			// Drop .0 on 100.0%
			if (percent === 100) {
				percOpts.numberOfDecimals = 0;
			}

			var percentFormatted = $().number_format(percent, percOpts) + '%';

			if (percent < 10) {
				percentFormatted = '0' + percentFormatted;
			}

			uiPercent.innerHTML = percentFormatted;

			// Drop .0 on 100.0%
			if (percent === 100) {
				percOpts.numberOfDecimals = 0;
			} else {
				percOpts.numberOfDecimals = 6;
			}

			var title = $().number_format(percent, percOpts) + '%';
			uiPercent.title = 'Selected People in row "' + this.getLabelText() +
				'" as a percentage of Total Number of Selected People: ' + title;
		}
	},
	onCheckboxChange: function(checkbox, delayed) {
		if(checkbox.checked) {
			$(checkbox.filter.label).addClass("selected");
			if(delayed){
				this._setFilterValue({'value': 1});
			}else{
				this.setFilterValue({'value': 1});
			}
		} else {
			$(checkbox.filter.label).removeClass("selected");
			if(delayed){
				this._clearFilterValue();
			}else{
				this.clearFilterValue();
			}
		}
		if(!delayed){
			this.checkFilterCount();
			this.changeFilterState(checkbox.id, checkbox.checked);
		}
	},
	getLastChecked: function(){
		return this.parent.lastChecked;
	},
	setLastChecked: function(checkbox){
		this.parent.lastChecked = checkbox;
	},
	checkFilterCount: function(){
		//the only this this does right now is check to see if the filterable has 
		//	filters selected, and shows/hides the clear button local to it's control,
		//  until it gets to MFiltersDatasource... then it does about the same.
		var hasFilters = this.countFilters([],this.struct);
		this.showHideClear(hasFilters);
		if(this.parent && this.parent.checkFilterCount){
			this.parent.checkFilterCount();
		}
	},
	showHideClear: function(showHide){
		if(this.clear_selection){
			if(showHide){
				$(this.clear_selection).removeClass("hide");
			}else{
				$(this.clear_selection).addClass("hide");
			}
		}
	},
	onChange: function(input) {
		var id = $(input).data("name");
		var filterable = $(input).data("filter");

		if(input.type == "checkbox") {
			var state = input.checked;
		} else if($(input).data("value") != undefined) {
			var state = ($(input).data("value") !== false) ? true : false;
		} else {
			var state = (input.value.length > 0);
		}

		var change = 0;

		if(state) {
			change = (typeof filterable.filters[id] == "undefined") ? 1 : 0;
			filterable.filters[id] = (input.value != undefined) ? input.value : $(input).data("value");
		} else {
			change = -1;
			delete filterable.filters[id];
		}

		this.parent.perculateChange();
	},
	changeFilterState: function(id,state) {},
	perculateChange: function() {
		this.hasFilters = this.countFilters();

		if(this.hasFilters <= 0) {
			$.each($(".filter-count",this.ui.handle),function(k,v) {
				$(v).empty();
			});

			$(this.ui.handle).removeClass("has-filters");
			this.hasFilters = 0;
		} else {
			var has = this.hasFilters;
			$.each($(".filter-count",this.ui.handle),function(k,v) {
				$(v).empty();
				v.appendChild(document.createTextNode("("+has+")"));
			});

			if(!$(this.ui.handle).hasClass("has-filters")) {
				$(this.ui.handle).addClass("has-filters");
			}
		}

		if(!this.parent || typeof this.parent.perculateChange != "function") {
			return;
		}

		this.parent.perculateChange();
	},
	getColorByTreePath: function(path) {
		var obj = {};
		obj.values = {};
		obj.values[this.int_name] = path || {};

		if(this.parent && this.parent.getColorByTreePath) {
			obj = this.parent.getColorByTreePath(obj);
		}

		return obj;
	},
	makeChildren: function() {
		var children = document.createElement("div");
		children.className = "children";
		this.childContainer = children;
		this.ui.children = children;
		return this.childContainer;
	},
	makeChildrenResizable: function(columnSorter, hidden){
		if(!this.childContainer){
			this.makeChildren();
		}
		return this.makeContainerResizable(columnSorter, hidden, this.childContainer);
	},
	makeContainerResizable: function(otherElements, hidden, container){
		if(!(otherElements instanceof Array)){
			otherElements = otherElements ? [otherElements] : [];
		}
		var r = document.createElement("div");
		$(r).addClass("manual_expander");
		if(hidden){
			$(r).addClass("hide");
		}else{
			$(container).css({
				"display": "inherit"
			});
		}
		
		var dH = 200; //default height
		var mH = 80; //min height

		var c = container;
		var self = this;
		var control = this.getControl();
		var manager = control.getManager();
		
		var getOtherHeights = function(){
			var oeh = 0;
			for(var i = 0, l = otherElements.length; i < l; ++i){
				var oeh1 = $(otherElements[i]).outerHeight() || 0;
				oeh += oeh1;
			}
			return oeh;
		};
		
		var appendOthers = function(container){
			for(var i = 0, l = otherElements.length; i < l; ++i){
				$(container)
					.prepend(
						$(otherElements[i]).get(0)
					)
			}
		}
		
		var rsize = function(obsMaxMin, ignoreDbl){
			var csH = getOtherHeights();
			var h = 0;
			$(c).children().each(function(i, e){
				if($(e).is(":visible"))
					h += $(e).outerHeight();
	    	})
	    	if(!h || h > dH && obsMaxMin){
	    		h = dH;
	    	}
	    	if(h < mH && obsMaxMin){
	    		h = mH;
	    	}
	    	if($(c).height() == h && !ignoreDbl){
	    		h = dH;
	    	}
	    	h += 2; //small space at bottom
    		$(r).css({"height": (h + csH) + "px"});
	    	$(c).css({"height": h + "px"});
		};
		
		var reHeight = function(e, o){
			if(self == o){
				if($(c).height() > dH){
					var csH = getOtherHeights()
					$(r).css({"height": (dH + csH) + "px"});
			    	$(c).css({"height": dH + "px"});
				}
				if($(c).height() < dH){
					rsize(true);
			    }
				manager.removeMapObserver('filterabletoggle', reHeight, self);
			}
		};
		
		manager.addMapObserver("filterabletoggle", reHeight, this);

		$(r).append(c)
			.resizable({
				"alsoResize": c,
				"handles": "s",
				"resize": function(){
					$(c).css({"width": "initial"})
					
				},
				"stop": function(){
					manager.mapObservers.notify('panel_resize', this);
				}
			})
			.get(0);
		
		$(".ui-resizable-handle", r)
			.on("dblclick", function(e){
				rsize();
				manager.mapObservers.notify('panel_resize', this);
			});
		
		$(container)
			.on("scroll", function(){
				manager.mapObservers.notify('sidepanelscroll', this);
			});
		
//		//if colsorter not added to doc, cant calculate it's height
		if(otherElements && otherElements.length && getOtherHeights() == 0){
			appendOthers($("body"));
			//$("body").append(otherElements);
		}
		
		rsize();
		
		if(otherElements && otherElements.length){
			appendOthers(r);
			//$(r).prepend(otherElements);
		}
		
		$(r).on("resizeInput", function(e, data){
			if(data){
				var rh = parseInt($(r).css("height"), 10);
				var ch = parseInt($(c).css("height"), 10);
				rh += data;
				ch += data;
				$(r).css({"height": rh + "px"});
		    	$(c).css({"height": ch + "px"});
			}
		})
		.on("rsize", rsize);
		
		return r;
	},
 	makeColorBy: function() {
		var control = this.getControl();
		var manager = control.getManager();
		var datasourcesControl = manager.getControl('datasources');

		var colorBy = document.createElement('div');
		var classNames = ['color-by'];

		var dsId = this.getDatasource().int_name;

		var colorByControl = manager.getControl("colorbycontrol");
		var activeColorByDsId = colorByControl.getActiveDsId();
		var activeColorBy = colorByControl.getActiveColorBy();
		
		var notSupported = ['selection', 'item', 'collection'];
		if(this.color_by && !this.noColor && $.inArray(this.dtype, notSupported) === -1) {
			var baseLayer = manager.getControl('layerBase');
			var meshes = manager.getControl('layerMesh');

			// Item is clickable, if choropelth support use double layer icon
			if(!this.viewOnly) {
				classNames.push('clickable');
			}

			if(this.supportsChoro() || this.supportsArea()) {
				classNames.push('double');
			} else {
				classNames.push('single');
			}
	
			// setup title
			colorBy.title = ['Color by', this.ext_name].join(' ');
			
			if ((dsId === activeColorByDsId || dsId === "__universes") &&
			   activeColorBy.color === this.int_name) {
				control.currentColorBy = this;
				classNames.push('colored');

				if(!baseLayer.isShown()) {
					baseLayer.show();
				}
			}

			// if this is the active choropleth add the class
			if (meshes.getActiveChoropleth(dsId, this.int_name) 
				|| meshes.getActiveMeshByDSFilter(dsId, this.int_name)) {
				classNames.push('choroed');
			} 

			if (!this.viewOnly) {
				$(colorBy).click((function(context) {
					return function(event) {
						if(typeof context.colorByClick == "function") {
							context.colorByClick(event);
						} else {
							context.showColorBy(event);
						}
					};
				}(this)));
			}
		}

		colorBy.className = classNames.join(' ');
		colorBy.filter = this;
		$(colorBy).data('filter', this);

		var childBy = document.createElement('div');
		childBy.colorBy = colorBy;
		childBy.className = 'childby sprite-layer_child';
		childBy.title = 'The current color by is a decendent of ' + this.ext_name;
		colorBy.appendChild(childBy);

		//child by path
		var treePath = activeColorBy.treePath;
		var matchIndex = $.inArray(this.int_name, treePath);
		if (matchIndex !== -1 && matchIndex !== treePath.length - 1) {
			childBy.style.display = 'block';
		}

		this.colorBy = colorBy;
		this.childBy = childBy;

		return colorBy;
	},
	showColorBy: function(event) {
		this.getControl().getManager().mapObservers.notify('colorbyclick', event.target);
	},
	setChildBy: function(isOn) {
		if(this.parent && typeof this.parent.setChildBy === 'function') {
			this.parent.setChildBy(isOn);
		}

		var colorby = this.getControl().getManager().getControl("filters").getColorBy();
		if(this.childBy && isOn && colorby !== this) {
			this.childBy.style.display = 'block';
		} else {
			this.childBy.style.display = 'none';
		}
	},
	supportsChoro: function() {
		var dsId = this.getDatasource().int_name;
		var manager = this.getControl().getManager();
		var meshes = manager.getControl('layerMesh');

		if(this.ctype !== 'area' || this.dtype === 'heatmap') {
			if(meshes && meshes.hasChoropleths(dsId)) {
				return true;
			}
		}

		return false;
	},
	supportsArea: function() {
		var manager = this.getControl().getManager();
		var meshes = manager.getControl('layerMesh');
		return !!meshes.getSupportedArea(manager.getDatasource().int_name, this.int_name);
	},
	setColoredBy: function(isOn) {
		var cb = $(this.colorBy);
		if(this.colorBy) {
			if(isOn) {
				cb.addClass('colored');
			} else {
				cb.removeClass('colored');
			}
		}
	},
	setChoroedBy: function(isOn) {
		if(this.colorBy) {
			var cb = $(this.colorBy);
			if(isOn) {
				// Right now it only supprots one
				$.each($(".filterable .color-by.choroed"),function(k,v) {
					$(v).removeClass("choroed");
				});
				cb.addClass('choroed');
			} else {
				cb.removeClass('choroed');
			}
		}
	},
	getColorIcon: function(type) {
		var colorPicker = this.getControl().getManager().getControl('colorpicker');
		return colorPicker.getColorIcon(this, type);
	},
	makeColorSel: function(type, callback) {
		var colorPicker = this.getControl().getManager().getControl('colorpicker');
		return colorPicker.getColorIcon(this, type, callback);
	},
	updateColorFromModel: function() {
		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath();
		var value = path.pop();

		var colors = this.getColorsControl();

		var color = colors.getColorForValue(dsId, path.join('|'), value);
		this.color = color;

		$(".color-picker", this.container)[0].style.backgroundColor = '#' + color;
	},
	updateColorModel: function() {
		var manager = this.getControl().getManager();
		if (manager.getOption("neutered") == 1) {
			return false;
		}

		var dsId = this.getDatasource().int_name;
		var path = this.getDataPath();
		var value = path.pop();
		var color = this.color;

		var colorControl = this.getColorsControl();
		colorControl.setColorsForValue(dsId, path.join('|'), value, color);
	},
	_cloneDiv: function() {
		var f = this._cloneDiv;
		if(!f.divElm) {
			f.divElm = document.createElement("div");
		}

		return f.divElm.cloneNode(false);
	},
	_cloneSpan: function() {
		var f = this._cloneSpan;
		if(!f.spanElm) {
			f.spanElm = document.createElement("span");
		}

		return f.spanElm.cloneNode(false);
	},
	_cloneCriteriaDiv: function() {
		var f = this._cloneCriteriaDiv;
		if(!f.divElm) {
			f.divElm = this._cloneDiv();
			f.divElm.className = "criteria";
		}

		return f.divElm.cloneNode(false);
	},
	_cloneCheckboxCon: function() {
		var f = this._cloneCheckboxCon;
		if(!f.checkBoxCon) {
			var container = this._cloneDiv();
			container.className = "checkbox";

			f.checkBoxCon = container;
		}

		return f.checkBoxCon.cloneNode(false);
	},
	_cloneCheckbox: function() {
		var f = this._cloneCheckbox;
		if(!f.checkBox) {
			var checkbox = document.createElement("input");
			checkbox.type = "checkbox";
			checkbox.name = "value";
			checkbox.value = "1";

			f.checkBox = checkbox;
		}

		return f.checkBox.cloneNode(false);
	},
	makeCheckboxFilter: function(id,isChecked) {
		
		var self = this;
		var container = this._cloneCheckboxCon();
		var checkbox = this._cloneCheckbox();
		var manager = this.getControl().getManager();
		
		var datasourcesControl = manager.getControl('datasources');
		var dsId = this.getDatasource().int_name;
		
		checkbox.id = id;
		checkbox.checked = isChecked;
		checkbox.title = this.getCheckboxFilterTitle(this,checkbox);
		checkbox.filter = this;

		if(!this.viewOnly) {
			$(checkbox)
				.on("click", function(e) {
					var lc = self.getLastChecked();
					if(e.shiftKey && lc){
						if(lc == this || lc.checked !== this.checked) {
							return self.setLastChecked(this);
						}
						e.stopImmediatePropagation();
						e.preventDefault();
						this.filter.multiCheck(this);
					}
				})
				.on("change", function(e) {
					this.filter.onCheckboxChange(this);
					this.filter.setLastChecked(this);
				});
		} else {
			checkbox.disabled = true;
		}

		if(isChecked && (this.dtype == "purchaseditem" || this.dtype == "universeitem")){
			$(this.label).addClass("selected");
		}

		this.checkbox = checkbox;
		container.checkbox = checkbox;
		container.appendChild(checkbox);

		return container;
	},
	getParentHasFilters: function(){
		return this.parent.getHasFilters();
	},
	getHasFilters: function(){
		return this.hasFilters;
	},
	getCheckboxFilterTitle: function(filter,checkbox) {
		return (filter.dtype != "mesh") ? "Change "+this.getControl().getOption("locale.filter","filter").toLowerCase()+" for this item" : "Show/Hide";
	},
	multiCheck: function(checkbox){
		var classSelector = $(checkbox.filter.container).attr("class");
		if(!classSelector){
			return;
		}
		var lastCheckedItem = this.getLastChecked();
		
		var checked = checkbox.checked;
		if(!lastCheckedItem){
			return $(checkbox).attr({
					"checked": checked
				})
				.trigger("change");
		}
		
		var selection = "." + classSelector.split(" ").join(".");
		var peerContainer = this.getParentContainer();
		
		var toBeChecked;
		$(selection, peerContainer).each(function(index, element){
			var box = $(".checkbox input", element).get(0);
			if(checkbox.id === box.id){
				if(toBeChecked === undefined){
					toBeChecked = [];
					return true;
				}
				return false;
			}
			if(lastCheckedItem.id === box.id){
				if(toBeChecked === undefined){
					toBeChecked = [];
					return true;
				}
				return false;
			}
			if(toBeChecked){
				var _checked = $(box).attr("checked") ? true : false;
				if(_checked != checked){
					toBeChecked.push(box);
				}
			}
		});

		if(toBeChecked){
			for(var i = 0, l = toBeChecked.length; i < l; ++i){
				var box = toBeChecked[i];
				box.checked = checked;
				box.filter.onCheckboxChange(box, true);
			}
		}
		
		var self = this;
		setTimeout(function(){
			$(checkbox).attr({
					"checked": checked
				})
				.trigger("change");
			
			 self.setLastChecked(checkbox);
		}, 0);
	},
	isChecked: function(){
		if(this.getFilterValue()){
			return true;
		}
		return false;
	},
	getParentContainer: function(){
		return this.parent && this.parent.childContainer;
	},
	makeSpreadsheetRowAdder: function(filterable){
		var manager = this.getControl().getManager();
		var ssControl = manager.getSpreadsheetControl();
		return ssControl.spreadsheetRowAdder(filterable);
	},
	makeSpreadsheetColumnAdder: function(filterable, specialType, bucket) {
		var manager = this.getControl().getManager();
		var ssControl = manager.getSpreadsheetControl();
		return ssControl.spreadsheetColumnAdder(filterable, specialType, bucket);
	},
	makeColumnSorter: function(inCols, areaClass, sortContainer, columnContainer, sortOrder, sortClassCriteria, sortOpts) {
		this.colsorter = this.makeColumnSorterInst(inCols, areaClass, sortContainer, columnContainer, sortOrder, sortClassCriteria, sortOpts)
		return this.colsorter.makeColumnSorter();
	},
	makeColumnSorterWithArray: function(inCols, areaClass, sortContainer, columnContainer, sortOrder, sortClassCriteria, sortOpts, sortableArray, itemFetch) {
		this.colsorter = this.makeColumnSorterInst(inCols, areaClass, sortContainer, columnContainer, sortOrder, sortClassCriteria, sortOpts, sortableArray, itemFetch)
		return this.colsorter.makeColumnSorter();
	},
	makeColumnSorterInst: function(inCols, areaClass, sortContainer, columnContainer, sortOrder, sortClassCriteria, sortOpts, sortableArray, itemFetch) {
		var scont =  sortContainer || columnContainer || this.childContainer;
		var sortc = sortClassCriteria || "> .selection, > .criteria";
		var cc = columnContainer || this.childContainer;
		
		var colSorterOptions = {
			"sortFunctions": sortOpts,
			"columnSettings": inCols,
			"columnSorterClassName": areaClass, 
			"columnDataContainer": cc,
			"sorterContainer": scont,
			"sortCriteriaClass": sortc,
			"sortOrder": sortOrder
		};
		
		var self = this;
		if(this.largeList && sortableArray){
			colSorterOptions.sortType = "array";
			colSorterOptions.maxSortableItems = 50;
			colSorterOptions.sortableArray = sortableArray;
			colSorterOptions.usePager = true;
			colSorterOptions.itemFetch = itemFetch;
			colSorterOptions.callback = function(){
				self.buildChildUIs();
			}
		}
		
		var colsorter = new MUIFilterableSorter(colSorterOptions);
		return colsorter;
	},
	makeExpander: function(disabled, title, expanded) {
		if(disabled == undefined){
			disabled = !this.hasExpander();
		}
		
		var handle = document.createElement("div");
		handle.className = "handle";

		if(this.hasFilters > 0) {
			handle.className += " has-filters";
		}

		handle.filter = this;
		handle.control = this.control;

		if(!disabled) {
			$(handle).click({"self": this}, function(e) {
				var self = e.data.self;
				self.toggle();
				self.getControl().getManager().mapObservers.notify('filterabletoggle', self);
			});
		}

		if(!disabled) {
			var expander = document.createElement("div");
			expander.className = "expander";
			if(expanded){
				expander.className += " expanded";
			}
			this.expander = expander;

			handle.className += " clickable";
			handle.appendChild(expander);
		} else {
			$(handle).addClass("disabled");
			handle.style.paddingLeft = "15px";
		}

		var label = this.makeLabel(title || this.getLabelText());
		handle.appendChild(label);

		this.ui.expander = expander;
		this.ui.handle = handle;

		return handle;
	},
	hasExpander: function() {
		return typeof this.values != "undefined" && this.values.length > 0;
	},
	getLabelText: function() {
		return Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "));
	},
	countChildren: function(){
		return Moonshadow.helpers.objCount(this.children);
	},
	makeLabel: function(text, selected) {
		var label = document.createElement("div");
		label.title = text;
		label.className = "label";
		label.appendChild(document.createTextNode(text));		

		if(selected) { label.className += " selected"; }

		label.appendChild(this.makeFilterCount());

		this.label = label;

		return label;
	},
	makeFilterCount: function(id) {
		var count = this._cloneSpan();

		count.className = "filter-count";
		if(this.hasFilters > 0) {
			count.appendChild(document.createTextNode("(" + this.hasFilters + ")"));
		}

		return count;
	},
	_cloneCountCon: function() {
		var f = this._cloneCountCon;
		if(!f.countCon) {
			var countCon = this._cloneDiv();
			countCon.className = "counts";

			f.countCon = countCon;
		}

		return f.countCon.cloneNode(false);
	},
	_cloneCount: function() {
		var f = this._cloneCount;
		if(!f.countElm) {
			var count = this._cloneDiv();
			count.className = "count";

			f.countElm = count;
		}

		return f.countElm.cloneNode(false);
	},
	_cloneTotal: function() {
		var f = this._cloneCount;
		if(!f.totalElm) {
			var total = this._cloneDiv();
			total.className = "total";

			f.totalElm = total;
		}

		return f.totalElm.cloneNode(false);
	},
	_clonePerc: function() {
		var f = this._clonePerc;
		if(!f.perc) {
			var perc = this._cloneDiv();
			perc.className = "perc";

			f.perc = perc;
		}

		return f.perc.cloneNode(false);
	},
	makeCounts: function(mode) {
		var countMode = mode || 'total';

		var countDiv = this._cloneCountCon();
		countDiv.className += ' ' + countMode + '-group';

		if (countMode === 'row') {
			var selected = this._cloneCount();
			var total = this._cloneTotal();
			var perc = this._clonePerc();

			countDiv.appendChild(selected);
			countDiv.appendChild(total);
			countDiv.appendChild(perc);
		} else { // 'total'
			var selected = this._cloneCount();
			var perc = this._clonePerc();

			countDiv.appendChild(selected);
			countDiv.appendChild(perc);
		}

		var clear = this._cloneDiv();
		clear.className = 'clear';

		countDiv.appendChild(clear);

		//this.countTotal = count;
		//this.countPerc = perc;

		return countDiv;
	},
	makeClear: function() {
		var clear = document.createElement("div");
		clear.className = "clear";
		clear.style.float = "none";

		return clear;
	},
	makeSpacer: function() {
		var spacer = document.createElement("div");
		spacer.className = "spacer";

		return spacer;
	},
	updateList: function() {
		var self = this;
		$.each(this.children, function(k,v) {
			var insert = true;
			$.each(self.childContainer.children,function(ck,cv) {
				// @CLEANUP .data() runs bad in IE
				var item = $(cv).data("item");
				if(item && item.ext_name == v.ext_name) {
					insert = false;
					return false;
				}
			});

			if(insert) {
				self.childContainer.appendChild(v.buildUI(true));
			}
			
			self.onEmpty();
		});
		
		if(this.colsorter){
			this.colsorter.refreshSort();
		}
	},
	onEmpty: function(childClassId){
		childClassId = childClassId || ".criteria";
		$(this.childContainer)
			.removeClass("empty");
		if(!$(childClassId, this.childContainer).length){
			$(this.childContainer)
				.addClass("empty");
		}
	},
	unselectAllChildren: function() { // Unselects all children
		var caller = this;
		$.each(this.children,function(k,v) {
			$(v.container).removeClass("selected");
		});
	},
	/**
	 * Turns filterArray into the proper format for MControlFilters
	 * @method filterPath
	 */
	filterPath: function() {
		var array = this.pathArray.slice();
		array.shift();
		return array.join('|');
	},
	filterPathArray: function() {
		return this.pathArray.slice();
	},
	setupDataPath: function() {
		// Path for all things data/qs
		var dataPath = this.parent.dataPath.slice();

		if (!this.organizationalElement) {
			dataPath.push(this.int_name);
		}

		this.dataPath = dataPath;
	},
	getDataPath: function() {
		return this.dataPath.slice();
	},
	setupTreePath: function() {
		// Path for the tree view
		this.treePath = this.parent.treePath.concat(this.int_name);
	},
	getTreePath: function() {
		return this.treePath.slice();
	}
};

//MFilterableCollection
function MFilterableCollection(branch,parent) {
	this.children = {};
	this.countTotal = null;
	this.countPerc = null;

	this.init(branch,parent);
	this.values = branch.values;

	if (this.hasUnknowns) {
		this.values.push("Unknown");
	}

	this.filterDocs = branch.filterDocs || false;

	this.hasFilters = this.countFilters();
}

MFilterableCollection.prototype = new MFilterable;

MFilterableCollection.prototype.buildUI = function() {
	var control = this.getControl();

	var container = document.createElement("div");
	container.className = "filterable "+this.dtype;
	container.id = "filterable_"+this.int_name;

	container.appendChild(this.makeColorBy());

	if(this.acceptableTableRow && this.acceptableTableRow == 1){
		$(this.getDatasource().openSS).removeClass("hide");
		this.rowAdder = this.makeSpreadsheetRowAdder(this);
		container.appendChild(this.rowAdder);
	} else {
		container.className += " no-spreadsheet-row";
	}

	if (this.filterDocs) {
		if (control.options.filter_docs) {
			container.appendChild(control.createDocList(
				control.options.filter_docs)
			);
		}
	}
	
	if(control.options[this.int_name+"_docs"]) {
		var doclist = control.createDocList(control.options[this.int_name+"_docs"]);
		container.appendChild(doclist);
	}
	
	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	container.appendChild(this.makeChildren());

	this.container = container;
	this.parent.childContainer.appendChild(this.container);
};

MFilterableCollection.prototype.getShowStats = function() {
	return true;
};
//MFilterableItemCollection
function MFilterableItemCollection(branch,parent) {
	this.children = {};
	this.color = null;
	this.columnAdder;
	
	this.init(branch,parent);

	this.values = branch.values;
	
	this.setupColors();

	this.hasFilters = this.countFilters();
}
MFilterableItemCollection.prototype = new MFilterable;
$.extend(MFilterableItemCollection.prototype,{
	buildUI: function(childCount) {

		var control = this.getControl();
		var container = document.createElement("div");
		container.className = "filterable "+this.dtype;
		container.id = "filterable_"+this.int_name;
		container.int_name = this.int_name;

		container.appendChild(this.makeColorBy());

		var isChecked = this.getFilterValue();

		container.appendChild(this.makeColorSel());
		container.appendChild(this.makeCheckboxFilter(this.int_name,isChecked));

		var filterableDS = this.getDatasource();
		
		if(this.parent.acceptableTableCol == 1) {
			this.columnAdder = this.makeSpreadsheetColumnAdder(this);
			if(this.columnAdder != false) {
				container.appendChild(this.columnAdder);
			}
		}

		if(control.getManager().getDatasource(this.getDatasource().int_name).area_pan_to) {
			var panTo = new UIPanTo(this);
			container.appendChild(panTo.getUI());
		}

		if(this.getControl().options[this.int_name+"_docs"]) {
			container.appendChild(control.createDocList(control.options[this.int_name+"_docs"]));
		}

		container.appendChild(this.makeCounts('row'));
		container.appendChild(this.makeCounts('total'));

		container.appendChild(this.makeExpander());
		container.appendChild(this.makeClear());
		container.appendChild(this.makeChildren());
		
		this.container = container;
		this.parent.childContainer.appendChild(this.container);
	},
	getColumnAdder: function(){
		return this.columnAdder;
	},
	changeFilterState: function(id,state) {
		this.parent.ui && this.parent.ui.sortResetIfByCount &&
			this.parent.ui.sortResetIfByCount();

		this.parent.perculateChange();
	},
	clearSpecificFilter: function() {
		if(this.container){
			$.each($(".checkbox input",this.container),function(k,v) {
				v.checked = false;
			});
	
			$.each($(".label.selected",this.container),function(k,v) {
				$(v).removeClass("selected");
			});
		}

		this.parent.ui && this.parent.ui.sortResetIfByCount && this.parent.ui.sortResetIfByCount();
	},
	clearSpecificColor: function() {
		this.setupColors();

		var selectedColor = this.color;
		$.each($(".color-picker", this.container),function(k,v) {
			v.style.backgroundColor = "#"+selectedColor;
			$(v).data("selectedColor",selectedColor);
		});
	}
});

//MFilterableItem
function MFilterableItem(branch,parent) {
	this.countTotal = null;
	this.countPerc = null;
	this.init(branch,parent);
	this.setupColors();
	this.columnAdder;
}

MFilterableItem.prototype = MFilterable.prototype;

MFilterableItem.prototype.buildUI = function(returnContainer) {
	var doReturn = returnContainer || false;
	var container = this._cloneCriteriaDiv();
	container.int_name = this.int_name;

	container.appendChild(this.makeColorBy());

	var filter = this.getFilterValue();
	var isChecked = (filter && filter.value) ? true : false;
	
	if (this.parent.color_by && !this.noColor) {
		var colors = this.parent.getColors();
		if(colors && colors[this.int_name]){
			this.color = colors[this.int_name];
		}
		container.appendChild(this.makeColorSel());
	}

	var labelText = Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "));
	this.label = this.makeLabel(labelText, isChecked);

	if (this.parent.filter_by) {
		container.appendChild(this.makeCheckboxFilter(this.int_name, isChecked));
	}
	
	if (this.parent.acceptableTableCol == 1) {
		this.columnAdder = this.makeSpreadsheetColumnAdder(this);
		if (this.columnAdder != false) {
			container.appendChild(this.columnAdder);
		}
	}

	if (this.getControl().getManager().getDatasource(this.getDatasource().int_name).area_pan_to) {
		var panTo = new UIPanTo(this);
		container.appendChild(panTo.getUI());
	}

	container.appendChild(this.makeCounts('row'));
	container.appendChild(this.makeCounts('total'));

	container.appendChild(this.label);
	container.appendChild(this.makeClear());

	this.container = container;

	if (!doReturn) {
		this.parent.childContainer.appendChild(this.container);
	} else {
		return this.container;
	}
};

MFilterableItem.prototype.getColumnAdder = function(){
	return this.columnAdder;
};

MFilterableItem.prototype.attach = function(branch) {
	if(typeof branch[this.int_name] != "object")
		branch[this.int_name] = {};

	return branch[this.int_name];
};

MFilterableItem.prototype.changeFilterState = function(id,state) {
	this.parent.ui && this.parent.ui.sortResetIfByCount &&
		this.parent.ui.sortResetIfByCount();

	this.parent.perculateChange();
};

MFilterableItem.prototype.clearSpecificFilter = function() {
	if(this.container){
		$.each($(".checkbox input",this.container),function(k,v) {
			v.checked = false;
		});

		$.each($(".label.selected",this.container),function(k,v) {
			$(v).removeClass("selected");
		});
	}
	this.parent.ui && this.parent.ui.sortResetIfByCount && this.parent.ui.sortResetIfByCount();
};

MFilterableItem.prototype.getColor = function() {
	var colors = this.getColorsControl();
	var dsId = this.getDatasource().int_name;
	var path = this.getDataPath();
	var value = path.pop();

	return colors.getColorForValue(dsId, path.join('|'), value);
};

MFilterableItem.prototype.setColor = function(color) {
	var colors = this.getColorsControl();
	var dsId = this.getDatasource().int_name;
	var path = this.getDataPath();
	var value = path.pop();

	return colors.setColorForValue(dsId, path.join('|'), value, color);
};

MFilterableItem.prototype.clearSpecificColor = function() {
	this.setupColors();

	var selectedColor = this.color;

	$.each($(".color-picker",this.container),function(k,v) {
		v.style.backgroundColor = "#"+selectedColor;
		$(v).data("selectedColor",selectedColor);
	});
};

//MFilterableMapOptions
function MFilterableMapOptions(branch,parent) {
	this.children = {};
	this.init(branch, parent);
	this.options = branch.options || [];

	this.countScope = null;
	this.scopeTypes = null;
}
$.extend(MFilterableMapOptions.prototype,MFilterable.prototype,{
	buildUI: function() {
		var self = this;
		var control = this.getControl();
		var ce = control.ce;
		
		this.container = document.createElement("div");
		this.container.className = "no-color-by filterable " + this.dtype;
		this.container.id = "filterable_" + this.int_name;

		var docs = control.getOption('mapoptions_docs');
		if(docs) {
			this.container.appendChild(control.createDocList(docs));
		}
		
		var countModel = this.getControl().getManager().getControl('countsmodel');
		this.scopeTypes = countModel.getCountScopeTypes();
		this.countScope = countModel.getCountScope();
	
		var currentScopeSprite = this.countScope == "global" ? "sprite-countscope_global" : "sprite-countscope_viewport";
		$(this.container)
			.append(
				$(ce("div"))
					.addClass("countscope_status")
					.addClass(this.countScope)
					.addClass(currentScopeSprite)
					.attr({
						"title": Moonshadow.helpers.capitalize(this.countScope) + " Count Scope"
					})
			);
		
		this.container.appendChild(this.makeExpander());
		this.container.appendChild(this.makeClear());
		this.container.appendChild(this.makeChildren());
		
		var hasOptions = false;
		
		if(this.options){
			
			//count scope options
			if(this.options.count_scopes && this.options.count_scopes.length > 1){
				hasOptions = true;
				$(this.childContainer)
					.append(
						$(ce("div"))
							.addClass("header")
							.append("Count Scope"),
						function(){
							var countscopeDocs = control.getOption('countscope_docs');
							if(countscopeDocs) {
								return control.createDocList(docs);
							}
							return "";
						}(),
						$(this.options.count_scopes).map(function(index, item){
							return $(ce("label"))
								.addClass("count_scope_option")
								.append(
									$(ce("input"))
										.attr({
											"type": "radio",
											"checked": (self.countScope == item.type),
											"name": "count_scope",
											"value": item.type
										})
										.click({"self": self}, function(e){
											e.data.self.changeCountScope(this.value);
										}),
									" ",
									Moonshadow.helpers.capitalize(item.type)
								)
								.get(0)
						})
					);
			}
			
		}
		if(hasOptions){
			this.parent.childContainer.appendChild(this.container);
		}
	},
	hasExpander: function() {
		return true;
	},
	changeCountScope: function(scope) {
		this.getControl().getManager().mapObservers.notify(
			'changecountscope', {'scope': scope});
		var scopeElem = $(".countscope_status", this.container);
		scopeElem
			.removeAttr("class")
			.addClass("countscope_status")
			.addClass(scope);
		scopeElem.removeClass("sprite-countscope_global sprite-countscope_viewport");
		if(scope === "global") {
			scopeElem.addClass("sprite-countscope_global");
		} else if(scope === "viewport"){
			scopeElem.addClass("sprite-countscope_viewport");	
		}
	},
	toggle: function() {
		if(this.childContainer.style.display !== 'block') {
			$(this.expander).addClass('expanded');
			this.childContainer.style.display = 'block';		
		} else {
			$(this.expander).removeClass('expanded');
			this.childContainer.style.display = 'none';
		}
	}	
});

//MFilterableUniverses
function MFilterableUniverses(branch,parent) {
	this.children = {};
	this.init(branch,parent);
	this.values = branch.values || [];
	this.reportListener();
	this.orderOfMarkedUniverses = {};
	this.selectedCreationMethod = null;
	this.defaultCreationMethod = null;
	this.cdn = null;
	this.estimatesCont = null;
	this.viewOnly = false;
	this.childrenHaveUi = false;
	this.registeredEstimateUpdaters = [];
	this.newUniverseColor = "0022ff";
	this.filterByNewUniverse = true;
	this.folders = {};
	this.foldersColSorter = null;
	this.lastChecked = {};
	this.nextOrder;
}
MFilterableUniverses.prototype = new MFilterable;
$.extend(MFilterableUniverses.prototype,{
	buildUI: function() {
		
		var ce = Moonshadow.helpers.ce;
		var self = this;
		var parent = this.parent;
		var parentControl = this.getParentControl();
		var manager = this.getManager();
		
		var univers_docs = parentControl.getOption("universe_docs");
		this.filterByNewUniverse = manager.getOption("user_settings.filter_by_new_universe", true);
		var dsControl = this.getManagerControl('datasources');
		
		//@TODO this only works with DS in position 1
		var ds = dsControl.getByIndex(0);
		var dsId = ds.id;
		this.viewOnly = ds.viewOnly;

		if (!dsControl.hasReqAddons(dsId)) {
			this.viewOnly = true;
		}

		this.cdn = manager.getOption("cdn");
		
		var filterOpsObject = {
			"univFilter": "Create universe from currently selected filters",
			"univCombine": "Create universe by combining two or more universes",
			"univIntersect": "Create universe by intersecting two or more universes",
			"univDiff": "Create universe by subtracting two or more universes",
			"univExpand": "Create a universe with all voters in each household",
			"univReduce": "Create a universe with only one voter per household" 
		};

		this.createWait = document.createElement("div");
		$(this.createWait)
			.addClass("refreshing generating_wait hide");
		
		var colorByIcon = this.getColorIcon(this);
		
		this.container = $(ce("div"))
			.addClass("filterable")
			.addClass(this.dtype)
			.attr({
				"id": "filterable_" + this.int_name
			})
			.append(
				this.makeColorBy(),
				univers_docs ? parentControl.createDocList(univers_docs) : "",
				parent.makeSectionClearerInst.call(this, this.onClearFilters),
				this.makeExpander(),
				this.makeClear(),
				$(ce("div"))
					.addClass("universe_expandable hide")
					.append(
						!this.viewOnly ? $(ce("div"))
							.addClass("universe_body")
							.append(
								$(ce("div"))
									.addClass("universe_tool_container")
									.append(
										$(ce("div"))
											.addClass("universe_tool sprite-tools clickable")
											.on("click", function(){
												self.displayUniverseTools();
											})
									),
								$(ce("div"))
									.addClass("filter_op_container")
									.append(
										$.map(filterOpsObject, function(item, i){
											var opElem = $(ce("div"))
												.addClass("createUniv clickable")
												.addClass(i)
												.addClass("sprite-" + i)
												.attr({
													"title": item,
													"id": i
												})
												.click({"self": self}, function(e){
													e.data.self.changeMethod(this);
												});
											
											if(i == "univFilter"){
												self.defaultCreationMethod = opElem;
											}
											return opElem.get(0);
										})
									),
								function(){
									self.createHeader = self.addSubHeader(
										$(self.defaultCreationMethod).attr("title"),
										function(){
											$(".universe_text_fields_holder")
												.toggleClass("hide");
										}
									)
									return self.createHeader;
								}(),
								$(ce("div"))
									.addClass("universe_text_fields_holder")
									.append(
										$(ce("div"))
											.addClass("ms_text_field_container")
											.append(
												$(ce("span"))
													.addClass("ms_text_field_small_label")
													.append(
														$(ce("span"))
															.addClass("red")
															.append("*"),
														" Universe Name:"
													),
												$(ce("div"))
													.addClass("ms_text_field_flex_container_outer")
													.append(
														$(ce("div"))
															.addClass("ms_text_field_flex_container_inner")
															.append(
																function(){
																	self.inputName = $(ce("input"))
																		.addClass("ms_text_field_input create_namefield")
																		.attr({
																			"type": "text",
																			"autocomplete": false,
																			"tabindex": 1
																		})
																		.on("change", function(){
																			var val = Moonshadow.helpers.sanitizeString($(this).val());
																			val && $(this).val(val);
																		});
																	
																	return self.inputName.get(0);		
																}()
															)
													)
											),
										$(ce("div"))
											.addClass("ms_text_field_container")
											.append(
												$(ce("span"))
													.addClass("ms_text_field_small_label")
													.append("Universe Description:"),
												$(ce("div"))
													.addClass("ms_text_field_flex_container_outer")
													.append(
														$(ce("div"))
															.addClass("ms_text_field_flex_container_inner")
															.append(
																function(){
																	self.inputDesc = $(ce("input"))
																		.addClass("ms_text_field_input create_descfield")
																		.attr({
																			"type": "text",
																			"autocomplete": false,
																			"tabindex": 2
																		})
																		.on("change", function(){
																			var val = Moonshadow.helpers.sanitizeString($(this).val());
																			val && $(this).val(val);
																		});
																	
																	return self.inputDesc.get(0);		
																}()
															)
													)
											),
										$(ce("div"))
											.addClass("ms_text_field_container new_universe_folder_cont hide")
											.append(
												$(ce("span"))
													.addClass("ms_text_field_small_label")
													.append("New Folder Name:"),
												$(ce("div"))
													.addClass("ms_text_field_flex_container_outer")
													.append(
														$(ce("div"))
															.addClass("ms_text_field_flex_container_inner")
															.append(
																$(ce("input"))
																	.addClass("ms_text_field_input new_universe_folder")
																	.attr({
																		"type": "text",
																		"autocomplete": false,
																		"tabindex": 2
																	})
															)
													)
											),
										$(ce("div"))
											.addClass("ms_text_field_container folder_selection_cont")
											.append(
												$(ce("span"))
													.addClass("ms_text_field_small_label")
													.append("Folder:"),
												$(ce("div"))
													.addClass("ms_text_field_flex_container_outer")
													.append(
														$(ce("div"))
															.addClass("ms_text_field_flex_container_inner")
															.append(
																$(ce("select"))
																	.addClass("ms_text_field_select folder_selection select_folder")
																	.attr({
																		"tabindex": 3
																	})
															)
													)
											),
										$(ce("div"))
											.addClass("create_button_container")
											.append(
												this.createWait,
												function(){
													self.createButton = $(ce("input"))
														.addClass("create_universe_button")
														.attr({
															"type": "button",
															"disabled": true,
															"title": "Please provide a name for the universe",
															"Value": "Create Universe"
														});
													return self.createButton;
												}()
											),
										this.addSubHeader("Universe Creation Options", function(){
											$(".createbuttonholder", this.container)
												.toggleClass("hide");
										}),
										$(ce("div"))
											.addClass("createbuttonholder")
											.append(
												$(ce("div"))
													.addClass("create_option")
													.append(
														$(ce("div"))
															.addClass("create_universe_with_color")
															.append(
																colorByIcon
															),
														$(ce("label"))
															.append("Universe color")
													),
												$(ce("div"))
													.addClass("create_option")
													.append(
														$(ce("input"))
															.addClass("filter_by_new_universe")
															.attr({
																"id": "filter_by_new_universe",
																"type": "checkbox",
																"checked": this.filterByNewUniverse
															})
															.on("click", {"self": this}, function(e){
																e.data.self.toggleFilterByNewUniverse(this);
															}),
														$(ce("label"))
															.append("Select new universe after creation:")
															.attr({
																"for": "filter_by_new_universe"
															})
													),
												this.showPhoneOnlyOption() ? $(ce("div"))
													.addClass("create_option")
													.append(
														$(ce("input"))
															.addClass("only_records_having_landline")
															.attr({
																"id": "only_records_having_landline",
																"type": "checkbox"
															}),
														$(ce("label"))
															.append("Only records having land line phones:")
															.attr({
																"for": "only_records_having_landline"
															})
													) : "",
												this.samplingInterface()
											)
									)
								) : "",
						this.makeChildren()
					)
			);

		$(this.parent.childContainer)
			.append(this.container);

		if(!this.viewOnly){
			//Ad Sales popup panel
			if(manager.shouldControlBeLoaded("MControlAdSales")){
				var adSalesPanel = document.createElement("div");
				adSalesPanel.className = "adsales_element_holder";
				$(this.container).before(adSalesPanel);
				var adSalesPanelControl = this.getManagerControl("adsales");
				if(adSalesPanelControl){
					adSalesPanelControl.contactVotersPopup();
				}
			}
			//end Ad Sales popup panel
			
			this.reSelectMethod();
			$(this.inputName).change({"control": this},function(e){
				e.data.control.checkCreateStatus();
			}).keyup({"control": this},function(e){
				e.data.control.checkCreateStatus();
			});
			
			$(".new_universe_folder", this.container)
				.on("change", function(e){
					var val = Moonshadow.helpers.sanitizeString($(this).val()).trim();
					val && $(this).val(val);
					self.checkCreateStatus();
				})
				.on("keyup", function(e){
					var val = $(this).val().replace(/[\/#!$\^&\*;{}=\`~]/g,"");
					$(this).val(val);
					self.checkCreateStatus();
				});
			
			$(this.createButton).click({"self":this}, function(e) {
				e.data.self.createUniverse();
			});
		}

		this.makeUniverseFolder("__default");
		this.ui.defaultHeader = this.addSubHeader("Your Universes", function(){
			$("#___default", self.container)
				.toggleClass("hide");
		});
		this.getUniverses(function(){
			self.buildUniversePanelContent();
		});
		
		manager.addMapObserver("universesuiloaded", function(){
			self.hasFilters = self.countFilters();
			self.parent.hasFilters += self.hasFilters;
			if(self.hasFilters > 0) {
				self.checkFilterCount();
				self.perculateChange();
			}
		}, this);

		manager.addMapObserver(["puchasesverified", "universerecovered"], function(){
			self.refreshListFromServer(function(){
				self.decartStuck();
			});
		}, this);

		manager.addMapObserver("filterupdated", this.filterUpdated, this);
	},
	showPhoneOnlyOption: function(){
		if(!this.getManager().hasAddon("phonecampaigns")){
			return false;
		}
		var ds = this.getManagerControl("datasources");
		if(!ds.getFieldDetails("VoterTelephones_TelCellFlag")){
			return false;
		}
		return true;
	},
	getPhoneOnlyFilters: function(){		
		return MControlPhoneCampaigns.getPhoneOnlyFilters();
	},
	getManager: function(){
		return this.getParentControl().getManager();
	},
	getManagerControl: function(name){
		return this.getManager().getControl(name);
	},
	getParentControl: function(getUniverse) {
		return this.parent.getControl();
	},
	getSurveyControl: function(){
		return this.getManagerControl('surveys');
	},
	getFirstDatasource: function(){
		return this.getManagerControl("datasources").getByIndex(0);
	},
	purchasingEnabled: function(){
		if(this.checkPrePurchased()){
			return false;
		}
		return this.getParentControl().purchasingEnabled();
	},
	hasExpander: function() {
		return true;
	},
	getColor: function() {
		return this.newUniverseColor;
	},
	setColor: function(color) {
		this.newUniverseColor = color;
	},
	lockUnlockCreation: function(onOff){
		this.toggleCreateButton(!onOff);
		$(this.createWait)
			.addClass(!onOff && "hide")
			.removeClass(onOff && "hide");
		this.checkCreateStatus();
	},
	displayUniverseTools: function(){
		this.universeToolsPanel = new MUILayoverPanel({
			"id": "universe_tools_panel",
			"content": this.universeToolTabsContent(),
			"title": "Universe Tools",
			"animate": true,
			"fixed": false,
			"resizeAlso": ".universe_tools_content_conatiner",
			"position": {
				"height": 500,
				"width": 900
			},
			"openNow": true
		});
	},
	universeToolTabsContent: function(){
		var ce = Moonshadow.helpers.ce;
		var self = this;
		
		//@TODO this only works with DS in position 1
		var dsId = this.getFirstDatasource().id;
		var zombies = new MControlZombieUniverses(this.getManager(), dsId);
		
		var universeToolsTabs = [{
			"title": "Select Universes",
			"id": "select_universes",
			"active": true,
			"content": this.selectUniversesToolContent(true)
		},{
			"title": "Recover Universes",
			"id": "recover_universes",
			"active": false,
			"content": zombies.buildUi(false),
			"init": function(){
				zombies.init(self.universeToolsPanel);
			}
		}];
		
		var contentContainer = $(ce("div"))
			.addClass("universe_tools_content_conatiner")
			.append(
				$.map(universeToolsTabs, function(v){
					return $(v.content).get(0);
				})
			);
		
		var tabElement = function(title, selected, callback){
			return $(ce("div"))
				.addClass("universe_tools_tab")
				.addClass(selected ? "tool_selected" : "clickable")
				.append(title)
				.on("click", function(){
					if($(this).hasClass("tool_selected")){
						return;
					}
					$(".tool_selected", tabCollection)
						.removeClass("tool_selected")
						.addClass("clickable");
					
					$(".universe_tools_content", contentContainer)
						.addClass("hide");
					
					$(this)
						.addClass("tool_selected")
						.removeClass("clickable");
					
					callback();
				})
				.get(0);
		};
		
		var tabCollection = $(ce("div"))
			.addClass("universe_tools_tabs_collection")
			.append(
				$.map(universeToolsTabs, function(v){
					return tabElement(
						v.title, v.active, function(){
							$(v.content).removeClass("hide");
							if(v.init){
								v.init(v);
							}
						}
					);
				})
			);
		
		return $(ce("div"))
			.append(
				tabCollection,
				contentContainer
			);
	},
	selectUniversesToolContent: function(active){
		var ce = Moonshadow.helpers.ce;
		var self = this;
		
		var runVerify = function(){
			var valid = verifyOpts();
			var count = self.countChecked();
			$(".universe_verify_valid", manipulatePanel)
				.attr({
					"disabled": !valid
				});
			$(".universe_notnull", manipulatePanel)
				.attr({
					"disabled": count === 0
				});
		}

		var clearForm = function(){
			$("input", contentForm).each(function(index, input){
				if($(input).attr("type") == "text"){
					input.value = "";
					return true;
				}
				if($(input).attr("type") == "number"){
					input.value = "";
					return true;
				}
				if($(input).attr("type") == "checkbox"){
					$(input).attr({
						"checked": false
					});
					return true;
				}
			});
			runVerify();
		};
		
		var datePicker = function(title, onSelect){
			return MUIFormElements.elem({
				"type": "dateField",
				"title": title,
				"className": "universe_tools_date_picker",
				"addClear": true,
				"events": {
					"onClear": function(){
						runVerify();
					},
					"change": onSelect
				} 
			});
		}

		var pickerFrom = datePicker("Starting on", function(){
			var toDate = $("input", pickerTo).val();
			if(!toDate){
				$("input", pickerTo).val(this.value);
			}
			runVerify();
		});
		
		var pickerTo = datePicker("Ending on", function(){
			var fromDate = $("input", pickerFrom).val();
			if(!fromDate){
				$("input", pickerFrom).val(this.value);
			}
			runVerify();
		});
		
		var pickerPFrom = datePicker("Starting on", function(){
			var pToDate = $("input", pickerPTo).val();
			if(!pToDate){
				$("input", pickerPTo).val(this.value);
			}
			runVerify();
		});
		
		var pickerPTo = datePicker("Ending on", function(){
			var pFromDate = $("input", pickerPFrom).val();
			if(!pFromDate){
				$("input", pickerPFrom).val(this.value);
			}
			runVerify();
		});
		
		var numberPicker = function(title, onChange){
			var rf = function(){
				runVerify();
			};
			
			return MUIFormElements.elem({
				"type": "numberField",
				"title": title,
				"className": "universe_tools_number_records_input",
				"addClear": true,
				"events": {
					"change": onChange,
					"mouseup keyup onClear": rf
				} 
			});
		};
		
		var minNumber = numberPicker("Minumum", function(){
			if(this.value < 1){
				this.value = null;
			}
		});
		
		var maxNumber = numberPicker("Maximum", function(){
			if(this.value < 1){
				this.value = null;
			}
		});
		
		var nameContains = MUIFormElements.elem({
			"type": "textField",
			"title": "Name Contains",
			"className": "universe_tools_name_contains_input",
			"addClear": true,
			"events": {
				"mouseup keyup onClear": runVerify
			}
		});

		var descriptionContains = MUIFormElements.elem({
			"type": "textField",
			"title": "Description Contains",
			"className": "universe_tools_description_contains_input",
			"addClear": true,
			"events": {
				"mouseup keyup onClear": runVerify
			}
		});

		var statusPanel = $(ce("div"))
			.addClass("universe_tools_status_panel");
		
		var numCurrent = $(ce("span"))
			.addClass("red")
			.append(this.countChecked());
		
		var updateNumCurrent = function(){
			$(numCurrent)
				.empty()
				.append(self.countChecked());
		};
		
		var fadeTimeout;
		var updateStatus = function(status){
			updateNumCurrent();
			clearTimeout(fadeTimeout);
			
			$(statusPanel)
				.empty()
				.append(status);
			
			fadeTimeout = setTimeout(function(){
				$(statusPanel)
					.animate({
						"opacity": 0
					},{
						"duration": 500,
						"complete": function(){
							$(statusPanel)
								.removeAttr("style")
								.empty();
						}
					});
				
			}, 3000);
		};
		
		var checkBoxWithLabel = function(title, name, value){
			var id = "_" + title.replace(/\W|\d/g, "");
			return  $(ce("div"))
				.addClass("universe_tools_checkbox_container")
				.append(
					$(ce("input"))
						.addClass("universe_tools_checkbox")
						.attr({
							"id": id,
							"type": "checkbox",
							"value": value,
							"name": name
						})
						.on("change", runVerify)
						.on("focus", function(){
							this.blur();
						}),
					$(ce("label"))
						.addClass("universe_tools_checkbox_label")
						.attr({
							"for": id
						})
						.append(title)
				);
		}
		
		var purchaseStatusPanel = $(ce("div"))
			.addClass("universe_tools_content_indent")
			.append(
				checkBoxWithLabel("Unpurchased", "purchaseStatus", 0),
				checkBoxWithLabel("Partially purchased", "purchaseStatus", 1),
				checkBoxWithLabel("Fully purchased", "purchaseStatus", 2)
			);
		
		var gatherOpts = function(){
			var nameCont = $("input", nameContains).val() || null;
			var descCont = $("input", descriptionContains).val() || null;
			var fromDate = $("input", pickerFrom).val() || null;
			var toDate = $("input", pickerTo).val() || null;
			var pFromDate = $("input", pickerPFrom).val() || null;
			var pToDate = $("input", pickerPTo).val() || null;
			if(fromDate || toDate){
				if(!fromDate){
					fromDate = Moonshadow.helpers.hrDate(new Date(), true);
				}
				if(!toDate){
					toDate = Moonshadow.helpers.hrDate(new Date(), true);
				}
			}
			if(pFromDate || pToDate){
				if(!pFromDate){
					pFromDate = Moonshadow.helpers.hrDate(new Date(), true);
				}
				if(!pToDate){
					pToDate = Moonshadow.helpers.hrDate(new Date(), true);
				}
			}
			var min = parseInt($("input", minNumber).val(), 10) || null;
			var max = parseInt($("input", maxNumber).val(), 10) || null;
			
			var ps = null;
			$("input", purchaseStatusPanel).each(function(index, box){
				if(box.checked){
					if(!ps){
						ps = [];
					}
					ps.push(parseInt(box.value, 10));
				}
			})
			
			return {
				"nameContains": nameCont,
				"descriptionContains": descCont,
				"fromDate": fromDate, 
				"toDate": toDate, 
				"pFromDate": pFromDate,
				"pToDate": pToDate,
				"min": min, 
				"max": max,
				"purchaseStatus": ps
			};
		};
		
		var verifyOpts = function(){
			var opts = gatherOpts();
			var valid = false;
			for(var i in opts){
				if(!opts.hasOwnProperty(i)){
					continue;
				}
				if(opts[i] != undefined){
					valid = true;
					break;
				}
			}
			return valid;
		};
		
		var sendOpts = function(onOff, selectAll){
			var opts = {};
			if(!selectAll){
				if(!verifyOpts()){
					return;
				}
				opts = gatherOpts();
			}
			var resultCount = self.selectUniverseFromCriteria(opts, onOff);
			updateStatus(
				resultCount + 
				" universes " + 
				(onOff ? "selected" : "deselected") +
				" (" + self.countChecked() + " total selections)"
				
			);
			runVerify();
		};

		var makeButton = function(title, className, callback){
			return $(ce("input"))
				.addClass("universe_tools_button")
				.addClass(className)
				.attr({
					"type": "button",
					"value": title
				})
				.on("click", runVerify)
				.on("click", callback)
				.on("focus", function(){
					this.blur();
				})
		};
		
		var cartControl = this.getManagerControl("cartcontrol");
		var manipulatePanel = $(ce("div"))
			.addClass("universe_manipulate_button_panel")
			.append(
				makeButton("Select All", null, function(){
					sendOpts(true, true);
				}),
				makeButton("Clear Selection", null, function(){
					sendOpts(false, true);
				}),
				ce("br"),
				makeButton(
					"Select From Criteria", 
					"universe_verify_valid", function(){
					sendOpts(true);
				}),
				makeButton(
					"Deselect From Criteria", 
					"universe_verify_valid", function(){
					sendOpts(false);
				}),
				makeButton(
					"Clear Criteria Form", 
					"universe_verify_valid", 
					clearForm
				),
				ce("br"),
				makeButton(
					"Move Selected Universes", 
					"universe_notnull", 
					function(){
						self.moveMarkedUniversesToFolderPrompt();
					}
				),
				makeButton(
					"Delete Selected Universes", 
					"universe_notnull", 
					function(){
						self.bulkDeleteMartkedUniversePrompt();
					}
				),
				makeButton(
					"Add Selected To Cart", 
					"universe_notnull", 
					function(){
						self.bulkAddMarkedToCart(function(cartCount){
							updateStatus(
								cartCount + " universes added to cart " + 
								" (" + cartControl.getNumCartItems() + " total items in cart)"
							);
						});
					}
				),
				makeButton(
					"Remove Selected From Cart", 
					"universe_notnull", 
					function(){
						self.bulkRemoveMarkedFromCart(function(cartCount){
							updateStatus(
								cartCount + " universes removed from cart " + 
								" (" + cartControl.getNumCartItems() + " total items in cart)"
							);
						});
					}
				)
			);
		var contentForm = $(ce("div"))
			.addClass("universe_tools_content_form")
			.append(
				$(ce("div"))
					.addClass("universe_tools_content_subheader")
					.append("Name and Description:"),
				$(ce("div"))
					.addClass("universe_tools_content_indent")
					.append(
						nameContains,
						descriptionContains
					),
				$(ce("div"))
					.addClass("universe_tools_content_subheader")
					.append("Date Created:"),
				$(ce("div"))
					.addClass("universe_tools_content_indent")
					.append(
						pickerFrom,
						pickerTo
					),
				$(ce("div"))
					.addClass("universe_tools_content_subheader")
					.append("Date Purchased:"),
				$(ce("div"))
					.addClass("universe_tools_content_indent")
					.append(
						pickerPFrom,
						pickerPTo
					),
				$(ce("div"))
					.addClass("universe_tools_content_subheader")
					.append("Number of records:"),
				$(ce("div"))
					.addClass("universe_tools_content_indent")
					.append(
						minNumber,
						maxNumber
					),
				$(ce("div"))
					.addClass("universe_tools_content_subheader")
					.append("Purchase Status:"),
				purchaseStatusPanel
			);
		
		runVerify();
		
		return $(ce("div"))
			.addClass("universe_tools_content")
			.addClass(!active ? "hide" : null)
			.append(
				manipulatePanel,
				$(ce("div"))
					.addClass("universe_tools_content_select scrollable")
					.append(
						$(ce("div"))
							.addClass("universe_tools_content_header readout_bigger")
							.append(
								"Currently Selected: ",
								numCurrent
							),
						$(ce("div"))
							.addClass("universe_tools_content_header")
							.append("Select universes based on the following criteria:"),
						contentForm
					),
					statusPanel
			);
	},
	checkPrePurchased: function(){
		return this.getManagerControl("universecontrol").checkPrePurchased();
	},
	selectUniverseFromCriteria: function(settings, selectDeselect){
		
		var funcs = {
			"nameContains": function(universe){
				return universe.ext_name.toLowerCase().search(settings.nameContains.toLowerCase()) > -1;
			},
			"descriptionContains": function(universe){
				return universe.description.toLowerCase().search(settings.descriptionContains.toLowerCase()) > -1;
			},
			"fromDate": function(universe){
				return universe.getCreatedDate() >= new Date(settings.fromDate);
			},
			"toDate": function(universe){
				return universe.getCreatedDate() <= new Date(settings.toDate);
			},
			"pFromDate": function(universe){
				return universe.getPurchasedDate() >= new Date(settings.pFromDate);
			},
			"pToDate": function(universe){
				return universe.getPurchasedDate() <= new Date(settings.pToDate);
			},
			"min": function(universe){
				return universe.cardinality >= settings.min;
			}, 
			"max": function(universe){
				return universe.cardinality <= settings.max;
			},
			"purchaseStatus": function(universe){
				return $.inArray(
					universe.getPurchasedStatus(), 
					settings.purchaseStatus
				) > -1;
			}
		};
		
		var selections = $.map(this.children, function(universe, id){
			var selected = true;
			for(var i in settings){
				if(!settings.hasOwnProperty(i) || settings[i] == undefined){
					continue;
				}
				if(!funcs[i](universe)){
					selected = false;
					break;
				}
			}
			if(selected){
				return universe;
			}
		});
		
		return this.markUniverses(selectDeselect, selections);
	},
	bulkAddMarkedToCart: function(callback){
		var self = this;
		var cartPanel = this.getManagerControl("cartpanel");
		var dsIds = {}
		var cartCount = 0;
		$(this.getMarkedUniverses()).each(function(index, universe){
			var ds = universe.addToCart(true);
			if(ds){
				dsIds[ds] = true;
				++cartCount
			}
		});
		cartPanel.runPurchaseStateAlterationQueue(function(){
			self.runBulkNotify(dsIds);
			callback(cartCount);
		});
	},
	bulkRemoveMarkedFromCart: function(callback){
		var self = this;
		var cartPanel = this.getManagerControl("cartpanel");
		var dsIds = {}
		var cartCount = 0;
		$(this.getMarkedUniverses()).each(function(index, universe){
			var ds = universe.removeFromCart(true);
			if(ds){
				dsIds[ds] = true;
				++cartCount
			}
		});
		cartPanel.runPurchaseStateAlterationQueue(function(){
			self.runBulkNotify(dsIds);
			callback(cartCount);
		});
	},
	getUniverseIds: function(){
		var ids = [];
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i)){
				continue;
			}
			ids.push(i);
		}
		return ids;
	},
	fetchAllCounts: function(callback){
		this.fetchCounts(this.getUniverseIds(), callback);
	},
	fetchCounts: function(ids, callback){
		if(!ids || !ids.length){
			callback && callback();
			return;
		}

		//@TODO this only works with DS in position 1
		var dsId = this.getFirstDatasource().id;
		var universeControl = this.getManagerControl("universecontrol");
		
		universeControl.fetchUniverses(dsId, ids, this.assignCounts);
		callback && callback();
	},
	assignCounts: function(universes){
		for(var i = 0, l = universes.length; i < l; ++i){
			var universe = this.children[universes[i].int_name];
			if(universe){
				universe.counts = universes[i].counts;
				universe.makeCountsObj();
				universe.countsFetched = true;
			}
		}
	},
	repollUniverses: function(callback){
		var manager = this.getManager();
		var universeControl = this.getManagerControl("universecontrol");
		
		//@TODO this only works with DS in position 1
		var dsId = this.getFirstDatasource().id;
		var ajax = new Moonshadow.Ajax();
		universeControl.repollUniverses(dsId, ajax);
		ajax.execute(function(){
			manager.mapObservers.notify("universesrepolled");
			callback && callback();
		});
	},
	refreshListFromServer: function(callback){
		var self = this;
		this.repollUniverses(function(){
			self.getUniverses(callback);
		});
	},
	decartStuck: function(){
		var stuck = this.getChildrenByAttribute("purchase_state", 20);
		if(!stuck || !Moonshadow.helpers.objCount(stuck)){
			return false;
		}
		var self = this;
		var cartPanel = this.getManagerControl("cartpanel");
		var dsIds = {}
		for(var i in stuck){
			if(!stuck.hasOwnProperty(i)){
				continue;
			}
			var ds = stuck[i].removeFromCart(true);
			if(ds){
				dsIds[ds] = true;
			}
		}
		cartPanel.runPurchaseStateAlterationQueue(function(){
			self.runBulkNotify(dsIds);
		});
	},
	toggleFilterByNewUniverse: function(checkbox){
		this.filterByNewUniverse = !!checkbox.checked;
		var userSettings = this.getManagerControl("usersettings");
		userSettings.setUserSetting("filter_by_new_universe", this.filterByNewUniverse);
	},
	filterUpdated: function(){
		this.refreshColorBy();
		this.adjustAllBulkActionTools();
		this.checkCreateStatus();
	},
	refreshColorBy: function(){
		var colorByControl = this.getManagerControl("colorbycontrol");
		var activeColorBy = colorByControl.getActiveColorBy();
		if(activeColorBy && activeColorBy.color == "__universes"){
			this.getManager().notify('colorbychange');
		}
	},
	adjustAllBulkActionTools: function(){
		var self = this;
		$.each(this.folders, function(path){
			self.updateFilterCounts(path);
			self.adjustBulkActionTools(path);
		});
	},
	getColors: function(){
		var colors = {};
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i))
				continue;
			colors[i] = {
				"values": this.children[i].color
			};
		}
		return colors;
	},
	updateList: function() {
		var self = this;
		var names = [];
		var childs = {};
		this.clearAllRegisteredUpdaters();
		
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				var unid = this.children[i].ext_name.toLowerCase() + i;
				names.push(unid);
				childs[unid] = this.children[i];
			}
		}

		$.each(names.sort(), function(k,v) {
			self.fillUniverseFolder(childs[v]);
		});
		
		$(this.childContainer).empty();
		this.placeUniverseFolders();
	},
	placeUniverseFolders: function(){
		var self = this;
		
		this.foldersColSorter = this.makeColumnSorterInst(
			this.getFolderSortCols(),
			"sortfolders", 
			this.childContainer,
			this.childContainer,
			null, "> .universe_folder.expandable"
		);
		this.foldersColSorter.makeColumnSorter();
		
		this.universeFoldersHeader = this.addSubHeader("Universe Folders", function(){
			self.foldersColSorter.toggleHideColSorter();
			$(".universe_folder.expandable", self.childContainer)
				.toggleClass("hide");
		});
		
		$(this.childContainer).append(
			this.universeFoldersHeader,
			this.foldersColSorter.ui
		);
		
		this.showHideFoldersHeader();

		$.each(this.folders, function(path, folder) {
			if(path != "__default"){
				$(self.childContainer).append(folder.cont);
			}
		});
		
		$(this.childContainer).append(
			this.ui.defaultHeader
		);
		
		$(this.childContainer).append(
			this.getFolderContainerAtPath()
		);
		
		this.emptyListMessage("__default");
		this.showHideFoldersHeader();
		this.foldersColSorter.refreshSort();
	},
	placeUniverseFolder: function(universe){
		var univFolder = this.fillUniverseFolder(universe);
		if(!$.contains(document.body, $(univFolder).get(0))){
			if(this.foldersColSorter){
				$(this.foldersColSorter.ui).after(univFolder);
			}else{
				$(this.childContainer).append(univFolder);
			}
		}
		this.showHideFoldersHeader();
	},
	addSubHeader: function(text, expanderCallback){
		var ce = Moonshadow.helpers.ce;
		var head = $(ce("div"))
			.addClass("header")
			.attr({
				"title": text
			})
			.append(
				function(){
					if(expanderCallback){
						return $(ce("div"))
							.addClass("sprite-expander_down folder_header_expander")
					}
					return "";
				}(),
				$(ce("span"))
					.addClass("header_text")
					.append(text)
			);
		if(expanderCallback){
			$(head)
				.addClass("clickable header_exandable header_expanded")
				.on("click", function(){
					$(head)
						.toggleClass("header_expanded header_collapsed")
						.find(".folder_header_expander")
						.toggleClass("sprite-expander_down sprite-expander_right")
					expanderCallback();
				});
		}
		return head;
	},
	fillUniverseFolder: function(universe){
		var path = universe.getPath();
		this.makeUniverseFolder(path);
		var folderContent = this.getFolderContentAtPath(path);
		$(folderContent).append(universe.buildUI(true, folderContent));
		this.adjustFolderCount(path, universe.cardinality);
		if(universe.isChecked()){
			this.updateFilterCounts(path, universe.isChecked() ? 1 : -1);
		}
		return this.getFolderContainerAtPath(path);
	},
	makeFolderColorPicker: function(path){
		var self = this;
		var colorPicker = this.getManagerControl('colorpicker');
		var pickerColor = this.newUniverseColor;
		var changeAllColor;
		var colorPicker = colorPicker.getColorIcon({
			"getColor": function() {
				return pickerColor;
			},
			"setColor": function(color) {
				changeAllColor = color;
			},
			"isDisabled": function(){
				var cp = self.getFolderColorPickerAtPath(path);
				return $(cp).hasClass("sprite-disabled13");
			},
			"pickerTitle": "Change Color Of Selected Universes"
		}, null, function(icon){
			MUILayoverPanel.confirm({
				"message": "Change the color for all selected universes " + 
					(path == "__default" ? "below" : "in this folder") + "?",
				"callback": function(res, id, hide){
					if(res){
						pickerColor = changeAllColor || pickerColor;
						self.changeColorAtPath(path, pickerColor);
					}
					hide();
				}
			});
		});
		return colorPicker;
	},
	makeUniverseFolder: function(path){
		if(!this.folders[path]){
			var self = this;
			var ce = Moonshadow.helpers.ce;
			var colorPicker = this.makeFolderColorPicker(path);
			
			var bulkActionButton = function(title, className, hasDisable, onClick){
				var button = $(ce("div"))
					.addClass("bulk_tool_button")
					.addClass(className)
					.attr({
						"title": title
					})
					.on("click", function(){
						if($("div", this).hasClass("sprite-disabled15")){
							return;
						}
						onClick();
					});
				if(hasDisable){
					$(button)
						.append(
							$(ce("div"))
								.addClass("sprite-disabled15")
						);
				}
				return button;
			};
			
			var folderContent = $(ce("div"))
				.addClass("universe_folder_content")
				.get(0);
			
			var bulkActionsPanel = $(ce("div"))
				.addClass("universe_bulk_actions")
				.append(
					bulkActionButton(
						"Delete Selected Universes",
						"sprite-trash trash_icon bulktool_right",
						true, function(){
							self.bulkDeleteUniversesAtPathPrompt(path);
						}),
					bulkActionButton(
						"Scroll To Top of " + (path != "__default" ? "Folder" : "Section"),
						"sprite-scroll_to_top clickable bulktool_right",
						false, function(){
							$(folderContent).scrollTop(0);
						}),
					bulkActionButton(
						"Collapse All Expanded Universes",
						"sprite-collapse_all clickable bulktool_right",
						false, function(){
							self.collapseUniversesAtPath(path);
						}),
					colorPicker,
					$(ce("input"))
						.addClass("check_all_universes")
						.attr({
							"type": "checkbox",
							"title": "Select/Deselect All Universes"
						})
						.on("change", function(){
							self.markUniversesAtPath(this.checked, path);
						})
						.on("focus", function(){
							this.blur();
						}),
					bulkActionButton(
						"Move All Selected Universes",
						"sprite-move_to_folder move_to_folder",
						true, function(){
							self.moveUniversesFromPathPrompt(path);
						})
				);

			var colSorter = this.makeColumnSorterInst(
				this.getSortCols(),
				"sortuniverses", 
				folderContent,
				folderContent
			);
			colSorter.makeColumnSorter();
			
			var expander = this.makeContainerResizable(
				[colSorter.ui, bulkActionsPanel], false, folderContent
			);

			var folderContainer = $(ce("div"))
				.addClass("universe_folder")
				.attr({
					"id": "_" + path.replace(/\W/g, "")
				})
				.append(expander);
			
			var expandSection = function(onOff){
				if(onOff == undefined){
					onOff = $(expander).hasClass("hide");
				}
				if(onOff){
					$(expander).removeClass("hide");
					$(".universe_folder_expander", folderContainer)
						.addClass("sprite-open_folder")
						.removeClass("sprite-folder");
					$(expander).trigger("rsize");
				}else{
					$(expander).addClass("hide");
					$(".universe_folder_expander", folderContainer)
						.removeClass("sprite-open_folder")
						.addClass("sprite-folder");
				}
			};
			
			if(path != "__default"){
				$(expander)
					.addClass("universe_folder_indent hide");
				
				$(folderContainer)
					.addClass("expandable")
					.prepend(
						$(ce("div"))
							.addClass("clickable universe_folder_icon label")
							.attr({
								"title": path
							})
							.append(
								$(ce("div"))
									.addClass("folder_count right")
									.attr({
										"title": "Total Record Count In " + path
									}),
								$(ce("div"))
									.addClass("sprite-folder universe_folder_expander"),
								$(ce("span"))
									.addClass("header_text")
									.append(path)
							)
							.on("click", function(){
								expandSection();
							})
					)
			}
			
			this.folders[path] = {
				"folderContent": folderContent,
				"cont": folderContainer,
				"colSorter": colSorter,
				"colorPicker": colorPicker,
				"expandSection": expandSection,
				"filter_count": 0,
				"folder_count": 0
			};
		}
	},
	getMarkedUniverses: function(){
		return $($.map(this.children, function(universe, id){
			return universe.isChecked() && universe;
		})).filter(function(i, a){return !!a});
	},
	getUniversesAtPath: function(path){
		return $.map(this.children, function(universe, id){
			var p = universe.getPath();
			if(p == path){
				return universe;
			}
		});
	},
	getAllUniversesArray: function(){
		return $.map(this.children, function(universe, id){
			return universe;
		});
	},
	getAllUniversesObject: function(){
		return this.children;
	},
	getMarkedUniversesAtPath: function(path){
		var universes = this.getUniversesAtPath(path);
		return $(universes).filter(function(index, universe){
			return universe.isChecked() && universe;
		});
	},
	getFolderInfoAtPath: function(path){
		path = path || "__default";
		return this.folders[path] || {};
	},
	getExistsAtPath: function(path){
		return !!this.getFolderInfoAtPath(path);
	},
	getFolderContentAtPath: function(path){
		return this.getFolderInfoAtPath(path).folderContent;
	},
	getFolderContainerAtPath: function(path){
		return this.getFolderInfoAtPath(path).cont;
	},
	getFolderColSorterAtPath: function(path){
		return this.getFolderInfoAtPath(path).colSorter;
	},
	getFolderColorPickerAtPath: function(path){
		return this.getFolderInfoAtPath(path).colorPicker;
	},
	getFilterCountAtPath: function(path){
		return this.getFolderInfoAtPath(path).filter_count;
	},
	setFilterCountAtPath: function(path, number){
		this.getFolderInfoAtPath(path).filter_count = parseInt(number, 10);
	},
	getFolderCountAtPath: function(path){
		return this.getFolderInfoAtPath(path).folder_count;
	},
	setFolderCountAtPath: function(path, number){
		this.getFolderInfoAtPath(path).folder_count = parseInt(number, 10);
	},
	expandSectionAtPath: function(path, onOff){
		this.getFolderInfoAtPath(path).expandSection(onOff);
	},
	deleteFolderAtPath: function(path){
		if(!path || path == "__default"){
			return;
		}
		var cont = this.getFolderContainerAtPath(path);
		$(cont).remove();
		delete this.folders[path];
	},
	getUniversesFromContainer: function(container){
		//this is to get all universes from a folder in the order they appear
		var self = this;
		var universes = [];
		$(".criteria", container).each(function(index, element){
			var id = $(element).attr("id");
			universes.push(self.children[id]);
		});
		return universes;
	},
	getMarkedUniversesFromContainer: function(container){
		var universes = this.getUniversesFromContainer(container);
		return $(universes).filter(function(index, universe){
			return universe.isChecked() && universe;
		});
	},
	updateFolderCount: function(path){
		var univs = this.getUniversesAtPath(path);
		var count = 0;
		$.each(univs, function(index, universe){
			count += universe.cardinality;
		});
		this.adjustFolderCount(path, count, true);
	},
	adjustFolderCount: function(path, count, overwrite){
		if(!this.getExistsAtPath(path)){
			return;
		}
		var folderCount = this.getFolderCountAtPath(path);
		if(overwrite){
			this.setFolderCountAtPath(path, count);
		}else if(count != undefined){
			folderCount += count;
			this.setFolderCountAtPath(path, folderCount);
		}
		$(".folder_count", this.getFolderContainerAtPath(path))
			.empty()
			.append(
				Moonshadow.helpers.numberCommas(
					this.getFolderCountAtPath(path)
				)
			);
	},
	removeEmptyFolder: function(path){
		if(!path || path === "__default"){
			return;
		}
		var univs = this.getUniversesFromContainer(
			this.getFolderContentAtPath(path)
		);
		if(!univs.length){
			this.deleteFolderAtPath(path);
			this.updateFoldersList();
		}
	},
	markUniversesAtPath: function(markUnMark, path){
		var univs = this.getUniversesFromContainer(
			this.getFolderContentAtPath(path)
		);
		this.markUniverses(markUnMark, univs);
	},
	markUniverses: function(markUnMark, universeList){
		if(!(universeList instanceof Array)){
			universeList = $.map(universeList, function(universe, id){
				return universe;
			});
		}
		var dsIds = {};
		var count = 0;
		var ul = universeList.slice().reverse();
		var l = ul.length;
		for(var i = l-1; i >= 0; --i){
			var universe = ul[i];
			var checked = universe.isChecked();
			if(markUnMark){
				if(!checked){
					dsIds[universe.checkFilter(true)] = true;
					++count;
				}
			}else{
				if(checked){
					dsIds[universe.unCheckFilter(true)] = true;
					++count;
				}
			}
		}
		this.updateFilterOrder();
		this.runBulkNotify(dsIds);
		return count;
	},
	runBulkNotify: function(dsIds){
		var dsIdsArray = $.map(dsIds, function(i, v){
			return v;
		});
		
		if(dsIdsArray.length){
			var filters = this.getFiltersControl();
			filters.notifyFilterChanges(dsIdsArray);
		}
	},
	changeColorAtPath: function(path, color){
		var univs = this.getMarkedUniversesAtPath(path);
		if(!univs.length){
			return;
		}
		
		var universeControl = this.getManagerControl("universecontrol");
		$.each(univs, function(id, universe){
			universeControl.queueAlteration(
				universe.int_name, universe.ds, 
				{"color": color}
			);
			universe.setColor(color);
			universe.setColorIcon(color);
		});
		
		var self = this;
		universeControl.runAlterationQueue(null, function(){
			self.refreshColorBy();
		});
	},
	changePathFromSelection: function(toPath){
		var univs = this.getMarkedUniverses();
		this.changePath(univs, toPath);
	},
	changePathAtPath: function(path, toPath){
		if(path == toPath){
			return;
		}
		var univs = this.getMarkedUniversesAtPath(path);
		if(!univs.length){
			return;
		}
		this.changePath(univs, toPath);
	},
	changePath: function(universes, toPath){
		var self = this;
		var universeControl = this.getManagerControl("universecontrol");
		var currentPaths = {}
		
		var univs = $(universes).filter(function(index, universe){
			return toPath != universe.getPath();
		});
		
		$.each(univs, function(index, universe){
			currentPaths[universe.getPath()] = true;
			universe.setMeta("path", toPath);
			universeControl.queueAlteration(
				universe.int_name, universe.ds, 
				{
					"json_metadata": universe.json_metadata
				}
			);
		});
		
		universeControl.runAlterationQueue(null, function(){
			$.each(univs, function(index, universe){
				universe.removeUi();
				self.placeUniverseFolder(universe);
			});	
			
			self.adjustBulkActionTools(toPath);
			self.emptyListMessage(toPath);
			if(cs = self.getFolderColSorterAtPath(toPath)){
				cs.refreshSort();
			}
			
			$.each(currentPaths, function(path){
				self.updateFilterCounts(path, 0, true);
				self.adjustBulkActionTools(path);
				self.emptyListMessage(path);
				self.updateFolderCount(path);
				self.removeEmptyFolder(path);
			});
			
			self.showHideFoldersHeader();
			self.updateFoldersList();
			self.foldersColSorter && self.foldersColSorter.refreshSort();
		});
	},
	showHideFoldersHeader: function(){
		var numFolders = Moonshadow.helpers.objCount(this.folders);
		if(numFolders <= 1){
			$(this.universeFoldersHeader)
				.addClass("hide");
			this.foldersColSorter.hideColSorter();
		}else{
			$(this.universeFoldersHeader)
				.removeClass("hide");
			this.foldersColSorter.unhideColSorter();
		}
	},
	bulkDeleteMartkedUniversePrompt: function(){
		var self = this;
		var univs = Moonshadow.helpers.sort(this.getMarkedUniverses());
		if(!univs.length){
			return;
		}
		this.bulkDeleteUniversesPrompt(
			"Delete all currently selected universes? The following universes will be deleted:", 
			univs,
			function(){
				self.deleteUniverses(univs);
			}
		);
	},
	bulkDeleteUniversesAtPathPrompt: function(path){
		if(!path){
			return;
		}
		var message = "Delete all selected universes";
		if(path == "__default"){
			message += " below";
		}else{
			message += " from " + path;
		}
		message += "? The following universes will be deleted:";
		
		var univs = this.getMarkedUniversesFromContainer(
			this.getFolderContentAtPath(path)
		);
		
		if(!univs.length){
			return;
		}
		var self = this;
		this.bulkDeleteUniversesPrompt(message, univs, function(){
			self.deleteMarkedUniversesAtPath(path);
		});
	},
	bulkDeleteUniversesPrompt: function(message, universes, callback){
		var self = this;
		var ce = Moonshadow.helpers.ce;
		var deleteList = $(ce("ul"))
			.addClass("bulk_delete_list")
			.append(
				$(universes).map(function(index, universe){
					return $(ce("li"))
						.append(universe.ext_name)
						.get(0);
				})
			);
		
		MUILayoverPanel.confirm({
			"title": "Delete Selected Universes",
			"titleIcon": "sprite-trash",
			"closeText": "Delete",
			"modal": true,
			"callback": function(response, id, hide){
				if(response === true){
					callback();
				}
				hide();
			},
			"message": function(){
				return 	$(ce("div"))
					.append(
						message, 
						deleteList
					)
			}()
		});	
	},
	moveUniversesFromPathPrompt: function(fromPath){
		var message = "Move the selected universes";
		if(fromPath != "__default"){
			message += " from " + fromPath;
		}
		message += " to:";
		var self = this;
		this.moveUniversesToFolderPrompt(message, function(toPath){
			self.changePathAtPath(fromPath, toPath);
		})
	},
	moveMarkedUniversesToFolderPrompt: function(){
		var message = "Move all selected universes to:";
		var self = this;
		this.moveUniversesToFolderPrompt(message, function(toPath){
			self.changePathFromSelection(toPath);
		})
	},
	moveUniversesToFolderPrompt: function(message, callback){
		var ce = Moonshadow.helpers.ce;
		var self = this;
		
		var folderSelection = $(ce("select"))
			.addClass("folder_selection select_folder_prompt");
		
		var newFolderName = $(ce("div"))
			.addClass("new_folder_promt_cont hide")
			.append(
				$(ce("div"))
					.append("New folder name:"),
				$(ce("input"))
					.addClass("new_universe_folder")
					.attr({
						"type": "text"
					})
				);
				
		this.updateFoldersList(folderSelection, newFolderName);
		
		MUILayoverPanel.confirm({
			"title": "Move Selected Universes to Folder",
			"closeText": "Move",
			"modal": true,
			"callback": function(response, id, hide){
				if(response === true){
					var value = self.getFolderName($("#" + id));
					if(!value){
						return MUILayoverPanel.alert("Please provide a folder.");
					}
					callback(value);
				}
				hide();
			},
			"message": function(){
				return 	$(ce("div"))
					.append(
						message,
						ce("br"),
						folderSelection, 
						newFolderName
					)
			}()
		});
	},
	deleteMarkedUniversesAtPath: function(path){
		this.deleteUniverses(
			this.getMarkedUniversesAtPath(path)
		);
	},
	deleteUniverses: function(univs){
		var self = this;
		var universeControl = this.getManagerControl("universecontrol");
		var universeIds = [];
		var dsIds = {};
		var haveFirms = [];
		$.each(univs, function(index, universe){
			
			universeIds.push(universe.int_name);
			dsIds[universe.ds] = true;
			universe.firms && universe.firms.length && haveFirms.push(universe.int_name);
			
			if(universe.isChecked()){
				universe.unCheckFilter(true);
			}
			universe.unRegisterEstimate();
			
			var path = universe.getPath();
			universeControl.queueUniverseForDeletion(
				universe.ds, universe.int_name,
				function(){
					self.adjustFolderCount(
						path, (universe.cardinality * -1)
					);
					universe.removeUi();
					delete self.children[universe.int_name];
					self.removeEmptyFolder(path);
					self.emptyListMessage(path);
				}
			);
		});
		
		var runDeletion = function(){
			universeControl.runDeletionQueue(null, function(){
				self.runBulkNotify(dsIds);
				self.refreshColorBy();
				self.showHideFoldersHeader();
				self.getManager().dataObservers.notify("itemsincartchanged");
			});
		};
		
		if(haveFirms.length){
			return new Moonshadow.Ajax({
				"url": "exportal/removelist", 
				"type": "POST",
				"execute": true,
				"payload": {
					"universeIds": haveFirms
				},
				"onSuccess": runDeletion
			});
		}
		runDeletion();
		
	},
	updateFilterCounts: function(path, number, overwrite){
		if(!this.getExistsAtPath(path)){
			return;
		}
		var count = this.setFilterCounts(path, number, overwrite);
		var container = this.getFolderContainerAtPath(path);
		var folderHeader = $(".universe_folder_icon", container);
		if(!folderHeader.length){
			folderHeader = $(this.ui.defaultHeader);
			if(!folderHeader.length){
				return;
			}
		}
		var text = $(folderHeader).attr("title");
		$(".header_text", folderHeader)
			.addClass(count !== 0 ? "has-filters" : null)
			.removeClass(count === 0 ? "has-filters" : null)
			.empty()
			.append(text)
			.append(count !== 0 ? " (" + count + ")" : null);
		
		this.checkFilterCount();
	},
	collapseUniversesAtPath: function(path){
		$.each(this.getUniversesAtPath(path), function(index, universe){
			universe.hide();
		});
	},
	setFilterCounts: function(path, number, overwrite){
		var count = this.getFilterCountAtPath(path);
		if(number != undefined){
			if(overwrite){
				count = number;
			}else{
				count += number;
			}
			this.setFilterCountAtPath(path, count);
		}
		return count;
	},
	clearFilterCounts: function(){
		var self = this;
		$.each(this.folders, function(path){
			self.updateFilterCounts(path, 0, true);
		});
	},
	getSortCols: function(){
		var filterOpType = this.getUniverseFilterOperations();
		var sortCols = [{
			"title": "Color",
			"sortby": "color",
			"float": "left"
		},{
			"title": "Checked",
			"sortby": "filter",
			"float": "left"
		},{
			"title": "Subtraction Order",
			"sortby": "order",
			"float": "left",
			"hidden": filterOpType != "univDiff"
		},{
			"title": "Count",
			"sortby": "cardinality",
			"float": "right"
		},{
			"title": "Purchased",
			"sortby": "purchased",
			"float": "right",
			"hidden": !this.purchasingEnabled()
		},{
			"spacer": "scroll_spacer",
			"float": "right"
		},{
			"title": "Name",
			"sortby": "label",
			"sortdefault": true
		}];
		
		return sortCols;
	},
	getFolderSortCols: function(){
		return [{
			"title": "Total Count",
			"sortby": "folder_count",
			"float": "right"
		},{
			"title": "Folder Name",
			"sortby": "header_text",
			"sortdefault": true
		}];
	},
	emptyListMessage: function(path){
		var fc = this.getFolderContentAtPath(path);
		if(fc){
			$(fc).removeClass("empty");
			if(!$(".criteria", fc).length){
				$(fc).addClass("empty");
			}
		}
	},
	toggleSamplingInterface: function(onOff){
		$(".univFilter").click();
		this.enableDisableFilterOperation(!onOff);
		if(onOff){
			//set defaults
			$(".number_of_records").val(1);
			$(".number_of_clusters").val(2);
			$(".number_of_records_per_cluster").val(1);
			$(".one_per_household").val("1");
			$(".normalize_by_age").get(0).checked = true;
			$(".telephone_confidence_code option:[value='2']").get(0).selected = true;
			$(".priority_confidence_code").get(0).checked = false;
			$(".records_with_phone option:[value='1']").get(0).selected = true;
			$(".sample_options_div").removeClass("hide");
			$(".create_sample_checkbox").attr("checked", true);
		}else{
			$(".sample_options_div").addClass("hide");
			$(".create_sample_checkbox").attr("checked", false);
		}
	},
	enableDisablePurchasing: function(onOff){
		if(onOff){
			$(".cartButton", this.container).show();
		}else{
			$(".cartButton", this.container).hide();
		}
		$.each(this.folders, function(path, folder){
			var cs = folder.colSorter;
			if(onOff){
				cs.unhideColumn("purchased");
			}else{
				cs.hideColumn("purchased");
			}
		});
	},
	showHideOpOrderSorter: function(onOff){
		$.each(this.folders, function(path, folder){
			var cs = folder.colSorter;
			if(onOff){
				cs.unhideColumn("order");
			}else{
				cs.hideColumn("order");
			}
		});
	},
	enableDisableFilterOperation: function (onOff) {
		var univOpts = $("#univCombine, #univIntersect, #univDiff, #univExpand, #univReduce");
		for(var i=0; i < univOpts.length; i++) {
			var id = $(univOpts[i]).attr("id");
			if(onOff == undefined){
				onOff = !$(univOpts[i]).hasClass("sprite-"+id+"Disabled");
			}
			$(univOpts[i])
				.addClass(onOff ? "clickable sprite-"+id : "sprite-"+id+"Disabled optiondisabled")
				.removeClass(onOff ? "sprite-"+id+"Disabled optiondisabled" : "clickable sprite-"+id);
		}
	},
	samplingInterface: function(){
		if(!this.getManager().getOption("sampling")){
			return "";
		}
		var ce = Moonshadow.helpers.ce;
		return 	[$(ce("div"))
			.addClass("create_option create_sample_checkbox_label")
			.append(
				$(ce("input"))
					.addClass("create_sample_checkbox")
					.attr({
						"id": "create_sample_checkbox",
						"type": "checkbox"
					})
					.click({"self": this}, function(e){
						e.data.self.toggleSamplingInterface(this.checked);
					}),
				$(ce("label"))
					.append("Create as a Sample:")
					.attr({
						"for": "create_sample_checkbox"
					})
			).get(0),
			$(ce("div"))
				.addClass("sample_options_div hide")
				.append(
					$(ce("div"))
						.addClass("ms_text_field_container")
						.append(
							$(ce("span"))
								.addClass("ms_text_field_small_label")
								.append("Type of sample:"),
							$(ce("div"))
								.addClass("ms_text_field_flex_container_outer")
								.append(
									$(ce("div"))
										.addClass("ms_text_field_flex_container_inner")
										.append(
											$(ce("select"))
												.addClass("sample_type_selector ms_text_field_select")
												.append(
													$(ce("option"))
														.attr({
															"value": "random"
														})
														.append("Random Sample"),
													$(ce("option"))
														.attr({
															"value": "cluster"
														})
														.append("Cluster Sample")
												)
												.on("change", {"self": this}, function(e){
													if(this.value == "random"){
														$(".number_of_records_container").removeClass("hide");
														$(".number_of_clusters_container, .number_of_records_per_cluster_container").addClass("hide");
													}
													if(this.value == "cluster"){
														$(".number_of_records_container").addClass("hide");
														$(".number_of_clusters_container, .number_of_records_per_cluster_container").removeClass("hide");
													}
													e.data.self.checkCreateStatus();
												})
										)
								)
						),
						
						
						$(ce("div"))
							.addClass("ms_text_field_container number_of_records_container")
							.append(
								$(ce("span"))
									.addClass("ms_text_field_small_label")
									.append("Number of records:"),
								$(ce("div"))
									.addClass("ms_text_field_flex_container_outer")
									.append(
										$(ce("div"))
											.addClass("ms_text_field_flex_container_inner")
											.append(
												$(ce("input"))
													.addClass("number_of_records ms_text_field_input")
													.attr({
														"type": "text",
														"value": 1
													})
													.on("change", {"self": this}, function(e){
														var val = $(this).val();
														val = parseInt(val, 10);
														if(typeof val != "number" || isNaN(val)){
															$(this).val(1).focus();
															MUILayoverPanel.alert("Invalid number of records.");
														}else{
															e.data.self.checkCreateStatus();
														}
													})
											)
									)
							),

					$(ce("div"))
						.addClass("ms_text_field_container number_of_clusters_container hide")
						.append(
							$(ce("span"))
								.addClass("ms_text_field_small_label")
								.append("Number of clusters:"),
							$(ce("div"))
								.addClass("ms_text_field_flex_container_outer")
								.append(
									$(ce("div"))
										.addClass("ms_text_field_flex_container_inner")
										.append(
											$(ce("input"))
												.addClass("number_of_clusters ms_text_field_input")
												.attr({
													"type": "text",
													"value": 2
												})
												.on("change", {"self": this}, function(e){
													var val = $(this).val();
													val = parseInt(val, 10);
													if(typeof val != "number" || isNaN(val) || val < 2){
														$(this).val(2).focus();
														MUILayoverPanel.alert("Invalid number of clusters. Needs to be 2 or higher.");
													}else{
														e.data.self.checkCreateStatus();
													}
												})
										)
								)
						),
						
					$(ce("div"))
						.addClass("ms_text_field_container number_of_records_per_cluster_container hide")
						.append(
							$(ce("span"))
								.addClass("ms_text_field_small_label")
								.append("Number of records per cluster:"),
							$(ce("div"))
								.addClass("ms_text_field_flex_container_outer")
								.append(
									$(ce("div"))
										.addClass("ms_text_field_flex_container_inner")
										.append(
											$(ce("input"))
												.addClass("number_of_records_per_cluster ms_text_field_input")
												.attr({
													"type": "text",
													"value": 1
												})
												.on("change", {"self": this}, function(e){
													var val = $(this).val();
													val = parseInt(val, 10);
													if(typeof val != "number" || isNaN(val)){
														$(this).val(1).focus();
														MUILayoverPanel.alert("Invalid number of records per cluster.");
													}else{
														e.data.self.checkCreateStatus();
													}
												})
										)
								)
						),
					$(ce("div"))
						.addClass("ms_text_field_container")
						.append(
							$(ce("span"))
								.addClass("ms_text_field_small_label")
								.append("Number of voters per household:"),
							$(ce("div"))
								.addClass("ms_text_field_flex_container_outer")
								.append(
									$(ce("div"))
										.addClass("ms_text_field_flex_container_inner")
										.append(
											$(ce("select"))
												.addClass("one_per_household ms_text_field_select")
												.append(
													$(ce("option"))
														.attr({
															"value": 1,
															"selected": true
														})
														.append("Select one voter per household"),
													$(ce("option"))
														.attr({
															"value": 0
														})
														.append("Allow more than one voter per household to be selected"),
													$(ce("option"))
														.attr({
															"value": 2
														})
														.append("Select one voter per household and add all other qualifying household members")
												)
										)
								)
						),
					$(ce("div"))
						.addClass("ms_checkbox_container")
						.append(
							$(ce("div"))
								.addClass("ms_checkbox_container_inner")
								.append(
									$(ce("input"))
										.addClass("normalize_by_age ms_checkbox_input")
										.attr({
											"type": "checkbox",
											"checked": true,
											"id": "normalize_by_age"
										})
								),
							$(ce("label"))
								.addClass("ms_checkbox_small_label")
								.attr({
									"for": "normalize_by_age"
								})
								.append("Normalize by age")
						),
					$(ce("div"))
						.addClass("ms_text_field_container")
						.append(
							$(ce("span"))
								.addClass("ms_text_field_small_label")
								.append("A telephone confidence code of at least:"),
							$(ce("div"))
								.addClass("ms_text_field_flex_container_outer")
								.append(
									$(ce("div"))
										.addClass("ms_text_field_flex_container_inner")
										.append(
											$(ce("select"))
												.addClass("ms_text_field_select telephone_confidence_code")
												.append(
													function(){
														var opts = [
															"Disregard", "1 -- highest", "2", "3", "4", "5 -- lowest"
														];
														return $(opts).map(function(index, item){
															return $(ce("option"))
																.attr({
																	"value": index,
																	"selected": index == 2
																})
																.append(item)
																.get(0);
														});
													}()
												)
										)
								)
						),
					$(ce("div"))
						.addClass("ms_checkbox_container")
						.append(
							$(ce("div"))
								.addClass("ms_checkbox_container_inner")
								.append(
									$(ce("input"))
										.addClass("priority_confidence_code ms_checkbox_input")
										.attr({
											"type": "checkbox",
											"id": "priority_confidence_code"
										})
								),
							$(ce("label"))
								.addClass("ms_checkbox_small_label")
								.attr({
									"for": "priority_confidence_code"
								})
								.append("Prioritize results on telephone confidence code")
						),
					$(ce("div"))
						.addClass("ms_text_field_container")
						.append(
							$(ce("span"))
								.addClass("ms_text_field_small_label")
								.append("Records with or without a phone:"),
							$(ce("div"))
								.addClass("ms_text_field_flex_container_outer")
								.append(
									$(ce("div"))
										.addClass("ms_text_field_flex_container_inner")
										.append(
											$(ce("select"))
												.addClass("ms_text_field_select records_with_phone")
												.append(
													function(){
														var opts = [
														    "All voter, regardless of phone",
															"Voters having a phone of any type",
															"Voters having a land line",
															"Voters having a cell phone",
															"Voters having no phone"
														];
														return $(opts).map(function(index, item){
															return $(ce("option"))
																.attr({
																	"value": index
																})
																.append(item)
																.get(0);
														});
													}()
												)
										)
								)
						)
				).get(0)];
	},
	getUniverseFilterOperations: function(){
		if($(this.selectedCreationMethod).length){
			return $(this.selectedCreationMethod).attr("id");
		}
		return false;
	},
	setUniverseFilterOperations: function(filterOp){
		var opType;
		switch(filterOp){
			case "univCombine":
				opType = "union";
				break;
			case "univIntersect":
				opType = "intersection";
				break;
			case "univDiff":
				opType = "difference";
		}

		var filterscontrol = this.getManagerControl('filterscontrol');
		
		var oldOp = filterscontrol.getFilterOperator();
		if(oldOp != opType){
			filterscontrol.setFilterOperator(opType);
			//@TODO this only works with DS in position 1
			var dsId = this.getFirstDatasource().id;
			this.getManager().mapObservers.notify("filterchange", [dsId]);
		}

		this.checkCreateStatus();
	},
	canvassingEnabled: function(enable){
		var manager = this.getManager();
		if(manager.getOption("user_details.user_type") != "read-only"){
			return manager.hasAddon("groundgame");
		}
		return false;
	},
	surveysExportable: function(enable){
		var manager = this.getManager();
		var enabled = false;
		if(manager.getOption("user_details.user_type") != "read-only"){
			enabled = manager.hasAddon("groundgame") || 
				manager.hasAddon("phonecampaigns") || 
				manager.hasAddon("fbpolls");
		}
		return enabled;
	},
	countChecked: function(container){
		return $(".criteria .checkbox input:checked", container).toArray().length;
	},
	countChildrenInContainer: function(container){
		return $(".criteria", container).toArray().length;
	},
	checkCreateStatus: function(){
		this.toggleCreateButton(false);
		
		var createEnabled = true;
		var disabledReasons = [];
		
		//check if name exists
		if(!$(".create_namefield").length || $(".create_namefield").val().length == 0){
			createEnabled = false;
			disabledReasons.push("Please provide a name for the universe.");
		}
		
		//check folder name
		var folderName = this.getFolderName();
		if(!folderName){
			createEnabled = false;
			disabledReasons.push("Please provide a folder for the universe.");
		}
		
		//when filter operations change, check if universes are check
		var filterOpType = this.getUniverseFilterOperations();
		if(filterOpType){
			var numChecked = this.countChecked(this.childContainer);
			if(numChecked <= 1 && (filterOpType == "univCombine" || filterOpType == "univIntersect" || filterOpType == "univDiff")){
				createEnabled = false;
				disabledReasons.push("Operation requires 2 or more selected universes.");
			}
			if(numChecked < 1 && (filterOpType == "univExpand" || filterOpType == "univReduce")){
				createEnabled = false;
				disabledReasons.push("Operation requires only 1 selected universe.");
			}
		}
		
		//if user is creating a sample, make sure values are valid.
		if($(".create_sample_checkbox").length && $(".create_sample_checkbox").get(0).checked){
			if($(".sample_type_selector").val() == "cluster"){
				var clusters = parseInt($(".number_of_clusters[type='text']").val(), 10);
				var recsPer = parseInt($(".number_of_records_per_cluster[type='text']").val(), 10);
				if(!clusters > 0 || !recsPer > 0){
					createEnabled = false;
					disabledReasons.push("Number of clusters and records per cluster greater than 0 required for cluster sample.");
				}
			}else{
				var numRecs = parseInt($(".number_of_records[type='text']").val(), 10);
				if(!numRecs > 0){
					createEnabled = false;
					disabledReasons.push("Number of records greater than 0 required for random sample.");
				}
			}
		}
		
		if(createEnabled){
			this.toggleCreateButton(true);
		}else{
			this.toggleCreateButton(false, disabledReasons.join("\n"));
		}

	},
	toggleCreateButton: function(onOff, reason){
		var createButton = $(".create_universe_button")[0];
		if(createButton){
			if(onOff){
				createButton.disabled = false;
				$(createButton).removeAttr("title");
			}else{
				createButton.disabled = true;
				if(reason && reason.length > 0)
					createButton.title = "Disabled: " + reason;
			}
		}
	},
	onAjaxResponse: function(){},
	getAllLiveSurveys: function(callback){
		if(this.surveysExportable()){
			var surveymanager = this.getSurveyControl();
			if(surveymanager && !surveymanager.surveys.length){
				surveymanager.getSurveys(true, function(){
					callback && callback(surveymanager.getLiveSurveys());
				});
			}else{
				callback && callback(surveymanager.getLiveSurveys());
			}
		}
	},
	changeMethod: function(elem){
		if (!$(elem).hasClass("optiondisabled")){
			if (!$(elem).hasClass("methodSelected")){
				var fop = this.getUniverseFilterOperations();
				if (fop) 
					this.deSelectMethod(fop);
				this.selectMethod(elem.id);
				this.setUniverseFilterOperations(elem.id);
			}
			if (elem.id == "univDiff"){
				this.restoreFilterOrder();
			}
			this.toggleFilterOrder();
			this.toggleFilterOperations();
			this.checkCreateStatus();
		}
	},
	reSelectMethod: function(){
		var filterscontrol = this.getManagerControl("filterscontrol");
		var elemType;
		switch(filterscontrol.getFilterOperator()){
			case "union":
				elemType = "univCombine";
				break;
			case "intersection":
				elemType = "univIntersect";
				break;
			case "difference":
				elemType = "univDiff";
		}
		elemType && this.selectMethod(elemType);
	},
	onClearFilters: function(){		
		var pattern = /^__universes((?!__purchased).)*$/;
		var filters = this.getManagerControl('filterscontrol');
		
		//@TODO this only works with DS in position 1
		var dsId = this.getFirstDatasource().id;
		
		filters.clearFiltersRegEx(dsId, pattern);
		filters.clearFilterOperator();
		this.clearFilters();
	},
	clearFilters: function() {
		$.each(this.children, function(k, v) {
			v.clearFilters();
		});
		this.hasFilters = 0;
		this.updateFilterCount(this.ui.handle);
		this.resetFilterOrder();
		this.deselectAllMethods();
		this.selectMethod(
			$(this.defaultCreationMethod).attr("id")
		);
		this.showHideClear(false);
		this.clearFilterCounts();
		this.clearLastChecked();
	},
	selectMethod: function(id){
		this.selectedCreationMethod = $("#"+id);
		if (this.selectedCreationMethod.length){
			$(this.selectedCreationMethod)
				.addClass("methodSelected")
				.addClass(id+"Selected")
				.addClass("sprite-"+id+"Selected")
				.removeClass("sprite-"+id)
				.removeClass(id);
			
			$(".header_text", this.createHeader)
				.empty()
				.append(
					this.selectedCreationMethod.attr(
						"title"
					)
				);
		}
	},
	deSelectMethod: function(id){
		if ($("#"+id).length){
			this.selectedCreationMethod = this.defaultCreationMethod;
			var oldMethod = $("#"+id);
			$(oldMethod)
				.removeClass("methodSelected")
				.removeClass(id+"Selected")
				.removeClass("sprite-"+id+"Selected")
				.addClass("sprite-"+id)
				.addClass(id);
			
			$(".header_text", this.createHeader)
				.empty();
		}
	},
	deselectAllMethods: function(){
		var methods = $(".createUniv").toArray();
		for(var i = 0, l = methods.length; i < l; ++i){
			this.deSelectMethod(methods[i].id);
		}
		this.hideFilterOrder();
	},
	clearLastChecked: function(universe){
		if(!universe){
			this.lastChecked = {};
			return;
		}
		var path = universe.getPath();
		this.lastChecked[path] = null;
	},
	restoreFilterOrder: function(){
		for(var i in this.orderOfMarkedUniverses){
			if (this.orderOfMarkedUniverses.hasOwnProperty(i))
				this.children[i].updateFilterOrder(parseInt(this.orderOfMarkedUniverses[i],10));
		}
	},
	showFilterOrder: function(){
		this.showHideOpOrderSorter(true);
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				this.children[i].showFilterOrder();
			}
		}
	},
	hideFilterOrder: function(){
		this.showHideOpOrderSorter(false);
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				this.children[i].hideFilterOrder();
			}
		}
	},
	resetFilterOrder: function(){
		this.orderOfMarkedUniverses = {};
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				this.children[i].updateFilterOrder("--");
			}
		}
	},
	getNextOrderInt: function(){
		if(!this.nextOrder){
			this.nextOrder = this.getFiltersControl().getNextOrderInt();
		}else{
			++this.nextOrder;
		}
		return this.nextOrder;
	},
	storeFilterOrder: function(int_name, checked, delayed){
		if (checked){
			this.addMarkedUniverseOrder(int_name, this.getNextOrderInt());
		}else{
			this.removeMarkedUniverseOrder(int_name);
		}

		if(!delayed){
			this.updateFilterOrder();
		}
	},
	addMarkedUniverseOrder: function(id, order){
		this.orderOfMarkedUniverses[id] = order;
	},
	removeMarkedUniverseOrder: function(id){
		delete this.orderOfMarkedUniverses[id];
	},
	countMarkedUniverseOrder: function(){
		return Moonshadow.helpers.objCount(this.orderOfMarkedUniverses);
	},
	adjustBulkActionTools: function(path){
		var filterCount = this.getFilterCountAtPath(path);
		this.enableDisabledFolderColorPicker(path, filterCount > 0);
		this.enableDisableMoveToFolder(path, filterCount > 0);
		this.enableDisableBulkTrash(path, filterCount > 0);
		this.verifyAllCheckedAtPath(path);
	},
	enableDisabledFolderColorPicker: function(path, onOff){
		var cp = this.getFolderColorPickerAtPath(path);
		$(cp)
			.addClass(!onOff ? "sprite-disabled13" : null)
			.removeClass(onOff ? "sprite-disabled13" :  null)
			.addClass(onOff ? "clickable" : null)
			.removeClass(!onOff ? "clickable" :  null);
	},
	enableDisableMoveToFolder: function(path, onOff){
		var cont = this.getFolderContainerAtPath(path);
		$(".move_to_folder", cont)
			.addClass(onOff ? "clickable" : null)
			.removeClass(!onOff ? "clickable" :  null)
			.find("div")
			.addClass(!onOff ? "sprite-disabled15" : null)
			.removeClass(onOff ? "sprite-disabled15" :  null);
	},
	enableDisableBulkTrash: function(path, onOff){
		var cont = this.getFolderContainerAtPath(path);
		$(".trash_icon", cont)
			.addClass(onOff ? "clickable" : null)
			.removeClass(!onOff ? "clickable" :  null)
			.find("div")
			.addClass(!onOff ? "sprite-disabled15" : null)
			.removeClass(onOff ? "sprite-disabled15" :  null);
	},
	verifyAllCheckedAtPath: function(path){
		var checkCount = this.countChildrenInContainer(
			this.getFolderContainerAtPath(path)
		);
		var filterCount = this.getFilterCountAtPath(path);
		var numUniv = this.getUniversesAtPath(path);
		var onOff = checkCount === filterCount;
		if(filterCount === 0){
			onOff = false;
		}
		this.tickCheckAll(onOff, path);
	},
	tickCheckAll: function(onOff, path){
		var container = this.getFolderContainerAtPath(path);
		container && $(".check_all_universes", container)
			.attr({
				"checked": onOff
			});
	},
	toggleFilterOperations: function(){
		var self = this;
		$(".criteria .checkbox input[type='checkbox']", this.childContainer).attr("disabled", false);
		var selectedMethod = this.getUniverseFilterOperations();

		if(selectedMethod && 
				(selectedMethod == "univExpand" || selectedMethod == "univReduce") && 
				this.countMarkedUniverseOrder() > 0){
			
			$.each(this.children, function(index, child){
				if(child.order != self.countMarkedUniverseOrder()){
					$("input", child.checkbox)[0].disabled = true;
				}
			});
		}
	},
	toggleFilterOrder: function(){
		var fop = this.getUniverseFilterOperations();
		if (fop && fop == "univDiff"){
			this.showFilterOrder();
		}else{
			this.hideFilterOrder();
		}
	},
	enableUniverses: function(enable){
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				this.children[i].enableUniverseInfo(enable);
			}
		}
	},
	updateFilterOrder: function(){
		var nextOrder = 0;
		var reordered = [];
		for(var i in this.orderOfMarkedUniverses){
			if (this.orderOfMarkedUniverses.hasOwnProperty(i)){
				reordered[nextOrder] = this.orderOfMarkedUniverses[i];
				++nextOrder
			}
		}
		reordered.sort(function(a,b){return a - b});
		var revisedOrder = [];
		for (var j = 0, ll = reordered.length; j < ll; ++j){
			for(var i in this.orderOfMarkedUniverses){
				if(this.orderOfMarkedUniverses.hasOwnProperty(i)){
					if (this.orderOfMarkedUniverses[i] == reordered[j]){
						revisedOrder.push(i);
					}
				}
			}
		}
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				this.children[i].order = 0;
				this.children[i].updateFilterOrder("--");
			}
		}
		for(var i = 0,l = revisedOrder.length; i < l; ++i){
			var nextInt = parseInt(i,10)+1;
			this.children[revisedOrder[i]].updateFilterOrder(nextInt);
			this.children[revisedOrder[i]].order = nextInt;
			this.orderOfMarkedUniverses[revisedOrder[i]] = nextInt;
		}
		this.toggleFilterOperations();
		this.toggleFilterOrder();
	},
	toggle: function() {
		var container = this.childContainer;
		var createContainer = $(".universe_expandable", this.container);
		if($(container).css("display") != "block") {
			if(typeof this.showStats == "undefined") {
				var showStats = true;
				this.showStats = showStats;
			}
			this.expander.className += " expanded";
			$(createContainer).removeClass("hide");
			$(container).css({
				"display": "block"
			});
		} else {
			this.expander.className = this.expander.className.replace(" expanded","");
			$(createContainer).addClass("hide");
			$(container).css({
				"display": "none"
			});
		}
	},
	buildUniversePanelContent:function(){
		this.enableUniverses(true);
		this.updateList();
		this.childrenHaveUi = true;
		this.toggleFilterOperations();
		this.getAllLiveSurveys();
		this.adjustAllBulkActionTools();
		this.updateFoldersList();
		this.getManager().mapObservers.notify("universesuiloaded");
	},
	getChildById: function(id){
		return this.children[id];
	},
	getChildrenByAttribute: function(attribute, value){
		var returnChildren = {}
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i)){
				continue;
			}
			if(!this.children[i][attribute]){
				continue;
			}
			if(this.children[i][attribute] == value){
				returnChildren[i] = this.children[i];
			}
		}
		return returnChildren;
	},
	getChildrenBriefList: function(attributes){
		var returnChildren = {}
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i)){
				continue;
			}
			var u = this.children[i];
			returnChildren[i] = this._fillChildBriefAttrs(u, attributes);
		}
		return returnChildren;
	},
	searchChildrenByNameBriefList: function(name, attributes){
		var returnChildren = {}
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i)){
				continue;
			}
			var u = this.children[i];
			if(u.ext_name.toLowerCase().search(name.toLowerCase()) > -1){
				returnChildren[i] = this._fillChildBriefAttrs(u, attributes);
			}
		}
		return returnChildren;
	},
	getLatestChildren: function(){
		var dates = [];
		
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i)){
				continue;
			}
			var u = this.children[i];
			dates.push({
				"date": u.created_time,
				"id": u.int_name
			})
		}
		
		dates.sort(function(a, b){
			var at = a.date;
			var bt = b.date;
			return bt - at;
		});
		
		var sortedChildren = [];
		for(var i = 0, l = dates.length; i < l; ++i){
			sortedChildren.push(this.children[dates[i].id]);
			if(sortedChildren.length >= 10){
				break;
			}
		}
		
		return sortedChildren;
	},
	_fillChildBriefAttrs: function(universe, attributes){
		var attrs = {
			"int_name": universe.int_name,
			"ext_name": universe.ext_name 
		}
		if(attributes && attributes.length){
			for(var i = 0, l = attributes.length; i < l; ++i){
				var attr = attributes[i];
				if(universe[attr] != undefined){
					attrs[attr] = universe[attr];
				}
				if(attr == "path"){
					attrs["path"] = universe.getPath();
				}
			}
		}
		return attrs;
	},
	getNumChildren: function(inPurchaseStates){
		childCount = 0;
		for(var i in this.children){
			if(this.children.hasOwnProperty(i)){
				if (!inPurchaseStates) {
					childCount++
				} else {
					var child = this.children[i];
					for(var j in inPurchaseStates){
						if (child.determinePurchaseState() == inPurchaseStates[j]) {
							childCount++;
						}
					}
				}
			}
		}
		return childCount;
	},
	countFilters: function() {
		var filterControl = this.getFiltersControl();

		//@TODO this only works with DS in position 1
		var dsId = this.getFirstDatasource().id;
		var filters = filterControl.getFilters(dsId);
		if(!filters){
			return 0;
		}
		
		var count = 0;
		for(var i in this.values){
			if(!this.values.hasOwnProperty(i))
				continue;
			
			var path = ['__universes', i].join('|');
			count += !!filters[path] ? 1 : 0
		}

		return count;
	},
	checkUniverseName: function(name){
		for (var i in this.children){
			if(this.children.hasOwnProperty(i)){
				var child = this.children[i];
				if(child.ext_name == name){
					return child
				}
			}
		}
		return false;
	},
	hasNonUniverseFilters: function(dsId) {
		var filters = this.getManagerControl("filterscontrol").getFilters(dsId);
		for(var i in filters){
			if(!filters.hasOwnProperty(i))
				continue;
			if(i.search(/^__universes/) > -1)
				continue;
			return true;
		}
		return false;
	},
	getName: function(){
		return Moonshadow.helpers.sanitizeString($(this.inputName).val());
	},
	getDesc: function(){
		return Moonshadow.helpers.sanitizeString($(this.inputDesc).val()) || "";
	},
	getFolderName: function(container){
		var path = $(".folder_selection", container || this.container).val();
		if(path == "__newFolder"){
			path = $(".new_universe_folder", container || this.container).val();
		}
		return Moonshadow.helpers.sanitizeString(path) || "";
	},
	checkFilterOpSupport: function(createType){
		// If type is one that doesn't support non-universe selections let the user know
		var lacksFilters = ['univCombine', 'univIntersect', 'univDiff', 'univExpand', 'univReduce'];
		if ($.inArray(createType, lacksFilters) !== -1) {

			//@TODO this only works with DS in position 1
			var dsId = this.getFirstDatasource().id;
			
			if(this.hasNonUniverseFilters(dsId)) {
				return false;
			}
		}
		return true;
	},
	validateCreation: function(createType){
		var message = "";
		var reordered = [];
		for(var i in this.orderOfMarkedUniverses){
			if (this.orderOfMarkedUniverses.hasOwnProperty(i)){
				var order = parseInt(this.orderOfMarkedUniverses[i],10);
				reordered[order] = i;
			}
		}
		
		if (createType == "univDiff"){
			var first = null;
			for(var i = 1; i < reordered.length; ++i){
				if (!reordered[i]) continue;
				if (message == ""){
					message += "This will create a universe by taking <br>";
					message += this.children[reordered[i]].ext_name + " and subracting from it <br>";
					first = i;
					continue;
				}
				if (first) {
					message += this.children[reordered[i]].ext_name;
					first = null;
					continue;
				}
				message += ", then subracting <br>";
				message += this.children[reordered[i]].ext_name + " from the total";
			}
			message += ".<br>Proceed?<br>";
		}

		if(!this.checkFilterOpSupport(createType)){
			message += '<br>WARNING: Only the selected unmodified universes will be used in this ' +
				'procedure. Area and/or demographic selections added after creating these ' +
				'universes will be ignored. <br>';
		}
		
		return message;
	},
	getCreateTypeForQuery: function(inType){
		switch(inType){
			case "univIntersect":
				return "intersection";
			case "univDiff":
				return "difference";
			case "univExpand":
				return "expand";
			case "univReduce":
				return "contract";
			case "univCombine":
				return "union";
		}
	},
	resetCreationForm: function(){
		$(this.inputName).val("");
		$(this.inputDesc).val("");
		$(".new_universe_folder", this.container)
			.val("")
			.closest(".new_universe_folder_cont")
			.addClass("hide");
		$(".select_folder option[value='__default']", this.container)
			.attr({
				"selected": true
			});
	},
	createUniverse: function() {
		var name = this.getName();
		if(!name.length){
			return;
		}

		var self = this;
		var postCreation = function(error){
			if (error){
				return self.creationError(error);
			}
			if(self.filterByNewUniverse){
				self.getManagerControl("filters").onClearFilters();
			}
			self.resetCreationForm();
			self.toggleSamplingInterface(false);
			self.getUniverses(function(){
				self.lockUnlockCreation(false);
			});
		};

		var createType = this.getUniverseFilterOperations() || "univFilter";
		var doCreation = function(){

			//@TODO this only works with DS in position 1
			var query = {
				"dsId": self.getFirstDatasource().id,
				"name": name
			};
			
			var isSample = $(".create_sample_checkbox").length && $(".create_sample_checkbox").get(0).checked;
			query.universeType = isSample ? "sample" : "universe"
			
			if(isSample){
				self.getSampleQuery(query);
			}
				
			var ct = self.getCreateTypeForQuery(createType);
			if(ct){
				query.createType = ct;
			}
			
			if(Moonshadow.helpers.objCount(self.orderOfMarkedUniverses) > 0){
				query.markedUniverses = self.orderOfMarkedUniverses;
			}

			var desc = self.getDesc();
			if(desc){
				query.description = desc;
			}

			var shapesControl = self.getManagerControl("shape");
			if(shapesControl && shapesControl.isActive()){
				query.points = shapesControl.getFilter();
			}

			if($(".only_records_having_landline").length && $(".only_records_having_landline").get(0).checked){
				query.filters = self.getPhoneOnlyFilters();
			}
			
			var color = self.getColor();
			if(color){
				query.color = color;
			}
			
			var path = self.getFolderName();
			if(path != "__default"){
				query.path = path;
			}
			
			query.callback = postCreation;

			var _createUniverse = function(){
				self.lockUnlockCreation(true);
				var universeControl = self.getManagerControl("universecontrol");
				universeControl.queueUniverseCreation(query);
			};
			
			var nameCheckUniverse = self.checkUniverseName(name);
			if(nameCheckUniverse){
				return MUILayoverPanel.confirm({
					"message": 'There is already a universe by the name "' + name + '". ' 
						+ ' Press OK to contune or Cancel to return and choose a new name.',
					"callback": function(res, id, hide){
						if(res){
							_createUniverse();
						}
						hide();
					}
				});
			}
			_createUniverse();
		};
		
		var message = this.validateCreation(createType);
		if (message){
			return MUILayoverPanel.confirm({
				"message": message,
				"callback": function(res, id, hide){
					if(res){
						doCreation();
					}
					hide();
				}
			});
		}
		
		doCreation();
	},
	getSampleQuery: function(query){
		
		if($(".sample_type_selector").val() == "random"){
			//random sample is on record chosen from many random clusters
			query.count = parseInt($("input.number_of_records").val().replace(/\W/g, ""),10);
			query.cluster_size = 1;
		}else{
			//cluster sample is multiple records chosen from one or more clusters
			query.count = parseInt($("input.number_of_clusters").val().replace(/\W/g, ""),10);
			query.cluster_size = parseInt($("input.number_of_records_per_cluster").val().replace(/\W/g, ""),10);
		}

		query.one_voter_per_residence = parseInt($(".one_per_household").val(), 10);
		query.normalized = false;
		if($(".normalize_by_age").get(0).checked){
			query.normalized = true;
		}

		query.records_with_phone = parseInt($(".records_with_phone").val(),10) || 0;
		query.telephone_confidence_code = parseInt($(".telephone_confidence_code").val(),10) || 0;
		query.priority_confidence_code = $(".priority_confidence_code").get(0).checked;
		
		return query;
	},
	creationError: function(error){
		MUILayoverPanel.alert("There was a problem creating the universe.\n Details: " + error.toString());
		this.lockUnlockCreation(false);
	},
	reportListener: function(){
		var manager = this.getManager();
		var self = this;
		manager.addMapObserver("reportdetailsupdated", function(){
			self.updateReportsUI();
			manager.mapObservers.notify("updateestimates");
		}, this);
		manager.addMapObserver("updateestimates", function(){
			self.updateRegisteredEstimates();
		}, this);
	},
	updateReportsUI: function(){
		for(var i in this.children){
			if(!this.children.hasOwnProperty(i)){
				continue;
			}
			this.children[i].updateReportsUI();
		}
	},
	registerEstimateUpdater: function(universe, tabInfo, estimateItems, options){
		if(!tabInfo.registered && tabInfo.active){
			this.registeredEstimateUpdaters.push({
				"universe": universe,
				"tabInfo": tabInfo,
				"estimateItems": estimateItems,
				"options": options,
				"info": {
					"layout": options.report_type,
					"numRecords": options.num_records
				}
			});
			tabInfo.registered = true;
		}
	},
	clearAllRegisteredUpdaters: function(){
		for(var i = 0, l = this.registeredEstimateUpdaters.length; i < l; ++i){
			this.registeredEstimateUpdaters[i].tabInfo.registered = false;
		}
		this.registeredEstimateUpdaters = [];
	},
	unRegisterEstimateUpdater: function(universe){
		for(var i = 0, l = this.registeredEstimateUpdaters.length; i < l; ++i){
			var obj = this.registeredEstimateUpdaters[i];
			if(obj.universe.int_name == universe.int_name){
				obj.tabInfo.registered = false;
				this.registeredEstimateUpdaters.splice(i, 1);
				return true;
			}
		}
	},
	updateRegisteredEstimates: function(){
		var self = this;
		var reportqueue = this.getManagerControl("reportqueue");
		var batch = [];
		for(var i = 0, l = this.registeredEstimateUpdaters.length; i < l; ++i){
			var item = this.registeredEstimateUpdaters[i];
			item.universe.estimatesRefreshing(item.tabInfo, true);
			batch.push(item.info);
		}
		if(batch.length){
			reportqueue.batchEstimates(batch, function(data){
				if(data.result == "ok"){
					var estimates = data.estimates;
					for(var i = 0, l = estimates.length; i < l; ++i){
						self.updateEstimateItem(estimates[i]);
					}
				}
			});
		}
	},
	updateEstimateItem: function(estimate){
		var index = 0;
		while(this.registeredEstimateUpdaters.length){
			var item = this.registeredEstimateUpdaters[index];
			if(!item){
				break;
			}
			if(item.info.layout == estimate.layout && item.info.numRecords == estimate.numRecords){
				item.universe.updateEstimateUi({
					"estimate": estimate
				}, item.tabInfo, item.estimateItems);
				item.universe.estimatesRefreshing(item.tabInfo, false);
			}
			++index;
		}
	},
	getUniverses: function(callback){
		var universeControl = this.getManagerControl("universecontrol");
		
		//@TODO this only works with DS in position 1
		var dsId = this.getFirstDatasource().id;
		var universes = universeControl.getUniverses(dsId);
		var universeIds = [];
		
		for(var i in universes){
			if(!universes.hasOwnProperty(i))
				continue;
			universeIds.push(i);
		}
		
		var self = this;
		universeControl.getQueuedUniverses(universeIds, function(queObj){
			self.processUniverses(universes, queObj);
			self.checkCreateStatus();
			callback && callback();
		});
	},
	processUniverses: function(universes, queObj){
		var showHead = false;
		var self = this;
		var newChildCheck = [];
		var redrawChild = [];
		this.values = universes;

		var foldersToRefresh = {};
		$.each(universes, function(key, item) {
			if (item.type == 1 || item.type == 2){
				item.dtype = "universeitem";
				var id = item.int_name;
				var univ = self.children[id];
				var firmInfo = queObj && queObj[id];
				if(!univ){
					univ = self.addNewUniverse(item, firmInfo);
					foldersToRefresh[univ.getPath()] = true;
				}else{
					univ.updateSelf(item, firmInfo);	
				}
			}
		});
		
		$.each(foldersToRefresh, function(path) {
			if(cs = self.getFolderColSorterAtPath(path)){
				cs.refreshSort();
			}
			self.emptyListMessage(path);
		});
		
		this.foldersColSorter && this.foldersColSorter.refreshSort();
		this.updateFoldersList();
		this.getManager().dataObservers.notify("itemsincartchanged");
	},
	addNewUniverse: function(universe, firmInfo){
		var control = this.getParentControl();
		var univ = control.getFilterable(universe, this);
		univ.updateSelf(universe, firmInfo);
		this.children[universe.int_name] = univ;
		if(this.childrenHaveUi) {
			this.placeUniverseFolder(univ);
			if(this.filterByNewUniverse){
				univ.checkFilter();
			}
			this.expandSectionAtPath(univ.getPath(), true);
		}
		return univ;
	},
	updateFoldersList: function(selector, newFolderCont){
		if(!this.childrenHaveUi){
			return;
		}
		
		var self = this;
		var ce = Moonshadow.helpers.ce;
		var opts = $.map(this.folders, function(folder, path){
			return $(ce("option"))
				.addClass(path == "__default" ? "font_italic" : "font_normal")
				.attr({
					"value": path
				})
				.append(path == "__default" ? "None" : path)
				.get(0);
		})
		.sort(function(a, b){
			var aVal = $(a).val();
			var bVal = $(b).val();
			return Moonshadow.helpers.naturalSortFunc(aVal, bVal);
		});
		
		if(!selector){
			selector = $(".select_folder", this.container);
		}
		if(!newFolderCont){
			newFolderCont = $(".new_universe_folder_cont", this.container);
		}
		
		$(selector)
			.empty()
			.append(opts)
			.on("change", function(){
				if(this.value == "__default"){
					$(this).addClass("italic")
				}else{
					$(this).removeClass("italic")
				}
				if(this.value == "__newFolder"){
					$(newFolderCont)
						.removeClass("hide")
						.find(".new_universe_folder")
						.focus();
				}else{
					$(newFolderCont)
						.addClass("hide");
				}
				self.checkCreateStatus();
			});
		
		var nfo = $(".new_folder_option", selector);
		if(!nfo.length){
			$("option[value='__default']", selector)
				.after(
					$(ce("option"))
						.addClass("font_normal new_folder_option")
						.attr({
							"value": "__newFolder"
						})
						.append("Make New Folder")
				);
		}
	},
	updatePurchasedCounts: function(){
		var that = this;
		$.each(this.children,function(k,v) {
			v.updatePurchasedCounts();
		});
	},
	deleteUniverse: function(universe, callback) {
		var self = this;
		var id = universe.int_name;
		var universeControl = this.getManagerControl("universecontrol");
			
		var checkBox = $("#cb_" + id).get(0);
		if(checkBox.checked){
			$(checkBox).click();
		}

		var finalStep = function(response){
			$("#" + id).remove();
			var path = universe.getPath();
			self.adjustFolderCount(path, (universe.cardinality * -1));
			universe.removeUi();
			delete self.children[id];
			self.removeEmptyFolder(path);
			self.emptyListMessage(path);
			self.showHideFoldersHeader();
			self.getManager().dataObservers.notify("itemsincartchanged");
			callback && callback();
		};
		
		universeControl.deleteUniverse(universe.ds, id, function(data){
			if(data.result == "ok"){
				if(universe.firms.length){
					return new Moonshadow.Ajax({
						"url": "exportal/removeall/" + id, 
						"type": "DELETE",
						"execute": true,
						"onSuccess": finalStep
					});
				}

				finalStep();
			}
		});
	}
});

//MFilterableUniverseItem
function MFilterableUniverseItem(branch,parent) {
	this.init(branch,parent);
	this.datasource = branch.ds || 0;
	this.order = 0;
	this.defaultColor = "0022ff";
	this.color = branch.color || defaultColor;	
	this.purchase_state = branch.purchase_state || 0;
	this.cardinality = branch.cardinality || 0;
	this.counts = branch.counts || [];
	this.countsObj = {};
	this.countsFetched = false;
	branch.purchased && (this.purchased = branch.purchased);
	branch.unpurchased && (this.unpurchased = branch.unpurchased);
	this.description = branch.description || null;
	this.upc = "L10001000";
	this.filter = branch.filter || null;
	this.container = null;
	this.options = branch.options || {}
	this.dynamic_aux_data = branch.dynamic_aux_data || [];
	this.control = this;
	this.write_access = branch.write_access || 0;
	this.infoDisabled = true;
	this.expire_time = null;
	this.firms = [];
	this.json_metadata = {};
	this.reportsPanel = null;
	this.reportsSubPanel = null;
	this.privs = this.getControl().getManager().getOption("user_details.user_type");
	this.getControl().getManager().getControl("reporttypes").getReportTypes(this);
	this.estimatesDirty = false;
	this.infoPanelBuilt = false;
	this.ui = {};
	this.iconReg = {
		"names": [],
		"initial": [],
		"selected": [],
		"disabled": []
	};
}
MFilterableUniverseItem.prototype = new MFilterable;
$.extend(MFilterableUniverseItem.prototype,{
	buildUI: function(returnContainer, folderContainer){
		this.makeCountsObj();
		
		var doReturn = returnContainer || false;
		var ce = Moonshadow.helpers.ce;
		var control = this.getControl();
		var manager = control.getManager();
		var colorPickerControl = manager.getControl('colorpicker');
		
		var self = this;
		
		this.container = $(ce("div"))
			.addClass("criteria autoHeight")
			.attr({
				"id": this.int_name
			})
			.on("click", function(){
				self.adjustExpander();
			});

		this.addCartButton();

		this.ui.colorPicker = colorPickerControl.getColorIcon(this, "universe", function(){
			self.updateColors();
		});
		$(this.container)
			.append(
				$(ce("span"))
					.addClass("cardinality")
					.append(Moonshadow.helpers.numberCommas(parseInt(this.cardinality,10))),
				this.ui.colorPicker
			);

		var checked = this.isChecked();
		var dsFilters = this.getFilterValue();
		
		if (checked && this.parent.orderOfMarkedUniverses && dsFilters && dsFilters.order){
			this.order = dsFilters.order;
			this.parent.addMarkedUniverseOrder(this.int_name, this.order);
		}
		
		this.checkbox = this.makeCheckboxFilter("cb_" + this.int_name, checked);
		$(this.container).append(this.checkbox);
	
		var fop = this.parent.getUniverseFilterOperations();
		$(this.container)
			.append(
				$(ce("div"))
					.addClass("univOrder")
					.addClass(function(){
						if(!fop || fop != "univDiff")
							return " hide";
					}())
					.append(this.order || "--")
					.attr({
						"title": "Subtraction order of opertations",
						"id": "order_"+this.int_name
					})
			);

		this.panTo = new UIPanTo(this);
		$(this.container).append(this.panTo.getUI());
		
		this.ui.infoButton = $(ce("div"))
			.append(
				$(ce("div"))
					.addClass("sprite-expander_right"),
				$(this.makeLabel(this.ext_name))
					.attr({
						"id": "name_"+this.int_name
					})
			)
			.addClass("infoexpander infoButton clickable")
			.click(function(){
				self.toggleExpandInfo();
			});
	
		$(this.container).append(this.ui.infoButton);
		
		this.finalClear = this.makeClear();

		this.infoPanel = $(ce("div"))
			.addClass("infoPanel hide")
			.append(this.finalClear);
		
		$(this.container).append(this.infoPanel);
		
		this.ui.initH = $(this.container).height();
		if(folderContainer){
			this.ui.folderContainer = folderContainer;
		}
		
		if(doReturn) {
			return this.container.get(0);
		} else {
			$(this.parent.childContainer).append(this.container);
		}
	},
	toggleExpandInfo: function(){
		if (!this.disabled){
			if(!$(this.infoPanel).hasClass("hide")){
				this.hide();
			}else{
				this.show();
			}
		}
	},
	adjustExpander: function(){
		if(!this.ui.folderContainer){
			return;
		}
		var adjustment = 0;
		var newHeight = $(this.container).height();
		if(!this.ui.newHeight){
			this.ui.newHeight = this.ui.initH || $(this.container).height();
		}
		adjustment = newHeight - this.ui.newHeight;
		$(this.ui.folderContainer).trigger("resizeInput", adjustment);
		this.ui.newHeight = newHeight;
	},
	makeCountsObj: function(){
		for(var i = 0, l = this.counts.length; i < l; ++i){
			this.countsObj[this.counts[i].name] = this.counts[i].count;
		}
	},
	getParentContainer: function(){
		return this.parent.getFolderContainerAtPath(this.getPath());
	},
	show: function(callback){
		var self = this;
		this.fetchCounts(function(){
			if(!self.infoPanelBuilt){
				self.buildInfoPanel();
			}

			$(self.infoPanel)
				.removeClass("hide");
			
			$(".infoexpander > .sprite-expander_right", self.container)
				.removeClass("sprite-expander_right")
				.addClass("sprite-expander_down");
			
			self.mapNotify("filterabletoggle", self);
			self.adjustExpander();
			callback && callback();
		});
	},
	hide: function(callback){
		$(".infoexpander > .sprite-expander_down", this.container)
			.removeClass("sprite-expander_down")
			.addClass("sprite-expander_right");
		
		$(this.infoPanel)
			.addClass("hide");
		
		this.closeSubPanels();

		this.mapNotify("filterabletoggle", this);
		this.adjustExpander();
		callback && callback();
	},
	isCompound: function(){
		var isCompound = false;
		if(!this.filter) {
			isCompound = true;
		}else{
			if(this.filter["circle_filter"]){
				isCompound = true;
			}
			if(this.filter["__universes"]) {
				isCompound = true;
			}
			if(this.filter["__polygon"]) {
				isCompound = true;
			}
			if(this.filter.base_universe){
				isCompound = true;
			}
			if(this.filter.non_filter){
				isCompound = true;
			}
		}
		return isCompound;
	},
	buildInfoPanel: function(){
		this.buildButtonHolder();
		this.buildEditPanel();
		this.buildFilterRecallButtons();
		this.buildReportsPanel();
		this.buildCanvasserPanel();
		this.buildContactPanel();
		this.buildTrashButton();
		this.buildDescriptionPanel();
		this.buildCompositionPanel();
		this.updatePurchasedCounts();
		$(this.buttonHolder).append(this.makeClear());
		this.infoPanelBuilt = true;
	},
	buildButtonHolder: function(){
		var ce = Moonshadow.helpers.ce;
		this.buttonHolder = $(ce("div"))
			.addClass("buttonHolder");
		
		$(this.infoPanel)
			.append(
				this.buttonHolder,
				this.finalClear
			);
	},
	fetchCounts: function(callback){
		if(this.countsFetched){
			if(!callback){
				return callback;
			}
			return callback();
		}
		var self = this;
		var universeControl = this.getControl().getManager().getControl("universecontrol");
		universeControl.fetchUniverse(this.datasource, this.int_name, function(universe){
			if(universe){
				self.counts = universe.counts;
				self.makeCountsObj();
				self.countsFetched = true;
			}
			callback && callback();
		});
	},
	addCartButton: function(){
		var ce = Moonshadow.helpers.ce;
		var self = this;
		if(this.purchasingEnabled()){
			this.cartButton = $(ce("div"))
				.addClass("cartButton")
				.on("click", function(e) {
					if($(this).data("enabled")){
						self.toggleCart();
					}
				}
			);
			
			this.updatePurchaseStateUI();
			$(this.container).append(this.cartButton);
		}
	},
	getCartPanel: function(){
		var control = this.getControl();
		var manager = control.getManager();
		return manager.getControl("cartpanel");
	},
	toggleCart: function(){
		this.getCartPanel().toggleAddUniverse(this);
	},
	addToCart: function(delayed){
		var pstatus = this.getPurchasedStatus();
		var pstate = this.purchase_state;
		if((pstatus === 0 || pstatus === 1) && (pstate === 0 || pstate == 1)){
			this.getCartPanel().addUniverse(this, delayed);
			return this.ds;
		}
		return false;
	},
	removeFromCart: function(delayed){
		var pstatus = this.getPurchasedStatus();
		var pstate = this.purchase_state;
		if((pstatus === 0 || pstatus === 1) && (pstate == 10 || pstate == 20)){
			this.getCartPanel().removeUniverse(this, delayed);
			return this.ds;
		}
		return false;
	},
	deselectIcons: function(subOf){
		if(this.iconReg.selected.length){
			for(var ii = 0, l = this.iconReg.selected.length; ii < l; ++ii){
				var targetGroup = $(subOf + " ." + this.iconReg.selected[ii], this.container);
				if(targetGroup.length){
					for(var iii = 0, ll = targetGroup.length; iii < ll; ++iii){
						$(targetGroup[iii])
							.removeClass(this.iconReg.selected[ii])
							.addClass(this.iconReg.initial[ii]);
					}
					
				}
			}
		}
	},
	selectIcon: function(name){
		$(".sprite-" + name, this.container)
			.removeClass("sprite-" + name)
			.addClass("sprite-" + name + "Selected");
	},
	registerIcon: function(name){
		this.iconReg.names.push(name);
		this.iconReg.initial.push("sprite-" + name);
		this.iconReg.selected.push("sprite-" + name + "Selected");
		this.iconReg.disabled.push("sprite-" + name + "Disabled");
	},
	buildEditPanel: function(){
		var ce = Moonshadow.helpers.ce;
		
		this.registerIcon("pencil");
		$(this.buttonHolder)
			.append(
				$(ce("div"))
					.addClass("universeTool")
					.addClass(this.write_access ? "editDetails sprite-pencil clickable" : "editDetailsDisabled sprite-pencilDisabled")
					.attr({
						"title": this.write_access ? "Edit Universe" : "Read only access"
					})
					.click({"universe": this}, function(e){
						var universe = e.data.universe;
						if(!universe.write_access)
							return false;
						
						universe.toggleSubPanel(
							this, 
							$(".editPanel", universe.container),
							null, "pencil"
						);
					})
			);
		
		$(this.infoPanel).append(
			$(ce("div"))
				.addClass("editPanel subPanel hide")
				.append(
					$(ce("div"))
						.append(
							$(ce("span"))
								.addClass("red")
								.append("*"),
							" Name"
						),
					$(ce("div"))
						.addClass("input_container")
						.append(
							$(ce("input"))
								.addClass("editName")
								.attr({
									"value": this.ext_name,
									"type": "text"
								})
								.on("change", function(){
									$(this).val(Moonshadow.helpers.sanitizeString($(this).val()));
								})
						),
					$(ce("div"))
						.append("Description"),
					$(ce("div"))
						.addClass("input_container")
						.append(
							$(ce("input"))
								.addClass("editDesc")
								.attr({
									"value": this.description || "",
									"type": "text"
								})
								.on("change", function(){
									$(this).val(Moonshadow.helpers.sanitizeString($(this).val()));
								})
						),
					$(ce("input"))
						.attr({
							"value": "Save",
							"type": "Button"
						})
						.click({"universe": this}, function(e){
							var self = e.data.universe;
							var name = $(".editName", self.container).val().trim();
							var desc = $(".editDesc", self.container).val().trim();
							if(!name && !desc){
								return;
							}
							
							if(self.ext_name == name && (self.description == desc || (self.description == null && desc == ""))){
								return false;
							}
									
							$(".editing_wait", self.container)
								.removeClass("hide");
							self.editNameDesc(name || "", desc || "", function(){
								$(".editing_wait", self.container)
									.addClass("hide");
							});
						}),
					$(ce("div"))
						.addClass("refreshing generating_wait editing_wait hide")
				)
		);
		
		$(this.infoPanel).append(this.finalClear);
	},
	buildFilterRecallButtons: function(){
		var isCompound = this.isCompound();
		var ce = Moonshadow.helpers.ce;
		$(this.buttonHolder)
			.append(
				//recall filters button
				$(ce("div"))
					.addClass("universeTool clickable")
					.addClass(isCompound ? "sprite-filterDisabled" : "sprite-filter" )
					.attr({
						"title": isCompound ? "Filters cannot be recalled" : "Recall Universe Filters"
					})
					.click({"universe": this}, function(e){
						if(e.data.universe.isCompound()){
							return MUILayoverPanel.alert("Filteres cannot be recalled for a universe created from another universe, from a shape, or from a sample.");
						}
						e.data.universe.setPreviousFilters(true);
					}),
				//add recalled filters to current filters button
				$(ce("div"))
					.addClass("universeTool clickable")
					.addClass(isCompound ? "sprite-addFilterDisabled" : "sprite-addFilter" )
					.attr({
						"title": isCompound ? "Filters cannot be recalled" : "Add Universe Filter to Current Filter Settings"
					})
					.click({"universe": this}, function(e){
						if(e.data.universe.isCompound()){
							return MUILayoverPanel.alert("Filteres cannot be recalled for a universe created from another universe, from a shape, or from a sample.");
						}
						e.data.universe.setPreviousFilters(false);
					})
			);
	},
	buildTrashButton: function(){
		if(this.write_access){
			var ce = Moonshadow.helpers.ce;
			$(this.buttonHolder)
				.append(
					$(ce("div"))
						.addClass("sprite-trash clickable right")
						.attr({
							"title": "Delete Universe"
						})
						.click({"universe": this}, function(e){
							e.data.universe.deleteUniverse();
						})
				);
		}
	},
	buildCompositionPanel: function(){
		var ce = Moonshadow.helpers.ce;
		$(this.infoPanel)
			.append(
				$(ce("div"))
						.addClass("filterExpButton clickable")
						.append(
							$(ce("div"))
								.addClass("sprite-expander_right"),
							"Composition"
						)
						.click({'universe': this}, function(e) {
							var universe = e.data.universe;
							var panel = $(".filterExpPanel", universe.container)
								.addClass("hide")
								.empty();
							
							if($(".sprite-expander_right", this).hasClass("sprite-expander_right")){
								$(panel)
									.removeClass("hide")
									.append(universe.buildExplainFilters());
								$(".sprite-expander_right", this)
									.removeClass("sprite-expander_right")
									.addClass("sprite-expander_down");
							}else{
								$(".sprite-expander_down", this)
									.removeClass("sprite-expander_down")
									.addClass("sprite-expander_right");
						}
					}),
				$(ce("div"))
					.addClass("filterExpPanel selectable hide")
			);
		$(this.infoPanel).append(this.finalClear);
	},
	buildDescriptionPanel: function(){
		var ce = Moonshadow.helpers.ce;
		if(this.description && this.description.replace(/\s/g,"").length > 0){
			$(this.infoPanel).append(
				$(ce("div"))
					.addClass("infoPanelDesc")
					.append(
						this.description
					)
			);
			$(this.infoPanel).append(this.finalClear);
		}
	},
	buildCanvasserPanel: function(){
		if(this.canvassingEnabled()){
			
			var ce = Moonshadow.helpers.ce;
			
			this.registerIcon("assignToUser");
			$(this.buttonHolder)
				.append(
					$(ce("div"))
						.addClass("universeTool sprite-assignToUser clickable")
						.attr({
							"title": "Ground Game Options"
						})
						.click({"self":this}, function(e){
							var self = e.data.self;
							self.toggleSubPanel(
								this, 
								$(".canvasserPanel", self.container),
								null, "assignToUser"
							);
						})
				);
			
			var surveymanager = this.getControl().getManager().getControl('groundgame');
			this.ui.canvasserPanel = $(ce("div"))
				.addClass("canvasserPanel subPanel hide")
				.append(
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Assign Surveys"
						})
						.click({"surveymanager": surveymanager, "universe": this}, function(e){
							var surveymanager = e.data.surveymanager;
							var universe = e.data.universe;
							surveymanager.show("lists", function(){
								surveymanager.expandUniverseSection(universe.int_name);
							});
						}),
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Assign Users"
						})
						.click({"surveymanager": surveymanager, "universe": this}, function(e){
							var surveymanager = e.data.surveymanager;
							var universe = e.data.universe;
							surveymanager.show("users", function(){
								surveymanager.switchUserAssignmentContent("users");
								surveymanager.expandUserAssignmentSection(universe.int_name);
							});
						}),
					$(ce("input"))
						.attr({
							"type": "button",
							"value": "Assign Route",
							"title": this.cardinality > 2500 ? "This universe is too large (limit 2500) to route" : "Assign Route",
							"disabled": this.cardinality > 2500
						})
						.click({"universe": this}, function(event) {
							var universe = event.data.universe;
							var manager = universe.getControl().getManager();
							manager.getControl("routing").beginRouting(universe);
						})
				);
				
			$(this.infoPanel).append(this.ui.canvasserPanel);
			$(this.infoPanel).append(this.finalClear);
		}
	},
	getMeta: function(key){
		if(this.json_metadata[key]){
			return this.json_metadata[key];
		}
		return false;
	},
	setMeta: function(key, value, save, callback){
		this.json_metadata[key] = value;
		save && this.saveMeta(callback);
	},
	saveMeta: function(callback){
		this.alterUniverse({
				"json_metadata": this.json_metadata
			},
			null,
			function(result){
				if(result.result == "ok"){
					callback && callback();
				}
			}
		);
	},
	getPath: function(){
		return this.getMeta("path") || "__default";
	},
	getSurveys: function(){
		return this.getMeta("surveys") || [];
	},
	assignSurveys: function(surveyIds, callback){
		this.setMeta("surveys", surveyIds, true, callback);
	},
	assignSurvey: function(surveyId, callback){
		var surveyIds = this.getSurveys();
		if($.inArray(surveyId, surveyIds) == -1){
			surveyIds.push(surveyId);
		}
		this.assignSurveys(surveyIds, callback);
	},
	removeSurvey: function(surveyId, callback){
		var surveyIds = this.getSurveys();
		if(!surveyIds.length){
			return;
		}
		var surveyIndex = $.inArray(surveyId, surveyIds);
		if(surveyIndex != -1){
			surveyIds.splice(surveyIndex, 1);
		}
		this.assignSurveys(surveyIds, callback);
	},
	refreshUi: function(){
		$(this.container).replaceWith(this.buildUI(true));
		this.infoPanelBuilt = false;
	},
	removeUi: function(){
		$(this.container).remove();
		this.infoPanelBuilt = false;
	},
	setFirmInfo: function(firmInfo){
		this.firms = firmInfo;
	},
	getUniverseHash: function(){
		return $.md5([
			this.ext_name,
			this.int_name,
		    this.description,
		    this.purchase_state,
		    this.purchased,
		    this.unpurchased,
		    this.owner,
		    this.color,
		    this.read_access,
		    this.write_access,
		    this.firms
		]);
	},
	updateSelf: function(incomingData, firmInfo){
		var hashA = this.getUniverseHash();
		for(var i in incomingData){
			if(incomingData.hasOwnProperty(i)){
				if(i == "reports"){
					continue;
				}else{
					this[i] = incomingData[i];
				}
			}
		}
		if(firmInfo){
			this.setFirmInfo(firmInfo);
		}
		
		var hashB = this.getUniverseHash();
		if(hashA != hashB){
			this.refreshUi();
		}
	},
	getExportOptions: function(column_set){
		var manager = this.getControl().getManager();
		var dsObj = manager.getDatasource(this.datasource);
		if(dsObj["export"]){
			if(column_set != undefined){
				if(dsObj["export"][column_set]){
					return dsObj["export"][column_set];
				}
				return false;
			}
			return dsObj["export"];
		}
	},
	showAdSales: function(callback){
		var manager = this.getControl().getManager();
		if(!manager.shouldControlBeLoaded("MControlAdSales"))
			return callback(false);
		var adsales = manager.getControl("adsales");
		adsales.adSalesEnabled(callback);
	},
	buildContactPanel: function(){
		var self = this;
		var ce = Moonshadow.helpers.ce;
		
		var buildPanel = function(){
			$(self.infoPanel)
				.append(
					$(ce("div"))
						.addClass("ad_sales_panel subPanel hide")
				);
		};
		
		var buildButton = function(){
			self.registerIcon("adSales");
			return $(ce("div"))
				.addClass("universeTool sprite-adSales clickable")
				.attr({
					"title": "Contact these Voters"
				})
				.click({"self": self}, function(e){
					var self = e.data.self;
					self.toggleSubPanel(
						this, 
						$(".ad_sales_panel", self.container),
						null, "adSales"
					);
				});
		};
		
		var showButton = false;
		this.showAdSales(function(addSalesEnabled){
			var phoneCampsEnabled = self.parent.showPhoneOnlyOption();
			
			if(addSalesEnabled || phoneCampsEnabled){
				showButton = true;
			}
			
			if(showButton){
				buildPanel();
				
				if(addSalesEnabled){
					self.buildAdSalesPanel();
				}
				
				if(phoneCampsEnabled){
					self.buildPhoneCampPanel();
				}
				
				var target = $(".universeTool:last", self.buttonHolder);
				if(target){
					$(target).after(buildButton());
				}else{
					$(self.buttonHolder).append(buildButton());
				}
			}
		});
	},
	buildPhoneCampPanel: function(){
		var self = this;
		var ce = Moonshadow.helpers.ce;
		var campControl = this.getControl().getManager().getControl('phonecampaigns');
		$(".ad_sales_panel", this.infoPanel)
			.append(
				$(ce("input"))
					.attr({
						"type": "button",
						"value": "Phone Campaign"
					})
					.click(function(e){
						campControl.show({
							"universe_id": self.int_name, 
							"total_records": self.purchased
						});
					})
			);
	},
	buildAdSalesPanel: function(){
		var self = this;
		var ce = Moonshadow.helpers.ce;
		$(".ad_sales_panel", this.infoPanel)
			.append(
				$(ce("input"))
					.attr({
						"type": "button",
						"value": "QuickConnect"
					})
					.click({"self": this}, function(e){
						var manager = e.data.self.getControl().getManager();
						if(manager.shouldControlBeLoaded("MControlAdSales") && 
								e.data.self.write_access){
							var man = manager.getControl("adsales");
							man.asui.adSalesPanel(e.data.self, true);
						}
					}),
				function(){
					if(self.firms.length){
						return $(ce("input"))
							.attr({
								"type": "button",
								"value": "View Firms"
							})
							.click({"self": self}, function(e){
								var manager = e.data.self.getControl().getManager();
								if(manager.shouldControlBeLoaded("MControlAdSales") && 
										e.data.self.write_access){
									var man = manager.getControl("adsales");
									man.asui.showSelectedFirms(e.data.self);
								}
							});
					}
				}()
			);
		
		$(this.infoPanel).append(this.finalClear);
	},
	updatePurchasedCounts: function(){
		$(".purchase_counts", this.infoPanel)
			.remove();
		this.buildPurchasedCounts();
	},
	buildPurchasedCounts: function() {
		var ce = Moonshadow.helpers.ce;
		var control = this.getControl();
		var manager = control.getManager();
		var self = this;
		
		var countsPanel = $(ce("div"))
			.addClass("purchase_counts selectable");
		
		if (this.purchasingEnabled()) {
			var totalPurch, totalUnpurch, pt, et, ptl, etl, ptl, etl;
			var expireType = this.isExpiringSetType();
		
			var totalCard = Moonshadow.helpers.numberCommas(
				parseInt(this.cardinality, 10)
			);
			
			var totalRes = this.countsObj.Residences &&
				Moonshadow.helpers.numberCommas(
					parseInt(this.countsObj.Residences, 10)
				) || false;
			
			if (expireType) {
				pt = this.purchaseTime("hr");
				et = this.expireTime("hr");

				ptl = "Date Purchased:";
				etl = "Date Expires:";
				
				if (this.expired) {
					ptl = "Original Purchase Date:";
					etl = "Date Expired:";
				}
			}else{
				var totalPurch = Moonshadow.helpers.numberCommas(
					parseInt(this.numberOfRecords(), 10)
				);
				var totalUnpurch = Moonshadow.helpers.numberCommas(
					parseInt(this.numberOfRecords(true), 10)
				);
			}
			
			$(countsPanel)
				.append(
					$(ce("span"))
						.addClass("infoPanelInfo")
						.append(
							$(ce("label"))
								.append(expireType ? ptl : "Purchased:"),
							$(ce("span"))
								.append(expireType ? pt || "" : totalPurch)
						),
					$(ce("span"))
						.addClass("infoPanelInfo")
						.append(
							$(ce("label"))
								.append(expireType ? etl : "Unpurchased:"),
							$(ce("span"))
								.append(expireType ? et || "" : totalUnpurch)
						),
					$(ce("span"))
						.addClass("infoPanelInfo")
						.append(
							$(ce("label"))
								.append("Total:"),
							$(ce("span"))
								.append(totalCard)
						),
					function(){
						if (totalRes) {
							return $(ce("span"))
								.addClass("infoPanelInfo")
								.append(
									$(ce("label"))
										.append("Households:"),
									$(ce("span"))
										.append(totalRes)
								)
						}
						return "";
					}(),
					$(ce("span"))
						.addClass("infoPanelInfo")
						.append(
							$(ce("label"))
								.append("Universe ID:"),
							$(ce("span"))
								.append(this.int_name)
						),
					function(){
						if(manager.getOption("user") != self.owner){
							return $(ce("span"))
								.addClass("infoPanelInfo")
								.append(
									$(ce("label"))
										.append("Universe Owner:"),
									$(ce("span"))
										.append(self.owner)
								)
						}
						return "";
					}()
				);
		}
		
		$(this.infoPanel).append(countsPanel);
		$(this.infoPanel).append(this.finalClear);
		this.enableExports && this.enableExports();
	},
	numberOfRecords: function(unpurchased){
		if(unpurchased){
			if(typeof this.unpurchased != "undefined"){
				return this.unpurchased;
			}
		}
		if(typeof this.purchased != "undefined"){
			return this.purchased;
		}
		if(this.expire_time && this.cardinality){
			return this.cardinality;
		}
		return this.cardinality;
	},
	enableUniverseInfo: function(enable){
		this.infoDisabled = !enable;
		if(this.purchase_state == 20){
			this.changePurchaseState(10, true);
		}
		this.updatePurchaseStateUI();
	},
	isExpiringSetType: function(){
		if(this.expire_time != undefined)
			return true;
		return false;
	},
	purchaseTime: function(returnType){
		if(this.purchase_time)
			return this.returnDateTime(this.purchase_time, returnType);
	},
    expireTime: function(returnType){
		if(this.expire_time)
			return this.returnDateTime(this.expire_time, returnType);
	},
	returnDateTime: function(timeString, returnType){
		var dateObj = new Date(parseInt(timeString, 10) * 1000);
		if(dateObj){
			if(returnType == "obj")
				return dateObj;
			if(returnType == "string")
				return dateObj.getTime();
			if(returnType == "hr"){
				var outStr = "";
				outStr += dateObj.getMonth() + 1;
				outStr += "/";
				outStr += dateObj.getDate();
				outStr += "/";
				outStr += dateObj.getFullYear();
				return outStr;
			}
		}
	},
	explainFilters: function(){
		var control = this.getControl();
		var manager = control.getManager();
		var filterscontrol = manager.getControl("filterscontrol");
		var pairs = filterscontrol.explainFilters(this.datasource, this.filter);
		var dsExt = manager.getDatasource(this.datasource).ext_name;
		pairs.push({				
			"ext": "Data Set",
			"val": [dsExt]
		});
		
		if(this.isExpiringSetType()){
			pairs.push({
				"ext": "Number of Records",
				"val": [this.numberOfRecords()]
			});
			
			var pt = this.purchaseTime("hr");
			if(pt){
				pairs.push({
					"ext": "Purchase Date",
					"val": [pt]
				});
				var et = this.expireTime("hr");
				if(et){
					pairs.push({
						"ext": "Expiration Date",
						"val": [et]
					});
				}
			}
		}
		
		if(this.type && this.type == 2){
			var p = {
				"ext": "Sample Type",
				"val": ["Random"]
			};
			
			if(this.getDynamicAuxData(1)){
				p.val = ["Cluster"];
			}
			
			pairs.push(p);
		}
		
		if(this.purchased != undefined){
			pairs.push({
				"ext": "Purchased Records",
				"val": [this.purchased]
			});
		}
		
		if(this.unpurchased != undefined){
			pairs.push({
				"ext": "Unpurchased Records",
				"val": [this.unpurchased]
			});
		}
		
		//get first 2 levels of count for displaying cardinality in universe at purchase
		if(this.counts && this.counts.length > 0){
			this.makeCountsObj();
			if(this.countsObj['Voters'] != undefined){
				pairs.push({
					"ext": "Total Records",
					"val": [this.countsObj['Voters']]
				});
			}
			if(this.countsObj['Residences'] != undefined){
				pairs.push({
					"ext": "Total Households",
					"val": [this.countsObj['Residences']]
				});
			}
		}
		
		return pairs;
	},
	buildExplainFilters: function(exclusions){
		var ce = Moonshadow.helpers.ce;
		var returnElems = [];
		var parsedNames = this.explainFilters();

		for(var i = 0, l = parsedNames.length; i < l; ++i){
			var ext = parsedNames[i].ext;
			if(exclusions && $.inArray(ext, exclusions) > -1){
				continue;
			}
			
			if(parsedNames[i].val && parsedNames[i].val.length > 0) {
				if(typeof parsedNames[i].val == "string"){
					returnElems.push(
						$(ce("span"))
							.append(ext, ": ", parsedNames[i].val)
							.get(0)
					);
					continue;
				}
				if(typeof parsedNames[i].val == "object" && parsedNames[i].val.length == 1){
					returnElems.push(
						$(ce("span"))
							.append(ext, ": ", parsedNames[i].val[0])
							.get(0)
					);
					continue;
				}
				
				returnElems.push(
					$(ce("span"))
						.append(ext, ":")
						.get(0)
				);
				for(var k = 0, ll = parsedNames[i].val.length; k < ll; ++k) {
					returnElems.push(
						$(ce("span"))
							.addClass("sub")
							.append(parsedNames[i].val[k])
							.get(0)
					);
				}
			}
		}
  
		return returnElems;
	},
	purchasingEnabled: function(){
		return this.parent.purchasingEnabled();
	},
	canvassingEnabled: function(){
		return this.parent.canvassingEnabled();
	},
	surveysExportable: function(){
		return this.parent.surveysExportable();
	},
	exportsEnabled: function(){
		var show = true;
		//Criteria to determine weather to load export interface for this universe or not (shown by default):
		////the "export" field list specification does not exist in the configuration:
		if(!this.getExportOptions())
			show = false;
		//if user does not have write_access to this universe, don't show
		if(!this.write_access)
			show = false;
		if(this.getControl().getManager().getOption("user_details.user_type") == "read-only")
			show = false;
		return show;
	},
	isFullyPurchased: function(){
		if (this.purchased != undefined && this.purchased > 0) {
			return true;
		}
		return false;
	},
	notExportableReason: function(){
		if(this.isFullyPurchased())
			return false;
		
		if (!this.purchased) {
			return {
				"id": "no_records_purchased",
				"reason": "No Records Purchased"
			};
		}
		if(this.privs == "read-only"){
			return {
				"id": "unprivileged_user",
				"reason": "Unprivileged user"
			};
		}
	},
	allRecordsPurchased: function(){
		if(this.expire_time){
			if(this.purchase_state > 20 && !this.expired)
				return true;
			return false;
		}
		if(this.unpurchased)
			return false;
		return true;
	},
	isChecked: function(){
		if(this.getFilterValue())
			return true;
		return false;
	},
	setPreviousFilters: function(clearPrev){
		if (this.isCompound()) {
			return;
		}

		var control = this.getControl();
		var manager = control.getManager();
		var filterscontrol = manager.getControl("filterscontrol");
		
		if (clearPrev) {
			control.onClearFilters();
		}
			
		filterscontrol.parseFilters(this.datasource, [], $.extend(true, {}, this.filter));
		control.updateFilterCounts();

		this.mapNotify("filterchange", [this.datasource]);
	},
	showFilterOrder: function(){
		$("#order_"+this.int_name).removeClass("hide");
	},
	hideFilterOrder: function(){
		$("#order_"+this.int_name).addClass("hide");
	},
	checkFilter: function(delayed){
		var cb = this.checkbox && this.checkbox.checkbox;
		if(cb && !cb.checked){
			cb.checked = true;
			return this.onCheckboxChange(cb, delayed);
		}
	},
	unCheckFilter: function(delayed){
		var cb = this.checkbox && this.checkbox.checkbox;
		if(cb && cb.checked){
			cb.checked = false;
			return this.onCheckboxChange(cb, delayed);
		}
	},
	onCheckboxChange: function(checkbox, delayed) {
		var checked = checkbox.checked;
		this.parent.storeFilterOrder(this.int_name, checked, delayed);
		if(checked) {
			$(this.label).addClass("selected");
			this.setFilterValue({'value': 1, 'order': this.order}, delayed);
		} else {
			$(this.label).removeClass("selected");
			this.order = 0;
			this.clearFilterValue(delayed);
		}
		this.setFilterCountAtPath(this.getPath(), checked ? 1 : -1);
		if(!delayed){
			this.checkFilterCount();
		}
		this.perculateChange();
		return this.datasource;
	},
	setFilterCountAtPath: function(path, num){
		this.parent.setFilterCounts(path, num);
	},
	getParentHasFilters: function(){
		return this.parent.getMarkedUniversesAtPath(this.getPath()).length;
	},
	getLastChecked: function(){
		var path = this.getPath();
		return this.parent.lastChecked[path];
	},
	setLastChecked: function(checkbox){
		var path = this.getPath();
		this.parent.lastChecked[path] = checkbox;
	},
	perculateChange: function(){
		this.parent.updateFilterCounts(this.getPath());
		this.parent.perculateChange();
	},
	setFilterValue: function(filter, delayed) {
		var filters = this.getFiltersControl();
		if(delayed){
			filters.setFilterValue(this.datasource, this.getDataPath().join('|'), filter);
		}else{
			filters.setFilter(this.datasource, this.getDataPath().join('|'), filter);
		}
	},
	clearFilterValue: function(delayed) {
		var filters = this.getFiltersControl();
		if(delayed){
			filters.clearFilterValue(this.datasource, this.getDataPath().join('|'));
		}else{
			filters.clearFilter(this.datasource, this.getDataPath().join('|'));
		}
	},
	countFilters: function() {
		var filters = this.getFiltersControl();
		return filters.countFilters(this.datasource, this.getDataPath().join('|'));
	},
	updateFilterOrder: function(orderInt){
		if (typeof orderInt == "number") {
			this.changeFilterOrder(orderInt);
		}else{
			this.changeFilterOrder(0);
		}
		$("#order_"+this.int_name).empty().append(orderInt);
	},
	getColor: function() {
		return this.color;
	},
	setColor: function(color) {
		this.color = color;
	},
	setColorIcon: function(color){
		this.ui.colorPicker && (this.ui.colorPicker.style.backgroundColor = "#" + color);
	},
	updateColorModel: function() {
		var manager = this.getControl().getManager();
		if (manager.getOption("neutered") == 1) {
			return false;
		}

		this.updateColors();
	},
	updateColors: function() {
		var self = this;
		var ajax = new Moonshadow.Ajax();
		this.alterUniverse({"color": this.color}, ajax, function(result) {
			if (result.result === 'ok') {
				$(self.editUniverseButn).click();
			} else {
				throw new Error(result.message || 'Error updating universe');
			}
		});
		ajax.execute(function(){
			self.parent.refreshColorBy();
		});
	},
	assignReadOnlyUser: function(username, callback){
		var caller = this;
		if($.inArray(username, this.read_users) == -1){
			caller.read_users.push(username);
			this.alterUniverse({"read_users": this.read_users}, null, callback);
		}
	},
	removeReadOnlyUser: function(username, callback){
		var caller = this;
		if($.inArray(username, this.read_users) > -1){
			for(var i = 0, l = this.read_users.length; i < l; ++i){
				if(this.read_users[i] == username){
					this.read_users.splice(i, 1);
					break;
				}
			}
			this.alterUniverse({"read_users": this.read_users}, null, callback);
		}
	},
	alterUniverse: function(properties, ajax, callback){
		var universeControl = this.getControl().getManager().getControl("universecontrol");
		universeControl.alterUniverse(
			this.int_name, this.datasource, properties, ajax, callback
		);
	},
	editNameDesc: function(name, desc, callback){
		var self = this;
		this.alterUniverse({
				"name": name,
				"description": desc
			}, null,
			function(result){
				if(result.result == "ok"){
					self.ext_name = name;
					self.description = desc;
					self.refreshUi();
					self.show();
					callback();
				} else {
					throw new Error(result.message || 'Error updating universe');
				}
			}
		);
	},
	deleteUniverse: function(bypassConfirmation){
		if(!bypassConfirmation){
			var self = this;
			var delUniv = function(){
				self.unRegisterEstimate();
				self.parent.deleteUniverse(self, function(){
					self.adjustExpander();
				});
			};
			MUILayoverPanel.confirm({
				"message": 'Delete universe "' + this.ext_name + '" ?',
				"callback": function(res, id, hide){
					if(res){
						delUniv();
					}
					hide();
				}
			});
		}
	},
	changePurchaseState: function(state, skipNotify) {
		//this does not run alter_universe query, just ui
		var universeControl = this.getControl().getManager().getControl("universecontrol");
		var universeData = universeControl.getUniverse(this.datasource, this.int_name);
		this.purchase_state = state;
		universeData.purchase_state = state;
		this.updatePurchaseStateUI();
		!skipNotify && this.getControl().getManager().dataObservers.notify("itemsincartchanged");
	},
	getPurchasedStatus: function(){
		// 0: unpurchase  1: partially purchased  2: totally purchased
		if(this.purchased === 0){
			return 0;
		}else if(this.cardinality !== this.purchased){
			return 1;
		}else{
			return 2;
		}
	},
	determinePurchaseState: function(){
		var state = this.purchase_state;
		
		if (this.unpurchased && parseInt(this.unpurchased, 10) === 0)
			state = -1;

		if(this.purchased && this.purchased == this.cardinality)
			state = -1;
		
		if(!this.write_access)
			state = -1;
		
		return state;
	},
	updatePurchaseStateUI: function(){
		
		this.disabled = false;
		
		if(this.parent.checkPrePurchased()){
			return $(this.cartButton)
				.addClass("hide");
		}
		
		var state = this.determinePurchaseState();
		
		$(this.ui.infoButton)
			.addClass("clickable");
		
		$(this.container)
			.removeClass("univ_wait");
		
		$(this.cartButton)
			.removeClass("sprite-cart_in sprite-cart_out cart_wait sprite-cart_purchased");

		switch(state){
			case 0:
			case 1:
				$(this.cartButton)
					.addClass("clickable sprite-cart_in")
					.attr({
						"title": "Add to Cart"
					})
					.data("enabled", true);
				break;
			case 10:
				$(this.cartButton)
					.addClass("clickable sprite-cart_out")
					.attr({
						"title": "Remove from Cart"
					})
					.data("enabled", true);
				break;
			case 20:
				this.disabled = true;
				this.hide();
				
				$(this.ui.infoButton)
					.removeClass("clickable");

				$(this.container)
					.addClass("univ_wait");
				
				$(this.cartButton)
					.addClass("cart_wait")
					.attr({
						"title": "Please wait. Verifying"
					})
					.data("enabled", false);
				break;
			default:
				$(this.cartButton)
					.addClass("sprite-cart_purchased")
					.attr({
						"title": this.write_access ? "All Records Purchased" : "Read only access"
					})
					.data("enabled", false);
		}
	},
	attach: function(branch) {
		if(typeof branch[this.int_name] != "object")
			branch[this.int_name] = {};

		return branch[this.int_name];
	},
	changeFilterOrder: function(inInt){
		var filter = this.getFilterValue();
		if(filter){
			filter.order = inInt;
		}
	},
	clearSpecificFilter: function() {
		if(this.container){
			$.each($(".checkbox input",this.container),function(k,v) {
				v.checked = false;
				v.disabled = false;
			});
	
			$.each($(".label.selected",this.container),function(k,v) {
				$(v).removeClass("selected");
			});
		}
	},
	getFilterValue: function() {
		var filters = this.getFiltersControl();
		return filters.getFilter(this.datasource, this.getDataPath().join('|'));
	},
	clearFilters: function(){
		this.clearFilterValue()
		this.clearSpecificFilter();
	},
	clearSpecificColor: function() {
		this.color = this.defaultColor;
		var selectedColor = this.color;
		$.each($(".color-picker",this.container),function(k,v) {
			v.style.backgroundColor = "#"+selectedColor;
			$(v).data("selectedColor",selectedColor);
		});
	},
	enableExports: function(){
		if(this.control.isFullyPurchased() && this.control.reportsPanel){
			$(".subUnivTool", this.control.reportsPanel).each(function(k, v){
				v.title = v.title.replace(" (Disabled: No Records Purchased)","");
				$(v).removeClass("disabled").addClass("clickable");
			});
		}
	},
	mapNotify: function(events, data){
		if(typeof events == "string"){
			events = [events];
		}
		var mapObservers = this.getControl().getManager().mapObservers;
		for(var i = 0, l = events.length; i < l; ++i){
			mapObservers.notify(events[i], data);
		}
	},
	deleteExport: function(reportId){
		this.estimatesDirty = true;
		var self = this;
		this.getControl().getManager().getControl("reportqueue").deleteReport(reportId, function(){
			self.mapNotify("updatedownloadui", reportId);
		});
	},
	downloadReport: function(reportId){
		var reportq = this.getControl()
			.getManager()
			.getControl("reportqueue");
		
		reportq
			.downloadReport
			.apply(reportq, [reportId]);

		this.mapNotify("updatedownloadui", reportId);
	},
	buildReportsPanel: function(){
		if(this.exportsEnabled()){
			var ce = Moonshadow.helpers.ce;
			
			this.registerIcon("reports");
			this.reportsButn = $(ce("div"))
				.addClass("universeTool sprite-reports clickable")
				.attr({
					"title": "Create Lists and Data Files"
				})
				.click({"self": this}, function(e){
					var self = e.data.self;
					self.toggleSubPanel(
						this, 
						$(".reportsPanel", self.container),
						null, "reports"
					);
				});

			$(this.buttonHolder).append(this.reportsButn);
			
			var self = this;
			this.reportsPanel = $(ce("div"))
				.addClass("reportsPanel subPanel hide")
				.append(function(){
					if(self.getControl().options.reports_docs) {
						return self.getControl().createDocList(
							self.getControl().options.reports_docs
						)
					}
				}());

			$(this.infoPanel).append(this.reportsPanel);
			
			this.reportsSubPanel = $(ce("div"))
				.addClass("reportsSubPanel subPanel hide");
			
			$(this.infoPanel).append(this.reportsSubPanel);
			
			this.createExportTypeButtons();
			
			$(this.infoPanel).append(this.finalClear);
		}
	},
	createExportTypeButtons: function(){
		var self = this;
		var ce = Moonshadow.helpers.ce;
		$.each(self.reportTypes, function(key, typeOpts) {
			if(!typeOpts.included)
				return true;
			
			self.registerIcon(typeOpts.typeId);
			
			var className = "subUnivTool universeTool";
			var innerClassName = "sprite-" + typeOpts.typeId;
			
			var availableUnpurchased = false;
			if(typeOpts.isAvailableUnpurchased){
				availableUnpurchased = typeOpts.isAvailableUnpurchased(self);
			}
			
			var notExportableReason = self.notExportableReason();
			if(!availableUnpurchased && notExportableReason){
				typeOpts.enabled = false;
				className += " disabled";
				innerClassName = "sprite-" + typeOpts.typeId + "Disabled";
				typeOpts.disabledReason = " (Disabled: " + notExportableReason.reason + ")";
			}else{
				typeOpts.enabled = true;
				className += " clickable";
				typeOpts.disabledReason = "";
			}

			var buttonElem = $(ce("div"))
				.addClass(className)
				.attr({
					"id": typeOpts.id,
					"title": typeOpts.title + typeOpts.disabledReason,
					"name": typeOpts.typeId
				})
				.append(
					$(ce("div"))
						.addClass(innerClassName)
				);
				
			if(typeOpts.enabled){
				var reports = self.getReportsForTab(typeOpts.valid_types);
				if(reports.length){
					for(var i = 0, l = typeOpts.tabs.length; i < l; ++i){
						if(!typeOpts.tabs[i].disabled){
							typeOpts.tabs[i].active = false;
							if(typeOpts.tabs[i].id == "download"){
								typeOpts.tabs[i].active = true;
							}
							if(typeOpts.tabs[i].id == "generatenb"){
								typeOpts.tabs[i].active = true;
							}
						}
					}
				};
				
				var buttonElemSubPanel = $(ce("div"))
					.addClass("subPanelSection hide")
					.attr({"id": typeOpts.typeId})
					.append(
						$(ce("div"))
							.addClass("universeSubTool sprite-" + typeOpts.typeId + "Selected")
							.attr({
								"title": typeOpts.title
							}),
						$(typeOpts.tabs).map(function(key, tab){
							if(typeOpts.hasSpecialTabConditions){
								typeOpts.hasSpecialTabConditions(self, tab);
							}
							return self.addReportSubTab(tab);
						}),
						$(ce("div"))
							.addClass("sub_panel_closer clickable sprite-cancel")
							.attr({
								"title": "Close panel"
							})
							.click({"universe": self}, function(e){
								var universe = e.data.universe;
								universe.closeSubPanelSection();
							}),
						$(typeOpts.tabs).map(function(key, tab){
							return self.addReportSubTabContent(
								typeOpts.title, key, tab, 
								$(typeOpts.uiOpts).filter(function(key, opt){
									if(opt.tabLocation == tab.id)
										return true;
								})
								.toArray(), typeOpts.hasSpecialOptConditions
							);
						})
					);
				
				$(self.reportsSubPanel).append(buttonElemSubPanel);
				
				$(buttonElem).click({
						"typeOpts": typeOpts,
						"universe": self,
						"buttonElemSubPanel": buttonElemSubPanel
					}, function(e){
						var open = $(this).hasClass("selected");
						var universe = e.data.universe;
						universe.closeReportsSubPanel();
						if(!open){
							universe.openReportsSubPanel(
								this, 
								e.data.buttonElemSubPanel, 
								e.data.typeOpts.tabs[0],
								e.data.typeOpts.typeId
							);
						}
					}
				);
			}
			$(self.reportsPanel).append(buttonElem);
		});
	},
	toggleSubPanel: function(button, panel, offOn, className){
		if(offOn == null){
			offOn = $(panel).hasClass("hide");
		}
		if(offOn){
			this.openSubPanel(button, panel, className);
		}else{
			this.closeSubPanels();
		}
	},
	openReportsSubPanel: function(target, buttonElemSubPanel, tab, className){
		$(".reportsSubPanel", this.container).removeClass("hide")
		$(target).addClass("selected");
		$("div", target)
			.removeClass("sprite-" + className)
			.addClass("sprite-" + className + "Selected");
		$(buttonElemSubPanel).removeClass("hide");
		this.activateTab(tab);
	},
	openSubPanel: function(button, panel, className){
		this.closeSubPanels();
		this.selectIcon(className);
		$(panel).removeClass("hide");
	},
	closeSubPanels: function(){
		this.deselectIcons(".buttonHolder");
		
		$(".subUnivTool", this.container)
			.removeClass("selected");
		
		$(".subPanel", this.container)
			.addClass("hide");
			
		this.closeReportsSubPanel();
	},
	closeReportsSubPanel: function(){
		this.deselectIcons(".reportsPanel");
		$(".reportsSubPanel", this.container).addClass("hide");
		this.closeSubPanelSection();
	},
	closeSubPanelSection: function(){
		$(".subPanelSection", this.reportsSubPanel).addClass("hide");
		$(".subUnivTool", this.reportsPanel)
			.removeClass("selected");
		this.unRegisterEstimate();
	},
	buildNextButton: function(tabInfo, index){
		if(tabInfo.nextButton){
			var ce = Moonshadow.helpers.ce;
			return $(ce("div"))
				.addClass("report_button next_button clickable")
				.addClass(tabInfo.nextButton.className)
				.append(tabInfo.nextButton.title)
				.click({"self": this, "index": index, "tabInfo": tabInfo}, function(e){
					!$(this).hasClass("disabled_button") &&
					e.data.self[e.data.tabInfo.nextButton.action] && 
					e.data.self[e.data.tabInfo.nextButton.action](e.data.tabInfo, e.data.index + 1, this);
				});
		}
	},
	enableSurveys: function(e){
		var checked = this.checked;
		var holder = $(this).closest(".sub_holder");
		var allSurveysCont = $(".all_surveys", holder);
		var universe = e.data.universe;
		if(checked){
			$(allSurveysCont)
				.removeClass("hide");
			$(".all_surveys input", holder)
				.attr({
					"checked": true
				});
			$(".survey_names select", holder)
				.attr({
					"disabled": true
				});
		}else{
			$(".all_surveys input", holder)
				.attr({
					"checked": false
				});
			e.data.universe.includeAllSurveys(e);
			$(allSurveysCont)
				.addClass("hide");
		}
	},
	includeAllSurveys: function(e){
		var holder = $(e.target).closest(".sub_holder");
		var self = $(".all_surveys input", holder).get(0);
		var surveyNames = $(".survey_names", holder);
		$("select", surveyNames)
			.attr({
				"disabled": self.checked
			});
		$(".survey_export_item", holder).each(function(key, surveyItem){
			var data = $(surveyItem).data();
			data.removeSurveyItem(data.selector, data.selectedOption, surveyItem);
		});
	},
	addSurveyItem: function(e){
		if($(e.target).find(":selected").not("[value]").length > 0)
			return false;
		
		var optInfo = e.data.opt;
		var holder = $(e.target).closest(".sub_holder");
		
		var selectedOption = $(e.target).find(":selected").detach();
		var selectedValue = $(selectedOption).val();
		var selectedText = $(selectedOption).text();
		var self = e.data.universe;
		
		var ce = Moonshadow.helpers.ce;
		$(holder)
			.append(
				$(ce("div"))
					.addClass("survey_export_item")
					.attr({
						"title": selectedText
					})
					.append(
						$(ce("input"))
							.addClass("survey_export_field")
							.attr({
								"type": "hidden",
								"value": selectedValue,
								"name": "survey_export_field"
							}),
						$(ce("span"))
							.addClass("remove_survey clickable")
							.append("x")
							.attr({
								"title": "Remove " + selectedText
							})
							.click(function(e){
								var data = $(this).closest(".survey_export_item").data();
								data.removeSurveyItem(data.selector, data.selectedOption, e.target, data.limit);
							}),
						($(".survey_export_item", holder).length + 1) + ": " + selectedText
					)
					.data({
						"selector": e.target, 
						"selectedOption": selectedOption,
						"limit": optInfo.limit,
						"removeSurveyItem": function(selector, selectedOption, target, limit){
							$(selector)
								.append(selectedOption);
							$("option:not([value])", selector).attr({"selected": true});
							$(selector)
								.attr({
									"disabled": limit && $(".survey_export_item", target).length >= limit
								});
							$(target).closest(".survey_export_item").remove();
						}
					})
			);
		
		$(e.target)
			.attr({
				"disabled": optInfo.limit && $(".survey_export_item", holder).length >= optInfo.limit
			});
	},
	addReportSubTabContent: function(typeName, index, tabInfo, tabOpts, hasSpecialOptConditions){
		var self = this;
		var ce = Moonshadow.helpers.ce;
		var makeOptionHidden = function(opt, results){
			var val = results && results[0] && results[0].val ? results[0].val : null;
			if(tabInfo.parent[opt.id]){
				val = tabInfo.parent[opt.id];
			}

			return $(ce("input"))
				.addClass(opt.gatherable ? "gatherable" : false)
				.attr({
					"name": opt.id,
					"value": val,
					"type": "hidden"
				})
				.get(0);
		};
		
		var makeOptionSelect = function(opt, results){
			return $(ce("select"))
				.addClass("exp_opt_select")
				.addClass(opt.gatherable ? "gatherable" : false)
				.attr({
					"name": opt.id
				})
				.append(
					$(results).map(function(key, item){
						var attr = {};
						if(item.val){
							attr.value = item.val;
						}
						if(item.disabled){
							attr.disabled = item.disabled;
						}
						if(tabInfo.parent[opt.id] && tabInfo.parent[opt.id] == item.val){
							attr.selected = true;
						}
						return $(ce("option"))
							.attr(attr)
							.append(item.name)
							.get(0);
					}).toArray()
				);
		};
		
		var makeOptionCheckbox = function(opt){
			
			var checkbox = $(ce("input"))
				.addClass(opt.gatherable ? "gatherable" : false)
				.attr({
					"type": "checkbox",
					"name": opt.id,
					"checked": opt.checked,
					"value": true
				});

			return checkbox;
		};
		
		var makeOptionText = function(opt, results){
			var val = results && results[0] && results[0].val ? results[0].val : null;
			if(tabInfo.parent[opt.id]){
				val = tabInfo.parent[opt.id];
			}
			return $(ce("input"))
				.addClass(opt.gatherable ? "gatherable" : false)
				.attr({
					"type": "text",
					"name": opt.id,
					"value": val
				});
		};
		
		var makeOptionButton = function(opt){
			return $(ce("dev"))
				.addClass("report_button clickable")
				.append(opt.title)
				.get(0);
		};
		
		var makeOptionLabel = function(opt, results){
			var message = results && results[0] && results[0].val ? results[0].val : null;
			if(message){
				return $(ce("label"))
					.addClass("report_label")
					.append(message)
					.get(0);
			}
		};
		
		var optionSwitch = function(opt, results, overrideType){
			var inputType = opt.inputType;
			if(overrideType){
				inputType = overrideType;
			}
			switch(inputType){
				case "checkbox":
					return makeOptionCheckbox(opt);
				case "hidden":
					return makeOptionHidden(opt, results);
				case "select":
					if(!results || !results.length)
						return makeOptionCheckbox(opt);
					if(results.length > 1)
						return makeOptionSelect(opt, results);
					return;
				case "button":
					return makeOptionButton(opt);
				case "text":
					return makeOptionText(opt, results);
				case "label":
					return makeOptionLabel(opt, results);
			}
		};
		
		var buildOption = function(opt){
			
			var optionControl = $(ce("div"));
			if(opt.options && typeof opt.options == "function"){
				opt.options(null, self, function(results, overrideType){
					optionControl = optionSwitch(opt, results, overrideType);
				});	
			}else{
				optionControl = optionSwitch(opt, opt.options);
			}
			
			if(hasSpecialOptConditions){
				var specialOptConditions = hasSpecialOptConditions(self, optionControl);
			}
			
			if(!optionControl)
				return false;
			
			if(opt.onAction){
				for(var i in opt.onAction){
					if(!opt.onAction.hasOwnProperty(i)){
						continue;
					}
					var callback = opt.onAction[i]
					if(typeof callback == "string"){
						callback = self[callback];
					}
					$(optionControl)
						.on(i, {
							"tabInfo": tabInfo,
							"tabOpts": tabOpts,
							"universe": self,
							"opt": opt
						},
						callback
					);
				}
			}
			if(opt.reportsDirty){
				$(optionControl).on(
					"change",
					{"self": self},
					function(e){
						e.data.self.estimatesDirty = true;
					}
				);
			}
			
			if(opt.disabled != undefined){
				$(optionControl).attr({"disabled": opt.disabled});
			}
			
			if($(optionControl).attr("type") == "hidden")
				return optionControl;
			
			if(opt.inputType == "button")
				return $(ce("div"))
					.addClass(opt.className || "report_option")
					.append(
						optionControl
					).get(0);
			
			return $(ce("div"))
				.addClass(opt.className || "report_option")
				.append(
					$(ce("label"))
						.append(opt.title, ": "),
					optionControl,
					function(){
						return opt.limit ? " Max: " + opt.limit : ""
					}()
				).get(0);
		};
		
		tabInfo.ui.content = $(ce("div"))
			.addClass("sub_content"+(tabInfo.active ? "" : " hide"))
			.append(
				$(ce("div"))
					.addClass("sub_content_header")
					.append(tabInfo.description.replace(/%typeName%/g, typeName)),
				$(ce("div"))
					.addClass("sub_holder")
					.append(
						$(tabOpts)
							.map(function(key, opt){
								var uiElem = buildOption(opt);
								if(uiElem){
									opt.uiElem = uiElem;
									return uiElem;
								}
							})
					),
				$(ce("div"))
					.addClass("sub_content_footer")
					.append(
						this.buildNextButton(tabInfo, index),
						$(ce("div"))
							.addClass("clear")
					)
			);
		
		return $(tabInfo.ui.content).get(0);
	},
	estimatesRefreshing: function(tabInfo, onOff){
		$(".generate_info:first-child", tabInfo.ui.content)
			.addClass(onOff && "refreshing")
			.removeClass(!onOff && "refreshing");
	},
	updateEstimates: function(tabInfo, estimateItems){
		this.estimatesRefreshing(tabInfo, true);

		var self = this;
		var reportOptions = tabInfo.parent;
		var target = this.getTargetFromTabInfo(tabInfo);
		if(target){
			this.fetchEstimate(reportOptions, target, function(data){
				self.updateEstimateUi(data, tabInfo, estimateItems);
				self.estimatesRefreshing(tabInfo, false);
			});
		}
	},
	fetchEstimate: function(reportOptions, target, callback){
		var self = this;
		this.gatherSelectedReportOptions(reportOptions, -1, target, function(options){
			var queue = self.getControl().getManager().getControl("reportqueue");
			queue.getEstimates(options.report_type, options.num_records, 0, callback);
		});
	},
	updateEstimateUi: function(data, tabInfo, estimateItems){
		this.parseInfoProperties(estimateItems, data.estimate);
		for(var i = 0, l = estimateItems.length; i < l; ++i){
			if(estimateItems[i].bound && estimateItems[i].bound.length){
				$("." + estimateItems[i].bound.join("-"), tabInfo.ui.content)
					.val(estimateItems[i].value);
			}
		}
	},
	getTargetFromTabInfo: function(tabInfo){
		if(tabInfo && tabInfo.ui){
			if(tabInfo.ui.content && tabInfo.ui.content.length){
				return tabInfo.ui.content;
			}
		}
	},
	buildEstimates: function(universe, tabInfo, estimateItems){
		var manager = this.getControl().getManager();

		if(!$(".sub_holder", tabInfo.ui.content).children().length){
			var ce = Moonshadow.helpers.ce;
			$(".sub_holder", tabInfo.ui.content)
				.append(
					$(estimateItems).map(function(key, option){
						return $(ce("div"))
							.addClass("generate_info")
							.addClass(key === 0 && "refreshing")
							.append(
								$(ce("label"))
									.append(option.title),
								$(ce("input"))
									.addClass(option.bound && option.bound.join("-"))
									.attr({
										"type": "text",
										"disabled": true
									})
									.val(option.value || "--")
							).get(0)
					})
				);
			
			$(".next_button", $(".sub_content_footer", tabInfo.ui.content))
				.after(
					$(ce("div"))
						.addClass("refreshing generating_wait hide")
				);

			this.estimatesDirty = true;
		}
		
		universe.registerEstimate(tabInfo, estimateItems);
		if(this.estimatesDirty){
			universe.updateEstimates(tabInfo, estimateItems);
			this.estimatesDirty = false;
		}
	},
	unRegisterEstimate: function(){
		this.parent.unRegisterEstimateUpdater(this);
	},
	registerEstimate: function(tabInfo, estimateItems){
		var reportOptions = tabInfo.parent;
		var target = this.getTargetFromTabInfo(tabInfo);
		var self = this;
		this.gatherSelectedReportOptions(reportOptions, -1, target, function(options){
			self.parent.registerEstimateUpdater(self, tabInfo, estimateItems, options);
		});
	},
	parseInfoProperties: function(estimateItems, data){
		for(var i = 0, l = estimateItems.length; i < l; ++i){
			
			if(estimateItems[i].value){
				if(!estimateItems[i].bound)
					continue;
			}
			if(typeof estimateItems[i].dataType == "function"){
				estimateItems[i].value = estimateItems[i].dataType(data);
				continue;
			}
			if(estimateItems[i].bound && estimateItems[i].bound.length){
				delete estimateItems[i].value;
				estimateItems[i].value;
				for(var ii = 0, ll = estimateItems[i].bound.length; ii < ll; ++ii){
					var value = data[estimateItems[i].bound[ii]] || 0;
					if(estimateItems[i].calcType == "sum"){
						estimateItems[i].value = +estimateItems[i].value;
						if(!estimateItems[i].value)
							estimateItems[i].value = 0;
						estimateItems[i].value += value;
					}else if(estimateItems[i].calcType == "percent" && value){
						if(estimateItems[i].bound.length != 2 || (!data[estimateItems[i].bound[0]] || !data[estimateItems[i].bound[1]])){
							estimateItems[i].value = 0;
							break;
						}
						estimateItems[i].value = data[estimateItems[i].bound[0]] / data[estimateItems[i].bound[1]];
					}else{
						estimateItems[i].value = value;
					}
				}
				if(estimateItems[i].calcType == "percent"){
					estimateItems[i].value = parseInt(((estimateItems[i].value) * 100), 10) + "%";
				}
				if(estimateItems[i].dataType == "date"){
					estimateItems[i].value = new Date(estimateItems[i].value).toString();
				}
				if(estimateItems[i].dataType == "time"){
					estimateItems[i].value = this.ms2hrTime(estimateItems[i].value);
				}
				if(estimateItems[i].dataType == "int"){
					estimateItems[i].value = Moonshadow.helpers.numberCommas(estimateItems[i].value);
				}
				if(estimateItems[i].dataType == "string"){
					if(estimateItems[i].value != 0){
						estimateItems[i].value = Moonshadow.helpers.capitalize(estimateItems[i].value + "");
					}
				}
			}
		}
	},
	addReportSubTab: function(tabInfo){
		tabInfo.ui.tab = $(Moonshadow.helpers.ce("div"))
			.addClass("sub_tab")
			.addClass(tabInfo.disabled && "tab_disabled")
			.addClass(tabInfo.active ? "active" : (!tabInfo.disabled && "clickable"))
			.attr({
				"title": tabInfo.title
			})
			.append(tabInfo.title)
			.click({"self": this, "tabInfo": tabInfo}, function(e){
				var index = $(".sub_tab", $(e.target).closest(".subPanelSection")).index(e.target);
				e.data.self.activateTab(e.data.tabInfo, index);
			});
		
		tabInfo.ui.toggleDisableTab = function(onOff){
			tabInfo.disabled = !onOff;
			if(onOff){
				return $(tabInfo.ui.tab)
					.removeClass("tab_disabled")
					.addClass("clickable");
			}
			$(tabInfo.ui.tab)
				.removeClass("clickable")
				.addClass("tab_disabled");
		}
		
		return $(tabInfo.ui.tab).get(0);
	},
	disableTab: function(disable, tabInfo){
		$(tabInfo.ui.tab, this)
			.removeClass(!disable && "tab_disabled")
			.addClass(disable && "tab_disabled")
			.removeClass(disable && "clickable")
			.addClass((!disable && !tabInfo.active) && "clickable")
		tabInfo.disabled = disable;
		if(disable)
			tabInfo.active = false;
	},
	tabOnUnload: function(tabInfo){
		if(tabInfo.onunload){
			var onunload = tabInfo.onunload;
			if(typeof tabInfo.onunload == "string") 
				onunload = this[tabInfo.onunload];
			onunload(this, tabInfo);
		}
	},
	tabOnload: function(tabInfo){
		if(tabInfo.onload){
			var onload = tabInfo.onload;
			if(typeof tabInfo.onload == "string") 
				onload = this[tabInfo.onload];
			onload(this, tabInfo);
		}
	},
	activateTab: function(tabInfo, index){
		if(tabInfo.disabled)
			return false;
		
		var tabs = tabInfo.parent.tabs;
		var activeTab = -1;
		var currentlyActive = -1;
		for(var i = 0, l = tabs.length; i < l; ++i){
			if(tabs[i].active){
				currentlyActive = i;
				break;
			}
		}
		
		if(index == null){
			activeTab = currentlyActive;
			if(activeTab == -1){
				activeTab = 0;
				tabs[0].active = true;
			}
		}else{
			activeTab = index;
		}
		
		for(var i = 0, l = tabs.length; i < l; ++i){
			var tab = tabs[i];
			if(i == activeTab){
				if(tab.disabled){
					++activeTab;
				}
				if(activeTab > tabs.length - 1){
					activeTab = currentlyActive;
				}
				break;
			}
		}
		
		for(var i = 0, l = tabs.length; i < l; ++i){
			var tab = tabs[i];
			tab.active = false;
			$(tab.ui.tab)
				.addClass(!tab.disabled && "clickable")
				.removeClass("active");
			this.tabOnUnload(tab);
			
			$(tab.ui.content)
				.addClass("hide");
			
			if(i == activeTab){
				tab.active = true;
				$(tab.ui.tab)
					.addClass("active")
					.removeClass("clickable");
				$(tab.ui.content)
					.removeClass("hide")
				this.tabOnload(tab);
			}
		}
	},
	ms2hrTime: function(inTime){
		var estimate = Math.round(inTime / 1000);
		var days = Math.floor(estimate / 86400);
		var hours = Math.floor((estimate % 86400) / 3600);
		var minutes = Math.floor(((estimate % 86400) % 3600) / 60);
		var seconds = ((estimate % 86400) % 3600) % 60;
		var timeArray = [];
		days > 0 && timeArray.push(days + " days");
		hours > 0 && timeArray.push(hours + " hrs");
		minutes > 0 && timeArray.push(minutes + " mins");
		seconds > 0 && timeArray.push(seconds + " secs");
		return timeArray.length == 0 ? "0" : timeArray.join(", ");
	},
	validateSurveyOptions: function(tabInfo, index, target){
		var optPanel = $(target).closest(".subPanelSection");
		if($("input[name='surveys']", optPanel).attr("checked")){
			if(!$("input[name='allsurveys']", optPanel).attr("checked")){
				if(!$(".survey_export_field", optPanel).length){
					MUILayoverPanel.alert("You have chosen to include survey data in the report, " +
						"however you have not chosen any surveys to include.");
					return false;
				}
			}
		}
		if(index > -1){
			this.activateTab(tabInfo, index);
		}else{
			return true;
		}
	},
	startExportGeneration: function(tabInfo, index, target){
		if(!this.validateSurveyOptions(tabInfo, -1, target))
			return false;
		
		if(this.isGenerating)
			return false;
		
		var self = this;
		var reportOptions = tabInfo.parent;
		this.gatherSelectedReportOptions(reportOptions, index, target, function(options){
			
			var start = function(){
				$(".generating_wait", tabInfo.ui.content)
					.removeClass("hide");
				self.isGenerating = true;
				self.generateExportReport(options, function() {
					self.activateTab(tabInfo, index);
					self.estimatesDirty = true;
					self.isGenerating = false;
					$(".generating_wait", tabInfo.ui.content)
						.addClass("hide");
				});
			};
			
			if(tabInfo.parent && 
					tabInfo.parent.bypassRestrictions && 
					tabInfo.parent.bypassRestrictions(self, options)){
				return start();
			}
			
			// Check for unpurchased records and show warning
			// if cancelled, abort generation
			if (self.numberOfRecords() != self.cardinality) {
				return MUILayoverPanel.confirm({
					"message": [
						'The number of records in this universe is ', self.cardinality, ', ',
						'however this report will only export the number of purchased records, ',
						'which is currently ', self.numberOfRecords(), '. To get all records ',
						', press \"Cancel\"', ' and purchase this universe. Continue?'
					].join(''),
					"callback": function(res, id, hide){
						if(res){
							start();
						}
						hide();
					}
				});
			}
			start();
		});
	},
	gatherSelectedReportOptions: function(reportOptions, index, target, callback){
		var options = {
			"query_params": {},
			"ds": this.datasource,
			"source_id": this.int_name, 
			"num_records": this.numberOfRecords(),
			"filter": this.export_filter,
			"column_set": null,
			"compression": null,
			"report_type": null,
			"format": null,
			"sort_order": null
		};
		
		var self = this;
		var surveyControl = this.getParent().getSurveyControl();
		
		for(var i in options){
			if(!options.hasOwnProperty(i))
				continue;
			if(reportOptions[i] != undefined)
				options[i] = reportOptions[i];
		}
		
		var optionElements = $(".gatherable", $(target).closest(".subPanelSection"));
		for(var i = 0, l = optionElements.length; i < l; ++i){
			var name = $(optionElements[i]).attr("name");
			var value = $(optionElements[i]).attr("value");
			if($(optionElements[i]).attr("type") == "checkbox")
				value = !!$(optionElements[i]).get(0).checked;
			options[name] = value;
		}

		if(options.column_set){
			var exportOptions = this.getExportOptions();
			if(exportOptions && exportOptions[options.column_set])
				options.fields = $.extend([], exportOptions[options.column_set]);
			//if column_set is "enhanced", the report_type becomes "enhanced"
			if(options.column_set == "enhanced"){
				options.report_type = "enhanced";
			}
			//if column_set is "id_only", the report_type becomes "id_only"
			if(options.column_set == "id_only"){
				options.report_type = "id_only";
			}
			
			delete options.column_set;
		}
		
		if(options.barcode){
			options.query_params.barcode_vid = true;
			delete options.barcode;
		}
		
		if(options.xbase_compatible){
			options.query_params.xbase_compatible = true;
			delete options.xbase_compatible;
		}
		
		if($.inArray(options.report_type, ["simple", "enhanced", "household"]) > -1){
			var clusterField = this.getClusterField();
			if(clusterField){
				options.query_params.cluster_sample = true;
				options.fields.unshift({
					"int_name": clusterField.int_name,
					"ext_name": clusterField.ext_name
				});
			}
		}
		
		if(!options.surveys){
			return callback(options);
		}
		
		delete options.surveys;
		var surveyExportItems = $(
			".survey_export_field", 
			$(target).closest(".subPanelSection"))
			.map(function(index, val){
				return $(val).val();
			})
			.toArray();

		if(reportOptions.typeId == "walking"){
			//if the options include survey data a list of survey ids are included in the query params
			//and the report_type becomes "survey"
			
			options.report_type = "survey";
			if(surveyExportItems.length){
				options.query_params.surveys = surveyExportItems;
				callback(options);
			}else{
				surveyControl.getAllSurveyIds(function(ids){
					options.query_params.surveys = ids;
					callback(options);
				});
			}
		}else{
			//if the report type is "csv" (or any other at this point) the fields of the 
			//surveys need to be uncluded in the field set sent to the QS
			
			var eItems = surveyExportItems.length ? surveyExportItems : null;
			surveyControl.getSurveysFields(eItems, true, function(fields){
				options.fields = options.fields.concat(fields);
				callback(options);
			});
		}
	},
	generateExportReport: function(opts, callback){
		var self = this;
		this.getControl().getManager().getControl("reportqueue").generateReport(opts, function(data) {
			if (!data.job) {
				throw new Error('No export job data returned');
			}
			self.unRegisterEstimate();
			self.mapNotify(["updatedownloadui", "updateestimates"], data.job.report_id);
			callback();
		});
	},
	sendNBReport: function(tabInfo, index, target){
		if(this.isGenerating)
			return false;
		
		var self = this;
		this.isGenerating = true;
		
		$(".generating_wait", tabInfo.ui.content)
			.removeClass("hide");
		
		var fields = [];
		var exportOptions = this.getExportOptions();
		if (exportOptions) {
			fields = exportOptions["nationbuilder"]; // TODO get from column_set
		}
		
		this.generateExportReport({
			"report_type": "nationbuilder_export",
			"ds": this.datasource,
			"source_id": this.int_name, 
			"num_records": this.numberOfRecords(),
			"filter": this.export_filter,
			"fields": fields
		}, function(){
			self.activateTab(tabInfo, index);
			self.estimatesDirty = true;
			self.isGenerating = false;
			$(".generating_wait", tabInfo.ui.content)
				.addClass("hide");
		});
	},
	getPercentDone: function(report){
		var percentDone = parseInt(((report.records_processed / report.num_records) * 100), 10);
		if(report.format == "csv"){
			percentDone = 100;
			if(report.status == 40){
				percentDone = 66;
			}else if(report.status <= 30){
				percentDone = 33;
			}
		}
		if(report.report_layout == "nationbuilder_export"){
			switch(report.status){
				case 30:
					percentDone = 10;
					break;
				case 40:
					percentDone = 20;
					break;
				case 42:
					percentDone = 40;
					break;
				case 44:
					percentDone = 60;
					break;
				case 46:
					percentDone = 80;
					break;
				case 60:
					percentDone = 100;
					break;
				default:
					percentDone = 0;
			}
		}
		return percentDone;
	},
	getIsReady: function(report){
		var isReady = report.status >= 50 && report.status < 70;
		if(report.report_layout == "nationbuilder_export"){
			isReady = report.status == 60;
		}
		return isReady;
	},
	getIsError: function(report){
		return report.status < 0 && report.status > -60;
	},
	getIsExpired: function(report){
		return report.status == 70;
	},
	getReportsForTab: function(valid_types){
		var self = this;
		var reportqueue = this.getControl().getManager().getControl("reportqueue");
		var attr, types;
		if(valid_types){
			attr = "report_layout";
			types = valid_types;
		}
		return $(reportqueue.getReportsByAttribute(attr, types))
			.filter(function(key, report){
				return report.source_id == self.int_name;
			})
			.toArray()
			.reverse();
	},
	getCreatedDate: function(){
		var dt = new Date(this.created_time * 1000);
		return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
	},
	getCreatedDateTime: function(){
		return new Date(this.created_time * 1000);
	},
	getPurchasedDate: function(){
		var dt = new Date(this.purchase_time * 1000);
		return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
	},
	getPurchasedDateTime: function(){
		return new Date(this.purchase_time * 1000);
	},
	buildExports: function(universe, tabInfo){
		universe.buildReportsUI();
		var container = $(".sub_holder", tabInfo.ui.content);
		var reportsForTab = universe.getReportsForTab(tabInfo.parent.valid_types);
		
		$(container)
			.removeClass("empty");
		if(!reportsForTab.length){
			return $(container)
				.addClass("empty");
		}
		
		var childIds = {}; 
		$(container).children().each(function(i, elem){
			childIds[elem.id] = $("input[name='report_hash']", elem).val();
		})
		
		$.each(reportsForTab, function(key, report){
			var hash = childIds[report.report_id];
			if(!hash){
				$(container).append(report.ui);
			}else if(hash != report.hash){
				$("#" + report.report_id, container).replaceWith(report.ui);
			}
		});
	},
	buildReportsUI: function(){
		var reports = this.getReportsForTab();
		for(var i = 0, l = reports.length; i < l; ++i){
			if(reports[i].ui){
				continue;
			}
			this.buildReportUI(reports[i]);
		}
	},
	buildReportUI: function(report, reportType){
		var reporttypes = this.getControl().getManager().getControl("reporttypes");
		var exportType = this.getReportTypeObjectFromLayout(report.report_layout);
		if(!exportType)
			return;
		var hoverDisplayOptions = reporttypes.hoverDisplayOptions[exportType.hoverDisplay](exportType.title);
		var reportType = exportType.typeId;
		
		var ce = Moonshadow.helpers.ce;
		
		var isNB = report.report_layout == "nationbuilder_export";
		var isReady = this.getIsReady(report);
		var percentDone = this.getPercentDone(report);
		var isError = this.getIsError(report);
		var isExpired = this.getIsExpired(report);
		
		this.parseInfoProperties(hoverDisplayOptions, report);
		
		var pickClass = function(){
			if(isReady){
				return "sprite-" + reportType + "Ready";
			}
			if(isExpired){
				return "sprite-" + reportType + "Disabled";
			}
			if(isError){
				return "sprite-export_error";
			}
			return "sprite-" + reportType;
		};
		
		var reportUI = $(ce("div"))
			.addClass("downloadable_export")
			.addClass(isReady && !isNB && !isError && !isExpired ? "clickable" : false)
			.attr({
				"id": report.report_id
			})
			.append(
				$(ce("input"))
					.attr({
						"type": "hidden",
						"name": "date_modified",
						"value": report.date_modified
					}),
				$(ce("input"))
					.attr({
						"type": "hidden",
						"value": report.date_created,
						"name": "date_created"
					}),
				$(ce("input"))
					.attr({
						"type": "hidden",
						"value": report.status,
						"name": "report_status"
					}),
				$(ce("input"))
					.attr({
						"type": "hidden",
						"value": report.hash,
						"name": "report_hash"
					}),
				$(ce("div"))
					.addClass("delete_report trash sprite-trash right universeTool clickable")
					.addClass(!isReady && !isError && !isExpired ? "invisible" : false)
					.attr({
						"title": "Delete Job"
					}),
				$(ce("span"))
					.addClass("report_date_created")
					.append(
						Moonshadow.helpers.mmddyyFromString(report.date_created)
					),
				$(ce("div"))
					.addClass("export_download_link")
					.append(
						$(ce("div"))
							.addClass("icon")
							.addClass(pickClass()),
						$(ce("span"))
							.addClass("downloadable_export_title")
							.addClass(!isReady && !isError && !isExpired ? "short" : false)
							.addClass(isExpired ? "report_expired" : false)
							.append(report.report_id),
						$(ce("div"))
							.addClass("report_progress_bar")
							.addClass(isReady || isError || isExpired ? "hide" : false)
							.append(
								$(ce("span"))
									.append(percentDone + "%"),
								$(ce("div"))
									.css({
										"width": percentDone + "%"
									})
							)
					)
			);

			$(reportUI)
				.data({
					"options": hoverDisplayOptions,
					"universe": this,
					"report": report,
					"exportHover": $(ce("div"))
						.addClass("export_descr")
						.append(
							report.status == 70 ? $(ce("div"))
								.addClass("export_descr_bit")
								.append(
									"This export has expired. Please regenerate."
								) : "",
							$(hoverDisplayOptions).filter(function(key, item){
								if(!item || (!item.hideAtStatus && !item.showAtStatus))
									return true;
								if(item.showAtStatus instanceof Array){
									if(report.status <= item.showAtStatus[0] || report.status >= item.showAtStatus[1]){
										return false
									}
								}
								if(item.hideAtStatus <= report.status || (isError && item.hideAtStatus))
									return false;
								return true;
							})
							.map(function(key, option){
								return $(ce("div"))
									.addClass("export_descr_bit")
									.addClass(option.forceWrap ? "force_wrap" : "")
									.append(
										option.title,
										function(){
											if(option.dataType){
												return $(ce("span"))
													.addClass(option.bound && option.bound.join("-"))
													.append(option.value || "--")
													.attr({
														"title": option.value || "--"
													})
											}
										}()
									)
									.get(0);
							})
						),
					"init": function(reportUI){
						var exportHover = this.exportHover;
						$(reportUI)
							.on("mousemove", {"exportHover": exportHover}, function(e){
								$("export_descr").remove();
								$(e.data.exportHover)
									.css({
										"top": $(this).offset().top + $(this).outerHeight(),
										"left": $(this).offset().left + 40,
										"z-index": 100
									})
									.appendTo("body");
							})
							.on("mouseout", {"exportHover": exportHover}, function(e){
								$("export_descr").remove();
								$(e.data.exportHover).remove();
							})
							.find(".export_download_link")
							.click({
								"self": this
							}, function(e){
								e.data.self.download();
							});
						
						$(reportUI)
							.find(".trash")
							.click({
								"self": this
							},  function(e){
								if(e.data.self.report && !e.data.self.report.deleted){
									e.data.self.deleteReport();
									e.data.self.report.deleted = true;
								}
							});
					},
					"updateReportStatus": function(){
						var report = this.report;
						var universe = this.universe;
						
						if(!report.ui)
							return;
						
						var reportUI = report.ui;
						
						if(!universe.reportUIShouldUpdate(this.report)){
							return false;
						}

						var options = this.options;
						
						var isReady = universe.getIsReady(report);
						var percentDone = universe.getPercentDone(report);
						universe.parseInfoProperties(options, report);
						var isError = universe.getIsError(report);
						var isExpired = universe.getIsExpired(report);
						
						for(var i = 0, l = options.length; i < l; ++i){
							var o = options[i];
							var b = o.bound;
							if(b && b.length){
								var target = $("." + b.join("-"), this.exportHover);
								if(o.hideAtStatus <= report.status || (o.hideAtStatus > 0 && isError)){
									$(target)
										.closest(".export_descr_bit")
										.remove();
									continue;
								}
								$(target)
									.empty()
									.append(o.value);
							}
						}

						
						var reportType = this.universe.getReportTypeObjectFromLayout(
							this.report.report_layout
						).typeId;
						
						if(isReady){
							$(".report_progress_bar", reportUI)
								.addClass("hide");
							$(".delete_report", reportUI)
								.removeClass("invisible");
							$(".icon", reportUI)
								.addClass("ready sprite-"+reportType+"Ready")
								.removeClass("sprite-export_error sprite-" + reportType);
							$(".downloadable_export_title", reportUI)
								.removeClass("short");
							if(report.report_layout != "nationbuilder_export"){
								$(reportUI)
									.addClass("clickable");
							}
						}else if(isError){
							$(".report_progress_bar", reportUI)
								.addClass("hide");
							$(".delete_report", reportUI)
								.removeClass("invisible");
							$(".icon", reportUI)
								.addClass("sprite-export_error")
								.removeClass("ready sprite-"+reportType+"Ready sprite-" + reportType);
							
							$(".downloadable_export_title", reportUI)
								.removeClass("short");
						}else if(isExpired){
							$(".report_progress_bar", reportUI)
								.addClass("hide");
							$(".delete_report", reportUI)
								.removeClass("invisible");
							$(".icon", reportUI)
								.addClass("sprite-export_error")
								.removeClass("sprite-"+reportType+"Disabled sprite-" + reportType);
						}else{
							$(".report_progress_bar span", reportUI)
								.empty()
								.append(percentDone + "%");
							$(".report_progress_bar div", reportUI)
								.css({
									"width": percentDone + "%"
								});
						}
						
						$("input[name='date_modified']", this.report.ui).val(this.report.date_modified);
					},
					"download": function(){
						var report = this.report;
						var universe = this.universe;
						if(report.report_layout != "nationbuilder_export"){
							if(report.status >= 50 && report.status < 70){
								universe.downloadReport(report.report_id);
								report.ui.data() && 
									report.ui.data().updateReportStatus &&
									report.ui.data().updateReportStatus();
							}
						}
					},
					"deleteReport": function(){
						if(this.report && this.report.ui){
							var parentContainer = this.report.ui.parent();
						}
						this.universe.deleteExport(report.report_id);
						$(this.report.ui).remove();
						$(this.exportHover).remove();
						$("export_descr").remove();
						if(parentContainer && !$(parentContainer).children().length){
							$(parentContainer).addClass("empty");
						}
						delete this.report.ui;
					}
				});
			
		report.ui = reportUI;
		report.ui.data() &&
			report.ui.data().init && 
			report.ui.data().init(report.ui);
		report.ui.data() && 
			report.ui.data().updateReportStatus && 
			report.ui.data().updateReportStatus();
	},
	reportUIShouldUpdate: function(report){
		if(!report.ui)
			return true;
		var lastUpdated = $("input[name='date_modified']", report.ui).val();
		if(lastUpdated == report.date_modified)
			return false;
		return true;
	},
	removeObservers: function(events){
		this.getControl().getManager().removeMapContext(events, this);
	},
	getReportTypeObject: function(typeId){
		for(var i = 0, l = this.reportTypes.length; i < l; ++i){
			if(typeId == this.reportTypes[i].typeId)
				return this.reportTypes[i];
		}
	},
	getReportTypeObjectFromLayout: function(layout){
		for(var i = 0, l = this.reportTypes.length; i < l; ++i){
			if(this.reportTypes[i].valid_types && this.reportTypes[i].valid_types.length){
				 if($.inArray(layout, this.reportTypes[i].valid_types) > -1){
					 return this.reportTypes[i];
				 } 
			}
		}
	},
	nationbuilderAccess: function(){
		var hasNBOAuthCreds = this.getControl().getManager().hasOAuth('nationbuilder');
		var reportType = this.getReportTypeObject("nationbuilder_export");
		
		for(var i = 0, l = reportType.tabs.length; i < l; ++i){
			if(!hasNBOAuthCreds){
				$(".next_button", reportType.tabs[i].ui.content)
					.removeClass("clickable")
					.addClass("disabled_button");
				if(reportType.tabs[i].id != "nbauth")
					this.disableTab(true, reportType.tabs[i]);
			}else{
				$(".next_button", reportType.tabs[i].ui.content)
					.removeClass("disabled_button")
					.addClass("clickable");
				this.disableTab(false, reportType.tabs[i]);
			}
		}
	},
	nationBuilderAccount: function(tabInfo, hasNBOAuthCreds){
		var ce = Moonshadow.helpers.ce;
		var content = $(".sub_holder", tabInfo.ui.content);
		if(!hasNBOAuthCreds){
			$(".next_button", tabInfo.ui.content)
				.removeClass("clickable")
				.addClass("disabled_button");
		}else{
			$(".next_button", tabInfo.ui.content)
				.removeClass("disabled_button")
				.addClass("clickable");
		}
		if(!$(content).children().length){
			$(content)
				.append(
					$(ce("div"))
						.addClass("center")
						.append(
							$(ce("p"))
								.addClass("nb_heading")
								.append("Exporting NationBuilder data requires logging into the NationBuilder site."),
							$(ce("p"))
								.append(hasNBOAuthCreds ? "Your authorization has been processed." : "Click the button to start the process."),
							$(ce("div"))
								.addClass("report_button nb_start_button clickable")
								.append(hasNBOAuthCreds ? "Reconfigure Settings" : "Get Started")
								.click({"self": this}, function(e){
									e.data.self
										.getControl()
										.getManager()
										.getControl("nationbuilderui")
										.getStarted(true);
								})
						)
				);
			
			var self = this;
			this.getControl().getManager().addMapObserver("nationbuilder_access", function(){
				self.nationbuilderAccess();
				self.activateTab(tabInfo, 1);
			}, self);
		}
	}
});


MFilterableUniverseItem.prototype.updateReportsUI = function(){
	var reportqueue = this.getControl().getManager().getControl("reportqueue");
	var reports = reportqueue.getReportsByAttribute("source_id", this.int_name);
	for(var i = 0, l = reports.length; i < l; ++i){
		var report = reports[i];
		if(this.reportUIShouldUpdate(report)){
			if(!report.ui){
				this.buildReportUI(report);
				continue;
			}
			report.ui.data() && 
				report.ui.data().updateReportStatus && 
				report.ui.data().updateReportStatus();
			this.mapNotify("updatedownloadui", report.report_id);
		}
	}
};

/**
 * Get cluster info for exports
 * 
 * @method getClusterField
 * @return {Object} object with cluster field data
 */
//[{int_name:7f0d05e4-2989-11e4-acb3-525400b357ae_sample, ext_name:Cluster_Number, du_type:1}]
MFilterableUniverseItem.prototype.getClusterField = function() {
	return this.getDynamicAuxData(1);
};

/**
 * Get the route id for a universe
 * 
 * @method getRouteId
 * @return {String} routeId The route id for the universe
 */
MFilterableUniverseItem.prototype.getRouteId = function() {
	var data = this.getDynamicAuxData(2);
	if(data)
		return data.int_name;
};

/**
 * Pull dynamic aux data from universe for du_type
 * 
 * @method getDynamicAuxData
 * @param {String} du_type ID of the data needed
 * @return {Object} object with field data
 */
MFilterableUniverseItem.prototype.getDynamicAuxData = function(du_type) {
	if (this.dynamic_aux_data) {
		var numAuxFields = this.dynamic_aux_data.length;
		for(var i = 0; i < numAuxFields; i++) {
			var f = this.dynamic_aux_data[i];
			if (f.du_type === du_type) {
				return f;
			}
		}
	}
};

/**
 * Sets the route aux id
 *
 * @method setRouteId
 * @param {String} routeId
 */
MFilterableUniverseItem.prototype.setRouteId = function(routeId) {
	this.dynamic_aux_data.push({
		'int_name': routeId,
		'ext_name': routeId,
		'du_type': 2
	});	
};

/**
 * Unsets the route aux id
 *
 * @method unsetRouteId
 * @private
 */
MFilterableUniverseItem.prototype.unsetRouteId = function(routeId) {
	var metadata = this.dynamic_aux_data;
	for(var i = 0, l = metadata.length; i < l; i++) {
		if (metadata[i].du_type === 2) {
			return metadata.splice(i, 1);
		}
	}
};

//MFilterablePurchased
function MFilterablePurchased(branch, parent) {
	this.children = {};
	this.countTotal = null;
	this.countPerc = null;
	this.init(branch,parent);
	this.values = branch.values || branch.filters || [];
}

MFilterablePurchased.prototype = new MFilterable;
$.extend(MFilterablePurchased.prototype, {
	 buildUI: function() {
		var container = document.createElement("div");

		container.className = "filterable " + this.dtype + " hide";
		container.id = "filterable_"+this.int_name;
		container.style.paddingLeft = "20px";

		if(this.getControl().options.purchased_docs) {
			container.appendChild(this.getControl().createDocList(this.getControl().options.purchased_docs));
		}

		container.appendChild(this.makeExpander());
		container.appendChild(this.makeClear());
		container.appendChild(this.makeChildren());

		this.container = container;
		this.parent.childContainer.appendChild(this.container);
		
		this.hasFilters = this.countFilters();

		this.parent.hasFilters += this.hasFilters;
		if (this.hasFilters > 0){
			this.perculateChange();
		}
		
		//@TODO this only works with DS in position 1
		var dsId = this.getDatasourcesControl().getByIndex(0).id;
		
		var manager = this.getControl().getManager();
		var self = this;
		manager.addMapObserver("universesuiloaded", function(){
			var univCont = manager.getControl("universecontrol");
			if(univCont.checkPrePurchased()){
				return self.hideControl();
			}
			if(univCont.getPurchased(dsId)){
				return self.showControl();
			};
		});
	},
	hideControl: function(){
		this.onClearFilters();
		$(this.container).addClass("hide");
	},
	showControl: function(){
		$(this.container).removeClass("hide");
	},
	setupDataPath: function() {
		this.dataPath = ['__universes'];
	},
	countFilters: function() {
		var count = 0;

		var filters = this.getFiltersControl();
		var universeFilters = filters.getUniverseFilters();
		
		//@TODO this only works with DS in position 1
		var dsId = this.getDatasourcesControl().getByIndex(0).id;

		for (var i = 0, l = this.values.length; i < l; i++) {
			var child = this.values[i];
			if(child) {
				var path = ['__universes', child.int_name].join('|');
				if(universeFilters[path]){
					++count;
				}
			}
		}

		return count;
	},
	onClearFilters: function(){
		//@TODO this only works with DS in position 1
		var dsId = this.getDatasourcesControl().getByIndex(0).id;
		
		var pattern = /^__universes\.__purchased/;
		var filters = this.getFiltersControl();
		filters.clearFiltersRegEx(dsId, pattern);
		this.clearFilters();
	},
	clearFilters: function() {
		$.each(this.children, function(k, v) {
			v.clearFilters();
		});
		this.hasFilters = 0;
		this.updateFilterCount(this.ui.handle);
		this.showHideClear(false);
	},
	enableDisablePurchasingDocs: function(onOff){
		if(onOff){
			$(".doc", this.container).show();
		}else{
			$(".doc", this.container).hide();
		}
	}
});

//MFilterablePurchasedItem
function MFilterablePurchasedItem(branch,parent) {
	this.countTotal = null;
	this.countPerc = null;
	this.init(branch,parent);
									//@TODO this only works with DS in position 1
	this.datasource = branch.ds || this.getDatasourcesControl().getByIndex(0).id;
}
MFilterablePurchasedItem.prototype = new MFilterable;
$.extend(MFilterablePurchasedItem.prototype, MFilterableItem.prototype, {
	buildUI: function() {
		
		var container = document.createElement("div");
		container.className = "criteria";
		
		var filter = this.getFilterValue();
		if (!filter) {
			filter = {};
		}

		var isChecked = (filter.value === 1) ? true : false;

		var name = Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "));
		this.label = this.makeLabel(name);

		container.appendChild(this.makeCheckboxFilter(this.int_name,isChecked));
		container.appendChild(this.makeCounts(this.int_name));
		container.appendChild(this.label);
		container.appendChild(this.makeClear());

		this.container = container;
		this.parent.childContainer.appendChild(this.container);
		
		var self = this;
		this.getControl().getManager().addMapObserver("universesrepolled", function(){
			self.updateTotal();
		}, this);
	},
	getUniverseInfo: function(){
		var manager = this.getControl().getManager();
		var universecontrol = manager.getControl("universecontrol");
		if(this.int_name == "__unpurchased___unpurchased"){
			return universecontrol.getUnpurchased(this.datasource);
		}
		return universecontrol.getPurchased(this.datasource);
	},
	updateTotal: function(){
		var universeInfo = this.getUniverseInfo();
		if (this.countTotal && universeInfo){
			var cardinality = parseInt(universeInfo.cardinality, 10);
			var text = Moonshadow.helpers.numberCommas(cardinality);
			$(this.countTotal).empty().append(text);
		}
	},
	getFilterValue: function() {
		return this.getFiltersControl().getFilter(this.datasource, this.getDataPath().join('|'));
	},
	onCheckboxChange: function(checkbox) {
		var nextInt = -1;
		if(this.int_name == "__unpurchased___unpurchased")
			nextInt = -2;
		if(checkbox.checked) {
			$(checkbox.filter.label).addClass("selected");
			this.setFilterValue({'value': 1, 'order': nextInt});
		} else {
			$(checkbox.filter.label).removeClass("selected");
			this.clearFilterValue();
		}
		this.checkFilterCount();
		this.parent.perculateChange();
	},
	setFilterValue: function(filter) {
		var filters = this.getFiltersControl();
		filters.setFilter(this.datasource, this.getDataPath().join('|'), filter);
	},
	clearFilterValue: function() {
		var filters = this.getFiltersControl();
		filters.clearFilter(this.datasource, this.getDataPath().join('|'));
	},
	makeCounts: function(id) {
		var universeInfo = this.getUniverseInfo();
		var currCount = Moonshadow.helpers.numberCommas(parseInt(universeInfo.cardinality,10));

		var countDiv = document.createElement("div");
		countDiv.className = "counts";

		var count = document.createElement("div");
		count.className = "perc";
		count.appendChild(document.createTextNode(currCount));

		countDiv.appendChild(count);

		this.countTotal = count;

		return countDiv;
	}
});

	
function MFilterableShapes(branch, parent) {
	this.children = {};
	this.init(branch, parent);
	this.control = this.getControl();
	this.manager = this.control.getManager();
	this.adapter = this.manager.getAdapter();

	this.values = branch.values || [];
	
	this.showStats = true;

	this.shapes = [];
	this.currentShape = null;
	this.namePrefix = 'New ';

	this.ui = {
		"drawButton": null,
		"shapeName": null
	};

	
	this.displayColor = this.adapter.options.displayColor || '#00FF00';
	this.displayFillAlpha = this.adapter.options.displayFillAlpha || 70;
	this.displayLineAlpha = this.adapter.options.displayLineAlpha || 204;

	this.activeColor = this.adapter.options.activeColor || '#FF0000';
	this.activeFillAlpha = this.adapter.options.activeFillAlpha || 127;
	this.activeLineAlpha = this.adapter.options.activeLineAlpha || 204;

	this.mouseEvent = null;
}


MFilterableShapes.prototype = new MFilterable;

MFilterableShapes.prototype.buildUI = function() {
	var control = this.getControl();

	// Main container
	var container = document.createElement("div");
	container.className = "no-color-by filterable " + this.dtype;
	container.id = "filterable_" + this.int_name;

	// Append any docs 
	// @TODO this needs to be move to uiset
	var docs = control.getOption('shapes_docs');
	if (!docs) { // This is legacy, please remove after attrs update
		docs = control.getOption('polygons_docs');
	}

	if(docs) {
		container.appendChild(control.createDocList(docs));
	}

	// Section expander and clear it
	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());

	// Create container
	var createCon = document.createElement("div");
	createCon.id = "create-shape";
	createCon.className = "create";
	createCon.style.display = "none";

	var ce = Moonshadow.helpers.ce;

	this.ui.drawButton = $(ce("input"))
		.addClass("create-shape_button")
		.attr({
			"type": "button",
			"value": "Create"
		})
		.click({'caller': this}, 
			$.proxy(function() {
				this.onDraw();
			}, this)
		)
		.get(0);
	
	var shapeNameCont = MUIFormElements.textField("Shape Name", null, true);
	this.ui.shapeName = $("input", shapeNameCont)
		.keyup({'control': this}, 
			$.proxy(function() {
				this.onNameChange();
			}, this)
		).get(0);
	
	this.ui.shapeType = $(ce("select"))
		.addClass("create-shape_name")
		.append(
			$(ce("option"))
				.attr({
					"value": "polygon"
				})
				.append("Polygon"),
			$(ce("option"))
				.attr({
					"value": "circle"
				})
				.append("Circle")
		)
		.change(
			$.proxy(function(event) {
				this.ui.shapeName.value = this.getNextName(event.target.value);
				this.onNameChange();
			}, this)
		)
		.get(0);
	
	var self = this;
	$(createCon)
		.append(
			$(ce("div"))
				.addClass("draw-container")
				.append(
					shapeNameCont,
					this.ui.drawButton,
					this.ui.shapeType
				),
			$(ce("div"))
				.addClass("header")
				.append(
					$(ce("input"))
						.addClass("selected-shape clear_shape_filters")
						.attr({
							"type": "radio",
							"title": "Clear All Current Shape Selections",
							"checked": true,
							"defaultChecked": true
						})
						.on("click", function(event) {
							self.clearFilters();
						}),
					$(ce("input"))
						.addClass("toggle_showhide_all")
						.attr({
							"type": "checkbox",
							"title": "Show/Hide All Shapes",
							"checked": this.displayed,
							"value": this.int_name
						})
						.on("click", function(event) {
							if (this.checked) {
								self.displayAllShapes();
							} else {
								self.undisplayAllShapes();
							}
						}),
					$(ce("span"))
						.addClass("shape_child_header")
						.append("Your Shapes")
				)
		);
	
	var sortElem = document.createElement("div");
	sortElem.className = "sort_elem";
	createCon.appendChild(sortElem);
	
	this.sortList = {
		"areaClass": "sortshapes",
		"sortElem": sortElem,
		"opts": [
			{
				"sortby": "shapeselected",
				"float": "left"
			},
			{
				"sortby": "shapedisplayed",
				"float": "left"
			},
			{
				"sortby": "shapescount",
				"float": "right"
			},
			{
				"sortby": "label",
				"sortdefault": true
			}
		]
	};
	
	// Make children (created shapes)
	//createCon.appendChild(this.makeChildren());
	createCon.appendChild(this.makeChildrenResizable());
	
	this.makeColumnSorter(
		this.sortList.opts,
		this.sortList.areaClass,
		this.sortList.sortElem,
		this.childContainer,
		this.sortList.sortOrder
	);

	// Add create container to parent
	container.appendChild(createCon);

	this.container = container;
	this.createContainer = createCon;

	// Add the entire UI to parent (attaching it to the DOM)
	this.parent.childContainer.appendChild(this.container);


	// Listen for shape enable and disable
	this.manager.addMapObserver('shapedisabled', this.onShapeDisabled, this);
	this.manager.addMapObserver('shapeenabled', this.onShapeEnabled, this);

	// Bind keyboard and mouse listeners
	this.keyDownHandle = this.adapter.addMapListener('keydown', this, this.onKeyDown);
	
	// @TODO may be good to bundle this query with some others
	this.getList(false);
};

MFilterableShapes.prototype.hasExpander = function() {
	return true;
};

MFilterableShapes.prototype.toggle = function() {
	var container = this.childContainer;
	var createContainer = this.createContainer;
	var manager = this.getControl().getManager();

	if (container.style.display !== 'block') {
		this.updateList();

		$(this.expander).addClass('expanded');
		createContainer.style.display = 'block';
		container.style.display = 'block';

		manager.addAjaxEventListener("filterchange", this);
		
		this.shapeStatistics();
		
	} else {
		$(this.expander).removeClass('expanded');

		this.createContainer.style.display = 'none';
		container.style.display = 'none';

		manager.removeAjaxEventListener("filterchange", this);
	}
	
	//manager.mapObservers.notify('filterabletoggle', this);
};

MFilterableShapes.prototype.onShapeEnabled = function() {
	for (var i in this.children){
		var item = this.children[i];
		var model = item.getModel();

		if (item.displayed && model.showable()) {
			model.show();
		}
	}
};

MFilterableShapes.prototype.onShapeDisabled = function() {
	for (var i in this.children) {
		var item = this.children[i];
		
		var model = item.getModel();
		if (model) {
			model.hide();
		}
	}
};

MFilterableShapes.prototype.nameExists = function(name) {
	var int_name = name.replace(/\s/g,'_').toLowerCase();
	return this.getShape(int_name) ? true : false;
};

MFilterableShapes.prototype.onNameChange = function() {
	var button = this.ui.drawButton;
	var name = this.ui.shapeName.value;

	if (!name || this.nameExists(name)) {
		button.disabled = true;
		button.title = 'Please enter a unique name';
		$(this.ui.shapeName).css('background-color', 'pink');
		return false;
	}

	button.disabled = false;
	button.removeAttribute('title');
	$(this.ui.shapeName).css('background-color', '');
	return true;
};

MFilterableShapes.prototype.onDraw = function() {
	if (!this.onNameChange()) {
		return;
	}

	var name = this.ui.shapeName.value;
	var type = this.ui.shapeType.value;
	var shape = this.newShape(name, type);

	// Update text field with next shape name
	this.ui.shapeName.value = this.getNextName(type);

	if (!shape) {
		throw new Error('Unable to make a new shape');
	}

	this.selectShape(shape);
};

//MFilterableShapes.prototype.onNoneSelected = function(event) {
//	event.data.that.deselectShape();
//};

MFilterableShapes.prototype.onKeyDown = function(event, details) {
	if (details.shiftKey) {
		this.shiftKey = true;

		if (!this.keyUpHandle) {
			this.keyUpHandle = this.adapter.addMapListener('keyup', this, this.onKeyUp);
		}

		// bind mouse listeners
		if (!this.mouseDownHandle) {
			this.mouseDownHandle = this.adapter.addMapListener('mousedown', this, this.onMouseDown);
		}
	}
};

MFilterableShapes.prototype.onKeyUp = function(event, details) {
	if (!details.shiftKey) {
		this.shiftKey = false;

		this.adapter.removeMapListener(this.keyUpHandle);
		this.keyUpHandle = null;

		// Unbind mouse listeners			
		this.adapter.removeMapListener(this.mouseDownHandle);
		this.adapter.removeMapListener(this.mouseMoveHandle);
		this.adapter.removeMapListener(this.mouseUpHandle);

		this.mouseDownHandle = null;
		this.mouseMoveHandle = null;
		this.mouseUpHandle = null;
		this.mouseEvent = null;
	}
};

MFilterableShapes.prototype.onMouseDown = function(event, details) {
	this.mouseEvent = details;
	this.mouseMoveHandle = this.adapter.addMapListener('mousemove', this, this.onMouseMove);
	this.mouseUpHandle = this.adapter.addMapListener('mouseup', this, this.onMouseUp);
};

MFilterableShapes.prototype.onMouseMove = function(events, details) {
	// Check if drag
};

MFilterableShapes.prototype.onMouseUp = function(events, details) {
	if (this.mouseEvent && details.targetType === 'polygon') {
		var shape = this.getByEntityRef(details.target);
		
		if (shape) {
			this.selectShape(shape);
		}
	}

	if (this.mouseMoveHandle) {
		this.adapter.removeMapListener(this.mouseMoveHandle);
	}

	if (this.mouseUpHandle) {
		this.adapter.removeMapListener(this.mouseUpHandle);
	}

	this.mouseEvent = null;
	this.mouseMoveHandle = null;
	this.moudsUpHandle = null;
};

MFilterableShapes.prototype.getShape = function(int_name) {
	var shape;

	$.each(this.children, function(k, v) {
		if(v.int_name === int_name) {
			shape = v;
			return false;
		}
	});

	return (shape) ? shape : undefined;
};

MFilterableShapes.prototype.newShape = function(name, type) {
	if(!name || typeof name != 'string' || name.length === 0) {
		throw new Error('Invalid ploygon name');
	}

 	var ext_name = name.toString();
	var int_name = ext_name.replace(/\s/g,'_').toLowerCase();

	var shape;
	if(shape = this.restoreShape(int_name, ext_name, type, [], true)) {
		this.updateList();

		shape.ui.radio.checked = true;
		shape.updateCount(0, null);

		this.saveShapes(null);
		return shape;
	}
	
	return false;
};

MFilterableShapes.prototype.getNextName = function(type) {
	var x = 0;

	var caller = this;
	var reg = new RegExp(caller.namePrefix + type + ' ' + '([0-9]+)', "i");
	$.each(this.children, function(k, v) {
		var matches = v.ext_name.match(reg);
		var match = (matches && matches[1]) ? matches[1] : 0;
		match = parseInt(match, 10);
		if(typeof match === 'number' && match > x)	{
			x = match;
		}
	});

	return this.namePrefix + type + ' '  + (x + 1);
};

MFilterableShapes.prototype.getByEntityRef = function(entity) {
	for (var i in this.children){
		var item = this.children[i];

		var model = item.getModel();
		if (model) {
			var mapEntity = model.getMapEntity();	
			
			if (mapEntity && mapEntity === entity) {
				return item;
			}
		}
	}

	return null;
};

MFilterableShapes.prototype.deleteShape = function(int_name_to_delete){
	/* probably a better way to do this, not a big performance
	   concern, will handle later @CLEANUP */
	for (var i in this.values) {
		if (int_name_to_delete == this.values[i].int_name){
			delete this.values[i];
			break;
		}
	}

	for (var i in this.children){
		if (int_name_to_delete == this.children[i].int_name){
			if (this.children[i].getModel()) {
				this.children[i].getModel().hide();
			}

			$(this.children[i].container).remove();
			delete this.children[i];
			break;
		}
	}

	if (this.filters && this.filters.values){
		for(var i in this.filters.values){
			if (int_name_to_delete == i){
				delete this.filters.values[i];
				break;
			}
		}
	}

	var curr = this.currentShape;
	if (curr && curr.int_name === int_name_to_delete) {
		curr.displayed = false;
		this.deselectShape();
	}

	this.onEmpty();
	this.onNameChange();
	this.saveShapes();
};

MFilterableShapes.prototype.restoreShape = function(int_name, ext_name, type, 
													path, displayed) {
	if(this.getShape(int_name)) {
		return false;
	}

	var item = {
		'int_name': int_name,
		'ext_name': ext_name,
		'type': type,
		'path': path,
		'dtype': 'shapeitem',
		'displayed': !!displayed
	};

	this.values.push(item);
	this.children[int_name] = this.getControl().getFilterable(item, this);

	return this.children[int_name];
};

MFilterableShapes.prototype.toggleShape = function(shape){
	if (this.currentShape && this.currentShape == shape) {
		this.deselectShape();
		return false;
	}
	this.selectShape(shape);
	return true;
};

MFilterableShapes.prototype.selectShape = function(shape) {
	if(typeof shape === 'undefined') {
		return false;
	}

	if (this.currentShape && this.currentShape != shape) {
		var model = this.currentShape.getModel();
		model.setLineColor(this.displayColor);
		model.setLineAlpha(this.displayLineAlpha);
		model.setFillColor(this.displayColor);
		model.setFillAlpha(this.displayFillAlpha);

		if (!this.currentShape.displayed) {
			model.hide();
		}
	}
	
	var manager = this.getControl().getManager();
	var shapeControl = manager.getControl('shape');

	this.unselectAllChildren();
	this.currentShape = shape;

	this.hasFilters = 1;
	this.updateFilterCount(this.ui.handle);
	
	var model = shape.getModel();

	model.setLineColor(this.activeColor);
	model.setLineAlpha(this.activeLineAlpha);
	model.setFillColor(this.activeColor);
	model.setFillAlpha(this.activeFillAlpha);

	/* Bind to the shapechange ajax event */
	manager.addAjaxEventListener('shapechanged', this);

	// Set shape as active
	shapeControl.bindShape(model);

	$(".clear_shape_filters", this.container)
		.attr({
			"checked": false
		});
	
	var shapeId = 'shape_' + shape.int_name;
	// Using getElementById to deal with '.'s and other characts being in the name
	var shapeElm = document.getElementById(shapeId);
	if (shapeElm) {
		$(shapeElm).addClass("selected");	
		// Can't use jquery here, because if the id of the shapeElm has 
		// a `\` character (illegal in ids), .find and it's ilk will mysteriously fail
		var inputs = shapeElm.getElementsByTagName('input');
		$.each(inputs, function (index, input) {
			if(input.getAttribute('name') == 'selected-shape') {
				input.checked = true;
				return;
			}
		});
	}		
};

MFilterableShapes.prototype.deselectShape = function() {
	if (!this.currentShape) {
		return;
	}

	var manager = this.getControl().getManager();
	var shapeControl = manager.getControl('shape');
	
	var prevActive = this.currentShape;
	this.currentShape = null;

	// Clear active shape
	shapeControl.unbindShape();
	prevActive.selectShape(false);

	var model = prevActive.getModel();
	if (!prevActive.displayed) {
		model.hide();
	} else {
		// Adjust transparency
		model.setLineColor(this.displayColor);
		model.setLineAlpha(this.displayLineALpha);
		model.setFillColor(this.displayColor);
		model.setFillAlpha(this.displayFillAlpha);

		model.show();
	}

//	$(this.ui.handle).removeClass("has-filters");
	this.hasFilters = 0;
	this.updateFilterCount(this.ui.handle);
	
	$('.children .criteria.selected').removeClass('selected');
	
	$(".clear_shape_filters", this.container)
		.attr({
			"checked": true
		});
	
	// Unbind events
	manager.removeAjaxEventListener('shapechanged', this);
};

MFilterableShapes.prototype.displayAllShapes = function() {
	this.massDisplayChange(true);	
};

MFilterableShapes.prototype.undisplayAllShapes = function() {
	this.massDisplayChange(false);
};

MFilterableShapes.prototype.massDisplayChange = function(show) {
	for (var i in this.children){
		var item = this.children[i];
		item.displayed = show;
		item.ui.display.checked = show;			

		if (show) {
			this.displayShape(item, false);
		} else {
			this.undisplayShape(item, false);
		}
	}

	this.saveShapes(null);
},

MFilterableShapes.prototype.displayShape = function(shape, dontSave) {
	var model = shape.getModel();

	if (shape !== this.currentShape) {
		model.setLineColor(this.displayColor);
		model.setLineAlpha(this.displayLineAlpha);
		model.setFillColor(this.displayColor);
		model.setFillAlpha(this.displayFillAlpha);
	}

	model.show();

	if (!dontSave) { 
		this.saveShapes(null);
	}
};

MFilterableShapes.prototype.undisplayShape = function(shape) {
	var model = shape.getModel();
	if (model && (!this.currentShape || 
				  model !== this.currentShape.getModel())) {
		model.hide();
		model = null;
	}

	this.saveShapes(null);
};

MFilterableShapes.prototype.saveShapes = function(ajax) {
	var shapes = [];
	var caller = this;
	
	$.each(this.children, function(k,v) {
		var s = {
			'name': v.ext_name,
			'ext_name': v.ext_name,
			'int_name': v.int_name,
			'path': v.path,
			'type': v.type
		};

		if(caller.currentShape === v) {
			s.selected = 1;
		}

		if (v.displayed) {
			s.displayed = 1;
		}

		shapes.push(s);
	});

	var obj = {
		"query": "save_stored_state",
		"name": "user_polygons",
		"value": shapes,
		"ds": "__app"
	};

	var hadAjax = (ajax) ? true : false;
	if(!hadAjax) {
		var ajax = new Moonshadow.Ajax();
	}

	ajax.addQuery(obj, this);

	if(!hadAjax) {
		ajax.execute();
	}
};

MFilterableShapes.prototype.onAjaxEvent = function(event, data, ajax) {
	if (event === 'shapechanged') {
		if (this.currentShape) {
			var shape = this.currentShape;
			shape.path = this.currentShape.getModel().getPoints(true);

			this.shapeStatistics(ajax, shape);
		}

		this.saveShapes(ajax);
	} else if (event === 'filterchange') {
		this.shapeStatistics(ajax);
	}
};

MFilterableShapes.prototype.onAjaxResponse = function(data) {};

MFilterableShapes.prototype.shapeStatistics = function(ajax, shape) {
	var self = this;

	var hadAjax = (ajax) ? true : false;
	if (!hadAjax) {
		var ajax = new Moonshadow.Ajax();
	}

	if (shape) {
		this.addShapeStatsQuery(ajax, shape);
	} else {
		$.each(this.children, function(key, shape) {
			self.addShapeStatsQuery(ajax, shape);
		});
	}

	if (!hadAjax) {
		ajax.execute();
	}
};

MFilterableShapes.prototype.addShapeStatsQuery = function(ajax, shape) {
	// If shape isn't ready no point in bothering QS about it
	if (!shape.getModel().isReady()) {
		shape.totalcount = 0;
		shape.updateCount(0);
		return;
	}
	
	var manager = this.getControl().getManager();
	var filtersControl = manager.getControl("filterscontrol");
	var shapeControl = manager.getControl("shape");
	var dsId = manager.getDatasource().int_name;
	var type = shape.getType();
	var query = shape.getStatsQuery(dsId);

	query.filter = shapeControl.getFilterValues(dsId);

	var callback = (function(shape) {
		return function(data) {
			if(data.result !== 'ok') {
				return; // Error in result - skip result
			}

			// Update counts with results;
			shape.totalcount = data.total || 0;
			shape.updateCount(data.total || 0);
		};
	}(shape));

	ajax.addQuery(query, callback);
};

MFilterableShapes.prototype.clearFilters = function() {
	this.deselectShape();
};

MFilterableShapes.prototype.getList = function(update) {
	var updateList = update || false;

	var obj = {
		"query": "load_stored_state",
		"name": "user_polygons",
		"ds": "__app"
	};

	var caller = this;
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(obj, this.processShapes, this);
	ajax.execute();
};

MFilterableShapes.prototype.processShapes = function(data) {
	if (data.result !== 'ok' || !data.value || !data.value.length) {
		var type = this.ui.shapeType.value;
		this.ui.shapeName.value = this.getNextName(type);
		this.onEmpty();
		return false;
	}

	var shapes = data.value;
	this.shapes = shapes; // @CLEANUP may want to remove this

	var updateList = false;
	var selected = false;

	var self = this;
	$.each(shapes, function(k, v) {
		var int_name = v.name.replace(/\s/g,'_').toLowerCase();
		var ext_name = v.name;
		var type = v.type || 'polygon';
		var shape = self.restoreShape(int_name, ext_name, type, v.path,
										  v.displayed);
		if (shape) {
			if (v.selected) {
				selected = shape;	
			}

			updateList = true;
		}

		if (shape.displayed) {
			self.displayShape(shape, true);
		}
	});

	var type = this.ui.shapeType.value;
	this.ui.shapeName.value = this.getNextName(type);

	if(updateList) {
		this.updateList();
	}
	
	if(selected && this.currentShape !== selected) {
		this.selectShape(selected);
	}
};


function MFilterableShapeItem(branch, parent) {
	this.countTotal = null;
	this.countPerc = null;
	this.path = branch.path;

	this.init(branch,parent);

	this.format = {
		"polygon": {
			"strokeColor": "#FF0000",
			"strokeOpacity": 0.8,
			"strokeWeight": 2,
			"fillColor": "#FF0000",
			"fillOpacity": 0.35
		},
		"polyline": {
			"strokeColor": "#FF0000",
			"strokeOpacity": 0.5,
			"strokeWeight": 2
		}
	};

	this.ui = {};
	this.displayed = branch.displayed;

	this.int_name = branch.int_name;
	this.ext_name = branch.ext_name;
	this.model = null;
	this.type = branch.type || 'polygon';
	this.createModel(parent.getControl().getManager());
}

MFilterableShapeItem.prototype = new MFilterable;

MFilterableShapeItem.prototype.buildUI = function(returnContainer) {
	var cdn = this.getControl().getManager().getOption("cdn");
	var doReturn = returnContainer || false;

	var container = document.createElement("div");
	container.className = "criteria autoHeight";
	container.id = 'shape_' + this.int_name;
	// @CLEANUP .data() runs bad in IE
	$(container).data("item", this);

	var radio = document.createElement('input');
	radio.type = 'radio';
	radio.name = 'selected-shape';
	radio.value = this.int_name;

	$(radio)
		.click({'self': this}, function(e) {
			var self = e.data.self;
			var parent = self.getParent();
			self.selectShape(parent.toggleShape(self));
		})

	this.ui.radio = radio;
	container.appendChild(radio);

	var display = document.createElement('input');
	display.type = 'checkbox';
	display.name = 'display-shape';
	display.value = this.int_name;
	display.checked = this.displayed;
	display.title = this.displayed ? "Hide shape" : "Show shape";
	
	$(display).click({'that': this, 'parent': this.getParent()}, function(event) {
		var data = event.data;
		if (event.target.checked) {
			data.that.displayed = true;
			data.that.title = "Hide shape";
			data.parent.displayShape(data.that);
		} else {
			data.that.displayed = false;
			data.that.title = "Show shape";
			data.parent.undisplayShape(data.that);
		}
	});

	this.ui.display = display;
	container.appendChild(display);

	var panTo = document.createElement("div");
	panTo.className = "pan-to sprite-zoomCenter toggle clickable";
	$(panTo).click({self: this}, function(event) {
		var self = event.data.self;

		var bounds = self.getModel().getBounds();
		if (!bounds) {
			return;
		}

		self.getControl().getManager().getAdapter().panToPoints(bounds);
	});

	container.appendChild(panTo);

	var deleteShape = document.createElement("div");
	deleteShape.className = "sprite-trash clickable right";
	deleteShape.title = "Delete Shape";

	$(deleteShape).click({"caller": this}, function(event){
		var caller = event.data.caller;
		MUILayoverPanel.confirm({
			"message": 'Delete shape "' + caller.ext_name + '"? This cannot be undone.',
			"callback": function(res, id, hide){
				if(res){
					caller.getParent().deleteShape(caller.int_name);
				}
				hide();
			}
		});
	});

	this.ui.deleteButton = deleteShape;
	container.appendChild(deleteShape);

	container.appendChild(this.makeCounts());
	if(this.countTotal && this.totalcount){
		this.countTotal.innerHTML = this.totalcount;
	}

	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	
	this.infoPanel = this.buildInfoPanel();
	container.appendChild(this.infoPanel);

	this.container = container;

	if(doReturn) {
		return this.container;
	} else {
		this.parent.childContainer.appendChild(this.container);
	}
};

MFilterableShapeItem.prototype.hasExpander = function() {
	return true;
};

MFilterableShapeItem.prototype.selectShape = function(onOff) {
	this.ui.radio.checked = onOff;
	this.ui.radio.title = (onOff ? "Disable " : "Enable ") + "shape filter";
	
};

MFilterableShapeItem.prototype.buildInfoPanel = function() {
	var container = document.createElement('div');
	container.className = 'info';
	container.style.display = 'none';

	// Name editing

	var nameGroup = document.createElement('div');
	nameGroup.className = 'datum name';

	var nameLabel = document.createElement('label');
	nameLabel.appendChild(document.createTextNode('Name:'));
	nameLabel.className = 'label';

	var nameField = document.createElement('input');
	nameField.type = 'text';
	nameField.className = 'value';

	// Radius apply button
	var nameApply = document.createElement('input');
	nameApply.type = 'button';
	nameApply.value = 'Save';
	nameApply.className = 'save';
	nameApply.disabled = true;

	$(nameField).on('input', $.proxy(function(event) {
		this.onNameFieldChange(event.target);
	}, this));

	$(nameField).keyup($.proxy(function(event) {
		if (event.keyCode === 13) {
			this.onNameApply(event.target);
		}
	}, this));
	
	$(nameApply).on('click', {'name': nameField}, $.proxy(function(event) {
		this.onNameApply(event.data.name);
	}, this));

	nameGroup.appendChild(nameLabel);
	nameGroup.appendChild(nameField);
	nameGroup.appendChild(nameApply);
	container.appendChild(nameGroup);

	// Shape specific controls
	if (this.type === 'polygon') {
		this.polygonInfoPanel(container);
	} else if (this.type === 'circle') {
		this.circleInfoPanel(container);
	} else {
		throw new Error('Invalid shape type');
	}

	return container;
};

MFilterableShapeItem.prototype.polygonInfoPanel = function(container) {

};

MFilterableShapeItem.prototype.circleInfoPanel = function(container) {
	// Radius	
	var radiusLabel = document.createElement('label');
	radiusLabel.appendChild(document.createTextNode('Radius:'));
	radiusLabel.className = 'label';

	var radiusField = document.createElement('input');
	radiusField.type = 'text';
	radiusField.className = 'value';

	// Radius unit select
	var radiusUnit = document.createElement('select');
	radiusUnit.className = 'unit';
	
	var mileOpt = document.createElement('option');
	mileOpt.appendChild(document.createTextNode('mile(s)'));
	mileOpt.value = 'mi';

	var feetOpt = document.createElement('option');
	feetOpt.appendChild(document.createTextNode('feet(s)'));
	feetOpt.value = 'ft';

	var kmOpt = document.createElement('option');
	kmOpt.appendChild(document.createTextNode('km(s)'));
	kmOpt.value = 'km';

	var meterOpt = document.createElement('option');
	meterOpt.appendChild(document.createTextNode('meter(s)'));
	meterOpt.value = 'm';
		
	radiusUnit.appendChild(mileOpt);
	radiusUnit.appendChild(feetOpt);
	radiusUnit.appendChild(kmOpt);
	radiusUnit.appendChild(meterOpt);

	// Radius apply button
	var radiusApply = document.createElement('input');
	radiusApply.type = 'button';
	radiusApply.value = 'Apply';
	radiusApply.className = 'apply';

	$(radiusField).on('input', $.proxy(function(event) {
		this.onRadiusFieldChange(event.target);
	}, this));
	
	$(radiusField).keyup($.proxy(function(event) {
		if (event.keyCode === 13) {
			this.onRadiusApply(event.target);
		}
	}, this));
	
	$(radiusApply).on('click', {'radius': radiusField}, $.proxy(function(event) {
		this.onRadiusApply(event.data.radius);
	}, this));

	$(radiusUnit).on('change', {'radius': radiusField}, $.proxy(function() {
		this.shapeDetails();	
	}, this));
	
	var radiusDatum = document.createElement('div');
	radiusDatum.className = 'datum radius';
	
	radiusDatum.appendChild(radiusLabel);
	radiusDatum.appendChild(radiusField);
	radiusDatum.appendChild(radiusUnit);
	radiusDatum.appendChild(radiusApply);
	container.appendChild(radiusDatum);

	container.appendChild(this.makeClear());
};

MFilterableShapeItem.prototype.toggle = function() {
	var container = this.infoPanel;
	var manager = this.getControl().getManager();
	var model = this.getModel();

	if (container.style.display !== 'block') {
		$(this.expander).addClass('expanded');
		container.style.display = 'block';

		model.addEventListener('changed', this.shapeDetails, this);

		this.shapeDetails();
	} else {
		$(this.expander).removeClass('expanded');
		container.style.display = 'none';

		model.removeEventListener('changed', this.shapeDetails, this);
	}
	
	//manager.mapObservers.notify('filterabletoggle', this);
};

MFilterableShapeItem.prototype.onNameFieldChange = function(element) {
	var name = element.value;
	if (this.parent.nameExists(name)) {
		if (this.ext_name !== name) {
			$(element).css('background-color', 'orange');
		}
		$('.save', element.parentNode).attr('disabled', 'disabled');
		$('.save', element.parentNode).attr('title', 'Please enter a unique name');
		return false;
	}

	$(element).css('background-color', '');
	$('.save', element.parentNode).removeAttr('disabled');
	$('.save', element.parentNode).removeAttr('title');

	return true;
};

MFilterableShapeItem.prototype.onNameApply = function(element) {
	if (!this.onNameFieldChange(element))  {
		return;
	} else {
		this.int_name = element.value.replace(/\s/g,'_').toLowerCase();
		this.ext_name = element.value;
		var handle = this.expander.parentNode;
		$('.label', handle).text(this.ext_name);
		this.parent.saveShapes(null);
	}
};

MFilterableShapeItem.prototype.onRadiusFieldChange = function(element) {
	var unit = $('.unit', element.parentNode).val();

	try {
		var radiusQty = Qty(element.value + ' ' + unit);
		radiusQty = radiusQty.to('m');
	} catch (e) {
		$(element).css('background-color', 'orange');
		$('.apply', element.parentNode).attr('disabled', 'disabled');
		return null;
	}

	$(element).css('background-color', '');
	$('.apply', element.parentNode).removeAttr('disabled');

	return radiusQty;
};

MFilterableShapeItem.prototype.onRadiusApply = function(element) {
	var radiusQty = this.onRadiusFieldChange(element);
	if (!radiusQty) {
		return;
	}

	var dist = parseFloat(radiusQty.toString());
	var model = this.getModel().setRadiusDistance(dist);
};

MFilterableShapeItem.prototype.shapeDetails = function() {
	var info = this.infoPanel;
	$('.name .value', info).val(this.ext_name);

	if (this.type === 'polygon') {
		this.polygonDetails();
	} else if (this.type === 'circle') {
		this.circleDetails();
	} else {
		throw new Error('Invalid shape type');
	}
};

MFilterableShapeItem.prototype.polygonDetails = function() {};

MFilterableShapeItem.prototype.circleDetails = function() {
	var info = this.infoPanel;
	var model = this.getModel();

	var unit = $('.radius .unit', info).val();
	var radius = model.getRadiusMeters();
	var radiusQty = Qty(radius + 'm').to(unit);

	var perc;
	switch (unit) {
	case 'mi':
		perc = '0.001 mi';
		break;
	case 'ft':
		perc = '0.1 ft';
		break;
	case 'km':
		perc = '0.001 km';
		break;
	case 'm':
		perc = '0.1 m';
		break;
	default: 
		throw new Error('Invalid unit');
	}

	$('.radius .value', info).val(parseFloat(radiusQty.toPrec(perc)));
};

MFilterableShapeItem.prototype.onAjaxEvent = function() {
	
};

MFilterableShapeItem.prototype.attach = function(branch) {
	if(typeof branch[this.int_name] != "object") {
		branch[this.int_name] = {};
	}

	return branch[this.int_name];
};

MFilterableShapeItem.prototype.getPoints = function() {
	if (!this.path) {
		return null;
	}

	return this.path.slice(0);
};

MFilterableShapeItem.prototype.createModel = function(manager) {
	var model;

	var type = this.getType();
	if (type === 'polygon') {
		// Create a polygon
		model = new MMapPolygon(manager);
	} else if (type === 'circle') {
		// Create a circle
		model = new MMapCircle(manager);
	} else {
		throw new Error('Invalid shape type');
	}

	model.setPoints(this.getPoints());
	this.setModel(model);

	return model;
};

MFilterableShapeItem.prototype.setModel = function(model) {
	this.model = model;
};

MFilterableShapeItem.prototype.getModel = function() {
	return this.model;
};

MFilterableShapeItem.prototype.getType = function() {
	return this.type;
};

MFilterableShapeItem.prototype.getStatsQuery = function(dsId) {
	return this.getModel().getStatsQuery(dsId, this.int_name);
};
//MFilterableBool
function MFilterableBool(branch,parent) {
	this.children = {};
	this.countTotal = null;
	this.countPerc = null;

	this.init(branch,parent);

	this.values = ["Yes","No"]; //This need to add "unknown"

	this.hasFilters = this.countFilters();
}

MFilterableBool.prototype = new MFilterable;

MFilterableBool.prototype.buildUI = function() {
	var control = this.getControl();
	var container = document.createElement("div");
	container.className = "filterable "+this.dtype;
	container.id = "filterable_"+this.int_name;

	container.appendChild(this.makeColorBy());

	if(this.acceptableTableRow && this.acceptableTableRow == 1){
		$(this.getDatasource().openSS).removeClass("hide");
		this.rowAdder = this.makeSpreadsheetRowAdder(this);
		container.appendChild(this.rowAdder);
	} else {
		container.className += " no-spreadsheet-row";
	}

	if(control.options[this.int_name+"_docs"]) {
		var doclist = control.createDocList(control.options[this.int_name+"_docs"]);
		container.appendChild(doclist);
	}

	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	container.appendChild(this.makeChildren());

	this.container = container;
	this.parent.childContainer.appendChild(this.container);
};

MFilterableBool.prototype.getShowStats = function() {
	return true;
};
//MFilterableInt
function MFilterableInt(branch,parent) {
	this.children = {};
	this.init(branch,parent);

	this.values = {};
	this.filterValue = {};

	this.max = (typeof branch.max != "undefined") ? branch.max : undefined;
	this.min = (typeof branch.min != "undefined") ? branch.min : undefined;
	this.hasUnknowns = 1;

	this.ui = {};

	this.hasFilters = this.countFilters();
}

MFilterableInt.prototype = new MFilterable;

MFilterableInt.prototype.buildUI = function() {
	var container = document.createElement("div");
	container.className = "no-color-by filterable "+this.dtype;
	container.id = "filterable_"+this.int_name;

	if(this.acceptableTableRow && this.acceptableTableRow == 1){
		$(this.getDatasource().openSS).removeClass("hide");
		this.rowAdder = this.makeSpreadsheetRowAdder(this);
		container.appendChild(this.rowAdder);
	} else {
		container.className += " no-spreadsheet-row";
	}

	if(this.getControl().options[this.int_name+"_docs"]) {
		container.appendChild(this.getControl().createDocList(
			this.getControl().options[this.int_name+"_docs"]));
	}

	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	container.appendChild(this.makeChildren());

	this.container = container;
	this.parent.childContainer.appendChild(this.container);
};

MFilterableInt.prototype.hasExpander = function() {
	return true;
};

MFilterableInt.prototype.buildChildren = function() {
	var rangecontainer = document.createElement("div");
	rangecontainer.className = "criteria range "+this.dtype;
	rangecontainer.style.height = "auto";

	var header = document.createElement("div");
	header.className = "header";
	var headerString = "Filter by range";
	if(this.min != undefined || this.max != undefined) {
		headerString = (function(s,min,max) {
			if(typeof min != "undefined" && typeof max != "undefined") {
				return headerString + " (" + min + " - " + max + ")";
			} else if(typeof min != "undefined") {
				return headerString + " (>=" + min + ")";
			} else if(typeof max != "undefined") {
				return headerString + " (<=" + max + ")";
			}

			return headerString; // Shouldn't get to this
		})(headerString,this.min,this.max);
	}

	header.appendChild(document.createTextNode(headerString));
	rangecontainer.appendChild(header);

	var fromContainer = document.createElement("div");
	fromContainer.className = 'limit';

	var fromLabel = document.createElement("span");
	fromLabel.className = "label";

	fromLabel.appendChild(document.createTextNode("From:"));

	var filter = this.getFilterValue();
	if (!filter) {
		filter = {};
	}

	var fromText = document.createElement("input");
	fromText.type = "text";
	fromText.value = (filter.from) ? filter.from : this.min;
	fromText.className = "range_field";
	this.ui.from = fromText;

	$(fromText).data("label",fromLabel);
	$(fromText).data("filter",this);
	$(fromText).data("name","from");
	$(fromText).change({"self":this},function(event) {
		var self = event.data.self;
		var element = $(this);

		self.validateFilter.call(this,event);

		element.data("filter").onChange(this);
	});

	fromContainer.appendChild(fromLabel);
	fromContainer.appendChild(fromText);
	fromContainer.appendChild(this.makeClear());

	var toContainer = document.createElement("div");
	toContainer.className = 'limit';

	var toLabel = document.createElement("span");
	toLabel.className = "label";
	toLabel.appendChild(document.createTextNode("To:"));

 	var toText = document.createElement("input");
	toText.type = "text";
	toText.value = (filter.to) ? filter.to : this.max;
	toText.className = "range_field";
	this.ui.to = toText;

	$(toText).data("label",toLabel);
	$(toText).data("filter",this);
	$(toText).data("name","to");
	$(toText).change({"self":this},function(event) {
		var self = event.data.self,
		element = $(this);

		self.validateFilter.call(this,event);

		element.data("filter").onChange(this);
	});

	toContainer.appendChild(toLabel);
	toContainer.appendChild(toText);
	toContainer.appendChild(this.makeClear());

	rangecontainer.appendChild(fromContainer);
	rangecontainer.appendChild(toContainer);
	rangecontainer.appendChild(this.makeClear());

	if(this.hasUnknowns) {
		var unknownContainer = document.createElement("div");
		var unknownLabel = document.createElement("span");
		unknownLabel.className = "label";
		unknownLabel.appendChild(document.createTextNode("Unknowns:"));
		
		var unknownCheckLabel = document.createElement("span");
		unknownCheckLabel.className = "label";

		var unknownBox = document.createElement("input");
		unknownBox.type = "checkbox";
		unknownBox.checked = (typeof filter.unknown === 'undefined' ||filter.unknown) ? true : false;
		unknownBox.value = "0";
		
		unknownCheckLabel.appendChild(unknownBox);

		this.ui.unknown = unknownBox;

		$(unknownBox).data("label", unknownLabel);
		$(unknownBox).data("filter", this);
		$(unknownBox).data("name", "unknown");
		$(unknownBox).change({"self":this}, function(event) {
			var self = event.data.self;
			self.onChange(this);
		});

		unknownContainer.appendChild(unknownLabel);
		unknownContainer.appendChild(unknownCheckLabel);

		rangecontainer.appendChild(unknownContainer);
		rangecontainer.appendChild(this.makeClear());
		rangecontainer.appendChild(this.makeSpacer());

	}

	return rangecontainer;
};

MFilterableInt.prototype.validateFilter = function(event) {
	var f = event.data.self;
	var n = $(this).data("name")
	var v = parseInt(this.value,10);
	if(v < f.min) {
		v = f.min
	} else if(v > f.max) {
		v = f.max
	}

	if(isNaN(v))
		v = (n == "to") ? f.max : f.min;

	this.value = v;
};

MFilterableInt.prototype.clearSpecificFilter = function() {
	var to = this.ui.to;
	var from = this.ui.from;
	var unknown = this.ui.unknown;

	if (typeof from != "undefined") {
		if(typeof this.min != "undefined") {
			from.value = parseInt(this.min,10);
		} else {
			from.value = 0;
		}
	}

	if (typeof to != "undefined") {
		if(typeof this.max != "undefined") {
			to.value = parseInt(this.max,10);
		} else {
			to.value = 0;
		}
	}

	if (typeof unknown != "undefined") {
		unknown.checked = true; 
	}

	if(this.container){
		$.each($(".checkbox input",this.container),function(k,v) {
			v.checked = false;
		});

		$.each($(".label.selected",this.container),function(k,v) {
			$(v).removeClass("selected");
		});
	}
};

MFilterableInt.prototype.onChange = function(input) {
	var filter = {};
	var to = parseInt(this.ui.to.value, 10);
	var from = parseInt(this.ui.from.value, 10);
	var unknown = true;

	if (this.ui.unknown) {
		unknown = this.ui.unknown.checked;
	}

	if (to !== this.max || from !== this.min || !unknown) {
		if (to) {
			filter.to = to;
		}

		if (from) {
			filter.from = from;
		}

		filter.unknown = (unknown) ? 1 : 0;

		this.setFilterValue(filter);
	} else {
		this.clearFilterValue();
	}

	this.perculateChange();
};

MFilterableInt.prototype.updateFilterState = function() {
	
	var filterValue = this.getFilterValue();

	if(filterValue){
		
		if(filterValue.to && this.ui.to){
			$(this.ui.to).val(filterValue.to);
		}
		
		if(filterValue.from && this.ui.from){
			$(this.ui.from).val(filterValue.from);
		}
		
		if(this.ui.unknown){
			$(this.ui.unknown).attr({
				"checked": filterValue > 0
			});
		}
	}
	
	this.hasFilters = this.countFilters();

	if(this.ui.handle) {
		this.updateFilterCount(this.ui.handle);
	}
};


//MFilterableDate
function MFilterableDate(branch,parent) {
	this.children = {};
	this.init(branch,parent);

	this.values = {};
	this.filterValue = {};

	this.max = (typeof branch.max_year != "undefined") ? branch.max_year : undefined;
	this.min = (typeof branch.min_year != "undefined") ? branch.min_year : undefined;

	this.forceExpander = true;
	this.ui = {};

	this.hasFilters = this.countFilters();

}

MFilterableDate.prototype = new MFilterable;

MFilterableDate.prototype.buildUI = function() {
	var container = document.createElement("div");
	container.className = "no-color-by filterable "+this.dtype;
	container.id = "filterable_"+this.int_name;

	if(this.acceptableTableRow && this.acceptableTableRow == 1){
		$(this.getDatasource().openSS).removeClass("hide");
		this.rowAdder = this.makeSpreadsheetRowAdder(this);
		container.appendChild(this.rowAdder);
	} else {
		container.className += " no-spreadsheet-row";
	}

	if(this.getControl().options[this.int_name+"_docs"]) {
		container.appendChild(this.getControl().createDocList(this.getControl().options[this.int_name+"_docs"]));
	}

	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	container.appendChild(this.makeChildren());

	this.container = container;
	this.parent.childContainer.appendChild(this.container);
};

MFilterableDate.prototype.hasExpander = function() {
	return true;
};
	
MFilterableDate.prototype.buildChildren = function() {
	var rangecontainer = document.createElement("div");
	rangecontainer.className = "criteria range date";
	rangecontainer.style.height = "auto";

	var header = document.createElement("div");
	header.className = "header";

	var headerString = "Filter by range";
	if(this.min != undefined || this.max != undefined) {
		headerString = (function(s,min,max) {
			if(typeof min_year != "undefined" && typeof max_year != "undefined") {
				return headerString + " (" + min + " - " + max + ")";
			} else if(typeof min_year != "undefined") {
				return headerString + " (>=" + min + ")";
			} else if(typeof max_year != "undefined") {
				return headerString + " (<=" + max + ")";
			}

			return headerString; // Shouldn't get to this
		})(headerString,this.min,this.max);
	}

	header.appendChild(document.createTextNode(headerString));
	rangecontainer.appendChild(header);

	var filter = this.getFilterValue();
	if (!filter) {
		filter = {};
	}

	var fromContainer = document.createElement("div");
	fromContainer.className = 'limit';

	var fromLabel = document.createElement("span");
	fromLabel.className = "label";
	fromLabel.appendChild(document.createTextNode("On and After:"));

	var fromDate;
	if (filter.from) {
		fromDate = this.formatDate(
			Moonshadow.helpers.rDateDecode(filter.from)
		);
	}

	var fromOptions = {
		"changeYear":true,
		"maxDate":"12/31/"+this.max.toString(),
		"minDate":"01/01/"+this.min.toString(),
		"yearRange": this.min.toString()+":"+this.max.toString(),
		"defaultDate": (fromDate) ? fromDate : "01/01/"+this.min.toString()
	};

	var fromText = document.createElement("input");
	$(fromText)
		.addClass("date_field")
		.attr({
			"type": "text",
			"readonly": true,
			"value": fromOptions.defaultDate.toString()
		})
		.data({
			"filter": this,
			"label": fromLabel,
			"name": "from"
		})
		.on("change", {"self":this}, function(event) {
			var self = event.data.self;
			var datepicker = $(this);
			var type = datepicker.data("name");
			var value = datepicker.val();
	
			self.validateFilter.call(this,event);
			datepicker.data("filter").onChange(this);
		})
		.datepicker(fromOptions)
		.get(0);

	this.ui.from = fromText;

	var fromClear = document.createElement("span");
	fromClear.className = "ui-icon ui-icon-circle-close";
	$(fromClear).data("input",fromText);
	$(fromClear).click(function(event) {
		$(this).data("input").value = $($(this).data("input")).datepicker("option","minDate");
		$($(this).data("input")).trigger("change");
	 });

	fromContainer.appendChild(fromLabel);
	fromContainer.appendChild(fromText);
	fromContainer.appendChild(fromClear);
	fromContainer.appendChild(this.makeClear());
	rangecontainer.appendChild(fromContainer);

	var toContainer = document.createElement("div");
	toContainer.className = 'limit';

	var toLabel = document.createElement("span");
	toLabel.className = "label";
	toLabel.appendChild(document.createTextNode("On and Before:"));

	var toDate;
	if (filter.to) {
		toDate = this.formatDate(
			Moonshadow.helpers.rDateDecode(filter.to)
		);
	}

	var toOptions = {
		"changeYear":true,
		"maxDate":"12/31/"+this.max.toString(),
		"minDate":"01/01/"+this.min.toString(),
		"yearRange": this.min.toString()+":"+this.max.toString(),
		"defaultDate": (toDate) ? toDate : "12/31/"+this.max.toString()
	};

	var toText = document.createElement("input");
	$(toText)
		.addClass("date_field")
		.attr({
			"type": "text",
			"readonly": true,
			"value": toOptions.defaultDate.toString()
		})
		.data({
			"filter": this,
			"label": toLabel,
			"name": "to"
		})
		.on("change", {"self":this}, function(event) {
			var self = event.data.self,
				datepicker = $(this),
				type = datepicker.data("name"),
				value = datepicker.val();
			
			self.validateFilter.call(this,event);
			datepicker.data("filter").onChange(this);
	
			self.filterValue[type] = Moonshadow.helpers.rDate(value);
		})
		.datepicker(toOptions)
		.get(0);
		
	this.ui.to = toText;

	var toClear = document.createElement("span");
	toClear.className = "ui-icon ui-icon-circle-close";
	$(toClear).data("input",toText);
	$(toClear).click(function(event) {
		$(this).data("input").value = $($(this).data("input")).datepicker("option","maxDate");
		$($(this).data("input")).trigger("change");
	});

	toContainer.appendChild(toLabel);
	toContainer.appendChild(toText);
	toContainer.appendChild(toClear);
	toContainer.appendChild(this.makeClear());

	rangecontainer.appendChild(toContainer);
	rangecontainer.appendChild(this.makeClear());

	if(this.hasUnknowns) {
		var unknownContainer = document.createElement("div");
		var unknownLabel = document.createElement("span");
		unknownLabel.className = "label";
		unknownLabel.appendChild(document.createTextNode("Unknowns:"));

		var unknownCheckLabel = document.createElement("span");
		unknownCheckLabel.className = "label";
		
		var unknownBox = document.createElement("input");
		unknownBox.type = "checkbox";
		unknownBox.checked = (typeof filter.unknown === 'undefined' ||
							  filter.unknown) ? true : false;
		unknownBox.value = "0";

		unknownCheckLabel.appendChild(unknownBox);
		
		this.ui.unknown = unknownBox;

		$(unknownBox).data("label",unknownLabel);
		$(unknownBox).data("filter",this);
		$(unknownBox).data("name","unknown");
		$(unknownBox).change({"self":this}, function(event) {
			var self = event.data.self;
			self.onChange(this);
		 });

		unknownContainer.appendChild(unknownLabel);
		unknownContainer.appendChild(unknownCheckLabel);

		rangecontainer.appendChild(unknownContainer);
		rangecontainer.appendChild(this.makeClear());
		rangecontainer.appendChild(this.makeSpacer());
	}

	return rangecontainer;
};

MFilterableDate.prototype.formatDate = function(intDate){
	return (intDate.getMonth() + 1 ) +"/"+ intDate.getDate() +"/"+ intDate.getFullYear();
};

MFilterableDate.prototype.validateFilter = function(event) {		
	var self = event.data.self;
	var itemValue = this.value;

	if(Date.parse(itemValue) < Date.parse("01/01/"+self.min)) {
		itemValue = "01/01/"+self.min;
	} else if(Date.parse(itemValue) > Date.parse("12/31/"+self.max)) {
		itemValue = "12/31/"+self.max;
	}

	this.value = itemValue;
};

MFilterableDate.prototype.clearSpecificFilter = function() {
	var to = this.ui.to;
	var from = this.ui.from;
	var unknown = this.ui.unknown;

	if (typeof from != "undefined") {
		from.value = $(from).datepicker("option","minDate");
	}

	if (typeof to != "undefined") {
		to.value = $(to).datepicker("option","maxDate");
	}

	if (typeof unknown != "undefined") {
		unknown.checked = true;
	}

	if(this.container){
		$.each($(".checkbox input",this.container),function(k,v) {
			v.checked = false;
		});
	
		$.each($(".label.selected",this.container),function(k,v) {
			$(v).removeClass("selected");
		});
	}
};

MFilterableDate.prototype.onChange = function() {
	var filter = {};
	var to = this.ui.to.value;
	var from = this.ui.from.value;
	var unknown = true;

	if (this.ui.unknown) {
		unknown = this.ui.unknown.checked;
	}

	if ((from !== '1/1/' + this.min && from !== '01/01/' + this.min) || 
		to !== '12/31/' + this.max || !unknown) {
		if (to) {
			filter.to = Moonshadow.helpers.rDate(to);
		}

		if (from) {
			filter.from = Moonshadow.helpers.rDate(from);
		}

		filter.unknown = (unknown) ? 1 : 0;

		this.setFilterValue(filter);
	} else {
		this.clearFilterValue();
	}

	this.perculateChange();
};

MFilterableDate.prototype.updateFilterState = function() {
	
	var filterValue = this.getFilterValue();

	if(filterValue){
		
		if(filterValue.to && this.ui.to){
			$(this.ui.to).val(
				this.formatDate(
					Moonshadow.helpers.rDateDecode(filterValue.to)
				)
			);
		}
		
		if(filterValue.from && this.ui.from){
			$(this.ui.from).val(
				this.formatDate(
					Moonshadow.helpers.rDateDecode(filterValue.from)
				)
			);
		}
		
		if(this.ui.unknown){
			$(this.ui.unknown).attr({
				"checked": filterValue > 0
			});
		}
	}
	
	this.hasFilters = this.countFilters();

	if(this.ui.handle) {
		this.updateFilterCount(this.ui.handle);
	}
};



//MFilterableDateTime
function MFilterableDateTime(branch,parent) {
	this.children = {};
	this.init(branch,parent);
	this.manager = this.getControl().getManager();

	this.values = {};
	//this.filterValue = {};

	this.columnAdder = [];
	
	this.min = null;
	this.max = null;

	this.globalMin = new Date(1370080000 * 1000);
	this.globalMax = new Date(4455344000 * 1000);	

	this.ui = {};

	this.hasFilters = this.countFilters();;
	this.histogramShowing = false;
}

MFilterableDateTime.prototype = new MFilterable;

MFilterableDateTime.prototype.buildUI = function() {
	var self = this;
	this.getDateTimeRange(function (data) {
		self.parseDateRange(data);
	});

	var container = document.createElement("div");
	container.className = "no-color-by filterable "+this.dtype;
	container.id = "filterable_"+this.int_name;

	if(this.acceptableTableRow && this.acceptableTableRow == 1){
		$(this.getDatasource().openSS).removeClass("hide");
		this.rowAdder = this.makeSpreadsheetRowAdder(this);
		container.appendChild(this.rowAdder);
	} else {
		container.className += " no-spreadsheet-row";
	}

	if (this.getControl().options[this.int_name+"_docs"]) {
		container.appendChild(this.getControl().createDocList(
			this.getControl().options[this.int_name+"_docs"]));
	}

	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	container.appendChild(this.makeChildren());

	this.container = container;
	self.parent.childContainer.appendChild(this.container);
};

MFilterableDateTime.prototype.hasExpander = function() {
	return true;
};

MFilterableDateTime.prototype.buildChildren = function() {
	var self = this,
	rangecontainer, filterUI, header, histogramDisplay, removeHistogram,
	spreadsheetColumns;

	// Main container
	rangecontainer = document.createElement("div");
	rangecontainer.className = "criteria range date";
	rangecontainer.style.height = "auto";

	// Filter group
	filterUI = document.createElement("div");
	filterUI.className = 'range-filters filterable-group';

	header = document.createElement("div");
	header.className = "header";

	histogramDisplay = document.createElement("span");
	histogramDisplay.className = "histogram-display";
	histogramDisplay.title = "Open Histogram";

	if (typeof d3 === 'undefined') {
		histogramDisplay.className += " sprite-chart_column_small clickable";
	} else {
		histogramDisplay.className += " sprite-chart_column_sel_small clickable";
	}

	$(histogramDisplay).click({"self":this}, this.showTemporal);
	header.appendChild(histogramDisplay);

	/*	
	removeHistogram = document.createElement("span");
	removeHistogram.className = "histogram-remove clickable";
	$(removeHistogram).click({"self":this}, this.hideTemporal);
	header.appendChild(removeHistogram);
	*/

	header.appendChild(document.createTextNode("Filter by range"));
	
	filterUI.appendChild(header);
	filterUI.appendChild(this.buildFilter("Start:", "from"));
	filterUI.appendChild(this.buildFilter("End:", "to"));

	rangecontainer.appendChild(filterUI);

	// Spreadsheet group
	spreadsheetColumns = document.createElement("div");
	spreadsheetColumns.className = 'ts_ss_column filterable-group';

	header = document.createElement("div");
	header.className = 'header';
	header.appendChild(document.createTextNode("Spreadsheet columns"));
	spreadsheetColumns.appendChild(header);
	
	self.columnAdder = [];
	$(spreadsheetColumns).append(
		$(["Hours", "Days", "Weeks"]).map(function(index, item){
			var ssObj = document.createElement("div"),
			ssObjLabel = document.createElement("span");
			
			var columnAdder = self.makeSpreadsheetColumnAdder(
				self, "timestamp", item.toLowerCase()
			);

			$(columnAdder).data({
				"bucket": item.toLowerCase()
			});
			
			self.columnAdder.push(columnAdder);
			
			return $(ssObj)
				.addClass("ss_ts_" + item.toLowerCase())
				.append(
					columnAdder,
					$(ssObjLabel)
						.append(item)
				)
				.get(0);
		})
	);
	rangecontainer.appendChild(spreadsheetColumns);

	return rangecontainer;
};

MFilterableDateTime.prototype.getColumnAdder = function(type){
	return this.columnAdder;
};

MFilterableDateTime.prototype.buildFilter = function(label, name) {
	var container = this.buildFilterContainer(label);

	var subContainer = this.buildSubContainer();
	container.appendChild(subContainer);

	var date = this.buildDateField(name);
	subContainer.appendChild(date);

	this.ui[name + "_date"] = date;

	var time = this.buildTimeField(name, date);
	subContainer.appendChild(time);

	this.ui[name + "_time"] = time;

	var clear = this.buildClearButton(name, date, time, name);
	subContainer.appendChild(clear);

	container.appendChild(this.makeClear());
	
	return container;
};

MFilterableDateTime.prototype.buildFilterContainer = function(labelText) {
	var container = document.createElement("div");
	container.className = 'limit';

	var label = document.createElement("span");
	label.className = "timestamp_label";
	label.appendChild(document.createTextNode(labelText));
	container.appendChild(label);

	return container;
};

MFilterableDateTime.prototype.buildDateField = function(fieldType) {
	var dateField = document.createElement("input");
	dateField.type = "text";
	dateField.readOnly = true;
	dateField.value = (fieldType === 'from') ? this.getDateValueForStart() :
		this.getDateValueForEnd();

	var options = {
		"changeMonth": true,
		"changeYear": true,
		"maxDate": "1/1/2037",
		"minDate": "1/1/1971",
		"yearRange": "1971:2037"
	};

	$(dateField).datepicker(options);
	$(dateField).addClass(fieldType + "_date date_field");
	$(dateField).data({
		"filter": this,
		"type": "date"
	});

	$(dateField).change({"self":this}, this.onChange);
	
	return dateField;
};

MFilterableDateTime.prototype.buildTimeField = function(fieldType, dateField) {
	var timeField = document.createElement("input");
	timeField.type = "text";

	// setting the value for fromTime is a touch tricky because we
	// must assume that the page could be reloaded so it has to be
	// calculated from persistent data which means that we have to
	// calculate it from fromDate's value.
	
	if (!dateField.value) {
		timeField.readOnly = true;
		$(timeField).addClass("field_disabled");
	}
	
	$(timeField).data({
		"filter": this,
		"type": "time"
	});

	$(timeField).timepicker({
		'disableTextInput': true,
		'scrollDefaulttime' : true
	});
	
	$(timeField).addClass(fieldType + "_time time_field");

	var value = (fieldType === 'from') ? this.getTimeValueForStart() :
		this.getTimeValueForEnd();

	$(timeField).timepicker('setTime', value);
	$(timeField).change({"self":this}, this.onChange);
	
	return timeField;
};

MFilterableDateTime.prototype.buildClearButton = function(clearString,
														  dateField, timeField,
														  name) {
	var clearButton = document.createElement("span");
	clearButton.className = "ui-icon ui-icon-circle-close";

	$(clearButton).click({"dateField": dateField, "timeField": timeField,
						  "self": this, 'type': name}, this.onClearDate);
	
	return clearButton;
};

MFilterableDateTime.prototype.buildSubContainer = function () {
	var subContainer = document.createElement("div");
	subContainer.className = "datetime_sub";
	return subContainer;
};

MFilterableDateTime.prototype.onChange = function(event) {	
	var self = event.data.self;

	var dates = self.getUIDates();
	self.setDates(dates[0], dates[1]);

	// This deals with an annoying problem related to datepicker not reopening
	$(this).blur();
};

MFilterableDateTime.prototype.onClearDate = function(event) {
	var self = event.data.self;
	var dateField = event.data.dateField;
	var timeField = event.data.timeField;
	var type = event.data.type

 	var dateValue = (type === 'to') ? self.formatDate(self.getMax()) :
		self.formatDate(self.getMin());
 	var timeValue = (type === 'to') ? self.formatTime(self.getMax()) :
		self.formatTime(self.getMin());

	dateField.value = dateValue;
	$(timeField).timepicker('setTime', timeValue);

	var dates = self.getUIDates();
	self.setDates(dates[0], dates[1]);
};

MFilterableDateTime.prototype.getMin = function() {
	return this.min || this.globalMin;
}

MFilterableDateTime.prototype.getMax = function() {
	return this.max || this.globalMax;
}

MFilterableDateTime.prototype.getDateForStart = function() {
	var date = this.getMin();

	var filter = this.getFilterValue({});
	if (filter['from']) {
		date = new Date(filter['from'] * 1000); // Make it ms
	}

	return date;
};

MFilterableDateTime.prototype.getDateForEnd = function() {
	var date = this.getMax();

	var filter = this.getFilterValue({});
	if (filter['to']) {
		date = new Date(filter['to'] * 1000); // Make it ms
	}

	return date;
};

MFilterableDateTime.prototype.getDateValueForStart = function() {
	var date = this.getDateForStart();
	return this.formatDate(date);
};

MFilterableDateTime.prototype.getTimeValueForStart = function() {
	var date = this.getDateForStart();
	return this.formatTime(date);
};

MFilterableDateTime.prototype.getDateValueForEnd = function() {
	var date = this.getDateForEnd();
	return this.formatDate(date);
};

MFilterableDateTime.prototype.getTimeValueForEnd = function() {
	var date = this.getDateForEnd();
	return this.formatTime(date);
};

MFilterableDateTime.prototype.formatDate = function(date) {
	var day = ('0' + date.getDate()).slice(-2);
	var month = ('0' + (date.getMonth() + 1)).slice(-2) ;
	var year = date.getFullYear();
	return [month, day, year].join('/');
};

MFilterableDateTime.prototype.formatTime = function(date) {
	var hour = ('0' + date.getHours()).slice(-2);
	var minute = ('0' + date.getMinutes()).slice(-2);
	return [hour, minute].join(':');
};

MFilterableDateTime.prototype.getDate = function(date, seconds) {
	return new Date(new Date(date).getTime() + seconds * 1000);
};

MFilterableDateTime.prototype.getTimestamp = function(date, time) {
	return new Date(date) / 1000 + time;
};

MFilterableDateTime.prototype.getUIDates = function() {
	var fromDate = $(this.ui['from_date']).val();
	var fromTime = $(this.ui['from_time']).timepicker('getSecondsFromMidnight');
	var from = this.getDate(fromDate, fromTime);

	var toDate = $(this.ui['to_date']).val();
	var toTime = $(this.ui['to_time']).timepicker('getSecondsFromMidnight');
	var to = this.getDate(toDate, toTime);

	return [from, to];
};

MFilterableDateTime.prototype.setUIDates = function(from, to) {
	var toDateField = this.ui.to_date;
	var toTimeField = this.ui.to_time;
	var fromDateField = this.ui.from_date;
	var fromTimeField = this.ui.from_time;

	if (fromDateField && fromTimeField) {
		var fromDate = from;
		var fromTime = from;
		$(fromDateField).datepicker('setDate', fromDate);
		$(fromTimeField).timepicker().data('timepicker-settings'); //hack
		$(fromTimeField).timepicker('setTime', fromTime);
	}

	if (toDateField && toTimeField) {
		var toDate = to;
		var toTime = to;
		$(toDateField).datepicker('setDate', toDate);
		$(toTimeField).timepicker().data('timepicker-settings'); //hack
		$(toTimeField).timepicker('setTime', toTime);
	}
};

MFilterableDateTime.prototype.setDates = function(from, to) {
	if (this.validateStartAndEndTimes(from, to)) {
		MUILayoverPanel.alert("The END timestamp has to be greater than the START timestamp.");
		return;
	}

	this.setUIDates(from, to);

	if (this.histogramShowing) {
		// Notify histogram of date changes
		this.updateTemporal();
	}

	this.setFilter(from, to);
	this.perculateChange();
};

MFilterableDateTime.prototype.setFilter =  function(from, to){
	var filter = {};

	from = from.getTime() / 1000;
	to = to.getTime() / 1000;

	if (from && from != this.getMin().getTime() / 1000) {
		filter['from'] = from;
	}
	
	if (to && to != this.getMax().getTime() / 1000) {
		filter['to'] = to;
	}
	
	if (!$.isEmptyObject(filter)) {
		this.setFilterValue(filter);
	} else {
		this.clearFilterValue();
	}
};

MFilterableDateTime.prototype.clearSpecificFilter = function() {
	this.setUIDates(this.min || this.globalMin, this.max || this.globalMax);
};

MFilterableDateTime.prototype.validateStartAndEndTimes = function(start, end) {
	return start >= end;
};

MFilterableDateTime.prototype.getDateTimeRange = function(callback) {
	var ajax = new Moonshadow.Ajax();
	var int_name = this.int_name;
	var query = {
		"query": "get_data_ranges",
		"qid": "dataRange",
		"filter":{},
		"ds": this.getDatasource().int_name,
		"statistics_tree":[{"filter_name":int_name}]
	};

	query.filter[int_name] = {"from":1};

	ajax.addQuery(query, callback, this);
	ajax.execute();
};

MFilterableDateTime.prototype.parseDateRange = function(data) {
	if (data && data.result && data.result == "ok") {
		// the magic number and empty string used in the following
		// conditional are from teh qury server. If they change
		// it'll break but I'm unsure what to do right now and
		// this'll work.
		var magicNumber = "9223372036854775807";

		var stringMin = data.range_results[0].min;
		var stringMax = data.range_results[0].max;

		var min = parseInt(stringMin, 10) * 1000;
		var max = parseInt(stringMax, 10) * 1000;

		if (min && stringMin !== magicNumber) {
			// Make min midnight that day
			minDate = new Date(min);
			minDate.setHours(0, 0, 0, 0);
			this.min = minDate;
		}

		if (max) {
			// Make max midnight the next day
			maxDate = new Date(max);
			maxDate.setDate(maxDate.getDate() + 1)
			maxDate.setHours(0, 0, 0, 0);
			this.max = maxDate;
		}
	}
};

MFilterableDateTime.prototype.showTemporal = function(event) {
	var self = event.data.self;

	if (typeof d3 === 'undefined') {
		return alert('This feature requires a more up-to-date browser');	
	}

	if (self.histogramShowing) {
		self.hideTemporal(event);
		return;
	}

	$('.histogram-container').empty();

	self.getControl().getManager().notify('openTemporal', {
		intName: self.int_name,
		filterable: self,
		surveyId: self.getParent().int_name
	});

	self.histogramShowing = true;
};

MFilterableDateTime.prototype.updateTemporal = function(from, to) {
	this.manager.notify('updateTemporal');
};

MFilterableDateTime.prototype.hideTemporal = function(event) {
	var self = event.data.self;

	self.getControl().getManager().notify('closeTemporal');
	this.histogramShowing = false;
};

//MFilterableMeshes
function MFilterableMeshes(branch,parent) {
	this.children = {};
	this.init(branch,parent);

	this.values = branch.values || [];

	this.defaultMaskColor = "FFFFFF";
	this.defaultMaskOutlineColor = "000000";

	this.currentMask;
	
	this.layer = this.getControl().getManager().getControl('layerMesh');
}
MFilterableMeshes.prototype = new MFilterable;
$.extend(MFilterableMeshes.prototype,{
	buildUI: function() {
		
		var control = this.getControl();
		var manager = control.getManager();
		var ce = control.ce;
		var self = this;
		
		var container = document.createElement("div");
		container.className = "no-color-by filterable "+this.dtype;
		container.id = "filterable_"+this.int_name;

		if(this.getControl().options.boundries_docs) {
			container.appendChild(this.getControl().createDocList(this.getControl().options.boundries_docs));
		}

		container.appendChild(this.makeExpander());
		container.appendChild(this.makeClear());
		container.appendChild(this.makeChildren());
		
		var childHeader = $(ce("div"))
			.addClass("children-header");
		
		$(this.childContainer)
			.append(childHeader)
		
		this.sortList = {
			"areaClass": "sortboundaries",
			"opts": [{
				"sortby": "line",
				"float": "left"
			},{
				"sortby": "color",
				"float": "left"
			},{
				"sortby": "filter",
				"float": "left"
			},{
				"sortby": "masker",
				"float": "left"
			},{
				"sortby": "label",
				"sortdefault": true
			}]
		};
		
		this.makeColumnSorter(
			this.sortList.opts,
			this.sortList.areaClass,
			childHeader,
			this.childContainer,
			this.sortList.sortOrder
		);
		
		//masking controls

		
		this.maskColor = this.getColorIcon('mask');		
		this.maskOutlineColor = this.getColorIcon('line');
		
		this.container = container;
		this.parent.childContainer.appendChild(this.container);
		
		this.sortMaskElem = $(ce("div"))
			.addClass("sort_mask_elem")
			.get(0);
		
		var maskControl = this.getMaskLayerControl();
		
		var selectNewRegionButton = $(ce("input"))
			.addClass("masking_select_region")
			.attr({
				"type": "button",
				"value": "Click to select a region to mask"
			})
			.data({
				"selectRegionToggle": function(selectDeselect){
					var button = $(".masking_select_region", self.container);
					if(selectDeselect == undefined){
						selectDeselect = $(button).val() == "Click to select a region to mask";
					}
					if(selectDeselect){
						$(button)
							.addClass("selected_mode_on")
							.val(
								"Cancel region selection" +
								($(button).data().locked ? " (Locked on)" : "")
							);
					}else{
						$(button)
							.removeClass("selected_mode_on")
							.val("Click to select a region to mask");
						$(button).data().locked = false;
					}
					return selectDeselect;
				},
				"buttonState": function(){
					return $(".masking_select_region", self.container).val() != "Click to select a region to mask";
				},
				"locked": false,
				"lockTimer": null
			})
			.on("mousedown", {"self": this}, function(e){
				e.data.self.selectRegion()
				var button = $(".masking_select_region", self.container);
				$(button).data().lockTimer = setTimeout(function(){
					$(".masking_select_region", self.container).data().locked = true;
					e.data.self.selectRegion(true);
				}, 5000)
			})
			.on("mouseup mouseout", {"self": this}, function(e){
				var button = $(".masking_select_region", self.container);
				if($(button).data().lockTimer){
					clearTimeout($(button).data().lockTimer);
					$(button).data().lockTimer = null;
				}
			});
		
		var maskingOptions = $(ce("div"))
			.addClass("masking_options hide")
			.append(
				$(ce("div"))
					.addClass("masking_option")
					.append(selectNewRegionButton),
				$(ce("div"))
					.addClass("masking_option")
					.append(
						$(ce("span"))
							.append("Mask Transparency: "),
						$(ce("span"))
							.addClass("transparency_value")
							.append(" 20%"),
						$(ce("div"))
							.addClass("transparency_slider")
							.data({
								"updateValue": function(value){
									$(".transparency_value", self.container)
										.empty()
										.append(" " + (Math.floor((value / 255) * 100)) + "%")
								}
							})
							.slider({
								"value": 51,
								"max": 255,
								"step": 2.55,
								"change": function(event,ui) {
									if(!this.hasSlid)
										return false;
									$(ui.handle).blur();
									if(self.currentMask.getMask()){
										self.getMaskLayerControl().updateMask({
											"mesh": self.currentMask.getMask().mesh,
											"ftrans": Math.floor(ui.value)
										});
									}
									this.hasSlid = false;
								},
								"slide": function(event, ui) {
									this.hasSlid = true;
									$(this).data().updateValue(ui.value);
								}
							})
					),
				$(ce("div"))
					.addClass("masking_option")
					.append(
						$(ce("div"))
							.addClass("masked_color")
							.append(
								this.maskColor
							),
						$(ce("span"))
							.append(" Mask fill color")
					),
				$(ce("div"))
					.addClass("masking_option")
					.append(
						$(ce("div"))
							.addClass("masked_color")
							.append(
								this.maskOutlineColor
							),
						$(ce("span"))
							.append(" Outline color")
					),
				$(ce("div"))
					.addClass("masking_option")
					.append(
						$(ce("div"))
							.addClass("mask_line_width clickable sprite-width" + maskControl.getSetting("line_width"))
							.data({"updateClass": function(className){
								$(".mask_line_width", self.container)
									.removeAttr("class")
									.addClass("mask_line_width clickable")
									.addClass(className)
							}})
							.click({
									"self": this
								}, function(e) {
									var mc = e.data.self.getMaskLayerControl();
									
									var lineWidth = mc.getSetting("line_width");
									
									++lineWidth;
									if(lineWidth >= 6) 
										lineWidth = 0;
								
									mc.changeSettings({
										'line_width': lineWidth
									});
									$(this).data().updateClass("sprite-width" + lineWidth);
						
									var mask = e.data.self.currentMask.getMask();
									if(mask && mask.regions && mask.regions.length){
										maskControl.updateMask({
											'line_width': lineWidth,
											'mesh': mask.mesh
										});
									}
								}
							),
						$(ce("span"))
							.append(" Outline width")
					),
				$(ce("div"))
					.addClass("clear"),
				$(ce("div"))
					.addClass("selected_regions_header")
					.data({
						"updateHeader": function(boundry){
							$(".selected_regions_header")
								.empty()
								.append("Selected Regions")
								.append(function(){
									if(boundry){
										 return " ("+ self.getMaskLayerControl().getMeshName(boundry) +")";
									}
									return "";
								}());
						}
					})
					.append("Selected Regions"),
				$(ce("div"))
					.addClass("selected_regions")
					.append(
						this.sortMaskElem,
						$(ce("div"))
							.addClass("empty_item masking_item")
							.append(
								$(ce("span"))
									.append("No selected regions.")
							)
					),
				$(ce("div"))
					.addClass("clear")
			)
			.get(0);

		$(container).append(maskingOptions);
		
		this.sortMaskList = {
			"areaClass": "sortmaskregions",
			"sortElem": this.sortMaskElem,
			"opts": [{
					"sortby": "region",
					"sortdefault": true
				}
			]
		};
		
		$.each(this.values, function(k,v) {
			if(typeof v == "string") {
				v = {"int_name":v, "ext_name":v, "dtype":"mesh"};
			}

			v.order = k;

			if(typeof self.children[v.int_name] == "undefined") {
				self.children[v.int_name] = control.getFilterable(v,self);
			}
		});
		
		this.loadMaskList();
	},
	clearFilters: function(){},
	onMeshChange: function() {
		this.loadMaskList();
	},
	selectRegion: function(onOff) {
		var maskSelectButton = $(".masking_select_region", this.container);
		var tog = $(maskSelectButton).data().selectRegionToggle;
		
		if(onOff == undefined){
			var onOff = tog();
		}else{
			tog(onOff);
		}
		
		var self = this;
		var _selectRegion = function(){
			this.getMaskLayerControl().updateMask();
			if(!(maskSelectButton).data().locked){
				tog(false);
				this.getMaskLayerControl().stopSelection();
				self.getControl().getManager().removeMapObserver('regionselected', _selectRegion, self);
			}
		};
		
		if(onOff){
			this.getMaskLayerControl().startSelection();
			this.getControl().getManager().addMapObserver('regionselected', _selectRegion, this);
		}else{
			this.getMaskLayerControl().stopSelection();
			this.getControl().getManager().removeMapObserver('regionselected', _selectRegion, this);
		}
		return onOff;
	},
	toggle: function() {
		var container = this.childContainer;
		if (container.style.display != "block") {
			this.getControl().getManager().addMapObserver('meshchange', this.onMeshChange, this);
			this.updateList();
			if(this.colsorter)
				this.colsorter.sortColumn("label", null, this.childContainer, this.childContainer);
			$(this.expander).addClass("expanded");
			container.style.display = "block";
			this.toggleMaskingControls(this.getMaskLayerControl().masksEnabled);
		} else {
			this.getControl().getManager().removeMapObserver('meshchange', this.onMeshChange, this);
			$(this.expander).removeClass("expanded");
			container.style.display = "none";
			this.toggleMaskingControls(false);
		}
	},
	clearMasks: function(){
		$(".mask_selected")
			.removeClass("mask_selected sprite-mask_selected")
			.addClass("sprite-mask");
	},
	toggleMaskingControls: function(onOff){
		if(onOff){
			$(".masking_options", this.container).removeClass("hide");
			this.updateMaskUI();
		}else{
			$(".masking_options", this.container).addClass("hide");
		}
	},
	updateList: function() {
		$(".criteria", this.childContainer)
			.remove();

		var self = this;
		$.each(this.children, function(k,v) {
			$(self.childContainer)
				.append(v.buildUI(true));
		});
	},
	loadMaskList: function(){
		var ce =  this.getControl().ce;
		var self = this;
		
		$(".masking_item", this.container)
			.remove();
		
		var mask;
		if(this.currentMask){
			var maskControl = this.getMaskLayerControl();
			mask = this.currentMask.getMask();
		}
		
		if(mask && mask.regions && mask.regions.length){
			$(".selected_regions", this.container)
				.append(
					$(mask.regions).map(function(index, region){
						return $(ce("div"))
							.addClass("criteria masking_item")
							.append(
								$(ce("div"))
									.addClass("remove_masking_item clickable")
									.append("x")
									.click({
											"mesh": mask.mesh,
											"int_name": region.int_name,
											"id": region.id,
											"maskControl": maskControl
										}, function(e){
											e.data.maskControl.removeMaskRegion(
												e.data.mesh, 
												e.data.int_name, 
												e.data.id
											);
										}
									),
								$(ce("div"))
									.addClass("region")
									.append(
										region.ext_name
									)
							)
							.on("mouseover",{
									"maskControl": maskControl,
									"region": region.region,
								}, function(e){
									var maskControl = e.data.maskControl;
									var region = e.data.region;
									if(region){
										maskControl.onRegionChange(
											null, 
											maskControl.getRasterLayer().getRegion(
												region.id,
												region.data,
												region.x,
												region.y,
												region.z
											)
										);
									}
								}
							)
							.on("mouseout",{
									"maskControl": maskControl,
									"region": region.region,
								}, function(e){
									var maskControl = e.data.maskControl;
									var region = e.data.region;
									if(region){
										maskControl.reMask();
									}
								}
							)
							.get(0);
					})
				);
		}else{
			$(".selected_regions", this.container)
				.append(
					$(ce("div"))
						.addClass("sort_mask_elem"),
					$(ce("div"))
						.addClass("empty_item masking_item")
						.append(
								$(ce("span"))
								.append("No selected regions.")
						)
						.get(0)
				);
		}
	},
	setMaskItem: function(maskItem){
		this.currentMask = maskItem;
		var mask = maskItem.getMask();
		this.getMaskLayerControl().updateMask({
			'ftrans': mask.ftrans,
			'fillColor': mask.fillColor,
			'line_width': mask.line_width,
			'line_color': mask.line_color,
			'mesh': mask.mesh
		});
		if(mask && (!mask.regions || !mask.regions.length)){
			this.selectRegion(true);
		}
	},
	unSetMaskItem: function(){
		this.currentMask = null;
		this.selectRegion(false);
	},
	updateMaskUI: function(){
		if(this.currentMask){
			$(".selected_regions_header").data().updateHeader(this.currentMask.int_name);
			if(this.currentMask.getMask()){
				$(this.maskColor).css({
						"background-color": "#" + (this.currentMask.getMask().fillColor || "FFFFFF")
					})
					.data("selectedColor", this.currentMask.getMask().fillColor);
				$(".mask_line_width", this.container)
					.data()
					.updateClass("sprite-width" + (this.currentMask.getMask().line_width));
				$(".transparency_slider")
					.slider({"value": this.currentMask.getMask().ftrans || 51})
					.data().updateValue(this.currentMask.getMask().ftrans || 51);
				$(this.maskOutlineColor).css({
						"background-color": "#" + (this.currentMask.getMask().line_color || "000000")
					})
					.data("selectedColor", this.currentMask.getMask().line_color);
			}
		}
	},
	getMaskLayerControl: function() {
		return this.getControl().getManager().getControl('layerMask');
	},
	getColorByControl: function(){
		return this.getControl().getManager().getControl('colorby');
	},
	addMask: function(mask){
		this.getMaskLayerControl().addMask(
			mask.mesh, 
			mask.line_width, 
			mask.fillColor, 
			mask.line_color,
			mask.ftrans,
			null
		);
		$(".masking_select_region", this.container)
			.data()
			.selectRegionToggle(true);
	}
});

MFilterableMeshes.prototype.getColor = function(type) {
	if (type === 'mask') {
		return this.defaultMaskColor;
	} else {
		return this.defaultMaskOutlineColor;
	}
};

MFilterableMeshes.prototype.setColor = function(color, type) {
	
	var maskControl = this.getMaskLayerControl();
	var maskitem = this.currentMask.getMask();
	
	if (!maskitem) {
		this.currentMask.setMaskItem();
		maskitem = this.currentMask.getMask();
	}
	
	var mask = {
		"mesh": maskitem.mesh
	};

	if (type === 'mask') {
		this.defaultMaskColor = color;
		mask.fillColor = color
	} else {
		this.defaultMaskOutlineColor = color;
		mask.line_color = color
	}

	if (this.currentMask.getMask()){
		maskControl.updateMask(mask);
	}
};
//MFilterableMeshItem
function MFilterableMeshItem(branch,parent) {
	this.order = branch.order;
	this.init(branch,parent);
	this.isChecked = branch.checked || false;

	this.lineWidth = 1;
}

MFilterableMeshItem.prototype = new MFilterable;

MFilterableMeshItem.prototype.buildUI = function(returnContainer) {
	var caller = this;
	var cdn = this.getControl().getManager().getOption("cdn");
	var doReturn = returnContainer || false;

	var container = document.createElement("div");
	container.className = "criteria";
	// @CLEANUP .data() runs bad in IE
	$(container).data("item",this);

	var meshes = this.getControl().getManager().getControl('layerMesh');
	var mesh = meshes.getMesh(this.int_name);


	if (mesh) {
		this.isChecked = true;

		if(mesh.width) {
			this.lineWidth = mesh.width;
		}

		if(mesh.color) {
			this.color = mesh.color;
		}
	} else {
		this.color = '000000';
	}	

	var lineWidth = document.createElement("div");
	lineWidth.className = "line clickable";
	lineWidth.title = "Adjust line width";
	$(lineWidth).click(function() {
		caller.lineWidth++;
		if(caller.lineWidth >= 6) caller.lineWidth = 1;
		caller.__lineWidthImg.className = 'sprite-width'+caller.lineWidth;
		//caller.__lineWidthImg.src = cdn + "/images/width"+caller.lineWidth+".png";

		var width = caller.lineWidth;
		var color = (typeof caller.color.value !== 'undefined') ? caller.color.value : false;

		caller.getParent().layer.changeMesh(caller.int_name, width, color);
	});

	var lineWidthImg = document.createElement("div");
	lineWidthImg.className = 'sprite-width'+caller.lineWidth;
	//lineWidthImg.src = cdn + "/images/width"+caller.lineWidth+".png";

	this.__lineWidthImg = lineWidthImg;

	lineWidth.appendChild(lineWidthImg);

	container.appendChild(lineWidth);

	container.appendChild(this.makeColorSel());
	container.appendChild(this.makeCheckboxFilter(this.int_name, this.isChecked));
	
	var mask = document.createElement("div");
	$(mask).addClass("masker sprite-mask clickable");
	mask.title = "Enable Masking for " + this.ext_name.replace(/_/g," ");
	if(this.parent.currentMask == this){
		$(mask).addClass("mask_selected sprite-mask_selected").removeClass("sprite-mask");
	}
	$(mask).click({"self": this},function(e){
		e.data.self.clearMasks();
		if(!e.data.self.isMasked()){
			e.data.self.setMaskItem();
			$(this).addClass("mask_selected sprite-mask_selected").removeClass("sprite-mask");
			e.data.self.enableMasking(true);
		}else{
			e.data.self.unSetMaskItem();
			$(this).removeClass("mask_selected sprite-mask_selected").addClass("sprite-mask");
			e.data.self.enableMasking(false);
		}
	});
	container.appendChild(mask);
	
	//container.appendChild(this.makeChoroSelector(this.int_name, this.parent));
	
	container.appendChild(this.makeLabel(
		Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "))));
	container.appendChild(this.makeClear());

	this.container = container;

	if(doReturn) {
		return this.container;
	} else {
		this.parent.childContainer.appendChild(this.container);
	}
};

MFilterableMeshItem.prototype.makeMaskObject = function() {
	return this.parent.getMaskLayerControl().getMaskObjDefault(this.int_name);
};

MFilterableMeshItem.prototype.getMask = function() {
	var layer = this.getParent().layer;
	return layer.getMask(this.int_name);
};

MFilterableMeshItem.prototype.isMasked = function() {
	return this.parent.currentMask == this;
};

MFilterableMeshItem.prototype.setMaskItem = function() {
	var layer = this.getParent().layer;
	var mask = this.getMask();
	if (!mask) {
		mask = this.makeMaskObject();
		this.parent.addMask(mask);
	}
	this.parent.setMaskItem(this);
	this.parent.updateMaskUI();
};

MFilterableMeshItem.prototype.unSetMaskItem = function() {
	this.parent.unSetMaskItem();
	this.parent.updateMaskUI();
};

MFilterableMeshItem.prototype.clearMasks = function() {
	this.parent.clearMasks();
};

MFilterableMeshItem.prototype.enableMasking = function(onOff) {
	if (onOff) {
		this.parent.getMaskLayerControl().show();
	} else {
		this.parent.getMaskLayerControl().hide();
	}

	this.parent.toggleMaskingControls(onOff);
};

MFilterableMeshItem.prototype.onCheckboxChange = function(checkbox) {
	this.isChecked = checkbox.checked;
	this.updateMeshLayer();
};

MFilterableMeshItem.prototype.updateMeshLayer = function() {
	var layer = this.getParent().layer;
	var width = this.lineWidth;
	var color;

	if (this.color) {
		color = this.color;
	} else {
 		throw new Error('No color set for this mesh item');
	}		

	if(this.isChecked) {
		layer.addMesh(this.int_name, this.lineWidth, color);
	} else {
		layer.removeMesh(this.int_name);
	}
};

MFilterableMeshItem.prototype.getColor = function() {
	return this.color;
};

MFilterableMeshItem.prototype.setColor = function(color) {
	this.color = color;
	this.updateMeshLayer();	
};

MFilterableMeshItem.prototype.updateColorModel = function() {
	this.updateMeshLayer();	
};
//MFilterableHeatMap
function MFilterableHeatMap(branch,parent) {
	branch.values = [
		{ext_name:"0%",int_name:"0",dtype:"heatmapitem"},
		{ext_name:"12.5%",int_name:"12_5",dtype:"heatmapitem"},
		{ext_name:"25%",int_name:"25",dtype:"heatmapitem"},
		{ext_name:"37.5%",int_name:"37_5",dtype:"heatmapitem"},
		{ext_name:"50%",int_name:"50",dtype:"heatmapitem"},
		{ext_name:"62.5%",int_name:"62_5",dtype:"heatmapitem"},
		{ext_name:"75%",int_name:"75",dtype:"heatmapitem"},
		{ext_name:"87.5",int_name:"87_5",dtype:"heatmapitem"},
		{ext_name:"100%",int_name:"100",dtype:"heatmapitem"}
	];

	this.children = {};
	this.init(branch,parent);

	this.values = branch.values || [];

	this.manager = this.getControl().getManager();

	this.getControl().getManager().addMapObserver("filterchange",this);
}

MFilterableHeatMap.prototype = new MFilterable;
MFilterableHeatMap.prototype.buildUI = function() {
	var container = document.createElement("div");
	container.className = "filterable "+this.dtype;
	container.id = "filterable_"+this.int_name;

	container.appendChild(this.makeColorBy());

	if(this.acceptableTableRow && this.acceptableTableRow == 1){
		$(this.getDatasource().openSS).removeClass("hide");
		this.rowAdder = this.makeSpreadsheetRowAdder(this);
		container.appendChild(this.rowAdder);
	} else {
		container.className += " no-spreadsheet-row";
	}

	if(this.getControl().options.heatmap_docs) {
		container.appendChild(this.getControl().createDocList(
			this.getControl().options.heatmap_docs));
	}

	container.appendChild(this.makeExpander());
	container.appendChild(this.makeClear());
	container.appendChild(this.makeChildren());

	this.container = container;

	// Update state of the color by icon (it should be enabled 
	// when a filter is set)
	this.updateAvailability();

	this.parent.childContainer.appendChild(this.container);
};

MFilterableHeatMap.prototype.hasExpander = function() {
	return true;
};

MFilterableHeatMap.prototype.hasFiltersOrDecs = function() {
	var dsId = this.getDatasource().int_name;
	var filtersControl = this.getFiltersControl();

	var hasFilters = filtersControl.hasFilters(dsId);
	var hasDeclarations = filtersControl.hasDeclarations(dsId);
	return hasFilters || hasDeclarations;
};

MFilterableHeatMap.prototype.colorByClick = function(event) {
	if(this.hasFiltersOrDecs()) {
		this.showColorBy(event);
	}
};

MFilterableHeatMap.prototype.updateAvailability = function() {
	if (this.hasFiltersOrDecs()) {
		$(this.colorBy).attr('title', 'Color by ' +  this.ext_name);
		$(this.container).removeClass("clickable");
		$(this.container).removeClass("disabled");
		$(this.colorBy).removeClass("disabled");
	} else {
		$(this.colorBy).attr('title', 'Make a selection to enable');
		$(this.container).addClass("clickable");
		$(this.container).addClass("disabled");
		$(this.colorBy).addClass("disabled");
	}	
};

MFilterableHeatMap.prototype.notify = function(event) {
	if (event === 'filterchange') {
		this.updateAvailability();
	}
};

MFilterableHeatMap.prototype.show = function() {};

//MFilterableHeatMapItem
function MFilterableHeatMapItem(branch,parent) {
	this.countTotal = null;
	this.countPerc = null;

	this.init(branch,parent);

	this.setupColors();
}
MFilterableHeatMapItem.prototype = new MFilterable;
MFilterableHeatMapItem.prototype.buildUI = function(returnContainer) {
	var doReturn = returnContainer || false;
	var container = document.createElement("div");
	container.int_name = this.int_name;

	container.className = "criteria";
	// @CLEANUP .data() runs bad in IE
	$(container).data("item",this);

	var isChecked = (this.filters && typeof this.filters.value != "undefined" &&
					 this.filters.value == 1) ? true : false;

	container.appendChild(this.makeColorSel());
	container.appendChild(this.makeCounts(this.int_name));
	container.appendChild(this.makeLabel(
		Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "))));
	container.appendChild(this.makeClear());

	this.container = container;

	if(!doReturn) {
		this.parent.childContainer.appendChild(this.container);
	}else{
		return this.container;
	}
};

MFilterableHeatMapItem.prototype.attach = function(branch) {
	if(typeof branch[this.int_name] != "object")
		branch[this.int_name] = {};

	return branch[this.int_name];
};

MFilterableHeatMapItem.prototype.clearSpecificColor = function() {
	this.setupColors();

	var selectedColor = this.color;
	$.each($(".color-picker",this.container),function(k,v) {
		v.style.backgroundColor = "#"+selectedColor;
		$(v).data("selectedColor",selectedColor);
	});
};

MFilterableHeatMapItem.prototype.updateColors = function(event) {
	this.getParent().updateColors();
};

function MFilterableRangeBool(branch,parent) {
	this.children = {};
	this.init(branch,parent);
	this.values = branch.values || {};
	this.hasFilters = this.countFilters();

	this.from = (typeof branch.from != "undefined") ? branch.from : 1;
	this.suffix = (typeof branch.suffix != "undefined") ? branch.suffix : "more";

	this.ui = {};
	this.changeTimer;
}
MFilterableRangeBool.prototype = new MFilterable;
$.extend(MFilterableRangeBool.prototype,{
	buildUI: function() {
		var container = document.createElement("div");
		container.className = "filterable "+this.dtype;
		container.id = "filterable_"+this.int_name;

		if(this.acceptableTableRow && this.acceptableTableRow == 1){
		
		} else {
			container.className += " no-spreadsheet-row";
		}

		container.appendChild(this.makeColorBy());

		if(this.getControl().options[this.int_name+"_docs"]) {
			var control = this.getControl();
			var docList = control.createDocList(control.options[this.int_name + "_docs"]);
			container.appendChild(docList);
		}

		container.appendChild(this.makeExpander());
		container.appendChild(this.makeClear());
		container.appendChild(this.makeChildren());

		this.container = container;
		this.parent.childContainer.appendChild(this.container);
	},
	hasExpander: function() {
		return true;
	},
	buildChildren: function() {
		var rangeContainer = document.createElement("div");
		rangeContainer.className = "criteria range " + this.dtype;
		rangeContainer.style.height = "auto";

		var header = document.createElement("div");
		header.className = "header";
		var headerString = "Select only records that have voted in";
		if(this.min != undefined || this.max != undefined) {
			headerString = (function(s,min,max) {
				if(typeof min != "undefined" && typeof max != "undefined") {
					return headerString + " (" + min + " - " + max + ")";
				} else if(typeof min != "undefined") {
					return headerString + " (>=" + min + ")";
				} else if(typeof max != "undefined") {
					return headerString + " (<=" + max + ")";
				}

				return headerString; // Shouldn't get to this
			})(headerString,this.min,this.max);
		}

		header.appendChild(document.createTextNode(headerString));
		rangeContainer.appendChild(header);

		// This is from becuse I'm reusing code from earlier
		var fromContainer = document.createElement("div"); 
		fromContainer.style.textAlign = "center";

		var filters = this.getFilterValue();
		if (!filters) {
			filters = {};
		}

		var fromText = document.createElement("input");
		fromText.style.display = "inline";
		fromText.style.float = "none";
		fromText.style.textAlign = "right";
		fromText.type = "text";
		fromText.value = (filters.from) ? filters.from : 1;
		this.ui.from = fromText;
		$(fromText).data("filter",this);
		$(fromText).data("name","from");
		$(fromText).change({"filter":this},function(event) {
			if ($(this).data("filter").changeTimer) {
				clearTimeout($(this).data("filter").changeTimer);
			}

			event.data.filter.validateFilter.call(this,event);

			$(this).data("filter").onFilterUIChange();
		});

		// Watch for changes and fire change after 1s
		$(fromText).keyup({"filter":this},function(event) {
			if(event.data.filter.changeTimer)
				clearTimeout(event.data.filter.changeTimer);

			event.data.filter.changeTimer = setTimeout(function() {
				event.data.filter.changeTimer = undefined;
				$(event.data.filter.ui.from).trigger("change");
			},1000);
		});

		fromContainer.appendChild(fromText);

 		var suffix = document.createElement("select");
		var suffixVals = [["or more","more"],["or fewer","fewer"],["exactly","exact"]];

		for(var i = 0, l = suffixVals.length; i < l; i++) {
			suffix.options[i] = new Option(suffixVals[i][0],suffixVals[i][1]);
			if (suffixVals[i][1] == filters.suffix) {
				suffix.selectedIndex = i;
			}
		}

		suffix.style.padding = "1px 0px";

		this.ui.suffix = suffix;
		$(suffix).data("filter",this);
		$(suffix).data("name","suffix");
		$(suffix).change({"filter":this},function(event) {
			var self = event.data.filter;

			if(self.changeTimer) {
				clearTimeout(self.changeTimer);
			}

			self.onFilterUIChange(self);
		 });

		fromContainer.appendChild(suffix);

		fromContainer.appendChild(this.makeClear());
		fromContainer.appendChild(this.makeSpacer());

		rangeContainer.appendChild(fromContainer);
		rangeContainer.appendChild(this.makeClear());

		var electionHeader = document.createElement("div");
		electionHeader.className = "header";
		electionHeader.appendChild(
			document.createTextNode("of the following elections")
		);
		rangeContainer.appendChild(electionHeader);

		return rangeContainer;
	},
	countFilters: function() {
		var count = 0;
	
		var filters = this.getFiltersControl();
		var dsId = this.getDatasource().int_name;

		count += filters.countDeclaration(dsId, this.int_name);		

		return count;
	},
	perculateChange: function(change) {
		this.hasFilters = this.countFilters();

		if(this.hasFilters <= 0) {
			$.each($(".filter-count",this.ui.handle),function(k,v) {
				$(v).empty();
			});

			$(this.ui.handle).removeClass("has-filters");
			this.hasFilters = 0;
		} else {
			var has = this.hasFilters;

			$.each($(".filter-count",this.ui.handle),function(k,v) {
				$(v).empty();
				v.appendChild(document.createTextNode("("+has+")"));
			});

			if($(this.ui.handle).hasClass("has-filters") == false) {
				$(this.ui.handle).addClass("has-filters");
			}
		}

		if(this.parent == null || typeof this.parent.perculateChange != "function") {
			return;
		}

		this.parent.perculateChange();
	},
	validateFilter: function(event) {
		var f = event.data.filter;
		var n = $(this).data("name")
		var v = parseInt(this.value,10);

		if(v < f.min) {
			v = f.min
		} else if(v > f.max) {
			v = f.max
		}

		if(isNaN(v))
			v = (n == "to") ? f.max : f.min;

		this.value = v;
	},
	clearSpecificFilter: function() {
		var from = this.ui.from;
		var suffix = this.ui.suffix;
		if (from) {
			from.value = 1;
		}

		if (suffix) {
			suffix.selectedIndex = 0;
		}

		if(this.container){
			$.each($(".checkbox input",this.container),function(k,v) {
				v.checked = false;
			});
	
			$.each($(".label.selected",this.container),function(k,v) {
				$(v).removeClass("selected");
			});
		}
	},
	onFilterUIChange: function() {
		this.updateFilter();
	},
	onDeclarationChange: function(path, dec) {
		this.updateFilter();
	},
	updateFilter: function() {
		var count = this.countFilters();				

		if (count) {
			var filter = {};
			var from = this.ui.from;
			var suffix = this.ui.suffix;

			var state = false;
			var suffixVal = suffix.options[suffix.selectedIndex].value;

			if (suffixVal == "fewer") {
				filter.to = parseInt(from.value,10);
			} else if(suffixVal == "exact") {
				filter.from = parseInt(from.value,10);
				filter.to = parseInt(from.value,10);
			} else if(parseInt(from.value,10) >= 0) {
				filter.from = parseInt(from.value,10);
			} else {
				filter.from = 1;
				from.value = 1;
			}

			if (suffixVal != "more") {
				filter.suffix = suffixVal;
			}

			this.setFilterValue(filter);
		} else {
			this.clearDeclaration();
			this.clearFilterValue();
		}

		this.perculateChange();
	},
	setupDataPath: function() {
		this.dataPath = [this.int_name];
	},
	updateColorFromModel: function() {},
	updateFilterState: function() {
		
		var filterValue = this.getFilterValue();
		if(this.ui.from && filterValue){
			$(this.ui.from).val(filterValue.to || filterValue.from);
			if(this.ui.suffix){
				$(this.ui.suffix).val(filterValue.suffix);
			}
		}

		this.hasFilters = this.countFilters();

		if(this.ui.handle) {
			this.updateFilterCount(this.ui.handle);
		}
	}
});


function MFilterableRangeBoolCollection(branch,parent) {
	this.children = {};
	this.organizationalElement = true;
	this.countTotal = null;
	this.countPerc = null;

	this.init(branch,parent);
	this.action = branch.action || 1;

	this.values = branch.values;

	if (this.hasUnknowns) {
		this.values.push("Unknown");
	}

	this.hasFilters = this.countFilters(this.values);
}

$.extend(true, MFilterableRangeBoolCollection.prototype, MFilterableCollection.prototype);

MFilterableRangeBoolCollection.prototype.onDeclarationChange = function() {
	this.parent.onDeclarationChange();
};

MFilterableRangeBoolCollection.prototype.countFilters = function() {
	var count = 0;
	var dsId = this.getDatasource().int_name;
	var decId = this.getDataPath().shift();
	var filters = this.getFiltersControl();

	for (var i = 0, l = this.values.length; i < l; i++) {
		var subBranch = this.values[i];
		count += filters.countDeclaration(dsId, decId, this.values[i].int_name);
	}

	return count;
};

MFilterableRangeBoolCollection.prototype.getShowStats = function() {
	return false;
};

MFilterableRangeBoolCollection.prototype.updateColorFromModel = function() {}


function MFilterableRangeBoolItem(branch, parent) {
	this.countTotal = null;
	this.countPerc = null;
	this.noColor = true;

	this.init(branch,parent);

	this.ui = {};
}

$.extend(MFilterableRangeBoolItem.prototype, MFilterableItem.prototype, {
	buildUI: function(returnContainer) {
		var doReturn = returnContainer || false;
		var container = document.createElement("div");
		container.className = "criteria";
		// @CLEANUP .data() runs bad in IE
		$(container).data("item",this);

		if(!this.noColor)
			container.appendChild(this.makeColorSel());

		var filters = this.getDeclarationValue();
		if (!filters) {
			filters = {};
		}

		var isChecked = (filters && filters.values && filters.values.Yes && 
						 filters.values.Yes.value == 1) ? true : false;

		var checkboxContainer = document.createElement("div");
		checkboxContainer.className = "checkbox";

		var checkbox = document.createElement("input");
		checkbox.type = "checkbox";
		checkbox.checked = isChecked;
		$(checkbox).data({"filter":this,"value":undefined,"name":this.int_name});
		if(checkbox.checked)
			$(checkbox).data("value",1);

		$(checkbox).change(function() {
			if(this.checked) {
				$($(this).data("filter").label).addClass("selected");
				$(this).data("value",1);
			} else {
				$($(this).data("filter").label).removeClass("selected");
				$(this).data("value",false);
			}

			$(this).data("filter").changeFilterState($(this).data("name"), 
													 $(this).data("value"));
		});

		this.ui.toggle = checkbox;
		checkboxContainer.appendChild(checkbox);
		container.appendChild(checkboxContainer);

		//container.appendChild(this.makeCounts(this.int_name));
		container.appendChild(this.makeLabel(Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "))));
		container.appendChild(this.makeClear());

		if($(this.ui.toggle).data("value"))
		   	$(this.label).addClass("selected");

		this.container = container;

		if(doReturn) {
			return this.container;
		} else {
			this.parent.childContainer.appendChild(this.container);
		}
	},
	changeFilterState: function(id, state) {
		var filter = this.getDeclarationValue();

		if (state) {
			if (!filter) {
				filter = {};
			}

			if(typeof filter.values == "undefined") {
				filter.values = {};
			}

			filter.values.Yes = {"value":1}
			this.setDeclarationValue(filter);
		} else if (filter) {
			this.clearDeclarationValue();
		}


		this.parent.onDeclarationChange();
		this.parent.perculateChange();
	},
	clearSpecificFilter: function() {
		if(this.container){
			$.each($(".select-button",this.container),function(k,v) {
				$(v).removeClass("exclude");
				$(v).removeClass("require");
				$(v).data("value",false);
			});
	
			$.each($(".label.selected",this.container),function(k,v) {
				$(v).removeClass("selected");
			});
		}

	},
	updateColorFromModel: function() {},
	updateFilterState: function() {
		var declarationValue = this.getDeclarationValue();
		if(this.ui.toggle && 
				declarationValue && 
				declarationValue.values && 
				declarationValue.values["Yes"] && 
				declarationValue.values["Yes"].value){
			$(this.ui.toggle).attr({
				"checked": !!declarationValue.values["Yes"].value
			})
		}
	}
});

//MFilterableVoterHistory
function MFilterableVoterHistory(branch,parent) {
	this.children = {};

	this.init(branch,parent);

	this.values = [];

	var parent = this;
	var branchValues = {};

	this.originalValues = branch.filters;

	branchValues.exclude = this.buildBranch(branch.filters, 'exclude');
	branchValues.require = this.buildBranch(branch.filters, 'require');
	branchValues.range = this.buildBranch(branch.filters, 'range');

	this.values.push({
		'dtype': 'rangebool',
		'int_name': 'select_elections',
		'ext_name': 'Selected Elections',
		'values': branchValues.range,
		'noColor': true
	});
	this.values.push({
		'dtype': 'elections',
		'int_name': 'required_elections',
		'ext_name': 'Require Elections',
		'action': 1,
		'values': branchValues.require,
		'noColor': true
	});
	this.values.push({
		'dtype': 'elections',
		'int_name': 'excluded_elections',
		'ext_name': 'Exclude Elections',
		'action': -1,
		'values': branchValues.exclude,
		'noColor': true
	});

	this.hasFilters = this.countFilters();

	this.ui = {};
	this.noColor = true;
}

$.extend(true, MFilterableVoterHistory.prototype, MFilterableCollection.prototype);

MFilterableVoterHistory.prototype.countFilters = function(dsId, path, values, action) {
	dsId = dsId || this.getDatasource().int_name;
	path = path || this.getDataPath();
	values = values || this.values;

	var filters = this.getFiltersControl();

	var count = 0;

	for (var i = 0, l = values.length; i < l; i++) {
		var child = values[i];

		if (child.dtype === 'rangebool') {
			count += filters.countDeclaration(dsId, child.int_name);
		} else if (child.dtype === 'elections') {
			if (child.int_name === 'required_elections') {
				count += this.countFilters(dsId, [], this.originalValues, 1);
			} else {
				count += this.countFilters(dsId, [], this.originalValues, -1);
			}
		} else {
			if (action === 1) {
				count += filters.countFilters(dsId, [child.int_name, 'Yes'].join('|'));
			} else {
				count += filters.countFilters(dsId, [child.int_name, 'No'].join('|'));
			}
		}
	}

	return count;
};

MFilterableVoterHistory.prototype.hasExpander = function() {
	return true;
};

// Restructure the values to grouped by ctype
MFilterableVoterHistory.prototype.buildBranch = function(i, itemType) {
	var self = this;
	var o = {};
	var a = [];

	$.each(i, function(k, v) {
		var details = self.getElectionDetails(v);
		if (!details) {
			return;
		}	

		var type = details.type;
		var name = details.name;

		v.ext_name = name;
		v.noColor = true;
		v.dtype = "election";

		if(itemType == "exclude") {
			v.action = -1;
		}

		if(itemType == "require") {
			v.action = 1;
		}

		if(itemType == "range") {
			v.dtype = 'rangebool_item';
			v.singleState = true;
		}

		if(!o[type]) {
			var collection = {
				"dtype": "electioncollection",
				"int_name": type,
				"values": [],
				"noColor": true
			};

			if (itemType === 'range') {
				collection.dtype = 'rangebool_collection';
			} else {
				if(typeof v.action != "undefined") {
					collection.action = v.action;
				}
			}

			a.push(collection);
			o[type] = a[a.length-1];
		}

		o[type].values.push($.extend(true,{},v));
	});

	$.each(o, function(k,v) { // Sort the records by date
		v.values.sort(function(a,b) {
			a = a.ext_name.split("/");
			b = b.ext_name.split("/");
			return new Date(b[2],b[0],b[1]) - new Date(a[2],a[0],a[1]);
		});
	});

	return a;
};

MFilterableVoterHistory.prototype.getElectionDetails = function(election) {
	var id = election.int_name;
	var isoFormat = /[0-9]+-[0-9]+-[0-9]+/.test(id);
	
	/* Some bad stuff can happen in here if the format doesn't 
	   match <type>_<i+>_<i+>_<i+> */
	try { 
		var name = id.match(/([0-9]+(_|-)[0-9]+(_|-)[0-9]+)/g)[0].replace(/(_|-)/g,"/");
		var type = id.replace(/_([0-9]+(_|-)[0-9]+(_|-)[0-9]+)/g,'').replace(/_/g," ");
	} catch(e) {
		if (typeof console != "undefined") {
			console.log([
				"MFilterable.MfilterableElections: invalid election int_name (",
				name, e
			].join(''));
		}

		return false;
	}

	if (isoFormat) {
		var parts = name.split('/');
		name = [parts[1], parts[2], parts[0]].join('/');
	}

	return {'type': type, 'name': name};
};

MFilterableVoterHistory.prototype.updateColorFromModel = function() {};

MFilterableVoterHistory.prototype.getShowStats = function() {
	return false;
};

//MFilterableElections
function MFilterableElections(branch,parent) {
	this.children = {};

	this.gradientable = false;
	
	this.action = branch.action || 1;

	this.init(branch,parent);

	this.values = branch.values || {};

	this.hasFilters = this.countFilters();

	this.ui = {};
}

$.extend(MFilterableElections.prototype, MFilterableCollection.prototype,{
	countFilters: function(dsId, path, values) {
		var filters = this.getFiltersControl();
		dsId = dsId || this.getDatasource().int_name;
		path = path || this.getDataPath();
		values = values || this.values;

		var count = 0;

		for (var i = 0, l = values.length; i < l; i++) {
			var child = values[i];

			if (child.dtype === 'electioncollection') {
					count += this.countFilters(dsId, [], child.values);
			} else {
				if (this.action === 1) {
					count += filters.countFilters(dsId, [child.int_name, 'Yes'].join('|'));
				} else {
					count += filters.countFilters(dsId, [child.int_name, 'No'].join('|'));
				}
			}
		}

		return count;
	},
	hasExpander: function() {
		return true;
	},
	isGradientable: function(){
		return false;
	},
	addColumnSorter: function() {},
	updateColorFromModel: function() {}
});

//MFilterableElectionCollection
function MFilterableElectionCollection(branch,parent) {
	this.children = {};
	this.organizationalElement = true;
	this.countTotal = null;
	this.countPerc = null;

	this.init(branch,parent);
	this.action = branch.action || 1;

	this.values = branch.values;

	if (this.hasUnknowns) {
		this.values.push("Unknown");
	}

	this.hasFilters = this.countFilters();
}
$.extend(MFilterableElectionCollection.prototype, MFilterableCollection.prototype,{
	countFilters: function(dsId, path, values) {
		var filters = this.getFiltersControl();
		dsId = dsId || this.getDatasource().int_name;
		path = path || this.getDataPath();
		values = values || this.values;

		var count = 0;

		for (var i = 0, l = values.length; i < l; i++) {
			var child = values[i];

			if (this.action === 1) {
				count += filters.countFilters(dsId, [child.int_name, 'Yes'].join('|'));
			} else {
				count += filters.countFilters(dsId, [child.int_name, 'No'].join('|'));
			}
		}

		return count;
	},
	updateColorFromModel: function() {},
	getShowStats: function() {
		return false;
	}
});

//MFilterableElection
function MFilterableElection(branch,parent) {
	this.countTotal = null;
	this.countPerc = null;
	this.noColor = true;
	
	// This decides if a yes:{value:1} or no:{value:1} is added to
	// the filters (acceptable options are "exclude" & "require")
	this.action = branch.action || 1; 

	this.init(branch,parent);

	this.ui = {};
}
$.extend(MFilterableElection.prototype,MFilterableItem.prototype,{
	buildUI: function(returnContainer) {
		var doReturn = returnContainer || false;
		var container = document.createElement("div");
		container.className = "criteria";
		// @CLEANUP .data() runs bad in IE
		$(container).data("item",this);

		if (!this.noColor) {
			container.appendChild(this.makeColorSel());
		}

		var filters = this.getFilterValue();
		if (!filters) {
			filters = {};
		}

		var electionSelect = document.createElement("div");
		electionSelect.className = "toggle clickable select-button";
		$(electionSelect).data({"filter":this,"value":false,"name":this.int_name});

		if (filters.value) {
			if (this.action === 1) {
				$(electionSelect).addClass("sprite-plus");
				$(electionSelect).data("value",1);
			} else {
				$(electionSelect).addClass("sprite-minus");
				$(electionSelect).data("value",-1);
			}
		}

		$(electionSelect).click(function(e) {
			var filter = $(this).data("filter");
			var action = filter.action;

			// If "value" == false then set value to either 1 or -1 (depending on action) else set value to false
			$(this).data("value",($(this).data("value") != false) ? false : action);

			// Remove classes and add then add the classes appropriate for the value
			$(this).removeClass("sprite-plus");
			$(this).removeClass("sprite-minus");

			switch($(this).data("value")) {
			case 1:
				$(this).addClass("sprite-plus");
				break;
			case -1:
				$(this).addClass("sprite-minus");
				break;
			case 0:
			default:
				// Do nothing
			}

			// If not false then mark label as selected else unmark label as selected
			if($(this).data("value") != false)
				$(filter.label).addClass("selected");
			else
				$(filter.label).removeClass("selected");


			filter.changeFilterState($(this).data("name"),$(this).data("value"));
		});

		this.ui.toggle = electionSelect;
		container.appendChild(electionSelect);

		container.appendChild(this.makeCounts(this.int_name));
		container.appendChild(this.makeLabel(Moonshadow.helpers.capitalize(this.ext_name.replace(/_/g," "))));
		container.appendChild(this.makeClear());

		if($(this.ui.toggle).data("value"))
		   	$(this.label).addClass("selected");

		this.container = container;

		if(doReturn) {
			return this.container;
		} else {
			this.parent.childContainer.appendChild(this.container);
		}
	},
	changeFilterState: function(id, state) {
		var filter = this.getFilterValue();

		if (state !== false) {
			this.setFilterValue({'value': 1});
		} else if(filter) {
			this.clearFilterValue(filter);
		}

		this.parent.perculateChange();
	},
	clearSpecificFilter: function() {
		if(this.container){
			$.each($(".select-button",this.container),function(k,v) {
				$(v).removeClass("sprite-minus");
				$(v).removeClass("sprite-plus");
				$(v).data("value",false);
			});
	
			$.each($(".label.selected",this.container),function(k,v) {
				$(v).removeClass("selected");
			});
		}
	
	},
	setupDataPath: function() {
		if (this.action === 1) {
			this.dataPath = [this.int_name, 'Yes'];
		} else {
			this.dataPath = [this.int_name, 'No'];
		}
	},
	updateColorFromModel: function() {},
	updateFilterState: function() {

		var filterValue = this.getFilterValue();
		if(filterValue && this.ui.toggle){
			if (this.action === 1) {
				$(this.ui.toggle).addClass("sprite-plus");
				$(this.ui.toggle).data("value",1);
			} else {
				$(this.ui.toggle).addClass("sprite-minus");
				$(this.ui.toggle).data("value",-1);
			}
		}
		
	}
});

function MFilterableGroup(branch, parent) {
	this.children = {};
	this.organizationalElement = true;
	this.isFilter = false;
	this.columnAdder;
	
	this.init(branch, parent);

	// @CLEANUP this is a hack to deal with the filter tree using the wrong
	// property name for this time. 
	this.values = branch.values || branch.filters || [];

	this.hasFilters = this.countFilters();
}

$.extend(MFilterableGroup.prototype, MFilterable.prototype, {
	'buildUI': function() {
		var container = document.createElement("div");
		container.className = "filterable " + this.dtype;
		container.id = "filterable_" + this.int_name;

		container.appendChild(this.makeColorBy());

		var filterableDS = this.getDatasource();
		
		if(this.parent.acceptableTableCol == 1) {
			this.columnAdder = this.makeSpreadsheetColumnAdder(this);
			if(this.columnAdder != false) {
				container.appendChild(this.columnAdder);
			}
		} else {
			container.className += " no-spreadsheet-row";
		}

		if(this.getControl().options[this.int_name+"_docs"]) {
			container.appendChild(this.getControl().createDocList(this.getControl().options[this.int_name+"_docs"]));
		}
		
		container.appendChild(this.makeExpander());
		container.appendChild(this.makeClear());
		container.appendChild(this.makeChildren());

		this.container = container;
		this.parent.childContainer.appendChild(this.container);
	},
	getColumnAdder: function(){
		return this.columnAdder;
	},
	countFilters: function(dsId, path, values) {
		var filters = this.getFiltersControl();
		dsId = dsId || this.getDatasource().int_name;
		path = path || this.getDataPath();
		values = values || this.values;

		var count = 0;

		for (var i = 0, l = values.length; i < l; i++) {
			var child = values[i];

			if (child.dtype === 'collection') {
				count += this.countFilters(dsId, path, child.filters);
			} else if (child.dtype === 'filter_group') {
				count += filters.countDeclaration(dsId, 'select_elections');

				count += this.countFilters(dsId, path, child.filters);
			} else {
				count += filters.countFilters(dsId, path.concat(child.int_name).join('|'));
			}
		}

		return count;
	}
});

function MFilterableDownloads(branch, parent) {
	this.children = {};
	this.init(branch, parent);
	this.uiBuilt = false;
}
$.extend(MFilterableDownloads.prototype, MFilterable.prototype, {
	"buildUI": function() {
		var ce = Moonshadow.helpers.ce;
		var self = this;
		var reporttypesControl = this.getControl().getManager().getControl("reporttypes");
		var reporttypes = reporttypesControl.reportTypesInfo.slice();
		var statustypes = [{
			"typeId": "pending",
			"title": "Pending Exports",
			"included": true
		},{
			"typeId": "finished",
			"title": "Finished Exports",
			"included": true
		},{
			"typeId": "errored",
			"title": "Errored Exports",
			"included": true
		},{
			"typeId": "downloaded",
			"title": "Downloaded Exports",
			"included": true
		},{
			"typeId": "expired",
			"title": "Expired Exports",
			"included": true
		}];
		
		var sortContainer = $(ce("div"))
			.addClass("sort_downloads_container")
		
		this.container = $(ce("div"))
			.addClass("filterable")
			.addClass(this.dtype)
			.css("padding-left", "20px") 
			.attr({
				"id": "filterable_" + this.int_name
			})
			.append(
				this.makeExpander(),
				this.makeClear(),
				$(ce("div"))
					.addClass("downloads_options hide")
					.append(
						$(ce("div"))
							.addClass("download_filters")
							.append(
								$(ce("div"))
									.addClass("preheader")
									.append(
										"To create an export, click on the ",
										$(ce("div"))
											.addClass("sprite-reports")
											.attr({"title": "Create Lists and Data Files"}),
										" icon in the tools section of a universe."
									),
								$(ce("div"))
									.addClass("header")
									.append("List the following export types:"),
								$(reporttypes).map(function(key, reportType){
									if(!reportType.included)
										return false;
									return $(ce("div"))
										.addClass("download_filter_type clickable")
										.append(
											$(ce("input"))
												.attr({
													"type": "checkbox",
													"checked": true,
													"name": reportType.typeId
												})
												.change({"self": self}, function(e){
													e.data.self.buildDownloadsPanelContent();
												}),
											$(ce("span"))
												.append(reportType.title)
												.click(function(){
													var target = $("input", $(this).closest(".download_filter_type"));
													$(target)
														.attr({
															"checked": !target.attr("checked")
														})
														.change();
												})
										)
										.get(0);
								})
								.filter(function(key, val){
									return !!val;
								})
								.toArray(),
								$(ce("div"))
									.addClass("header")
									.append("Export status:"),
								$(statustypes).map(function(key, statusType){
									if(!statusType.included)
										return false;
									return $(ce("div"))
										.addClass("download_filter_type clickable")
										.append(
											$(ce("input"))
												.attr({
													"type": "checkbox",
													"checked": statusType.typeId == "downloaded" || 
														statusType.typeId == "errored" || 
														statusType.typeId == "expired" ? false : true,
													"name": statusType.typeId
												})
												.change({"self": self}, function(e){
													e.data.self.buildDownloadsPanelContent();
												}),
											$(ce("span"))
												.append(statusType.title)
												.click(function(){
													var target = $("input", $(this).closest(".download_filter_type"));
													$(target)
														.attr({
															"checked": !target.attr("checked")
														})
														.change();
												})
										)
										.get(0);
								})
								.filter(function(key, val){
									return !!val;
								})
								.toArray()
							),
						sortContainer
					),
				$(this.makeChildrenResizable())
					.addClass("hide")
			)
			.get(0);
		
		this.makeColumnSorter([{
				"sortby": "type",
				"float": "left",
				"title": "Type"
			},{
				"sortby": "percentDone",
				"float": "right",
				"title": "Percent Done"
			},{
				"sortby": "dateCreated",
				"float": "right",
				"title": "Date Created",
				"sortdefault": true
			},{
				"sortby": "downloadTitle",
				"title": "Filename"
			}],
			"sortdownloads",
			sortContainer,
			this.childContainer, -1,
			".downloadable_export"
		);
		
		if(this.getControl().options[this.int_name+"_docs"]) {
			$(container)
				.append(
					this.getControl()
						.createDocList(
							this.getControl()
								.options[
									this.int_name+"_docs"
								]
						)
				);
		}

		this.getControl().getManager().addMapObserver("universesuiloaded", function(){
			$(self.parent.childContainer).append(self.container);
		});
		
		this.getControl().getManager().addMapObserver("updatedownloadui", function(event, data){
			self.updateDownloadsPanelContent(data);
		});
		
	},
	'hasExpander': function() {
		return true;
	},
	"filterTypes": function(){
		return $(".download_filter_type input", this.container).map(
			function(key, checkbox){
				return !!$(checkbox).attr("checked") ? 
					$(checkbox).attr("name") : 
					false;
			}
		)
		.filter(function(key, val){
			return !!val;
		})
		.toArray()
	},
	"toggle": function() {
		if(!$(this.expander).hasClass("expanded")) {
			if(!this.uiBuilt){
				this.buildDownloadsPanelContent();
			}
			$(this.expander)
				.addClass("expanded");
			$(".downloads_options", this.container)
				.removeClass("hide");
			$(this.childContainer)
				.show();
			$(".manual_expander", this.container)
				.removeClass("hide");
		} else {
			$(this.expander)
				.removeClass("expanded");
			$(".downloads_options", this.container)
				.addClass("hide");
			$(".manual_expander", this.container)
				.addClass("hide");
			$(this.childContainer)
				.hide();
		}
	},
	"updateDownloadsPanelContent": function(reportId){
		if(!this.uiBuilt)
			return false;
		
		$(this.childContainer).removeClass("empty");
		
		var reportqueue = this.getControl().getManager().getControl("reportqueue");
		var universeControl = this.getControl().getManager().getUniverseControl();
		var typesToShow = this.filterTypes();
		
		var targetUI = $("#" + reportId, this.childContainer);
		var report = reportqueue.getReportsByAttribute("report_id", reportId)[0];
		
		if(!report){
			$(targetUI).remove();
		}else{
			if(!report.source_id)
				return;
			
			var universe = universeControl.getChildById(report.source_id);
			var shouldBeShown = this.uiShouldBeShown(report, typesToShow);
			if(shouldBeShown){
				if(!targetUI.length){
					$(this.childContainer).prepend(this.cloneReportUI(report, universe));
				}else if(!!universe){
					$(targetUI).replaceWith(this.cloneReportUI(report, universe));
				}
			}else{
				$(targetUI).remove();
			}
		}

		if(!$(this.childContainer).children().length){
			$(this.childContainer)
				.addClass("empty");
		}
	},
	"uiShouldBeShown": function(report, typesToShow){
		var universeControl = this.getControl().getManager().getUniverseControl();
		var universe = universeControl.getChildById(report.source_id);
		if(!universe)
			return false;
		
		var typeObj = universe.getReportTypeObjectFromLayout(report.report_layout);
		if(!typeObj)
			return false;
		
		if($.inArray(typeObj.typeId, typesToShow) == -1){
			return false;
		}
		if(report.status == 70 && $.inArray("expired", typesToShow) == -1){
			return false;
		}
		if(report.status == 60 && $.inArray("downloaded", typesToShow) == -1){
			return false;
		}
		if(report.status == 50 && $.inArray("finished", typesToShow) == -1){
			return false;
		}
		if(report.status > 0 && report.status < 50 && $.inArray("pending", typesToShow) == -1){
			return false;
		}
		if(report.status < 0 && $.inArray("errored", typesToShow) == -1){
			return false;
		}
		return true;
	},
	"cloneReportUI": function(report, universe){
		universe.buildReportsUI();
		return $(report.ui).clone(true, true);
	},
	"buildDownloadsPanelContent": function(){
		var reportqueue = this.getControl().getManager().getControl("reportqueue");
		var universeControl = this.getControl().getManager().getUniverseControl();
		var self = this;
		var typesToShow = this.filterTypes();
		var ce = Moonshadow.helpers.ce;
		
		var appendReport = function(report, universe){
			$("#"+report.report_id, self.childContainer)
				.replaceWith(
					self.cloneReportUI(report, universe)
				);
		};
		
		$(this.childContainer)
			.empty();
		
		var reports = reportqueue.getReportsByAttribute().sort(function(a, b){
			var aDate = new Date(a.date_created);
			var bDate = new Date(b.date_created);
			return bDate - aDate;
		});
		
		var isEmpty = true;
		for(var i = 0, l = reports.length; i < l; ++i){
			var report = reports[i];
			if(!report.source_id)
				continue;
			
			if(this.uiShouldBeShown(report, typesToShow)){
				$(self.childContainer)
					.append(
						$(ce("div"))
							.addClass("downloadable_export")
							.attr({
								"id": report.report_id
							})
						
					);
				var universe = universeControl.getChildById(report.source_id);
				if(universe){
					appendReport(report, universe);
					isEmpty = false;
				}
			}
		}

		this.colsorter.refreshSort();
		
		this.onEmpty(".export_download_link");
		this.uiBuilt = true;
	}
});
function MFilterableSeparator(branch, parent) {
	this.init(branch, parent);
}
$.extend(MFilterableSeparator.prototype, MFilterable.prototype, {
	'buildUI': function() {
		var separator = document.createElement('div');
		separator.className = "filterable " + this.dtype;
		separator.id = "filterable_" + this.int_name;

		this.container = separator;
		this.parent.childContainer.appendChild(this.container);

	}
});
//MFilterableSearch
function MFilterableSearch(branch, parent) {
	this.init(branch, parent);
	this.manager = parent.getControl().getManager();
	this.options = this.manager.getOption("search");
	if(!this.options){
		return;
	}
	
	this.ui = {};
	this.applyDelay = this.options.applyDelay || 500;
	
	if(!this.options.fields){
		this.options.fields = [
       		{"int_name":"Voters_FirstName","ext_name":"First name:"},
    		{"int_name":"Voters_LastName","ext_name":"Last name:"},
    		{"int_name":"Residence_Addresses_HouseNumber_searchable",
    		 "ext_name":"House #:"},
    		{"int_name":"Residence_Addresses_StreetName_searchable",
    		 "ext_name":"Street Name:"}
    	];
	}
};

MFilterableSearch.prototype = new MFilterable;

/**
 *
 * @method buildUI
 */
MFilterableSearch.prototype.buildUI = function() {
	if(!this.options){
		return;
	}
	
	var container = document.createElement("div");
	container.className = "filterable " + this.dtype;
	container.id = "filterable_search";
	this.container = container;
	this.parent.childContainer.appendChild(container);
	
	var fields = this.options.fields;

	var label = document.createElement("span");
	label.className = "label";
	var input = document.createElement("input");
	var clear = document.createElement("div");
	clear.className = "clear";
	var clearField = document.createElement("span");
	clearField.className = "ui-icon ui-icon-circle-close clickable";
	clearField.style.display = "inline-block";
	
	this.ui.fields = [];
	
	for(var i = 0,l = fields.length;i < l;i++) {
		var itemLabel = label.cloneNode(false);
		itemLabel.appendChild(document.createTextNode(fields[i].ext_name));
		itemLabel.id = fields[i].int_name + '_label';

		var itemInput = input.cloneNode(false);
		itemInput.id = fields[i].int_name;
		
		$(itemInput).keyup({"control":this},function(e) {
			e.data.control.inputChange(this.id,this.value);
		});

		var itemClear = clearField.cloneNode(false);
		itemClear.id = fields[i].int_name;

		this.ui.fields.push(itemInput);

		$(itemClear).data("input",itemInput);
		$(itemClear).click(function(event) {
			$(this).data("input").value = "";
			$($(this).data("input")).trigger("keyup");
		});

		this.container.appendChild(itemLabel);
		this.container.appendChild(itemInput);
		this.container.appendChild(itemClear);
		this.container.appendChild(clear.cloneNode(false));
	}

	this.loadFilters();
	this.bind();
};

/**
 *
 * @method loadFilters
 */
MFilterableSearch.prototype.loadFilters = function() {
	var manager = this.manager;
	
	var filtersControl = manager.getControl('filterscontrol');

	var datasources = manager.getControl('datasources');
	var ds = datasources.getByIndex(0);

	var fields = this.options.fields;
	for(var i = 0, l = fields.length; i < l; i++) {
		var field = fields[i];
		var fieldId = field.int_name;

		var filter = filtersControl.getFilter(ds.id, fieldId);
		if (filter && filter.match) {
			this.ui.fields[i].value = filter.match;
			$(['#', fieldId, '_label'].join(''), this.container).addClass('active');
		}
	}
};

/**
*
* @method hasValues
*/
MFilterableSearch.prototype.hasValues = function() {
	var manager = this.manager;
	
	var filtersControl = manager.getControl('filterscontrol');

	var datasources = manager.getControl('datasources');
	var ds = datasources.getByIndex(0);

	var fields = this.options.fields;
	for(var i = 0, l = fields.length; i < l; i++) {
		var fieldId = fields[i].int_name;
		var filter = filtersControl.getFilter(ds.id, fieldId);
		if (filter && filter.match) {
			return true;
		}
	}
	return false;
};

/**
 *
 * @method inputChange
 * @param {} id
 * @param {} value
 */
MFilterableSearch.prototype.inputChange = function(id, value) {
	if (value.length) {
		$(['#', id, '_label'].join(''), this.container).addClass('active');
	} else {
		$(['#', id, '_label'].join(''), this.container).removeClass('active');
	}


	if (this.timer) {
		clearTimeout(this.timer);
		this.timer = null;
	}

	var caller = this;
	this.timer = setTimeout(function() {
		caller.applyFilters();
	}, this.applyDelay);
},

/**
 *
 * @method applyFilters
 */
MFilterableSearch.prototype.applyFilters = function() {
	var manager = this.manager;
	
	var filtersControl = manager.getControl('filterscontrol');

	var datasources = manager.getControl('datasources');
	var ds = datasources.getByIndex(0);

	var fields = this.options.fields;
	for(var i = 0, l = fields.length; i < l; i++) {
		var id = fields[i].int_name;

		var value = $('#' + id, this.container).val().trim();
		if (value) {
			filtersControl.setFilter(ds.id, id, {'match': value});
		} else {
			filtersControl.clearFilter(ds.id, id);
		}
	}
};

/**
 *
 * @method clearInputs
 */
MFilterableSearch.prototype.clearInputs = function() {
	var fields = this.ui.fields;
	for(var i = 0,l = fields.length;i < l;i++) {
		fields[i].value = "";
	}

	$(['.label'].join(''), this.container).removeClass('active');
};

/**
 *
 * @method datasourceChanged
 */
MFilterableSearch.prototype.datasourceChanged = function() {
	this.clearInputs();
};

/**
 *
 * @method bind
 */
MFilterableSearch.prototype.bind = function() {
	var manager = this.manager;
	manager.addMapObserver("filterreset",this.clearInputs,this); 
	manager.addMapObserver("datasourcechange",this.datasourceChanged,this); 
};

/**
 *
 * @method unbind
 */
MFilterableSearch.prototype.unbind = function() {
	var manager = this.manager;
	manager.removeMapObserver("filterreset",this.clearInputs,this); 
	manager.removeMapObserver("datasourcechange",this.datasourceChanged,this); 
};


//MFilterableSpreadsheets
function MFilterableSpreadsheets(branch, parent) {
	this.children = {};
	this.init(branch, parent);
	this.control = this.getControl();
	this.manager = this.control.getManager();
	this.sheet = null;
	this.saved_spreadsheet_info = [];
	this.spreadsheets = {};
	this.presetSpreadsheets = {};
};

MFilterableSpreadsheets.prototype = new MFilterable;

MFilterableSpreadsheets.prototype.buildUI = function(){
	var container = document.createElement("div");
	container.className = "filterable " + this.dtype;
	container.id = "filterable_spreadsheet";
	this.container = container;
	this.parent.childContainer.appendChild(container);
	
	this.sheet = {
		windowOptions: [
			"height=800",
			"left=0",
			"location=no",
			"menubar=no",
			"resizable=yes",
			"scrollbars=yes",
			"status=yes",
			"titlebar=yes",
			"toolbar=no",
			"width=700"
		]
	};
	
	var self = this;
	self.getAppTypePresets(function(){
		if(self.presetSpreadsheets.length){
			self.spreadsheets = self.presetSpreadsheets;
		}
		self.getSavedSheets(function(){
			var datasources = self.manager.getOptions().datasources;
			for(var i = 0, l = datasources.length; i < l; ++i){
				var dsId = datasources[i].int_name;
				self.buildSSControls(dsId);
				self.selectOpenSSRows(dsId);
				self.selectOpenSSColumns(dsId);
			}
		});
	});
	
	window.onbeforeunload = function(e){
		Moonshadow.getManager().getSpreadsheetControl().hide("main");
	};
};

MFilterableSpreadsheets.prototype.getSavedSheets = function(callback){
	var self = this;
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery({
		"query": "load_stored_state",
		"name": "saved_spreadsheet_info"
	}, function(data){
		if (data.result != "not_found"){
			self.saved_spreadsheet_info = data.value.sheets;
		}
	});
	
	var datasources = this.manager.getOptions().datasources;
	for(var i = 0, l = datasources.length; i < l; ++i){
		var ds = datasources[i].int_name;
		self.initSpreadSheets(self.spreadsheets, ds);
		ajax.addQuery({
			"query": "load_stored_state",
			"name": "saved_table_settings",
			"ds": ds
		}, function(data){
			if (data.result != "not_found"){
				self.setSheetInfo(
					self.spreadsheets,
					data.ds, 
					data.value.columns, 
					data.value.rows, 
					data.value.row_ext_name,
					data.value.row_path,
					data.value.omitZeroRows, 
					data.value.omitZeroColumns
				);
			}
		});
	}
	
	ajax.execute(callback);
};

MFilterableSpreadsheets.prototype.initSpreadSheets = function(spreadsheets, dsId){
	var omitZeroRows = omitZeroColumns = true;
	
	if (!spreadsheets[dsId])
		spreadsheets[dsId] = {};
	
	this.setSheetInfo(spreadsheets, dsId, null, null, null, null,
		omitZeroRows, omitZeroColumns
	);
	
	if(!spreadsheets[dsId].name){ 
		spreadsheets[dsId].name = {};
	}
	spreadsheets[dsId].name.ext_name = this.manager.getDatasource(dsId).ext_name;
	spreadsheets[dsId].name.type = "datasource";
	spreadsheets[dsId].order = parseInt(Moonshadow.helpers.objCount(spreadsheets),10);
};

MFilterableSpreadsheets.prototype.setSheetInfo = function(spreadsheets, ds, columns, rows, 
		row_ext_name, row_path, omitZeroRows, omitZeroColumns){

	spreadsheets[ds].columns = [];
	if(columns){
		spreadsheets[ds].columns = columns;
		if(columns.length && columns[0].bucket_info){
			spreadsheets[ds].specialType = columns[0].field_ext_name;
		}
	}
	
	spreadsheets[ds].rows = "";
	if(rows){
		spreadsheets[ds].rows = rows;
	}
	if(row_ext_name){
		spreadsheets[ds].row_ext_name = row_ext_name;
	}
	if(row_path){
		spreadsheets[ds].row_path = row_path;
	}
	if(omitZeroRows != undefined){
		spreadsheets[ds].omitZeroRows = omitZeroRows;
	}
	if(omitZeroColumns != undefined){
		spreadsheets[ds].omitZeroColumns = omitZeroColumns;
	}
};

MFilterableSpreadsheets.prototype.buildSSControls = function(dsId){
	
	var ss = this.spreadsheets[dsId];
	
	var ssOptions = document.createElement("div");
	ssOptions.className = "criteria";
	
	var t_editable = true;
	var t_selectedRows = null;
	var t_omitZeroRows = null;
	var t_omitZeroColumns = null;
	var t_name = null;

	var ssOpener = this.getSSOpener(dsId);
	ssOptions.ssOpener = ssOpener;
	ssOptions.appendChild(ssOpener);
	
	var xlsOpener = this.getXLSOpener(dsId);
	ssOptions.xlsOpener = xlsOpener;
	ssOptions.appendChild(xlsOpener);
	
	var sheetButton = document.createElement("div");
	sheetButton.className = "sheetButton clickable";
	var sheetButtonIcon = document.createElement("div");
	sheetButtonIcon.className = "expander left";
	sheetButton.appendChild(sheetButtonIcon);
	
	$(sheetButton).click({"ssOptions":ssOptions, "t_editable":t_editable},function(e) {
		if(e.data.t_editable === false || e.data.t_editable === 0)
			$(e.data.ssOptions.sheetOptionsPanel).addClass("sheetButtonDisabled");
		
		$(e.data.ssOptions.sheetOptionsPanel).toggleClass("hide");
		
		if ($(e.data.ssOptions.sheetOptionsPanel).hasClass("hide")){
			$(".expander", this).removeClass("expanded");
		}else{
			$(".expander", this).addClass("expanded");
		}

	});

	var controlTitle = "Spreadsheet";
	if (this.spreadsheets && ss && ss.name && ss.name.ext_name)
		controlTitle = ss.name.ext_name;
	
	if(t_name)
		controlTitle += " "+t_name;
	
	sheetButton.appendChild(document.createTextNode(controlTitle));
	ssOptions.appendChild(sheetButton);

	var sheetOptionsPanel = document.createElement("div");
	sheetOptionsPanel.className = "sheetOptionsPanel hide";
	ssOptions.sheetOptionsPanel = sheetOptionsPanel;
	
	var resetContainer = document.createElement("div");
	var resetButton = document.createElement("input");
	$(resetContainer)
		.addClass("reset_ss_button_cont")
		.addClass(this.presetSpreadsheets[dsId] ? "" : "hide")
		.append(
			$(resetButton)
				.addClass("reset_ss_button")
				.attr({
					"value": "Reset to defaults",
					"type": "button"
				})
				.on("click", {"self": this, "dsId": dsId, "ssOptions": ssOptions}, function(e){
					var self = e.data.self;
					var dsId = e.data.dsId;
					var name = (self.spreadsheets[dsId].name && self.spreadsheets[dsId].name.ext_name) || "this";
					
					MUILayoverPanel.confirm({
						"message": "Reset " + name + " spreadsheet to default settings?",
						"callback": function(res, id, hide){
							if(res){
								self.mergeSSInfo(dsId, self.presetSpreadsheets[dsId]);
								self.changeTable();
								self.toggleSpreadsheetButton(null, dsId);
							}
							hide();
						}
					});
				})
		);
	
	
	sheetOptionsPanel.appendChild(resetContainer);
	ssOptions.resetContainer = resetContainer;
	
	var zrf_holder = document.createElement("div");
	var zrf_span = document.createElement("span");
	zrf_span.appendChild(document.createTextNode("Omit rows having all zeros"));
	ssOptions.appendChild(zrf_span);
	var zrf_input = document.createElement("input");
	zrf_input.type = "checkbox";
	!t_editable && (zrf_input.disabled = true);
	var omit_zero_rows = ss.omitZeroRows === true || 
		ss.omitZeroRows === false ? 
			ss.omitZeroRows : true;
	if(t_omitZeroRows === "1")
		omit_zero_rows = true;
	if(t_omitZeroRows === "0")
		omit_zero_rows = false;
	zrf_input.checked = omit_zero_rows;
	ssOptions.appendChild(zrf_input);
	
	var zcf_holder = document.createElement("div");
	var zcf_span = document.createElement("span");
	zcf_span.appendChild(document.createTextNode("Omit columns having all zeros"));
	ssOptions.appendChild(zcf_span);
	var zcf_input = document.createElement("input");
	zcf_input.type = "checkbox";
	!t_editable && (zcf_input.disabled = true);
	var omit_zero_columns = ss.omitZeroColumns === true || 
		ss.omitZeroColumns === false ? 
			ss.omitZeroColumns : true;
	if(t_omitZeroColumns === "1")
		omit_zero_columns = true;
	if(t_omitZeroColumns === "0")
		omit_zero_columns = false;
	zcf_input.checked = omit_zero_columns;
	ssOptions.appendChild(zcf_input);

	if(t_editable){
		$(zrf_input).on("change", {"control":this,"dsId":dsId},function(e){
			e.data.control.changeOmitZeros(e.data.dsId, "rows", this.checked);
		});
		$(zrf_span).on("click", {"zrf_input":zrf_input},function(e){
			$(e.data.zrf_input).click();
		});
	}

	if(t_editable){
		$(zcf_input).on("change", {"control":this,"dsId":dsId},function(e){
			e.data.control.changeOmitZeros(e.data.dsId, "columns", this.checked);
		});
		$(zcf_span).on("click", {"zcf_input":zcf_input},function(e){
			$(e.data.zcf_input).click();
		});
	}
	
	ssOptions.zero_rows_checkbox = zrf_input;
	ssOptions.zero_columns_checkbox = zcf_input;
	zrf_holder.appendChild(zrf_input);
	zrf_holder.appendChild(zrf_span);
	sheetOptionsPanel.appendChild(zrf_holder);

	zcf_holder.appendChild(zcf_input);
	zcf_holder.appendChild(zcf_span);
	sheetOptionsPanel.appendChild(zcf_holder);

	var row_holder = document.createElement("div");
	var row_span = document.createElement("span");
	row_span.className = "row_span_title";
	var row_span_val = document.createElement("span");
	row_span_val.className = "row_span_val";
	
	var spacer_cols = document.createElement("div");
	spacer_cols.className = "ss_sheet_option_spacer";
	row_holder.appendChild(spacer_cols);

	row_span.appendChild(document.createTextNode("Selected rows: "));
	
	var row_name = t_selectedRows || ss.row_ext_name || "";
	row_span_val.appendChild(document.createTextNode(row_name));
	
	row_holder.appendChild(row_span);
	row_holder.appendChild(row_span_val);
	ssOptions.rowInfo = row_span_val;
	sheetOptionsPanel.appendChild(row_holder);
	
	var col_holder = document.createElement("div");
	var col_utils_holder = document.createElement("div");
	col_utils_holder.className = "col_utils_holder";
	
	var clear_cols = document.createElement("div");
	if(t_editable){
		clear_cols.className = "sprite-clearColumn";
		$(clear_cols).click({"control":this,"dsId":dsId},function(e){
			if($(this).hasClass("sprite-clearColumnDisabled"))
				return;
			e.data.control.clearColumnSelections(e.data.dsId);
		});
		clear_cols.title = "Clear all spreadsheet column selections for this datasource";
		ssOptions.clear_cols = clear_cols;
		col_utils_holder.appendChild(clear_cols);
	}else{
		var spacer_cols = document.createElement("div");
		spacer_cols.className = "ss_sheet_option_spacer";
		col_utils_holder.appendChild(spacer_cols);
	}
	
	var col_holder_text = document.createElement("div");
	col_holder_text.className = "selected_columns_title";
	col_holder_text.appendChild(document.createTextNode("Selected columns: "));
	col_utils_holder.appendChild(col_holder_text);
	
	var showHideColumnPreview = function(){
		var target = $(this).closest(".col_utils_holder");
		var hide = $(".selected_columns_preview", target).hasClass("hide");
		if(hide){
			$(".selected_columns_preview", target)
				.removeClass("hide");
			$(".col_group_holder", $(target).parent())
				.addClass("hide");
			$(".show_selected_column_preview", target)
				.removeClass("expanded");
		}else{
			$(".selected_columns_preview", target)
				.addClass("hide");
			$(".col_group_holder", $(target).parent())
				.removeClass("hide");
			$(".show_selected_column_preview", target)
				.addClass("expanded");
		}
	};
	
	var viewSelectedColumns = document.createElement("div");
	viewSelectedColumns.className = "expander show_selected_column_preview clickable";
	$(viewSelectedColumns).on("click", showHideColumnPreview);
	col_utils_holder.appendChild(viewSelectedColumns);
	
	col_holder.appendChild(col_utils_holder);
	
	var col_group_holder = document.createElement("div");
	col_group_holder.className = "col_group_holder hide";
	ssOptions.colInfo = col_group_holder;
	
	if (ss.columns && ss.columns.length > 0){
		$(clear_cols).addClass("clickable");
		for(var i = 0, l = ss.columns.length; i < l; ++i){
			var colHolder = this.columnItemControl(ss.columns[i], dsId, true);
			if(colHolder){
				$(col_group_holder).append(colHolder);
			}
		}
	}else{
		if(t_editable){
			$(clear_cols)
				.removeClass("sprite-clearColumn")
				.addClass("sprite-clearColumnDisabled");
		}
		var no_col_container = document.createElement("div");
		no_col_container.appendChild(document.createTextNode("No columns selected."));
		no_col_container.className = "no_col_container"
		col_group_holder.appendChild(no_col_container);
	}
	
	var viewSelectedColumnsPreview = document.createElement("div");
	viewSelectedColumnsPreview.className = "selected_columns_preview clickable";
	$(viewSelectedColumnsPreview)
		.on("click", showHideColumnPreview)
		.append($(col_group_holder).text());
	col_utils_holder.appendChild(viewSelectedColumnsPreview);

	col_holder.appendChild(col_group_holder);
	
	var clear = document.createElement("div");
	clear.className = "clear";
	col_holder.appendChild(clear);
	
	sheetOptionsPanel.appendChild(col_holder);
	
	ssOptions.appendChild(sheetOptionsPanel);
	
	var clear = document.createElement("div");
	clear.className = "clear";
	ssOptions.appendChild(clear);
	
	this.container.appendChild(ssOptions);
	
	if(!ss.ui)
		ss.ui = [];
	ss.ui.push(ssOptions);
	
	this.toggleSpreadsheetButton(null, dsId);
};

MFilterableSpreadsheets.prototype.getSSOpener =  function(dsId){
	var ce = this.getControl().ce;
	
	return $(ce("div"))
		.addClass("sprite-spreadsheet_disabled")
		.data({"disabled": true})
		.attr({
			"title": "Open Spreadsheet (Disabled: Choose rows and columns)"
		})
		.click({"dsId": dsId, "control": this}, function(e){
			var control = e.data.control;
			var manager = control.manager;
			var dsId = e.data.dsId;
			var datasourcesControl = manager.getControl('datasources');

			if (!datasourcesControl.hasReqAddons(dsId)) {
				return manager.cvSubscriptionRequired();
			}
			
			if (!$(this).data("disabled")) {
				control.show(dsId);
			}
		})
		.get(0);
}

MFilterableSpreadsheets.prototype.getXLSOpener = function(dsId){
	var ce = this.getControl().ce;
	
	return $(ce("div"))
		.addClass("sprite-exportAsXLSDisabled")
		.data({"disabled": true})
		.attr({
			"title": "Open in MS Excel (Disabled: Choose rows and columns)",
			"disabled": true
		})
		.click({"dsId": dsId, "control": this}, function(e){
			var control = e.data.control;
			var manager = control.manager;
			var dsId = e.data.dsId;
			var datasourcesControl = manager.getControl('datasources');

			if (!datasourcesControl.hasReqAddons(dsId)) {
				return manager.cvSubscriptionRequired();
			}
			
			if (!$(this).data("disabled")) {
				control.exportToExcel(dsId);
			}
		})
		.get(0);
};


MFilterableSpreadsheets.prototype.exportToExcel = function(dsId){
	this.exportTable(this.getTableQuery(dsId, true), "filters");
};

MFilterableSpreadsheets.prototype.mergeSSInfo = function(dsId, spreadsheets){
	for(var i in spreadsheets){
		if(!spreadsheets.hasOwnProperty(i)){
			continue;
		}
		this.spreadsheets[dsId][i] = spreadsheets[i];
	}
};

MFilterableSpreadsheets.prototype.changeOmitZeros = function(dsId, type, onOff){
	if (type === "rows") {
		this.spreadsheets[dsId].omitZeroRows = onOff;
	}
	if (type === "columns") {
		this.spreadsheets[dsId].omitZeroColumns = onOff;
	}
	if (this.spreadsheets[dsId].columns && this.spreadsheets[dsId].columns.length > 0){
		this.changeTable();
	}
};

MFilterableSpreadsheets.prototype.clearColumnSelections = function(dsId){
	var ss = this.spreadsheets[dsId];
	if(!ss.columns){
		return;
	}
	var self = this;
	var clearCol = function(filterable){
		if(filterable){
			filterable.tableColSelected = false;
			self.toggleSSColButton(0, filterable.getColumnAdder());
		}
	}
	
	for(var i = 0, l = ss.columns.length; i < l; ++i){
		var f = ss.columns[i];
		for(ii in f.values){
			if(!f.values.hasOwnProperty(ii)){
				continue;
			}
			clearCol(this.getControl().getItemByTreePath(dsId, f.values[ii]));
		}
		if(f.bucket_info){
			clearCol(this.getControl().getItemByTreePath(dsId, f.bucket_info.path));
		}
		
	}
	ss.columns = [];
	ss.specialType = false;
	this.toggleSpreadsheetButton(0, dsId);
	this.resetZeroChecked(dsId);
	$(".selected_columns_preview", this.spreadsheets[dsId].ui[i]).empty();
	this.changeTable();
};

MFilterableSpreadsheets.prototype.resetZeroChecked = function(ds){
	for(var i = 0, l = this.spreadsheets[ds].ui.length; i < l; ++i){
		this.spreadsheets[ds].ui[i].zero_rows_checkbox.checked = true; 
		this.spreadsheets[ds].omitZeroRows = true;
		this.spreadsheets[ds].ui[i].zero_columns_checkbox.checked = true; 
		this.spreadsheets[ds].omitZeroColumns = true;
	}
};

MFilterableSpreadsheets.prototype.columnItemControl = function(col, dsId, editable){
	var self = this;
	var ce = this.getControl().ce;
	var getColHeader = function(title){
		return [$(ce("div"))
			.addClass("col_group")
			.append(
				$(ce("span"))
					.append(" ", 
						function(){
							var _title = title || col.field_ext_name || col.field;
							return Moonshadow.helpers.capitalize(_title.replace(/_/g," ")+": ");
						}()
					)
			).get(0)];
	};
	
	var makeColRemover = function(data, value, callback){
		return $(ce("div"))
			.addClass("col_item")
			.append(
				 $(ce("div"))
					.addClass("sprite-removeSmallGray col_remover")
					.addClass(editable ? "clickable" : "")
					.click(data, callback),
				$(ce("span"))
					.addClass("col_remover_text")
					.append(" ", value)
			)
			.get(0);
	};
	
	var getValues = function(){
		return $.map(col.values, function(value, key){
			return makeColRemover({
					"control":self,
					"dsId":dsId,
					"path": value,
					"editable":editable,
					"field": col.field,
					"value": key
				},  Moonshadow.helpers.capitalize(key),
				function(e){
					if(e.data.editable){
						var dsId = e.data.dsId;
						var treePath = e.data.path;
						var control = e.data.control;
						var field = e.data.field;
						var value = e.data.value;
						
						var filterable = control.getControl().getItemByTreePath(dsId, treePath);
						if(filterable){
							control.removeColumn(filterable);
							self.toggleSSColButton(0, filterable.getColumnAdder());
						}else{
							control._removeColumn(dsId, field, col);
						}
						control.changeTable();
						control.toggleSpreadsheetButton(null, dsId);
					}
				}
			);
		});
	};
	
	var getTimestampItem = function(){
		return makeColRemover({
				"control":self,
				"dsId":dsId,
				"path": col.bucket_info.path,
				"editable":editable,
				"field": col.field,
				"bucket": col.bucket_info.time_slice
			}, Moonshadow.helpers.capitalize(
				col.bucket_info.time_slice
			),
			function(e){
				if(e.data.editable){
					var dsId = e.data.dsId;
					var treePath = e.data.path;
					var control = e.data.control;
					var field = e.data.field;
					var bucket = e.data.bucket;
					
					
					var filterable = control.getControl().getItemByTreePath(dsId, treePath);
					if(filterable){
						//hack: there is only one special type. need to change this when there are more
						control.removeColumn(filterable, "timestamp", bucket);
						self.toggleSSColButton(0, filterable.getColumnAdder());
					}else{
						//hack: there is only one special type. need to change this when there are more
						control._removeColumn(dsId, field, field, "timestamp", bucket);
					}
					control.changeTable();
					control.toggleSpreadsheetButton(null, dsId);
				}
			});
	};

	if(col.bucket_info){
		return getColHeader(col.field_ext_name).concat([getTimestampItem()]);
	}
	
	var hasValues = this.hasValues(dsId, col);
	if (hasValues){
		return getColHeader().concat(getValues());
	}

	return false;
};

MFilterableSpreadsheets.prototype.hasValues = function(dsId, column){
	var checkItem = function(column){
		if(column.values){
			for(var ii in column.values){
				if(column.values.hasOwnProperty(ii)){
					return true;
				}
			}
		}
		if(column.bucket_info){
			return true;
		}
		return false;
	};
	
	if(column)
		return checkItem(column);
	
	var ss = this.spreadsheets[dsId];
	if(ss.columns && ss.columns.length){
		for(var i = 0, l = ss.columns.length; i < l; ++i){
			return checkItem(ss.columns[i]);
		}
	}
	return false;
};

MFilterableSpreadsheets.prototype.getSelectedPath = function(dsId, field, col){
	var ss = this.spreadsheets[dsId];
	if(ss.columns && ss.columns.length){
		for(var i = 0, l = ss.columns.length; i < l; ++i){
			if(ss.columns[i].field == field && 
						ss.columns[i].values && 
						ss.columns[i].values[col]){
					return ss.columns[i].values[col];
			}
		}
	}
};

MFilterableSpreadsheets.prototype.selectOpenSSColumns = function(dsId){
	var ss = this.spreadsheets[dsId];
	if(!ss || !ss.columns || !ss.columns.length)
		return;
	for(var i = 0, l = ss.columns.length; i < l; ++i){
		for(var ii in ss.columns[i].values){
			var path = ss.columns[i].values[ii];
			var filterable = this.getControl().getItemByTreePath(dsId, path);
			if(filterable){
				filterable.tableColSelected = true;
				this.toggleSSColButton(1, filterable.getColumnAdder());
			}
		}
	}
};

MFilterableSpreadsheets.prototype.selectOpenSSRows = function(dsId){
	var ss = this.spreadsheets[dsId];
	if(!ss || !ss.row_path || !ss.row_path.length)
		return;
	var filterable = this.getControl().getItemByTreePath(dsId, ss.row_path);
	if(filterable){
		this.ssRowButtonSelect(filterable);
	}
};

MFilterableSpreadsheets.prototype.reloadControls = function(ds){
	if (!this.spreadsheets[ds].ui){
		this.buildSSControls(ds);
	}
	var ss = this.spreadsheets[ds];
	var ui = ss.ui;
	if (ss.row_ext_name){
		for(var i = 0, l = ui.length; i < l; ++i){
			$(ui[i].rowInfo).empty();
			ui[i].rowInfo.appendChild(document.createTextNode(ss.row_ext_name));
		}
	}
	
	var noCols = function(){
		var no_col_container = document.createElement("div");
		return $(no_col_container)
			.addClass("no_col_container")
			.append(
				document.createTextNode("No columns selected.")
			);
	};
	
	for(var i = 0, l = ui.length; i < l; ++i){
		$(ui[i].colInfo).empty();
		if (ss.columns && ss.columns.length){
			$(ui[i].clear_cols)
				.removeClass("sprite-clearColumnDisabled")
				.addClass("clickable sprite-clearColumn");
			
			for(var j in ss.columns){
				var colHolder = this.columnItemControl(ss.columns[j], ds, true);
				if(colHolder){
					$(ui[i].colInfo).append(colHolder);
				}else{
					$(ui[i].colInfo).append(noCols());
				}
			}
		}else{
			$(ui[i].clear_cols)
				.addClass("sprite-clearColumnDisabled")
				.removeClass("clickable sprite-clearColumn");
				
			$(ui[i].colInfo).append(noCols());
		}
		$(".selected_columns_preview", ui[i])
			.empty()
			.append($(".col_group_holder", ui[i]).text());
	}
};

MFilterableSpreadsheets.prototype.show = function(dsId) {	
	var sheetInst = this.getSheetInstance();
	if (sheetInst){
		this.focusSheet();
		var sc = this.getSheetContainer();
		if(sc){
			this.buildDataTable(dsId, sc.spreadSheetUtils.buildSheet);
		}
	}else{
		this.createSheetInstance(dsId);
	}
};

MFilterableSpreadsheets.prototype.getSheetContainer = function(){
	return !!this.sheet && this.sheet.container;
};

MFilterableSpreadsheets.prototype.getSheetInstance = function(){
	var sc = this.getSheetContainer();
	return (!!sc && !!sc.$ && !!sc.$.sheet && !!sc.$.sheet.instance && sc.$.sheet.instance[0]) || false;
};

MFilterableSpreadsheets.prototype.errorState = function(ds, error){
	MUILayoverPanel.alert(error.message);
	this.toggleSpreadsheetButton(0, ds, null, "Error");
	this.hide("main");
	return false;
};

MFilterableSpreadsheets.prototype.buildDataTable = function(dsId, callback){
	var self = this;
	this.getTable(dsId, function(data, message){
		if(!data){
			var sc = self.getSheetContainer();
			if(sc){
				sc.close();
			}
			return MUILayoverPanel.alert("There was a problem: " + (message || "Unknown"));
		}
		try{
			callback(data, dsId, self.spreadsheets[dsId].name.ext_name);
		}catch(e){
			//previous sheet closed too soon. Do nothing.
		}
	});
};

MFilterableSpreadsheets.prototype.hide = function(source) {
	if(!this.sheet){
		return;
	}
	var ops = $.extend([], this.sheet.windowOptions);
	if(this.sheet.container && source == "main"){
		this.sheet.container.close();
	}
	this.sheet = {
		"windowOptions": ops
	}
};

MFilterableSpreadsheets.prototype.focusSheet = function(){
	var sc = this.getSheetContainer();
	if(sc){
		sc.focus();
	}
};

MFilterableSpreadsheets.prototype.unmarkAllColumns = function(toggle){
	var buttons = $(".ssbutton");
	$.each(buttons,function() {
		if(this.isSelected){
			this.toggle = toggle;
			$(this).click();
		}
	});
};

MFilterableSpreadsheets.prototype.toggleSSColButton = function(onOff, target, bucket){
	if(!target)
		return;
	
	var specialType = $(target).hasClass("radio_selection");
	var sTarget;
	if(specialType){
		for(var i = 0, l = target.length; i < l; ++i){
			if($(target[i]).data("bucket") == bucket){
				sTarget = $(target[i]);
				break;
			}
		}
		$(target)
			.removeClass("sprite-addColumnSelected")
			.addClass("sprite-addColumn");
		if(sTarget)
			target = sTarget;
	}
	
	if(onOff == 1){
		$(target).removeClass("sprite-addColumn");
		$(target).addClass("sprite-addColumnSelected");
		target.isSelected = true;
		target.toggle = false;
	}else{
		$(target).removeClass("sprite-addColumnSelected");
		$(target).addClass("sprite-addColumn");
		target.isSelected = false;
		target.toggle = false;
	}
};

MFilterableSpreadsheets.prototype.toggleSpreadsheetButton = function(onOff, dsId, target, message){
	var manager = this.getControl().getManager();
	var filters = manager.getControl('filters');
	var filterableDS = filters.getDatasource(dsId);
	if (target == null && dsId != null){
		if (!filterableDS){
			return false;
		}
		target = filterableDS.openSS;
	}
	var ss = this.spreadsheets[dsId];
	if(!ss)
		return false;
	
	if (!onOff || onOff == 1 || onOff == undefined || onOff == "" || onOff == null){
		var colsSelected = ss.columns && ss.columns.length;
		var rowsSelected = !!ss.rows;
		
		if(!colsSelected || !rowsSelected){
			onOff = 0;
			message = !colsSelected ? 
				"(Disabled: Select Columns in this Datasource)" : 
				"(Disabled: Select Rows in this Datasource)";
		}
		if (onOff != 0) 
			onOff = 1;
	}

	var ssTitle, ssAdd, ssRem, xlTitle, xlAdd, xlRem;
	if (onOff == 1){
		ssTitle = "Open Spreadsheet";
		ssAdd = "sprite-spreadsheet clickable";
		ssRem = "sprite-spreadsheet_disabled";
		xlTitle = "Open in MS Excel";
		xlAdd = "sprite-exportAsXLS clickable";
		xlRem = "sprite-exportAsXLSDisabled";
	}else{
		if(!message)
			message = "(Disabled: Select Columns in this Datasource)";
		ssTitle = "Open Spreadsheet " + message;
		ssAdd = "sprite-spreadsheet_disabled";
		ssRem = "sprite-spreadsheet clickable";
		xlTitle = "Open in MS Excel " + message;
		xlAdd = "sprite-exportAsXLSDisabled";
		xlRem = "sprite-exportAsXLS clickable";
	}
	
	$(target)
		.addClass(ssAdd)
		.removeClass(ssRem)
		.data("disabled", !onOff)
		.attr({
			"title": ssTitle
		});
	
	for(var i = 0, l = ss.ui.length; i < l; ++i){
		$(ss.ui[i].ssOpener)
			.addClass(ssAdd)
			.removeClass(ssRem)
			.data({"disabled": !onOff})
			.attr({
				"title": ssTitle
			});
		$(ss.ui[i].xlsOpener)
			.addClass(xlAdd)
			.removeClass(xlRem)
			.data({"disabled": !onOff})
			.attr({
				"title": xlTitle
			});
	}
};

MFilterableSpreadsheets.prototype.addColumn = function(filterable, specialType, bucket){
	var filterableDS = filterable.getDatasource();
	var dsId = filterableDS.int_name;
	var field = filterable.parent.int_name;
	var field_ext_name = filterable.parent.ext_name;
	var col = filterable.int_name;
	var path = filterable.getTreePath();
	var bucketName = filterable.ext_name;
	if(!this._checkSpecial(dsId, specialType, field_ext_name, bucketName)){
		return false;
	}
	this._addColumn(dsId, field, field_ext_name, col, path, specialType, bucket, bucketName);
	filterable.tableColSelected = true;
	return true;
}

MFilterableSpreadsheets.prototype._checkSpecial = function(dsId, specialType, field_ext_name, bucketName){
	var ss = this.spreadsheets[dsId];
	var extName = Moonshadow.helpers.capitalize(field_ext_name);
	if(specialType){
		extName = Moonshadow.helpers.capitalize(field_ext_name) + ": " + Moonshadow.helpers.capitalize(bucketName);
	}
	
	var message;
	if(ss.specialType){
		var message = "The column " +  extName  + " cannot be selected while a the special field type " + 
			ss.specialType + " is also selected. To view the columns for " +  extName + 
			", deselect the special field type " + ss.specialType + ". ";
	}
	if(specialType && ss.columns.length){
		var message = "The column for special field type " +  extName + " cannot be selected while other " +
			" columns are also selected for this spreadsheet. To view the columns for " +  extName + 
			", it must be selected alone. ";
	}
	if(message){
		MUILayoverPanel.alert(message);
		return false;
	}
	return true;
};

MFilterableSpreadsheets.prototype._getExistingItem = function(field, dsId){
	var ss = this.spreadsheets[dsId];
	if(!ss){
		return false;
	}
	for(var i = 0, l = ss.columns.length; i < l; ++i){
		if (ss.columns[i].field == field){ 
			return ss.columns[i];
		}
	}
	return false;
};

MFilterableSpreadsheets.prototype._addColumn = function(dsId, field, field_ext_name, col, path, specialType, bucket, bucketName){
	var ss = this.spreadsheets[dsId];
	if(!ss){
		this.initSpreadSheets(this.spreadsheets, dsId);
		ss = this.spreadsheets[dsId];
	}

	if (specialType == "timestamp" && bucket){
		field = col;
	}
	
	var item = this._getExistingItem(field, dsId);
	
	if(!item){
		item = {
			"field": field,
			"field_ext_name": field_ext_name
		};
		ss.columns.push(item);
	}
	
	if (specialType == "timestamp" && bucket){
		item.parent_ext = field_ext_name;
		item.field_ext_name = field_ext_name + ": " + bucketName;
		item.bucket_info = {
			"path": path,
			"time_slice": bucket,
			"tz_offset": new Date().getTimezoneOffset() * -60,
			"display_timeslice_human_readable": 1
		};
		ss.specialType = item.field_ext_name;
	}
	
	if(col && !specialType){
		if(!item.values){
			item.values = {};
		}
		item.values[col] = path;
	}

	this.changeTable();
};

MFilterableSpreadsheets.prototype.removeColumn = function(filterable, specialType, bucket){
	var filterableDS = filterable.getDatasource();
	var dsId = filterableDS.int_name;
	var field = filterable.parent.int_name;
	var col = filterable.int_name;
	this._removeColumn(dsId, field, col, specialType, bucket);
	filterable.tableColSelected = false;
	return true;
};

MFilterableSpreadsheets.prototype._removeColumn = function(dsId, field, col, specialType, bucket){
	var ss = this.spreadsheets[dsId];
	if(!ss){
		return;
	}
	
	if(specialType){
		ss.specialType = false;
	}
	
	if(specialType == "timestamp"){
		field = col;
	}
	
	if(ss.columns && ss.columns.length){
		for(var i = 0, l = ss.columns.length; i < l; ++i){
			if (ss.columns[i].field == field){
				if(specialType == "timestamp" && 
						ss.columns[i].bucket_info && 
						ss.columns[i].bucket_info.time_slice == bucket){
					delete ss.columns[i].bucket_info;
					continue;
				}
				delete ss.columns[i].values[col];
			}
		}
	}
	
	this.removeEmptyColumns(dsId);
	
	if(!ss.columns.length){
		this.resetZeroChecked(dsId);
	}
	
	this.changeTable();
};

MFilterableSpreadsheets.prototype.removeEmptyColumns = function(dsId){
	var ss = this.spreadsheets[dsId];
	if(!ss || !ss.columns.length){
		return;
	}
	var self = this;
	ss.columns = $(ss.columns).map(function(index, column){
		if(self.hasValues(dsId, column)){
			return column;
		}
		if(column.bucket_info){
			return column;
		}
	}).toArray();
};

MFilterableSpreadsheets.prototype.addRow = function(filterable){
	var int_name = filterable.int_name;
	var ext_name = filterable.ext_name;
	var filterableDS = filterable.getDatasource();
	var dsId = filterableDS.int_name;
	var path = filterable.getTreePath();
	
	this.ssRowButtonSelect(filterable);
	this._addRow(dsId, int_name, ext_name, path);
	this.changeTable();
	this.toggleSpreadsheetButton(null, dsId);
};

MFilterableSpreadsheets.prototype._addRow = function(dsId, rowIntName, rowExtName, rowPath){
	var ss = this.spreadsheets[dsId];
	if(!ss){
		this.initSpreadSheets(this.spreadsheets, dsId);
		ss = this.spreadsheets[dsId];
	}
	if (rowIntName){
		ss.rows = rowIntName;
	}
	if (rowExtName){
		ss.row_ext_name = rowExtName;
	}
	if(rowPath){
		ss.row_path = rowPath;
	}
};

MFilterableSpreadsheets.prototype.exportTable = function(jsonData, type){
	
	if(!type)
		type = "sheet";
	
	var exportForm = document.createElement("form");
	exportForm.action = Moonshadow.getDataUrl("/export/" + type);
	exportForm.method = "POST";
	exportForm.target = "_blank";

	var data = document.createElement("input");
	data.type = "hidden";
	data.name = "data";
	data.value = JSON.stringify(jsonData);

	var key = document.createElement("input");
	key.type = "hidden";
	key.name = "key"
	key.value = Moonshadow.key;

	exportForm.appendChild(key);

	var user = document.createElement("input");
	user.type = "hidden";
	user.name = "user"
	user.value = Moonshadow.user;

	exportForm.appendChild(user);

	exportForm.appendChild(data);
	Moonshadow.getManager().getContainer().appendChild(exportForm);
	exportForm.submit();
	$(exportForm).remove();
};

MFilterableSpreadsheets.prototype.setFiltersSpecial = function(ds, reset, callback){
	var query = this.manager.getControl("filters").datasources[ds].getFilterQuery();

	if(reset && Moonshadow.helpers.objCount(query.value) > 0){
		query.value = {};
	}
	
	var ajax = new Moonshadow.Ajax();
	ajax.addQuery(query, callback);
	ajax.execute();
};

MFilterableSpreadsheets.prototype.getTableQuery = function(dsId, isCSV){
	var spreadsheet = this.spreadsheets[dsId];
	var inCols = spreadsheet.columns;
	var outCols = []
	for(var i = 0, l = inCols.length; i < l; ++i){
		var outItem = $.extend({}, inCols[i]);
		if(inCols[i].values){
			outItem.values = $.map(inCols[i].values, function(a, b){return b});
		}
		outCols.push(outItem);
	}
	
	var filtersControl = this.getControl().getManager().getControl("filterscontrol");
	
	var query = {
		"query": "get_table",
		"dirty_only": false,
		"omit_zero_rows": spreadsheet.omitZeroRows ? 1 : 0,
		"omit_zero_columns": spreadsheet.omitZeroColumns ? 1 : 0,
		"table_settings": {
	        "rows": spreadsheet.rows,
	        "columns": outCols
	    },
	    "filter": filtersControl.filtersToJSON(dsId),
		"ds": dsId
	};
	
	if(isCSV){
		query.query = "get_table_csv";
		query.ext_type =  "csv";
	}
	
	return query;
};

MFilterableSpreadsheets.prototype.runTableQuery = function(dsId, callback){
	var ajax = new Moonshadow.Ajax();
	var self = this;
	ajax.addQuery(this.getTableQuery(dsId, false), callback);
	ajax.execute();
};

MFilterableSpreadsheets.prototype.changeTable = function(callback){
	var ajax = new Moonshadow.Ajax();
	var datasources = this.manager.getOptions().datasources;
	for(var i = 0, l = datasources.length; i < l; ++i){
		var dsId = datasources[i].int_name;
		var query = {
			"query": "save_stored_state",
			"name": "saved_table_settings",
			"ds": dsId
		}
		
		var ss = this.spreadsheets[dsId];
		if(!ss){
			this.initSpreadSheets(this.spreadsheets, dsId);
			ss = this.spreadsheets[dsId];
		}
		
		if (ss.columns && ss.columns.length){
			var row_ext_name = ss.row_ext_name || "";
			var rows = ss.rows || "";
			var row_path = ss.row_path || [];
			var cols = ss.columns || [];
			if(!rows.length || !this.hasValues(dsId)){
				return this.reloadControls(dsId);
			}
			query.value = {
				"row_ext_name": row_ext_name,
				"rows": rows,
				"row_path": row_path,
				"columns": cols,
				"omitZeroRows": ss.omitZeroRows,
				"omitZeroColumns": ss.omitZeroColumns
			};
		}else{
			query.query = "delete_stored_state";
		}
		var self = this;
		ajax.addQuery(query, function(result){
			self.reloadControls(result.ds);
		});
	}
	ajax.execute(callback);
};

MFilterableSpreadsheets.prototype.clearTableSettings = function(ds, callback){
	var ajax = new Moonshadow.Ajax();
	var query = {
		"query": "delete_stored_state",
		"name": "saved_table_settings",
		"ds": ds
	};
	ajax.addQuery(query, callback);
	ajax.execute();
};

MFilterableSpreadsheets.prototype.verifyData = function(data, callback){
	var size = 0;
	var header = data.header;
	
	if(header.length > 0) {
		var fields = header[0].fields;
		if(fields.length > 0) {
			size = fields[0].values.length;
		} else {
			return callback(false, "No data was found for the rows provided.");
		}
	} else {
		return callback(false, "No headers were provided.");
	}
	
	if (size > 600) {
		return callback(false, "Too much data was returned.\n\n" +
		  "Please select a smaller amount of data,\n" +
		  "Try changing the inputs.\n" +
		  "Or try selecting 'Omit columns having all zeros' in the Spreadsheet options.");
	}
		
	callback(true);
}

MFilterableSpreadsheets.prototype.getTable = function(dsId, callback){
	var returnObj = {};
	var self = this;
	this.runTableQuery(dsId, function (data) {
		if(data.result != "ok"){
			throw new Error(data.message || "Unknown");
			return;
		}

		self.verifyData(data, function(valid, message){
			if(!valid){
				return callback(false, message);
			}
			
			var header = data.header;
			var rows = data.rows;
			var tableData = [];
			var headerRowValue = self.spreadsheets[data.ds].rows;
			var headerRow = [{
				"value":headerRowValue.replace(/_/g," ")
			}];
			for (var k = 0, l = header.length; k < l; ++k){
				for (var i = 0, ll = header[k].fields.length; i < ll; ++i){
					var name = header[k].fields[i].name;
					for (var j = 0, lll = header[k].fields[i].values.length; j < lll; ++j){
						headerRow.push({
							"value": header[k].fields[i].values[j] + ' (' + name + ')'
						});
					}
				}
			}
			tableData.push(headerRow);
			for (var i = 0, l = rows.length; i < l; ++i){
				var name = rows[i].name;
				var rowData = [{
					"value":(name == "__unassigned" ? " " : name)
				}];
				for(var j = 0, ll = rows[i].values.length; j < ll; ++j){
					var val = rows[i].values[j];
					rowData.push({
						"value": val == "__unassigned" ? " " : val
					});
				}
				tableData.push(rowData);
			}
			
			callback(tableData);
		});
	});
};

MFilterableSpreadsheets.prototype.saveTable = function(tableData, ext_name, int_name, pushName){
	if (pushName) 
		this.saved_spreadsheet_info.push({
			"ext_name" : ext_name, 
			"int_name": int_name
		});
	
	var value = {
		"columns":this.spreadsheets[int_name].columns,
		"rows":this.spreadsheets[int_name].rows,
		"omitZeroRows": this.spreadsheets[int_name].omitZeroRows,
		"omitZeroColumns": this.spreadsheets[int_name].omitZeroColumns,
		"ext_name": ext_name,
		"int_name": int_name,
		"table_obj":tableData
	};
	var ajax = new Moonshadow.Ajax();
	
	var save_query = {
		"query": "save_stored_state",
		"name": "saved_spreadsheet__"+ext_name,
		"qid": "save_spreadsheet",
		"ds": int_name,
		"value": value
	};		
	ajax.addQuery(save_query, this);
	
	ajax.addQuery({
		"query": "save_stored_state",
		"name": "saved_spreadsheet_info",
		"qid": "save_saved_spreadsheet_info",
		"value": {"sheets": this.saved_spreadsheet_info}
	}, this);
	ajax.execute();
};

MFilterableSpreadsheets.prototype.loadTable = function(ds, name){
	var ajax = new Moonshadow.Ajax();
	var self = this;
	ajax.addQuery({
		"query": "load_stored_state",
		"name": "saved_spreadsheet__"+name,
		"qid": "load_save_spreadsheet",
		"ds": ds
	}, function(data){
		if (data.result == "not_found"){
			return;
		}

		var sc = self.getSheetContainer();
		if(sc){
			sc.spreadSheetUtils.getLoadedSheet(data)
		}
	});
	ajax.execute();
};

MFilterableSpreadsheets.prototype.createSheetInstance = function(dsId){
	var rts = new Date().getTime();
	var winOpen = ["/ssc?rts=",rts,"&ds=",dsId,"&template_int_name=default"];
	this.sheet.container = window.open(
		winOpen.join(""),
		"spreadsheet"+(new Date().getTime()),
		String(this.sheet.windowOptions), true
	);
};

MFilterableSpreadsheets.prototype.columnSelected = function(filterable, specialType, bucket){
	var dsId = filterable.getDatasource().int_name;
	var int_name = filterable.int_name;
	var field = filterable.parent.int_name;
	
	var spreadsheets = this.spreadsheets;
	if (spreadsheets[dsId]){
		var cols = spreadsheets[dsId].columns;
		for(var i = 0, l = spreadsheets[dsId].columns.length; i < l; ++i){
			if(specialType && cols[i].bucket_info){
				if(cols[i].field == int_name){
					if(cols[i].bucket_info.time_slice == bucket){
						return true;
					}
				}
			}
			
			if (cols[i].field == field){
				if(cols[i].values[int_name]){
					return true;
				}
			}
		}
	}
	return false;
};

MFilterableSpreadsheets.prototype.spreadsheetColumnAdder = function(filterable, specialType, bucket){
	var ce = Moonshadow.helpers.ce;
	
	var self = this;
	
	var datasourcesControl = this.manager.getControl('datasources');
	var viewOnly = filterable.getDatasource().viewOnly;
	var isSelected = this.columnSelected(filterable, specialType, bucket);
	filterable.tableColSelected = isSelected;
	
	var ssbutton = $(ce("div"))
		.addClass("ssbutton")
		.addClass(viewOnly ? "sprite-addColumnDisabled" : "clickable")
		.addClass(!viewOnly && (isSelected ? "sprite-addColumnSelected" : "sprite-addColumn"))
		.addClass(specialType == "timestamp" ? "radio_selection" : "")
		.attr({
			"title": "Add this as a column in a spreadsheet"
		});
	
	if(!viewOnly) {
		ssbutton.on("click", {"filterable": filterable, "control": this,
				"specialType": specialType, "bucket": bucket}, function(e){
			
			var filterable = e.data.filterable;
			var control = e.data.control;
			var specialType = e.data.specialType;
			var bucket = e.data.bucket;
			var selected = filterable.tableColSelected;
			
			if(bucket){
				if($(this).hasClass("sprite-addColumnSelected")){
					selected = true;
				}else{
					selected = false;
				}
			}
			
			if(e.shiftKey){
				var ls = self.getLastSSRowSelected();
				if((ls && ls.parent == filterable.parent) && (ls != filterable)){
					return self.multiSelect(filterable, specialType, bucket);
				}
			}

			self.setLastSSRowSelected(filterable);
			var success = control.toggleColumn(filterable, selected, specialType, bucket);
			if(success){
				control.toggleSSColButton(!selected, filterable.getColumnAdder(), bucket);
			}
		});
	}
	
	return $(ssbutton).get(0);
};

MFilterableSpreadsheets.prototype.getLastSSRowSelected = function(){
	return this.SSRowSelectedFilterable;
};

MFilterableSpreadsheets.prototype.setLastSSRowSelected = function(filterable){
	this.SSRowSelectedFilterable = filterable;
};

MFilterableSpreadsheets.prototype.multiSelect = function(filterable, specialType, bucket){

	var classSelector = $(filterable.container).attr("class");
	if(!classSelector){
		return;
	}
	var selection = "." + classSelector.split(" ").join(".");
	
	var lastSelectedItem = this.getLastSSRowSelected();
	var _selected = $(lastSelectedItem.columnAdder).hasClass("sprite-addColumnSelected") ? true : false;
	
	var detSelect = function(child){
		var _childSelected = $(child.columnAdder).hasClass("sprite-addColumnSelected") ? true : false;
		if(_childSelected != _selected){
			return true;
		}
	};
	
	var toBeSelected;
	var childrenContainer = $(selection, filterable.parent.childContainer).toArray();
	for(var i = 0, l = childrenContainer.length; i < l; ++i){
		var child;
		var childCont = childrenContainer[i];
		for(var j in filterable.parent.children){
			if(!filterable.parent.children.hasOwnProperty(j)){
				continue;
			}
			var c = filterable.parent.children[j];
			if(c.container == childCont){
				child = c;
				break;
			}
		}
		if(!child){
			continue;
		}
		if(filterable.int_name === child.int_name){
			if(toBeSelected === undefined){
				toBeSelected = [];
				detSelect(child) && toBeSelected.push(child);
				continue;
			}
			detSelect(child) && toBeSelected.push(child);
			break;
		}
		if(lastSelectedItem.int_name === child.int_name){
			if(toBeSelected === undefined){
				toBeSelected = [];
				continue;
			}
			break;
		}
		if(toBeSelected && detSelect(child)){
			toBeSelected.push(child);
		}
	};
	
	if(toBeSelected && toBeSelected.length){
		for(var i = 0, l = toBeSelected.length; i < l; ++i){
			var f = toBeSelected[i];
			f.columnAdder && $(f.columnAdder).trigger("click");
		}
	}
	
	this.setLastSSRowSelected(false);
};

MFilterableSpreadsheets.prototype.rowSelected = function(dsId, int_name){
	return this.spreadsheets[dsId] && this.spreadsheets[dsId].rows == int_name;
};

MFilterableSpreadsheets.prototype.spreadsheetRowAdder = function(filterable){
	var ce = Moonshadow.helpers.ce;
	
	var int_name = filterable.int_name;
	var ext_name = filterable.ext_name;
	var dsId = filterable.getDatasource().int_name;
	var datasourcesControl = this.manager.getControl('datasources');
	
	var viewOnly = filterable.getDatasource().viewOnly;
		
	var isSelected = this.rowSelected(dsId, int_name);
	if(isSelected){
		this.ssRowButtonSelect(filterable);
	}
	
	var ssRowButton = $(ce("div"))
		.addClass("ssRowButton")
		.addClass(viewOnly ? "sprite-addRowDisabled" : "clickable")
		.addClass(!viewOnly && (isSelected ? "sprite-addRowSelected" : "sprite-addRow"))
		.attr({
			"title": "Add this as a row in a spreadsheet"
		});
	
	if(!viewOnly) {
		$(ssRowButton).on("click", 
			{"filterable": filterable, "control": this}, 
			function(e){
				var control = e.data.control;
				var filterable = e.data.filterable;
				
				var filterableDS = filterable.getDatasource();
				var selected = filterableDS.selectedSSRow && 
					(filterableDS.selectedSSRow.int_name == filterable.int_name);
				
				if(!selected){
					control.addRow(filterable);
				}
			}
		);
	}
	
	return $(ssRowButton).get(0);
};

MFilterableSpreadsheets.prototype.ssRowButtonSelect = function(filterable){
	var filterableDS = filterable.getDatasource();
	if(filterableDS.selectedSSRow){
		$(filterableDS.selectedSSRow.rowAdder)
			.removeClass("sprite-addRowSelected")
			.addClass("sprite-addRow");
	}
	filterableDS.selectedSSRow = filterable;
	$(filterable.rowAdder)
		.addClass("sprite-addRowSelected")
		.removeClass("sprite-addRow");
};

MFilterableSpreadsheets.prototype.toggleColumn = function(filterable, selected, specialType, bucket) {
	var success = false;
	if(selected){
		success = this.removeColumn(filterable, specialType, bucket);
	}else{
		success = this.addColumn(filterable, specialType, bucket);
	}

	if(success){
		var dsId = filterable.getDatasource().int_name;
		this.toggleSpreadsheetButton(null, dsId);
	}
	return success
};

MFilterableSpreadsheets.prototype.getAppTypePresets = function(callback){
	/*
{
   "omitZeroRows": true,
   "omitZeroColumns": true,
   "templates": {
      "default": {}
   },
   "name": {
      "ext_name": "Oregon Voters",
      "type": "datasource"
   },
   "order": 1,
   "columns": [
      {
         "field": "zip",
         "field_ext_name": "Zip",
         "values": {
            "97001": true,
            "97002": true,
            "97004": true,
            "97005": true
         }
      }
   ],
   "rows": "Parties_Description",
   "row_ext_name": "Political Party"
}
	 */
	
	var appType = this.getControl().getManager().getOption("app_details.type");
	if(appType == "adpsycho"){

		var datasources = Moonshadow.getManager().getOptions().datasources;
		var ajax = new Moonshadow.Ajax();
		var dsIntNames = [];
		for(var i = 0, l = datasources.length; i < l; ++i){
			if(!datasources.hasOwnProperty(i)){
				continue;
			}
			var ds = datasources[i].int_name;
			this.initSpreadSheets(this.presetSpreadsheets, ds);
			dsIntNames.push(ds);
		}
		
		var presetRows = "__total";
		var presetCols = "zip";
		var presetColsExtName = "Zip";
		var presetRowPath = ["__individual_demographics", "zip"];
		var omitZeroRows = true;
		var omitZeroColumns = true;
		
		var self = this;
		var qCount = 0;
		for(var i = 0, l = dsIntNames.length; i < l; ++i){
			ajax.addQuery({
				"query": "get_data_statistics",
				"ds": dsIntNames[i],
				"statistics_tree": [{
					"filter_name": presetCols,
					"filter_tree": []
				}],
                "lat_s": -85,
                "lat_n": 85,
                "long_w": -180,
                "long_e": 180
			}, function(data){
				if(data && data.stats && data.stats.length){
					var ds = data.ds;
					var values = {};
					for(var ii = 0, l = data.stats.length; ii < l; ++ii){
						if(data.stats[ii].filter_result){
							var filterResult = data.stats[ii].filter_result;
							for(var iii in filterResult){
								if(!filterResult.hasOwnProperty(iii)){
									continue;
								}
								values[iii] = true;
							}
						}
					}
					self.setSheetInfo(self.presetSpreadsheets, ds, 
						[{
				         "field": presetCols,
				         "field_ext_name": presetColsExtName,
				         "values": values
						}], presetRows, presetColsExtName, presetRowPath, omitZeroRows, omitZeroColumns
					);
				}
				++qCount;
				if(qCount == dsIntNames.length){
					callback && callback();
				}
			});
		}

		return ajax.execute();
	}
	callback && callback();
};

//MFilterableReports
function MFilterableReports(branch, parent) {
	this.init(branch, parent);
	this.children = {};
	this.parent = parent || null;
	this.ext_name = branch.ext_name || branch.int_name;
	this.int_name = branch.int_name;
	this.dtype = branch.dtype;
	this.values = branch.values || {};
	this.manager = this.getControl().getManager();
	this.ui = {};
	
	this.currentType;
	this.currentSortBy;
	this.currentSortOrder;
	this.defaultType;
	this.childrenShowing = true;
	
	this.reportControls = {};
};

MFilterableReports.reportTypeControls = {
	"visual": MReportsVisual,
	"image": MReportsImage
}

MFilterableReports.prototype = new MFilterable;

MFilterableReports.prototype.buildUI = function(){
	this._uiFunc = this._uiFunc();
	this._enableTabTypes();
	
	if(Moonshadow.helpers.objCount(this.reportControls) == 0){
		return;
	}
	
	var ce = Moonshadow.helpers.ce;
	this.container = $(ce("div"))
		.addClass("filterable " + this.dtype)
		.attr({
			"id": "filterable_reports"
		})
		.get(0);
	
	this._buildTabsPanels();
	$(this.container)
		.append(
			$(ce("div"))
				.addClass("reports_children")
				.append(
					this.makeExpander(false, "Your Reports", true),
					this.makeClear(),
					$(ce("div"))
						.addClass("reports_column_sorter"),
					this.makeChildrenResizable()
				)
		);
	
	this.parent.childContainer.appendChild(this.container);
	this.manager.addMapObserver("reportdetailsupdated", this._refreshControls, this);
	this.openReportPanel(this.defaultType);
};

MFilterableReports.prototype._refreshControls = function(){
	this._getReports();
	this._buildChildren(this.currentType);
	this._envokeChildProcess("refreshControls");
};

MFilterableReports.prototype._envokeChildProcess = function(processName, arguments){
	if(!arguments){
		arguments = [];
	}
	if(!(arguments instanceof Array)){
		arguments = [arguments];
	}
	for(var i in this.reportControls){
		if(!this.reportControls.hasOwnProperty(i)){
			continue;
		}
		var control = this.reportControls[i];
		if(control[processName]){
			control[processName].apply(control, arguments);
		}
	}
};

MFilterableReports.getEnabledTypes = function(){
	var types = [];
	for(var i in MFilterableReports.reportTypeControls){
		if(!MFilterableReports.reportTypeControls.hasOwnProperty(i)){
			continue;
		}
		var Const = MFilterableReports.reportTypeControls[i];
		if(Const && Const.enabled()){
			types.push(Const.meta);
		}
	}
	return types;
}

MFilterableReports.typeEnabled = function(typeId){
	var Const = MFilterableReports.reportTypeControls[typeId];
	return Const && Const.enabled();
};

MFilterableReports.prototype._enableTabTypes = function(){
	var noDefault = false;
	var types = MFilterableReports.getEnabledTypes();
	for(var i = 0, l = types.length; i < l; ++i){
		var typeId = types[i].id;
		var Const = MFilterableReports.reportTypeControls[typeId];
		this.reportControls[typeId] = new Const(this);
		if(!noDefault){
			noDefault = typeId;
		}
		if(this.reportControls[typeId].defaultTab){
			this.defaultType = typeId;
		}
	}
	if(!this.defaultType && noDefault){
		this.defaultType = noDefault;
	}
};

MFilterableReports.prototype.toggle = function() {
	if(!$(this.expander).hasClass("expanded")) {
		$(this.expander)
			.addClass("expanded");
		$(this.childContainer)
			.css({"display": "block"});
		$(".manual_expander", this.container)
			.removeClass("hide");
		this.colsorter && this.colsorter.unhideColSorter();
		this.childrenShowing = true;
	} else {
		$(this.expander)
			.removeClass("expanded");
		$(".manual_expander", this.container)
			.addClass("hide");
		$(this.childContainer)
			.css({"display": "inherit"});
		this.colsorter && this.colsorter.hideColSorter();
		this.childrenShowing = false;
	}
};

MFilterableReports.prototype._buildTabsPanels = function(){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	
	var showTabs = true;
	if(Moonshadow.helpers.objCount(this.reportControls) <= 1){
		showTabs = false;
	}
	
	var typeOrder = $($.map(this.reportControls, function(item){
		return {
			"id": item.id,
			"order": item.order,
		}
	})
	.sort(function(a, b){
		return a.order - b.order;
	}))
	.map(function(key, val){
		return val.id;
	})
	
	
	if(showTabs){
		this.ui.tabs = $(ce("div"))
			.addClass("reports_tabs")
			.append(
				$(typeOrder).map(function(key, item){
					return self._buildTab(
						self.reportControls[item]
					);
				})
			);

		this.ui.panels = $(ce("div"))
			.addClass("reports_panels")
			.append(
				$(typeOrder).map(function(key, item){
					return self._buildPanel(
						self.reportControls[item]
					)
				})
			);
		
		$(this.container)
			.append(
				this.ui.tabs,
				this.ui.panels
			);
	
		return;
	}
	
	$(this.container)
		.append(
			$(typeOrder).map(function(key, item){
				return self._buildPanel(
					self.reportControls[item]
				)
			})
		);
};

MFilterableReports.prototype._buildTab = function(typeControl){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	return $(ce("div"))
		.addClass("reports_tab clickable")
		.addClass(typeControl.id)
		.append(typeControl.name)
		.on("click", function(){
			self.openReportPanel(typeControl.id);
		})
		.get(0);
};

MFilterableReports.prototype.openReportPanel = function(typeId){
	var tabElem = $(".reports_tab." + typeId, this.container);
	var typeControl = this.reportControls[typeId];
	
	if($(tabElem).hasClass("reports_tab_selected")){
		return;
	}
	
	$(".reports_tab_selected", this.container)
		.removeClass("reports_tab_selected");
	
	$(tabElem)
		.addClass("reports_tab_selected")
	
	$(".reports_panel", this.ui.panels)
		.addClass("hide");
	
	$(".reports_panel." + typeId, this.ui.panels)
		.removeClass("hide");
	
	$(".handle .label", this.container)
		.attr({
			"title": typeControl.childrenTitle
		})
		.empty()
		.append(typeControl.childrenTitle);
	
	this._removeListeners();
	this._addListeners(typeId);
	this._buildChildren(typeId);
};

MFilterableReports.prototype._buildPanel = function(typeControl){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	return $(ce("div"))
		.addClass("reports_panel hide")
		.addClass(typeControl.id)
		.append(
			$(ce("span"))
				.addClass("reports_type_description")
				.append(typeControl.description),
			typeControl.reportControl()
		)
		.get(0);
}

MFilterableReports.prototype.generateReport = function(typeId){
	var self = this;
	this.reportControls[typeId].generateReport(function(){
		$(".reports_generating", self.container)
			.addClass("clickable")
			.removeClass("reports_generating");
	});
}

MFilterableReports.prototype._deleteReport = function(report_id){
	delete this.values[report_id];
	var reportqueue = this.manager.getControl("reportqueue");
	var self = this;
	reportqueue.deleteReport(report_id, function(){
		self._refreshControls();
	});
};

MFilterableReports.prototype._downloadReport = function(report_id){
	var reportqueue = this.manager.getControl("reportqueue");
	reportqueue.downloadReport(report_id);
};

MFilterableReports.prototype._getAllReportTypes = function(){
	return $.map(this.reportControls, function(reportControl){
		return reportControl.id;
	});
};

MFilterableReports.prototype._addListeners = function(typeId){
	this.reportControls[typeId].addListeners();
};

MFilterableReports.prototype._removeListeners = function(){
	this._envokeChildProcess("removeListeners");
};

MFilterableReports.prototype._getReports = function(){
	var reportqueue = this.manager.getControl("reportqueue");
	var reportTypes = this._getAllReportTypes();
	var reports = reportqueue.getReportsByAttribute("report_layout", reportTypes, true);
	
	for(var i in reports){
		if(!reports.hasOwnProperty(i)){
			continue;
		}
		if(this.values[i]){
			if(this.values[i].hash != reports[i].hash){
				this.values[i] = $.extend(true, {}, reports[i]);
				this.values[i].updateRequired = true;
			}else{
				this.values[i].updateRequired = false;
			}
		}else{
			this.values[i] = $.extend(true, {}, reports[i]);
			this.values[i].updateRequired = true;
		}
	}
}

MFilterableReports.prototype._getReportsOfType = function(typeId){
	var reports = {};

	if(Moonshadow.helpers.objCount(this.values) == 0){
		this._getReports();
	}
	
	for(var i in this.values){
		if(!this.values.hasOwnProperty(i)){
			continue;
		}
		if(this.values[i].report_layout == typeId){
			reports[i] = this.values[i];
		}
	}
	
	return reports;
};

MFilterableReports.prototype._buildChildren = function(typeId){
	var reports = this._getReportsOfType(typeId);
	
	if(this.colsorter){
		this.currentSortBy = this.colsorter.currentSortBy;
		this.currentSortOrder = this.colsorter.sortOrder;
	}

	var self = this;
	if(this.currentType != typeId){
		$(this.childContainer)
			.removeClass(function(){
				var curCl = this.className.match(/reportchildren_[^\s]+/);
				return (curCl && curCl[0]) || "";
			})
			.addClass("reportchildren_" +  typeId)
			.empty();
		
		if(this.colsorter){
			$(this.colsorter.ui).remove();
			delete this.colsorter;
		}

		this._columnSorter(typeId);

		$(this.childContainer)
			.append(
				$.map(reports, function(report){
					return self._reportItem(report);
				})
			);
	}else{
		$.map(reports, function(report){
			if(report.updateRequired){
				var ui = self._reportItem(report);
				var target = $("#reports_" + report.report_id, self.childContainer);
				if(target.length){
					$(target).replaceWith(ui)
				}else{
					$(self.childContainer)
						.append(ui);
				}
			}
		});
		
		this.colsorter && this.colsorter.refreshSort();
	}

	this.onEmpty("." + typeId);
	this.currentType = typeId;
};

MFilterableReports.prototype._uiFunc = function(){
	var self = this;
	var ce = Moonshadow.helpers.ce;
	return {
		"controlContainer": function(title, inputElem, className){
			if($(inputElem).attr("type") == "text"){
				$(inputElem).addClass("ms_text_field_input");
				return $(ce("div"))
					.addClass("ms_text_field_container")
					.addClass(className)
					.append(
						$(ce("span"))
							.addClass("ms_text_field_small_label")
							.append(title + ":"),
						$(ce("div"))
							.addClass("ms_text_field_flex_container_outer")
							.append(
								$(ce("div"))
									.addClass("ms_text_field_flex_container_inner")
									.append(
										inputElem
									)
							)
					);
			}
			if($(inputElem).attr("type") == "checkbox"){
				var attr = {};
				$(inputElem).addClass("ms_checkbox_input");
				if($(inputElem).attr("id")){
					attr = {
						"for": $(inputElem).attr("id")
					}
				}
				return $(ce("div"))
					.addClass("ms_checkbox_container")
					.addClass(className)
					.append(
						$(ce("div"))
							.addClass("ms_checkbox_container_inner")
							.append(
								inputElem
							),
						$(ce("label"))
							.addClass("ms_checkbox_small_label")
							.attr(attr)
							.append(title)
					);
			}
			if($(inputElem).get(0) && $(inputElem).get(0).nodeName.toLowerCase() == "select"){
				$(inputElem).addClass("ms_select_input");
				return $(ce("div"))
					.addClass("ms_select_container")
					.addClass(className)
					.append(
						$(ce("span"))
							.addClass("ms_text_field_small_label")
							.append(title + ":"),
						$(ce("div"))
							.addClass("ms_text_field_flex_container_outer")
							.append(
								$(ce("div"))
									.addClass("ms_text_field_flex_container_inner")
									.append(
										inputElem
									)
							)
					);
			}
			return $(ce("div"))
				.addClass("ms_readout_container")
				.addClass(className)
				.append(
					$(ce("label"))
						.addClass("ms_readout_small_label")
						.append(title + ":"),
					inputElem
				);
		},
		"generateButton": function(typeId){
			var typeControl = self.reportControls[typeId];
			return $(ce("div"))
				.addClass("reports_generate_button clickable")
				.addClass(typeId)
				.append(typeControl.buttonTitle || "Generate")
				.on("click", function(){
					if($(this).hasClass("reports_generating")){
						return;
					}
					$(this)
						.addClass("reports_generating")
						.removeClass("clickable");
					self.generateReport(typeId);
				})
		},
		"reportStatus": function(int){
			if(int == 40){
				return $(ce("span"))
					.append("Generating...");
			}
			if(int >= 50 && int < 70){
				return $(ce("span"))
					.append("Finished");
			}
			if(int == 70){
				return $(ce("span"))
					.addClass("report_expired")
					.append("Expired");
			}
			if(int < 0){
				return $(ce("span"))
					.addClass("report_error")
					.append("Error!");
			}
			return $(ce("span"))
				.append("Starting...");
		} 
	}
};

MFilterableReports.prototype._columnSorter = function(typeId){
	
	this.currentSortBy = this.currentSortBy || "report_datecreated";
	this.currentSortOrder = this.currentSortOrder || -1;
		
	var sortCols = [{
		"sortby": "report_datecreated",
		"title": "Date Created",
		"float": "right",
		"sortdefault": this.currentSortBy == "report_datecreated"
	},{
		"sortby": "report_status",
		"title": "Status",
		"float": "right",
		"sortdefault": this.currentSortBy == "report_status"
	},{
		"sortby": "report_name",
		"title": "Report Name",
		"sortdefault": this.currentSortBy == "report_name"
	}];
	
	var stringSort = function(className){
		return function(a, b, sortorder){
			var avalue = $(className, a).text();
			var bvalue = $(className, b).text();
			var retVal = MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortorder);
			if(retVal === 0){
				return this.sortFunctions.report_name(a, b, sortorder);
			}
			return retVal;
		};
	};
	
	var sortOpts = {
		"report_name": function(a, b, sortorder){
			var avalue = $(".report_name", a).text();
			var bvalue = $(".report_name", b).text();
			return MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortorder);
		},
		"report_datecreated": stringSort(".report_datecreated"),
		"report_status": function(a, b, sortorder){
			var avalue = parseInt($("input[name='status_int']", a).val(), 10);
			var bvalue = parseInt($("input[name='status_int']", b).val(), 10);
			var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortorder);
			if(retVal === 0){
				return this.sortFunctions.report_name(a, b, sortorder);
			}
			return retVal;
		}
	};

	this.makeColumnSorter(
		sortCols,
		"sortreportsitems",
		$(".reports_column_sorter", this.container),
		this.childContainer, 
		this.currentSortOrder,
		".report_item." + typeId,
		sortOpts
	);
	
	if(!this.childrenShowing){
		this.colsorter.hideColSorter();
	}
};

MFilterableReports.prototype._reportItem = function(report){
	
	var typeId = report.report_layout;
	
	var ce = Moonshadow.helpers.ce;
	var title = (report.query_params.data && report.query_params.data.title) || (report.report_id);
	var status = report.status;
	var dsControl = this.manager.getControl("datasources");
	var dateCreated = Moonshadow.helpers.hrDate(report.date_created);
	var self = this;
	var typeControl = this.reportControls[typeId];
	var icon = typeControl.icon;
	var status = report.status;
	
	var getValue = function(id, val){
		var value;
		if(report[id] != undefined){
			value = val.format(report[id]);
		}else if(report.query_params[id] != undefined){
			value = val.format(report.query_params[id], id);
		}else if(val.path){
			var path = val.path.split(".")
			var pathTrail = report.query_params;
			for(var i = 0, l = path.length; i < l; ++i){
				pathTrail = pathTrail[path[i]];
				if(pathTrail && pathTrail[id] != undefined){
					value = val.format(pathTrail[id]);
					break;
				}
			}
		}
		return value;
	};
	
	var makeHoverPanel = function(){
		var id = "report_hoverpanel_" + report.report_id;
		var opts = typeControl.fields
		return $(ce("div"))
			.attr({
				"id": id
			})
			.addClass("reports_descr")
			.append(
				status == 70 ? $(ce("div"))
					.addClass("reports_descr_bit")
					.append(
						"This report has expired. Please regenerate."
					) : "",
				$($.map(opts, function(val){
					var value;
					if(val.id instanceof Array){
						for(var i = 0, l = val.id.length; i < l; ++i){
							value = getValue(val.id[i], val);
							if(value){
								break;
							}
						}
					}else{
						value = getValue(val.id, val);
					}
					if(!value){
						return false;
					}
					return $(ce("div"))
						.addClass("reports_descr_bit")
						.append(
							val.name, ": ",
							$(ce("span"))
								.append(value)
						)
						.get(0);
				}))
				.filter(
					function(a, b){
						return !!b
					}
				)
			);
	};
	
	var reportItem;
	reportItem = $(ce("div"))
		.addClass("report_item")
		.addClass(typeId)
		.attr({
			"id": "reports_" + report.report_id
		})
		.append(
			$(ce("div"))
				.addClass("right")
				.append(
					$(ce("div"))
						.addClass("report_datecreated left")
						.append(dateCreated),
					$(ce("div"))
						.addClass("report_status left")
						.append(
							$(ce("input"))
								.attr({
									"type": "hidden",
									"name": "status_int",
									"value": status
								}),
							this._uiFunc.reportStatus(status),
							status >= 50 || status < 0 ? $(ce("div"))
								.addClass("reports_tools reports_delete sprite-trash right clickable")
								.attr({
									"title": "Delete " + title
								})
								.on("click", function(e){
									var hoverPanel = $(reportItem).data().hoverPanel;
									if(hoverPanel){
										$(hoverPanel).remove();
									}
									self._deleteReport(report.report_id);
									$(reportItem).remove();
								}) : "",
							status >= 50 && status < 70 ? $(ce("div"))
								.addClass("reports_tools reports_download sprite-download right clickable")
								.attr({
									"title": "Download " + title
								})
								.on("click", function(){
									self._downloadReport(report.report_id);
								}) : ""
						)
				),
			$(ce("div"))
				.addClass("report_name selectable")
				.append(
					$(ce("div"))
						.addClass("report_icon")
						.addClass(icon),
					title
				)
		)
		.data({
			"hoverPanel": null
		})
		.on("mousemove", function(e){
			$(".reports_descr").remove();
			var hoverPanel = $(this).data().hoverPanel;
			if(!hoverPanel){
				hoverPanel = makeHoverPanel();
				$(this).data().hoverPanel = hoverPanel;
			}
			$(hoverPanel)
				.appendTo("body")
				.css({
					"top": $(this).offset().top + $(this).outerHeight(),
					"left": $(this).offset().left + 40,
					"z-index": 100
				});
		})
		.on("mouseout", function(){
			var hoverPanel = $(this).data().hoverPanel;
			if(hoverPanel){
				$(hoverPanel).remove();
			}
		})
		.get(0);
	
	return reportItem;
};
/**
 *
 * @class MLayerBase
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MLayerBase(options) {
	this.name = "layerBase";
	this.manager;
	this.layer;
	this.options = options || {};

	this.disabled = false;
	this.shown = false;
};

MLayerBase.prototype = {
	/**
	 *
	 * @method function
	 * @param {} manager
	 */
	init: function(manager) {
		this.manager = manager;

		var ds = this.getManager().getDatasource();
		var adapter = this.getManager().getAdapter();
		var colorByControl = this.manager.getControl('colorbycontrol');

		var colorBy = colorByControl.getColorBy(ds.int_name);
		if (!colorBy) {
			throw new Error('Error setting up tile layer');
		}

		// @LEAFLET - for some reason, show was set to false
		// 		leaflet disabled, changing back to true
		var settings = {
			"show": true,
			"density": true,
			"datasource": this.getManager().getDatasource().int_name
		};

		if(this.options.levels) {
			settings.levels = this.options.levels;
		}
		
		settings.getUrl = this.getUrl;
		this.layer = adapter.createLayer("base", settings);
		this.layer.getUrl = this.getUrl;

		var dataType = colorBy.color;
		if(dataType != undefined) {
			this.layer.changeSettings({"dataType": dataType});
		}

		if (settings.show) {
			this.show();
		}
	},
	'getDefaultLevels': function(){
		return this.layer.getSetting('defaultLevels');
	},
	/**
	 *
	 * @method getUrl
	 * @param {} tile
	 * @param {} layer
	 */
	'getUrl': function(tile, layer) {
 		// At runtime this will be pointing to the layer
		var settings = this.settings;
		return [
			settings.tilePath,
			settings.tileName,
			'?x=', tile.x,
			'&y=', tile.y,
			'&z=', tile.levelOfDetail,
			'&norm=', 0,
			'&ceil=', 0,
			'&f=', 0,
			'&color=', settings.dataType,
			'&ds=', settings.datasource,
			'&b=', settings.levels[tile.levelOfDetail],
			'&t=', settings.trans,
			'&dd=', (settings.density) ? 1 : 0,
			'&sm=', settings.smoothing
			
			/////XXX START of Roy only controls
			,
			'&con=', settings.contourness,
			'&fuz=', settings.fuzziness_threshold,
			'&mult=', settings.intensity_mult,
			'&sub=', settings.intensity_sub
			/////END of Roy only controls
		].join('');
	},
	/**
	 *
	 * @method getDensity
	 */
	getDensity: function() {
		return this.layer.getSetting('density');
	},
	/**
	 *
	 * @method showDensity
	 */
	showDensity: function() {
		this.changeSettings({'density': true});
	},
	/**
	 *
	 * @method hideDensity
	 */
	hideDensity: function() {
		this.changeSettings({'density': false});
	},
	/**
 	 *
	 * @method getTransparency
	 */
	getTransparency: function() {
		return this.layer.getSetting('trans');
	},
	/**
	 *
	 * @method setTransparency
	 * @param {} trans
	 */
	setTransparency: function(trans) {
		this.changeSettings({'trans': trans});
	},
	/**
	 *
	 * @method getLevels
	 */
	getLevels: function() {
		return this.layer.getSetting('levels');
	},
	/**
	 *
	 * @method setLevels
	 * @param {} level
	 */
	setLevels: function(level) {
		var z = this.getManager().getAdapter().getZoom();

		var levels = this.getLevels();

		for(var i = z, l = levels.length; i < l; i++) {
			levels[i] = level;
		}

		this.changeSettings({'levels': levels});
	},
	/**
	 *
	 * @method getDataType
	 */
	'getDataType': function() {
		return this.layer.getSetting('dataType');
	},
	/**
	 *
	 * @method setDataType
	 * @param {} dataType
	 */
	'setDataType': function(dataType) {
		this.changeSettings({'dataType': dataType});
	},
	/**
	 *
	 * @method getSmoothing
	 */
	'getSmoothing': function() {
		return this.layer.getSetting('smoothing');
	},
	/**
	 *
	 * @method setSmoothing
	 * @param {} dataType
	 */
	'setSmoothing': function(smoothing) {
		this.changeSettings({'smoothing': smoothing});
	},
	/**
	 *
	 * @method getDatasource
	 */
	'getDatasource': function() {
		return this.layer.getSetting('datasource');
	},
	/**
	 *
	 * @method setDataSource
	 * @param {} datasource
	 */
	'setDataSource': function(datasource) {
		this.changeSettings({'datasource': datasource});
	},
	/**
	 *
	 * @method onContentChange
	 * @param {} event
	 * @param {} data
	 */
	'onContentChange': function(event, data) {
		if(this.layer.getSetting('show')) {
			var colorByControl = this.manager.getControl('colorbycontrol');
			var activeDsId = colorByControl.getActiveDsId();
			var targetDsId = activeDsId;
			if(data){
				if(typeof data == "string"){
					targetDsId = data;
				}
				if(typeof data == "object" && data.ds){
					targetDsId = data.ds;
				}
			}
			if(targetDsId == activeDsId){
				this.reloadLayer();
			}
		}
	},
	/**
	 *
	 * @method notify
	 */
	notify: function() {},
	/**
	 *
	 * @method isShown
	 */
	isShown: function() {
		return this.layer.getSetting('show');
	},
	/**
	 * Allow a layer to be shown
	 *
	 * @method enable
	 */
	enable: function() {
		this.disabled = false;

		if (this.shown) {
			this.show();
		}
	},
	/**
	 * Prevent a layer from being show and hide layer
	 *
	 * @method disable
	 */
	disable: function() {
		this.disabled = true;

		if (this.shown) {
			this.hide(true);
		}
	},
	/**
	 *
	 * @method show
	 */
	show: function() {
		this.shown = true;

		if (this.disabled) {
			return;
		}

		this.getManager().addMapObserver(
			['filterupdated','colorbychange'], 
			this.onContentChange, this);
		this.changeSettings({'show': true});	
	},
	/**
	 *
	 * @method hide
	 */
	hide: function(disabled) {
		if (!disabled) {
			this.shown = false;
		}

		this.getManager().removeMapObserver(
			['filterupdated','colorbychange'], 
			this.onContentChange, this);
		this.changeSettings({'show': false});	
	},	
	/**
	 *
	 * @method reloadLayer
	 */
	'reloadLayer': function() {
		this.layer.reload();
	},
	/**
	 *
	 * @method changeSettings
	 * @param {} settings
	 */
	changeSettings: function(settings) {
		this.layer.changeSettings(settings);
		this.reloadLayer();
	}	
};
Moonshadow.helpers.extend(MLayerBase, MControl);

/**
 *
 * @class MLayerMask
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MLayerMask(options) {
	this.name = "layerMask";
	this.manager;
	this.layer;
	this.options = options || {};
	this.masksEnabled = false;
	this.isSelecting = false;
	this.defaults = {
		"fillColor": "FFFFFF",
		"line_width": 1,
		"line_color": "000000",
		"ftrans": 51
	};

	this.disabled = false;
	this.shown = false;
	this.mouseBound = false;
};

MLayerMask.prototype = {
	/**
	 *
	 * @method init
 	 * @param {} manager
	 */
	"init": function(manager) {
		this.manager = manager;
		var ds = manager.getDatasource();
		var adapter = manager.getAdapter();

		var settings = {
			"show": false,
			"line_width": 1,
			"z": 100,
			"tileName": "mask.php"
		};

		this.layer = adapter.createLayer("mask", settings);
		this.layer.getUrl = this.getUrl;
	},
	/**
	 *
	 * @method getMaskObjDefault
	 * @param {} mesh
	 */
	"getMaskObjDefault": function(mesh){
		return {
			"mesh": mesh,
			"fillColor": this.defaults.fillColor,
			"line_width": this.defaults.line_width,
			"line_color": this.defaults.line_color,
			"ftrans": this.defaults.ftrans,
			"enabled": true
		}
	},
	/**
	 *
	 * @method meshControl
	 */
	"meshControl": function(){
		return this.getManager().getControl("layerMesh");
	},
	/**
	 *
	 * @method getMeshName
	 * @param mesh
	 */
	"getMeshName": function(mesh){
		return this.meshControl().getMeshName(mesh);
	},
	/**
	 *
	 * @method getRasterLayer
	 */
	"getRasterLayer": function(){
		return this.getManager().getControl("rasterlayer");
	},
	/**
	 *
	 * @method getRegionLayer
	 */
	"getRegionLayer": function(){
		return this.getManager().getControl("layerRegion");
	},
	/**
	 *
	 * @method updateMask
	 * @param {} settings
	 */
	"updateMask": function(settings, bypassUpdate){
		if(settings){
			if(settings.mesh){
				var mask = this.meshControl().getMask(settings.mesh);
				if(mask){
					if(settings.ftrans != undefined)
						mask.ftrans = settings.ftrans;
					if(settings.fillColor != undefined)
						mask.fillColor = settings.fillColor;
					if(settings.line_width != undefined)
						mask.line_width = settings.line_width;
					if(settings.line_color != undefined)
						mask.line_color = settings.line_color;
					this.changeSettings(settings);
				}
			}
		}
		if(!bypassUpdate){
			this.meshControl().updateMesh();
		}
	},
	/**
	 *
	 * @method removeMaskRegion
	 * @param mesh
	 * @param int_name
	 * @param id
	 */
	"removeMaskRegion": function(mesh, int_name, id){
		this.meshControl().removeMaskRegion(mesh, int_name, id);
		this.updateMask();
	},
	/**
	 *
	 * @method removeMasks
	 */
	"removeMasks": function(){
		this.meshControl().removeMasks();
	},
	/**
	 *
	 * @method onRegionChange
	 * @param {} event
	 * @param {} region
	 */
	"onRegionChange": function(event, region) {
		if(!this.masksEnabled)
			return;
		
		if(!region.data.length) {
			return;
		}

		var settings = {
			"region": region,
			"show": true
		};

		this.changeSettings(settings);
		this.reloadLayer();
	},
	/**
	 *
	 * @method getMeshForMask
	 * @param mask; {} mask 
	 */
	"getMeshForMask": function(mask){
		if(!mask){
			return {
				"int_name": this.layer.settings.mesh,
				"width": this.layer.settings.line_width == undefined ? 0 : this.layer.settings.line_width,
				"enabled": 1,
				"color": "000000"
			};
		}
		if(typeof mask == "string"){
			return {
				"int_name": mask,
				"width": this.layer.settings.line_width == undefined ? 0 : this.layer.settings.line_width,
				"enabled": 1,
				"color": "000000"
			};
		}
		return {
			"int_name": mask.mesh,
			"width": mask.line_width,
			"enabled": 1,
			"color": "000000"
		};
	},
	/**
	 *
	 * @method getUrl
	 * @param {} tile
	 */
	"getUrl": function(tile) {
		var settings = this.settings;

		var returnString = [
			settings.tilePath,
			settings.tileName,
			"?x=", tile.x,
			"&y=", tile.y,
			"&z=", tile.levelOfDetail,
			"&ftrans=", settings.ftrans,
			"&fc=", settings.fillColor,
			"&lw=", settings.line_width == undefined ? 1 : settings.line_width,
			"&lc=", settings.line_color || "000000"
		];
		
		returnString.push("&mesh=", settings.mesh);
		
		var region = settings.region;
		if(region){
			var data = region.getData(0);
			var mask = this.adapter.getManager().getControl("layerMesh").getMask(settings.mesh);
			var idArray = [];
			if(mask){
				idArray = $(mask.regions).map(function(key, item){
					return item.id;
				})
				.toArray();
			}
			
			if(region.inBounds(tile.x, tile.y, tile.levelOfDetail)) {
				returnString.push("&tid=", data.id);
			}

			if(idArray.length){
				returnString.push("&geo=", idArray.join(","));
			}
		}

		return returnString.join("");
	},
	/**
	 * Allow a layer to be shown
	 *
	 * @method enable
	 */
	enable: function() {
		this.disabled = false;

		if (this.shown) {
			this.show(this.masks);
		}
	},
	/**
	 * Prevent a layer from being show and hide layer
	 *
	 * @method disable
	 */
	disable: function() {
		this.disabled = true;

		if (this.shown) {
			this.hide(true);
		}
	},
	/**
	 *
	 * @method show
	 */
	"show": function(masks) {
		this.shown = true;

		if (this.disabled) {
			return;
		}

		this.masksEnabled = true;
		this.changeSettings({"show": true});
		this.showRasterLayer(masks);
		this.getManager().addMapObserver(["choroplethon"], this.reMask, this);
		this.reMask();
		this.cleanUpMasks();
	},
	/**
	 *
	 * @method hide
	 */
	"hide": function(disabled) {
		if (!disabled) {
			this.shown = false;
		}

		this.getManager().getControl("layerMesh").disableMasks();
		this.masksEnabled = false;
		this.changeSettings({"show": false});
		this.unBindMouse();
		this.getManager().removeMapObserver(["choroplethon"], this.reMask, this);
		this.cleanUpMasks();
	},
	/**
	 *
	 * @method reMask
	 */
	"reMask": function(){
		this.onRegionChange(
			null, 
			this.getRasterLayer().getRegion("__remask",
				[{
					"int_name": "__remask",
					"ext_name": "Remask layer",
					"mesh": this.getSetting("mesh")
				}],
				0, 0, 0
			)
		);
	},
	/**
	 *
	 * @method cleanUpMasks
	 */
	"cleanUpMasks": function(){
		this.meshControl().cleanUpMasks();
	},
	/**
	 *
	 * @method stopSelection
	 */
	"stopSelection": function(){
		this.getManager().removeMapObserver("regionchange", this.onRegionChange, this);
		this.isSelecting = false;
		this.getRegionLayer().unFreezeControl();
		this.unBindMouse();
	},
	/**
	 *
	 * @method startSelection
	 */
	"startSelection": function(){
		this.getManager().addMapObserver("regionchange", this.onRegionChange, this);
		this.isSelecting = true;
		this.getRegionLayer().freezeControl();
		this.bindMouse();
	},
	/**
	 *
	 * @method showRasterLayer
	 * @param [] masks
	 */
	"showRasterLayer": function(masks){
		var meshes = [];
		var mesh = this.getSetting("mesh");
		if(!masks)
			masks = this.meshControl().getMasks();
		if(masks.length){
			for(var i = 0, l = masks.length; i < l; ++i){
				masks[i].enabled = false;
				if(masks[i].mesh == mesh){
					masks[i].enabled = true;
					meshes.push(this.getMeshForMask(masks[i]));
				}
			}
			if(!meshes.length){
				meshes.push(this.getMeshForMask(mesh));
			}
		}else{
			meshes.push(this.getMeshForMask(mesh));
		}
		this.getRasterLayer().show(meshes, "masks");
	},
	/**
	 *
	 * @method bindMouse
	 */
	"bindMouse": function(){
		if(this.mouseBound)
			return;

		var manager = this.getManager();
		var adapter = manager.getAdapter();
		if(!this.onMouseMoveHandler){
			this.onMouseMoveHandler = adapter.addMapListener("mousemove", this, this.onMouseMove);
		}
		
		if(!this.onMouseOutHandler){
			this.onMouseOutHandler = adapter.addMapListener("mouseout", this, this.reMask);
		}
		
		if(!this.onMouseUpHandler) {
	 		this.onMouseUpHandler = adapter.addMapListener("mouseup", this, this.onMouseUp);
		}
		this.mouseBound = true;
	},
	/**
	 *
	 * @method unBindMouse
	 */
	"unBindMouse": function(){
		if(!this.mouseBound)
			return;
		
		var manager = this.getManager();
		var adapter = manager.getAdapter();
		
		if(this.onMouseUpHandler) {
			adapter.removeMapListener(this.onMouseUpHandler);
			this.onMouseUpHandler = null;
		}
		
		if(this.onMouseOutHandler){
			adapter.removeMapListener(this.onMouseOutHandler);
			this.onMouseOutHandler = null;
		}
		
		if(this.onMouseMoveHandler){
			adapter.removeMapListener(this.onMouseMoveHandler);
			this.onMouseMoveHandler = null;
		}
		
		this.mouseBound = false;
	},
	/**
	 *
	 * @method onMouseUp
	 * @param {} event
	 * @param {} data
	 */
	"onMouseUp": function(event, data) {
		if(this.getRasterLayer().dragging) {
			return;
		}
		
		this.onMouseMove(event, data);
		var settings = this.layer.settings;
		this.addMaskRegion(settings);
	},
	/**
	 *
	 * @method addMaskRegion
	 * @param {} settings 
	 */
	"addMaskRegion": function(settings) {
		var regionInfo;
		if(settings && settings.region){
			if(settings.region.data && settings.region.data.length){
				var dataItem = settings.region.data[0];
				if(dataItem && dataItem.id){
					var meshLayer = this.getManager().getControl("layerMesh");
					regionInfo = meshLayer.addMaskRegion(
						dataItem.mesh, 
						settings.line_width,
						settings.fillColor, 
						settings.line_color,
						settings.ftrans, 
						settings.show_names,
						dataItem.ext_name, 
						dataItem.int_name, 
						dataItem.id
					);
					
					if(regionInfo){
						regionInfo.region = settings.region;
						this.getManager().mapObservers.notify("regionselected");
					}
				}
			}
		}
	},
	/**
	 *
	 * @method onMouseMove
	 * @param event 
	 * @param {} data
	 */
	"onMouseMove": function(event, data) {
		if(this.getRasterLayer().mouseDown) {
			return;
		}

		var adapter = this.getManager().getAdapter()
		var location = adapter.getLocationFromEvent(data);
		var zoom = adapter.getZoom();

		// Check if we are in midzoom
		if(parseFloat(zoom) != parseInt(zoom, 10)) {
			return;
		}

		var meshControl = this.getManager().getControl("layerMesh");
		var mesh = meshControl.getMesh(this.getSetting("mesh"));
		if(!mesh){
			mesh = this.getMeshForMask(this.getSetting("mesh"));
		}

		this.getRasterLayer().updateTile(location.latitude, location.longitude, zoom, "masks", [mesh]);
	},
	/**
	 *
	 * @method addMask
	 * @param mesh
	 * @param line_width
	 * @param fillColor
	 * @param ftrans
	 * @param show_names
	 */
	"addMask": function(mesh, line_width, fillColor, line_color, ftrans, show_names){
		this.meshControl().addMask(mesh, line_width, fillColor, line_color, ftrans, show_names);
	},
	/**
	 *
	 * @method reloadLayer
	 */
	"reloadLayer": function() {
		this.layer.reload();
	},
	/**
	 *
	 * @method changeSettings
	 * @param {} settings
	 */
	"changeSettings": function(settings) {
		this.layer.changeSettings(settings);
	},
	/**
	 *
	 * @method getSetting
	 * @param name
	 */
	"getSetting": function(name){
		return this.layer.getSetting(name);
	}
};

Moonshadow.helpers.extend(MLayerMask, MControl);

/**
 *
 * @method MLayerMesh
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MLayerMesh(options) {
	this.name = 'layerMesh';
	this.manager;
	this.layer;
	this.options = options || {};

	this.meshList = [];

	this.meshes = [];
	this.choropleths = [];
	this.masks = [];

	this.disabled = false;
	this.shown = false;
};

MLayerMesh.prototype = {
	/**
	 *
	 * @method init
	 * @param {} manager
	 */
	'init': function(manager) {
		this.manager = manager;

		this.meshList = manager.getOption('available_meshes', []);
		
		var ds = manager.getDatasource();
		var adapter = manager.getAdapter();
		var self = this;

		this.restoreSettings();

		var settings = {
			'show': false,
			'z': 75,
			'tileName': 'mesh.php'
		};
		
		this.layer = adapter.createLayer('mesh', settings);
		this.layer.getUrl = this.getUrl;
		
		if(this.choropleths.length || this.meshes.length || this.masks.length) {
			this.updateMesh();
		}
	},
	/**
	 *
	 * @method restoreSettings
	 */
	'restoreSettings': function() {
		var manager = this.getManager();
		var defaults = manager.getOption('default_meshes', {});
		var userMeshes = manager.getOption('user_meshes', null);
		
		if (!userMeshes) {
			userMeshes = defaults;
		}

		if(userMeshes.choropleths) {
			this.choropleths = userMeshes.choropleths;
		}

		if(userMeshes.meshes) {
			this.meshes = userMeshes.meshes;
		}
		
		if(userMeshes.masks) {
			this.masks = userMeshes.masks;
		}

		// Need to make sure invalid choros didn't sneak in
		var supported = [];
		for(var i = 0, l = this.choropleths.length; i < l; i++) {
			var choro = this.choropleths[i];
			if(this.isChoroplethSupported(choro.ds, choro.int_name)) {
				supported.push(choro);
			}
		}

		for (var i = 0, l = supported.length; i < l; i++) {
			var choro = supported[i];
			this.bindColorChangeListener(choro.ds, choro.path);
		}

		this.choropleths = supported;
	},
	/**
	 *
	 * @method getUrl
	 * @param {} tile
	 * @param {} layer
	 */
	'getUrl': function(tile, layer) {
		var settings = this.settings;
		var params = [
			settings.tilePath,
			settings.tileName,
			'?x=', tile.x,
			'&y=', tile.y,
			'&z=', tile.levelOfDetail
		];

		if(settings.filltrans) {
			params.push('&tf=', settings.filltrans);
		}

		if(settings.linetrans) {
			params.push('&tl=', settings.linetrans);
		}

		if(settings.names === 'none') {
			params.push('&names=', 0);
		}

		return params.join('');
	},
	/**
	 *
	 * @method getFillTransparency
	 * @param {} ds
	 * @param {} colorby
	 */
	'getFillTransparency': function(ds, colorby) {
		var choro = this.getChoropleth(ds, colorby);

		if(!choro) {
			return;
		}

		return choro.fill_transparency || 150;
	},
	/**
	 *
	 * @method setFillTransparency
	 * @param {} ds
	 * @param {} colorby
	 * @param {} trans
	 */
	'setFillTransparency': function(ds, colorby, trans) {
		var choro = this.getChoropleth(ds, colorby);

		if(choro && choro.fill_transparency !== trans) {
			choro.fill_transparency = parseInt(trans, 10);
			return this.updateChoropleth(ds, colorby, choro);
		}
	},
	/**
	 *
	 * @method getLineTransparency
	 * @param {} ds
	 * @param {} colorby
	 */
	'getLineTransparency': function(ds, colorby) {
		var choro = this.getChoropleth(ds, colorby);

		if(!choro) {
			return;
		}

		return choro.line_transparency || 0;
	},
	/**
	 *
	 * @method setLineTransparency
	 * @param {} ds
	 * @param {} colorby
	 * @param {} trans
	 */
	'setLineTransparency': function(ds, colorby, trans) {
		var choro = this.getChoropleth(ds, colorby);

		if(choro && choro.line_transparency !== trans) {
			choro.line_transparency = parseInt(trans, 10);
			return this.updateChoropleth(ds, colorby, choro);
		}

		return this.layer.getSetting('linetrans');
	},
 	/**
	 *
	 * @method setColors
	 * @param {} ds
	 * @param {} colorby
	 * @param {} colors
	 */
	'setColors': function(ds, colorby, colors) {
		var choro = this.getChoropleth(ds, colorby);		

		if(!choro) {
			return;
		}

		choro.colors = colors || {};
		return this.updateChoropleth(ds, colorby, choro);
	},
	/**
	 *
	 * @method getColors 
	 * @param {} ds
	 * @param {} colorby
	 */
	'getColors': function(ds, colorby) {
		var choro = this.getChoropleth(ds, colorby);

		if(!choro) {
			return;
		}

		return choro.colors || {};
	},
	/**
 	 *
	 * @method getRegionNames
	 * @param {} ds
 	 * @param {} colorby
	 */
	'getRegionNames': function(ds, colorby) {
		var choro = this.getChoropleth(ds, colorby);

		if(!choro) {
			return;
		}

		return choro.names || 'all';
	},	
	/**
	 *
	 * @method setRegionNames
	 * @param {} ds
	 * @param {} colorby
	 * @param {} onOff
	 */
	'setRegionNames': function(ds, colorby, onOff) {
		var choro = this.getChoropleth(ds, colorby);

		if(choro && choro.names !== onOff) {
			choro.names = onOff;
			return this.updateChoropleth(ds, colorby, choro);
		}
	},
	/**
	 *  
	 * @method getMesh
	 * @param {} int_name
	 */
	'getMesh': function(int_name) {
		var found;
		$.each(this.meshes, function(k, v) {
			if(v.int_name === int_name) {
				found = v;
				return false;
			}
		});

		return found;
	},
	/**
	 *
	 * @method getActiveMeshByDSFilter
	 * @param {} dsId
	 * @param {} filterId
	 */
	'getActiveMeshByDSFilter': function(dsId, filterId) {
		var areaId = this.getSupportedArea(dsId, filterId);
		if(areaId) {
			return this.getMesh(areaId);	
		}

		return undefined
	},
	/**
	 *
	 * @method addMesh
	 * @param {} int_name
	 * @param {} width
	 * @param {} color
	 * @param {} ftrans
	 */
	'addMesh': function(int_name, width, color, ftrans) {
		var mesh = this.getMesh(int_name);
		if(mesh) {
			return this.changeMesh(int_name, width, color);
		}

		var mesh = {
			'int_name': int_name,
			'width': width,
			'enabled': 1
		};

		if(ftrans) {
			mesh.fill_transparency = ftrans;
		}

		if(color) {
			mesh.color = color;
		}

		this.meshes.push(mesh);
		this.updateMesh();
		return mesh;
	},
	/**
	 *
	 * @method changeMesh
	 * @param {} int_name
	 * @param {} width
	 * @param {} color
	 */
	'changeMesh': function(int_name, width, color) {
		for(var i = 0, l = this.meshes.length; i < l; i++) {
			var mesh = this.meshes[i];
			if(mesh.int_name === int_name) {
				this.meshes[i].width =  width;

				if(color) {
					this.meshes[i].color = color;
				}

				this.updateMesh();
				break;
			}
		}

		return this.meshes[i];
	},
	/**
	 *
	 * @method removeMesh
	 * @param {} int_name
	 */
	'removeMesh': function(int_name) {
		this.meshes = $.grep(this.meshes, function(mesh) {
			return mesh.int_name !== int_name;
		});

		this.updateMesh();
	},
	/**
	 *
	 * @method addChoropleth
	 * @param {} ds
	 * @param {} colorby
	 * @param {} path
	 * @param {} mesh
	 * @param {} colors
	 * @param {} color
	 * @param {} width
	 * @param {} ltrans
	 * @param {} ftrans
 	 * @param {} names
	 */
	'addChoropleth': function(ds, colorby, path, mesh, colors, color, width, 
							  ltrans, ftrans, names) {
		var choro = {
			'ds': ds,
			'color_by': colorby,
			'path': path,
			'int_name': mesh,
			'width': (width !== undefined) ? width : 1,
			'colors': colors,
			'color': color || '333333',
			'line_transparency': (ltrans !== undefined) ? ltrans : 0,
			'fill_transparency': (ftrans !== undefined) ? ftrans : 90,
			'names': names || 'all'
		};

		this.choropleths = [choro];

		this.bindColorChangeListener(choro.ds, choro.path);

		this.updateMesh();
		this.getManager().addMapObserver('filterupdated', this.onFilterUpdated, this);

		return choro;
	},
	/**
	 *
	 * @method addMaskRegion
	 * @param {} mesh
	 * @param {} line_width
	 * @param {} fillColor
	 * @param {} line_color
	 * @param {} ftrans
	 * @param {} show_names
	 * @param {} ext_name
	 * @param {} int_name
	 * @param {} id
	 * @return {} regionInfo
	 */
	'addMaskRegion': function(mesh, line_width, fillColor, line_color, ftrans, 
							  show_names, ext_name, int_name, id, region) {
		var mask = this.getMask(mesh);
		if (!mask) {
			 return this.addMask(mesh, line_width, fillColor, line_color, ftrans, show_names,
						  ext_name, int_name, id, region);
		} else {
			var exists = false;
			for (var i = 0, l = mask.regions.length; i < l; ++i) {
				if (mask.regions[i].id == id) {
					exists = true;
					break;
				}
			}

			if (!exists) {
				return this.addMask(mesh, line_width, fillColor, line_color, ftrans, show_names,
							 ext_name, int_name, id, region);
			}
		}
	},
	/**
	 *
	 * @method addMask
	 * @param {} mesh
	 * @param {} line_width
	 * @param {} fillColor
	 * @param {} line_color
	 * @param {} ftrans
	 * @param {} show_names
	 * @param {} ext_name
	 * @param {} int_name
	 * @param {} id
	 * @return {} regionInfo
	 */
	'addMask': function(mesh, line_width, fillColor, line_color, ftrans,
						show_names, ext_name, int_name, id) {
		this.disableMasks();
		var mask = this.getMask(mesh);
		if(!mask){
			mask = {
				'mesh': mesh,
				'line_width': line_width,
				'fillColor': fillColor || 'FFFFFF',
				'line_color': line_color || '000000',
				'ftrans': (ftrans !== undefined) ? ftrans : 0,
				'show_names': show_names || 'all',
				'enabled': true,
				'regions': []
			};
			this.masks.push(mask);
		}
		if(ext_name && int_name && id){
			var regionInfo = {
				'ext_name': ext_name,
				'int_name': int_name,
				'id': id,
			};
			mask.regions.push(regionInfo);
			return regionInfo;
		}
	},
	/**
	 *
	 * @method disableMasks
	 */
	'disableMasks': function() {
		for (var i = 0, l = this.masks.length; i < l; ++i) {
			this.masks[i].enabled = false;
		}
	},
	/**
	 *
	 * @method removeMaskRegion
	 * @param {} mesh
	 * @param {} int_name
	 * @param {} id
	 */
	'removeMaskRegion': function(mesh, int_name, id) {
		var mask = this.getMask(mesh);
		if (mask) {
			for (var i = 0, l = mask.regions.length; i < l; ++i) {
				if (mask.regions[i].id == id) {
					mask.regions.splice(i, 1);
					break;
				}
			}
			if (!mask.regions.length) {
				this.deleteMask(mesh);
			}
		}
	},
	/**
	 *
	 * @method getMasks
	 */
	'getMasks': function() {
		return this.masks;
	},
	/**
	 *
	 * @method getMask
	 * @param {} mesh
	 */
	'getMask': function(mesh) {
		for (var i = 0, l = this.masks.length; i < l; ++i) {
			if (this.masks[i].mesh == mesh) {
				return this.masks[i];
			}
		}
	},
	/**
	 *
	 * @method cleanUpMasks
	 * @param {} mesh
	 */
	'cleanUpMasks': function(){
		var masks = this.masks.slice();
		for(var i = 0, l = masks.length; i < l; ++i){
			if(!masks[i].regions.length && !masks[i].enabled){
				this.deleteMask(masks[i].mesh);
			}
		}
	},
	/**
	 *
	 * @method deleteMask
	 * @param {} mesh
	 */
	'deleteMask': function(mesh){
		for(var i = 0, l = this.masks.length; i < l; ++i){
			if(this.masks[i].mesh == mesh){
				return this.masks.splice(i, 1);
			}
		}
	},
	/**
	 *
	 * @method removeMasks
	 */
	'removeMasks': function() {
		this.masks = [];
		this.updateMesh();
	},
	/**
	 *
	 * @method getChoropleth
	 * @param {} ds
	 * @param {} colorby
	 */
	'getChoropleth': function(ds, colorby) {
		for(var i = 0, l = this.choropleths.length; i < l; i++) {
			var choro = this.choropleths[i];
			if(choro.ds === ds && choro.color_by === colorby) {
				return choro;			
			}
		}
	},
	/**	
	 *
	 * @method updateChoropleth
	 * @param {} ds
	 * @param {} colorby
	 * @param {} newChoro
	 */
	'updateChoropleth': function(ds, colorby, newChoro) {
		for(var i = 0, l = this.choropleths.length; i < l; i++) {
			var choro = this.choropleths[i];
			if(choro.ds === ds && choro.color_by === colorby) {
				// @TODO - I don't this event should be fired here. MLayerRegion needs to know
				// about changes that would affect the data being shown.
				this.getManager().mapObservers.notify('chorosettingschange', newChoro);
				return this.choropleths[i] = newChoro;
			}
		}
	}, 
	/**
	 *
	 * @method removeChoropleth
	 * @param {} ds
	 * @param {} colorby
	 * @param {} mesh
	 */
	'removeChoropleth': function(ds, colorby, mesh) {
		var choropleth = null;
		for (var i = 0, l = this.choropleths.length; i < l; i++) {
			var choro = this.choropleths[i];
			if (choro.ds === ds && choro.color_by === colorby &&
				choro.int_name === mesh) {
				this.choropleths.splice(i, 1);
				choropleth = choro;
				break;
			}
		}

		this.updateMesh();

		this.unbindColorChangeListener(choropleth.ds, choropleth.path);

		if (!this.choropleths.length) {
			this.manager.removeMapObserver('filterupdated', this.onFilterUpdated, this);
		}
	},
	/**
	 *
	 * @method setChoroplethMesh
	 * @param {} ds
	 * @param {} colorby
	 * @param {} mesh
	 */
	'setChoroplethMesh': function(ds, colorby, mesh) {
		var choro = this.getChoropleth(ds, colorby);
		
		if(choro) {
			choro.int_name = mesh;
			return this.updateChoropleth(ds, colorby, choro);
		}
	},
	/**
	 *
	 * @method setChoroplethLineWidth
	 * @param {} ds
	 * @param {} colorby
	 * @param {} width
	 */
	'setChoroplethLineWidth': function(ds, colorby, width) {
		var choro = this.getChoropleth(ds, colorby);

		if(choro && choro.width !== width) {
			choro.width = parseInt(width, 10);
			return this.updateChoropleth(ds, colorby, choro);
		}
	},
	/**
	 *
	 * @method getChoroplethLineWidth
	 * @param {} ds
	 * @param {} colorby
	 */
	'getChoroplethLineWidth': function(ds, colorby) {
		var choro = this.getChoropleth(ds, colorby);

		if(!choro) {
			return;
		}

		return (choro.width !== undefined) ? choro.width : 1;
	},
	/**
	 *
	 * @method setChoroplethLineColor
	 * @param {} ds
	 * @param {} colorby
	 * @param {} color
	 */
	'setChoroplethLineColor': function(ds, colorby, color) {
		var choro = this.getChoropleth(ds, colorby);

		if(choro && choro.color !== color) {
			choro.color = color;
			return this.updateChoropleth(ds, colorby, choro);
		}		
	},
	/**
	 *
	 * @method getChoroplethLineColor
	 * @param {} ds
	 * @param {} colorby
	 */
	'getChoroplethLineColor': function(ds, colorby) {
		var choro = this.getChoropleth(ds, colorby);

		if(!choro) {
			return;
		}

		return choro.color || '000000';
	},
	/**
	 *
	 * @method getActiveChoropleth
	 * @param {} ds
	 * @param {} colorby
	 */
	'getActiveChoropleth': function(ds, colorby) {
		return this.getChoropleth(ds, colorby);
	},
	/**
	 * 
	 * @method getActiveChoropleths
	 */
	'getActiveChoropleths': function() {
		return this.choropleths;
	},
	/**
	 *
	 * @method getActiveMeshes
	 */
	'getActiveMask': function(){
		var mesh = this.getManager().getControl("layerMask").getSetting("mesh");
		for(var i = 0, l = this.masks.length; i < l; ++i){
			if(this.masks[i].mesh == mesh && this.masks[i].enabled)
				return this.masks[i];
		}
	},
	/**
	 *
	 * @method getActiveMeshes
	 */
	'getActiveMeshes': function(){
		return this.meshes;
	},
	/**
	 *
	 * @method getActiveChoroplethsByDatasource
	 * @param {} ds
	 */
	'getActiveChoroplethsByDatasource': function(ds) {
		var matching = [];
		for(var i = 0, l = this.choropleths.length; i < l; i++) {
			var choro = this.choropleths[i];
			if(choro.ds === ds) {
				matching.push(choro);
			}
		}

		return matching;
	},
	/**
	 * 
	 * @method {} getMeshName
	 * @param {} mesh
	 */
	'getMeshName': function(mesh){
		for(var i = 0, l = this.meshList.length; i < l; i++) {
			if(this.meshList[i].int_name == mesh) {
				return this.meshList[i].ext_name;
			}
		}
	},
	/**
	 * 
	 * @method {} getSuportedChoropleths
	 * @param {} ds
	 */
	'getSupportedChoropleths': function(ds) {
		var supported = [];

		for(var i = 0, l = this.meshList.length; i < l; i++) {
			var mesh = this.meshList[i];
			if(mesh.choropleth_datasources[ds]) {
				supported.push(mesh);
			}
		}

		return supported;		
	},
	/**
	 *
	 * @method getSupportedArea
	 * @param {} dsId
	 * @param {} filterId
	 */
	'getSupportedArea': function(dsId, filterId) {
		var manager = this.getManager();
		var dsDef = manager.getDatasource(dsId);
		var displayMeshes = manager.getOption('display_meshes');

		if(dsDef && dsDef.common_names && displayMeshes) {
			var found;
			for(var i in dsDef.common_names) {
				if(dsDef.common_names[i] ===  filterId) {
					found = i;
					break;
				}
			}

			if(found) {
				for(var i = 0, l = displayMeshes.length; i < l; i++) {
					if(displayMeshes[i].common_name === found && displayMeshes[i].int_name) {
						return displayMeshes[i].int_name;
					}
				}
			}
		}

		return undefined;
	},
	/**
	 *
	 * @method isChoroplethSupported
	 * @param {} ds
	 * @param {} mesh
	 */
	'isChoroplethSupported': function(ds, mesh) {
		var supported = this.getSupportedChoropleths(ds);
		for(var i = 0, l = supported.length; i < l; i++) {
			if(supported[i].int_name === mesh) {
				return true;
			}
		}
	},
	/**
	 *
	 * @method hasChoropleths
	 * @param {} ds
	 */
	'hasChoropleths': function(ds) {
		return !!this.getSupportedChoropleths(ds).length;
	},
	/**
	 *
	 * @method hasActiveChoropleths
	 */
	'hasActiveChoropleths': function() {
		// @TODO this needs to check if layer is on. Needs async control loading
		return !!this.choropleths.length;
	},
	/**
	 *
	 * @method updateMesh
	 */
	'updateMesh': function() {
		var activeMeshes = [];
		var layerOn = false;
		var caller = this;

		var settings = {
			'meshes': [],
			'choropleths': [],
			'masks': []
		};
		
		if(this.choropleths.length) {
			settings.choropleths = this.choropleths.slice();
		}

		if(this.meshes.length) {
			settings.meshes = this.meshes.slice();
		}
		
		if(this.masks.length) {
			settings.masks = this.masks.slice();
		}

		var obj = {
			'query': 'save_stored_state',
			'name': 'mesh_settings',
			'value': settings,
			'ds': '__app'
		};

		var ajax = new Moonshadow.Ajax();
		ajax.addQuery(obj, function(data) {
			if(data.result === 'ok') {
				caller.show();
				caller.reloadLayers();
			}
			caller.notifyMeshChange(settings);
		}, this).execute();
	},
	/**
	 *
	 * @method notify
 	 */
	'notify': function() {},
	/**
	 * Allow a layer to be shown
	 *
	 * @method enable
	 */
	enable: function() {
		this.disabled = false;

		if (this.shown) {
			this.show();
		}
	},
	/**
	 * Prevent a layer from being show and hide layer
	 *
	 * @method disable
	 */
	disable: function() {
		this.disabled = true;

		if (this.shown) {
			this.hide(true);
		}
	},
	/**
	 *
	 * @method show
	 */
	'show': function() {
		this.shown = true;

		if (this.disabled) {
			return;
		}

		if(this.choropleths.length) {
			var manager = this.getManager();
			manager.addMapObserver('filterupdated', this.onFilterUpdated, this);
		}

		this.changeSettings({'show': true});
	},	
	/**
	 *
	 * @method hide
	 */
	'hide': function(disabled) {
		if (!disabled) {
			this.shown = false;
		}

		this.changeSettings({'show': false});	
	},
	/**
	 * Bind listeners for color changes
	 *
  	 * @method bindColorChangeListener
	 */
	bindColorChangeListener: function(dsId, dataPath) {
		var colorsControl = this.manager.getControl('colors');
		colorsControl.addListener(dsId, dataPath.join('|'), null,
								  this.onColorChange, this);
	},
	/**
	 * Unbind listeners for color changes
	 *
  	 * @method unbindColorChangeListener
	 */
	unbindColorChangeListener: function(dsId, dataPath) {
		var colorsControl = this.manager.getControl('colors');
		colorsControl.removeListener(dsId, dataPath.join('|'), null,
									 this.onColorChange, this);
	},
	/**	 
 	 *
	 * @methods onFilterUpdated
	 * @param {} event
	 * @param {} data
	 */
	'onFilterUpdated': function(event, data) {
		if (this.getActiveChoroplethsByDatasource(data.ds).length) {
			this.reloadLayer();
		}
	},
 	/**
	 *
	 * @method onColorChange
	 * @param {} event
	 * @param {} data
	 */ 
	'onColorChange': function(id, event) {
		var parts = id.split(':');
		var dsId = parts[0];
		var dataPath = parts[1].split('|');

		var colorsControl = this.manager.getControl('colors');
		var colors = colorsControl.getColorsForField(dsId, dataPath.join('|'));

		for (var color in colors) {
			colors[color] = {'value': colors[color]};
		}

		this.setColors(dsId, dataPath.slice().pop(), colors);
		this.updateMesh();
	},
	/**
	 *
	 * @method notifyMeshChange
	 * @param {} settings
	 */
	'notifyMeshChange': function(settings) {
		this.getManager().mapObservers.notify('meshchange', settings);
	},
	/**
	 *
	 * @method reloadLayer
	 */
	'reloadLayer': function() {
		this.layer.reload();
	},
	/**
	 *
	 * @method reloadLayers
	 */
	'reloadLayers': function() {
		this.reloadLayer();

		var maskControl = this.getManager().getControl("layerMask");
		if (maskControl.masksEnabled) {
			maskControl.reMask();
		}
	},
	/**
	 *
	 * @method changeSettings
	 * @param {} settings
	 */
	'changeSettings': function(settings) {
		this.layer.changeSettings(settings);
	}
};
Moonshadow.helpers.extend(MLayerMesh, MControl);

/**
 *
 * @class MLayerRegion
 * @extends MControl
 * @constructor
 * @param {} options
 */
function MLayerRegion(options) {
	this.name = 'layerRegion';
	this.manager;
	this.layer;
	this.options = options || {};
	this.lineAddition = 2;
	this.frozen = false;

	this.region = null;
	this.disabled = false;
	this.shown = false;
	this.choropleths = null;
};

MLayerRegion.prototype = {
	/**
	 *
	 * @method init
 	 * @param {} manager
	 */
	'init': function(manager) {
		this.manager = manager;
		var ds = manager.getDatasource();
		var adapter = manager.getAdapter();

		// Need to determin the largest choropleth line size
		var meshLayer = manager.getControl('layerMesh');
		var biggestLine = 1;
		var choropleths = meshLayer.getActiveChoropleths();
		for(var i = 0, l = choropleths.length; i < l; i++) {
			if(choropleths[i].width > biggestLine) {
				biggestLine = choropleths[i].width;
			}
		}		

		var settings = {
			'show': false,
			'line_width': biggestLine + this.lineAddition,
			'z': 50,
			'tileName': 'region.php'
		};

		this.layer = adapter.createLayer('region', settings);
		this.layer.getUrl = this.getUrl;
	},
	/**
	 *
	 * @method addObservers
	 */
	'addObservers': function(){
		var manager = this.getManager();
		manager.addMapObserver('regionchange', this.onRegionChange, this);
		manager.addMapObserver('chorosettingschange', this.onChoroSettingsChange, this);
	},
	/**
	 *
	 * @method removeObservers
	 */
	'removeObservers': function(){
		var manager = this.getManager();
		manager.removeMapObserver('regionchange', this.onRegionChange, this);
		manager.removeMapObserver('chorosettingschange', this.onChoroSettingsChange, this);
	},
	/**
	 *
	 * @method onRegionChange
	 * @param {} event
	 * @param {} region
	 */
	'onRegionChange': function(event, region) {
		if(!region.data.length) {
			this.region = null;
			this.hide();
			return;
		}

		this.region = region;

		var settings = {
			'show': true,
			'region': region,
		};

		this.changeSettings(settings);
		this.reloadLayer();
	},
	/**
	 *
	 * @method onChoroSettingsChange
	 * @param {} event
	 * @param {} choro
	 */
	'onChoroSettingsChange': function(event, choro) {
		this.layer.settings.line_width = choro.width + this.lineAddition;
		this.reloadLayer();
	},
	/**
	 *
	 * @method getUrl
	 * @param {} tile
	 */
	'getUrl': function(tile) {
		var settings = this.settings;
		var region = settings.region;

		if (!region) {
			return undefined;
		}

		var data = region.getData(0);

		if(!data) {
			return undefined;
		}
		
		if(data.int_name == "__unknown") {
			return undefined;
		}
		
		// if tile not inside region bounds
		if(!region.inBounds(tile.x, tile.y, tile.levelOfDetail)) {
			return undefined;
		}

		return [
			settings.tilePath,
			settings.tileName,
			'?x=', tile.x,
			'&y=', tile.y,
			'&z=', tile.levelOfDetail,
			'&mesh=', data.mesh,
			'&geo=', data.id,
			'&lw=', settings.line_width || 3,
			'&lc=', settings.line_color || '000000',
		].join('');
	},
	/**
	 *
	 * @method freezeControl
	 */
	'freezeControl': function(){
		if(!this.frozen){
			this.unBindMouseMove();
			this.removeObservers();
			this.getManager().getControl('rasterdisplay').onRasterOff();
			this.frozen = true;
		}
	},
	/**
	 *
	 * @method unFreezeControl
	 */
	'unFreezeControl': function(){
		if(this.frozen){
			this.bindMouseMove();
			this.addObservers();
			this.getManager().getControl('rasterdisplay').onRasterOn();
			this.frozen = false;
		}
	},
	/**
	 *
	 * @method showRasterLayer
	 * @param {} choropleths
	 */
	'showRasterLayer': function(choropleths){
		var manager = this.getManager();
		manager.getControl('rasterlayer').show(choropleths, 'choro');
	},
	/**
	 *
	 * @method bindMouseMove
	 */
	'bindMouseMove': function(){
		this.getManager().addMapObserver('mousemove', this.onMouseMove, this);
	},
	/**
	 *
	 * @method unBindMouseMove
	 */
	'unBindMouseMove': function(){
		this.getManager().removeMapObserver('mousemove', this.onMouseMove, this);
	},
	/**
	 *
	 * @method onMouseMove
	 * @param {} event 
	 * @param {} data
	 */
	'onMouseMove': function(event, data) {
		if(this.getManager().getControl('rasterlayer').mouseDown) {
			return;
		}

		var adapter = this.getManager().getAdapter()
		var location = adapter.getLocationFromEvent(data);
		var zoom = adapter.getZoom();

		// Check if we are in midzoom
		if(parseFloat(zoom) != parseInt(zoom, 10)) {
			return;
		}

		var raster = this.getManager().getControl('rasterlayer')
		raster.updateTile(location.latitude, location.longitude, zoom, 'choro');
	},
	/**
	 * Allow a layer to be shown
	 *
	 * @method enable
	 */
	enable: function() {
		this.disabled = false;

		if (this.shown) {
			this.show(this.choropleths);
		}
	},
	/**
	 * Prevent a layer from being show and hide layer
	 *
	 * @method disable
	 */
	disable: function() {
		this.disabled = true;

		if (this.shown) {
			this.hide(true);
		}
	},
	/**
	 *
	 * @method show
	 */
	show: function(choropleths) {
		this.shown = true;
		this.choropleths = choropleths;

		if (this.disabled) {
			return;
		}

		this.getManager().mapObservers.notify('choroplethon', choropleths);

		this.addObservers();
		this.bindMouseMove();
		this.showRasterLayer(choropleths);

		if (this.region) {
			this.changeSettings({'show': true});
		}
	},
	/**
	 *
	 * @method hide
	 */
	hide: function(disabled) {
		if (!disabled) {
			this.shown = false;
		}

		this.getManager().mapObservers.notify('choroplethoff');

		this.removeObservers();
		this.unBindMouseMove();

		this.changeSettings({'show': false});	
	},
	/**
	 *
	 * @method reloadLayer
	 */
	'reloadLayer': function() {
		this.layer.reload();
	},
	/**
	 *
	 * @method changeSettings
	 * @param {} settings
	 */
	'changeSettings': function(settings) {
		this.layer.changeSettings(settings);
	}
};

Moonshadow.helpers.extend(MLayerRegion, MControl);

/** 
 * Handles display of color picker
 *
 * @class MUIGradientPicker
 * @constructor
 * @param {MFilterable|MDatasource} parent
 * @param {Object} options
 */
function MUIGradientPicker(parent, options) {
	this.name = 'gradient';
	this.position = 6;
	this.manager = null;
	this.options = options || {};

	this.picker = null;
	this.icon = null;
	this.gradient = null;
	this.gradientable = null;
	this.prevColors = null;
};

MUIGradientPicker.prototype = new MControl;

/**
 * Init function for class, called as part of control loading
 * 
 * @method init
 * @param {Manager} manager Reference to manager
 */
MUIGradientPicker.prototype.init = function(manager) {
	this.manager = manager;
};

/**
 * Determine if the Gradient Picker should load
 * 
 * @method enabled
 */
MUIGradientPicker.prototype.enabled = function(){
	return MUIGradientPicker.enabled();
};
MUIGradientPicker.enabled = function(){
	var manager = Moonshadow.getManager();
	if($.inArray("gradient", manager.getOption("app_addons")) > -1){
		return true;
	}
	return false;
};

/**
 * Check if supplied object meets gradientable interface
 * 
 * @method checkGradientable
 * @param {Gradientable} obj
 */
MUIGradientPicker.prototype.checkGradientable = function(obj) {
	if (!MUIGradientPicker.isGradientable(obj)) {
		throw new Error('Supplied object is not gradientable');
	}
};

MUIGradientPicker.isGradientable = function(obj) {
	if(obj.isGradientable){
		return obj.isGradientable();
	}
	return MControl.hasMethods(obj, 
			'getGradient', 'setColorsWithGradient', 'setChildColors', 'setGradient', 'getColors');
};

/**
 * Get icon that when click will open gradient picker
 *
 * @method getOpenIcon
 * @param {Gradientable} colorable
 * @return {DOMElement} Icon element
 */
MUIGradientPicker.prototype.getOpenIcon = function(gradientable) {
	this.checkGradientable(gradientable);

	var icon = document.createElement('div');
	icon.className = 'gradient-picker icon sprite-gradient left';
	icon.title = "Apply Gradient"
	icon.gradientable = gradientable;

	if (!this.isCanvassSupported()) {
		icon.className += ' disabled';
		icon.title = 'Gradients require a modern browser';
	} else {
		icon.className += ' clickable';

		var preview = document.createElement('canvas');
		preview.className = 'preview'
		
		icon.appendChild(preview);
		
		preview.width = 13;
		preview.height = 13;

		icon.preview = preview;
		icon.preview2d = preview.getContext("2d");

		var gradient = gradientable.getGradient() || {};
		this.updateIconPreview(gradient, icon);

		var self = this;
		$(icon).click(function() {
			self.onIconClick(this.gradientable, this);
		});	
	}

	return icon;
};

/**
 * Get color picker UI
 *
 * @method getPicker
 * @private
 * @return {DOMElement} picker ui
 */
MUIGradientPicker.prototype.getPicker = function() {
	var self = this;

	var picker = document.createElement('div');
	picker.className = 'gradient-picker picker';

	// Context menu interfears with right-clicking gradient control points
	$(picker).bind('contextmenu', function(e) {
		e.preventDefault();
		return false;
	});

	var gradientGroup = document.createElement('div');
	gradientGroup.className = 'gradient-group';

	var gradient = document.createElement('div');
	gradient.className = 'gradient';

	gradientGroup.appendChild(gradient);

	picker.appendChild(gradientGroup);

	var buttonGroup = document.createElement('div');
	buttonGroup.className = 'button-group';

	var okButton = document.createElement('div');
	okButton.className = 'button ok clickable';
	okButton.appendChild(document.createTextNode('OK'));	

	$(okButton).click(function() {
		self.onConfirm();
	});

	buttonGroup.appendChild(okButton);

	var revertButton = document.createElement('div');
	revertButton.className = 'button revert clickable';
	revertButton.appendChild(document.createTextNode('Cancel'));

	$(revertButton).click(function() {
		self.onRevert();
	});

	buttonGroup.appendChild(revertButton);

	picker.appendChild(buttonGroup);

	var pointer = document.createElement('div');
	pointer.className = 'pointer';

	picker.appendChild(pointer);

	return picker;
};

/**
 * Icon click event handler
 * 
 * @method onIconClick
 * @param {Colorable} colorable
 * @param {DOMElement} icon that was clicked 
 */
MUIGradientPicker.prototype.onIconClick = function(gradientable, icon) {
	this.checkGradientable(gradientable);

	if (this.isPickerShown() && this.gradientable === gradientable) {
		this.onRevert();
 	} else {
		if (this.gradientable && this.gradientable !== gradientable) {
			this.onRevert();
		}

		this.showPicker(gradientable, icon);
	}
};

/**
 * Event handler for gradient changes
 *
 * @method onGradientChange
 * @private
 */
MUIGradientPicker.prototype.onGradientChange = function(gradient) {
	if(this.gradientable) {
		this.gradientable.setColorsWithGradient(gradient.points, gradient.model);
		this.updateIconPreview(gradient, this.icon);
	}
};

/**
 * On revert event handler
 *
 * @method onRevert
 */
MUIGradientPicker.prototype.onRevert = function() {
	this.gradientable.setChildColors(this.prevColors);
	this.updateIconPreview(this.prevGradient, this.icon);
	this.hidePicker();
};

/**
 * On confirm event handler
 *
 * @method onConfirm
 * @private
 */
MUIGradientPicker.prototype.onConfirm = function() {
	this.gradientable.setGradient(this.gradient, true);
	this.updateIconPreview(this.gradient, this.icon);
	this.hidePicker();
};

/**
 * Update icon gradient preview
 *
 * @method updateIconPreview
 * @private
 * @param {Array} gradient
 * @param {DOMElement} icon 
 */
MUIGradientPicker.prototype.updateIconPreview = function(gradient, icon) {
	var rows = icon.preview2d.canvas.width;
	var pixles = icon.preview2d.canvas.height;

	var points = gradient.points || [];
	if (!points.length) {
		points = [
			{'color': '#0000ff', 'position': 0},
			{'color': '#00ff00', 'position': 0.5},
			{'color': '#ff0000', 'position': 1}
		];
	}

	var colorsControl = this.manager.getControl('colors');
	var colors = colorsControl.getGradientColors(points, 'hsl', rows);

	for (r = 0; r < rows; r++) {
		color = colors[r];
		icon.preview2d.fillStyle = tinycolor(color).toHexString();
		icon.preview2d.fillRect(r, 0, 1, pixles);
	}
};

/**
 * Check if <canvas> is supported
 *
 * @method isCanvassSupported
 * @private
 * @return {Boolean}
 */
MUIGradientPicker.prototype.isCanvassSupported = function() {
	var elem = document.createElement('canvas');
	return !!(elem.getContext && elem.getContext('2d'));
};

/**
 * Determin if picker is shown
 *
 * @method isPickerShown
 * @return {Boolean} true if show, false if not
 */
MUIGradientPicker.prototype.isPickerShown = function() {
	return !!this.picker;
};

MUIGradientPicker.prototype._timeout;

/**
 * Show gradient picker UI
 *
 * @method showPicker
 * @param {Colorable} colorable
 * @param {DOMElement} icon that was clicked
 */
MUIGradientPicker.prototype.showPicker = function(gradientable, icon) {
	this.checkGradientable(gradientable);

	this.gradientable = gradientable;
	this.icon = icon;
	this.picker = this.getPicker();
	this.prevColors = this.gradientable.getColors();
	this.prevGradient = this.gradientable.getGradient() || {};
	
	var gradient = this.gradientable.getGradient() || {};

	$('body').append(this.picker);

	this.updatePosition();

	var self = this;
	$('.gradient', this.picker).gradientPicker({
		change: function(gradient, colorModel) {
			clearTimeout(self._timeout);
			this._timeout = setTimeout(function () {
				self.gradient = {
					'model': colorModel,
					'points': gradient,
				};
				self.onGradientChange(self.gradient);
			}, 500);
		},
		colorPickerShow: function(picker) {},
		colorPickerHide: function(picker) {},
		representation: gradient.model || 'hsl',
		fillDirection: '45deg',
		controlPoints: gradient.points || ['#0000ff 0', '#00ff00 0.5', '#ff0000 1']
	});

	this.getManager().addMapObserver('sidepanelscroll', this.updatePosition, this);
	this.getManager().addMapObserver('filterabletoggle', this.onFilterableToggle,
									 this);
	this.getManager().addMapObserver('panel_resize', this.updatePosition, this);
	this.getManager().addMapObserver('before_panel_close', this.hidePicker, this);
	this.getManager().addWindowObserver('resize', this.updatePosition, this);
};

/**
 * Hide color picker
 *
 * @method hidePicker
 */
MUIGradientPicker.prototype.hidePicker = function() {
	clearTimeout(this._timeout);
	
	this.getManager().removeMapObserver('sidepanelscroll', this.updatePosition,
										this);
	this.getManager().removeMapObserver('filterabletoggle',
										this.onFilterableToggle, this);
	this.getManager().removeMapObserver('panel_resize', this.updatePosition, this);
	this.getManager().removeMapObserver('before_panel_close', this.hidePicker,
										this);
	this.getManager().removeWindowObserver('resize', this.updatePosition, this);

	if (this.picker) {
		$('.gradient', this.picker).gradientPicker('remove');
		$(this.picker).remove();

		this.picker = null;
		this.gradientPicker = null;
		this.gradientable = null;
		this.prevColors = null;
		this.prevGradient = null;
	}
};

/**
 *  filterabletoggle (collapse) event handler
 *
 * @method onFilterableToggle
 * @private
 * @param {String} event
 * @param {Filterable} filterable Filterable toggled
 */
MUIGradientPicker.prototype.onFilterableToggle = function(event, filterable) {
	// MDatasource isn't a filterable, but emits this event (which should probably
	// be fixed at some point)
	if (filterable instanceof MDatasource) {
		this.hidePicker();
		return;
	}

	var filterablePath = filterable.getDataPath().join('.') + '.';	
	var gradientablePath = this.gradientable.getDataPath().join('.') + '.';

	if (gradientablePath.indexOf(filterablePath) === 0) {
		this.hidePicker();
	} else {
		this.updatePosition();
	}
};

/**
 * Adjust position of color picker and align it with
 *
 * @method updatePosition
 */
MUIGradientPicker.prototype.updatePosition = function() {
	var offset = $(this.icon).offset();
	var offsetLeft = offset.left - $(this.picker).width() - 25;
	var offsetTop = offset.top - 20;

	$(this.picker).css("top", offsetTop + "px");
	$(this.picker).css("left", offsetLeft + "px");
};
/** 
 * Handles display of color picker
 *
 * @class MUIColorPicker
 * @constructor
 * @param {MFilterable|MDatasource} parent
 * @param {Object} options
 */
function MUIColorPicker(parent, options) {
	this.name = 'colorpicker';
	this.poition = 6;
	this.container = null;
	
	this.manager = null;
	this.options = options || {};

	this.prevColor = null;
	this.icon = null;
	this.colorable = null;
}

MUIColorPicker.prototype = new MControl;

/**
 * Init function for class, called as part of control loading
 * 
 * @method init
 * @param {Manager} manager Reference to manager
 */
MUIColorPicker.prototype.init = function(manager) {
	this.manager = manager;
};

/**
 * Check if supplied object meets colorable interface
 * 
 * @method checkColorable
 * @param {Colorable} obj
 */
MUIColorPicker.prototype.checkColorable = function(obj) {
	if (!this.hasMethods(obj, 'getColor', 'setColor')) {
		throw new Error('Supplied object does not meet interface requirements');
	}
};

/**
 * Get icon that when click will open color picker
 *
 * @method getColorIcon
 * @param {Colorable} colorable
 * @param {String} type Type of color (needed if colorable has >=2 colors)
 * @param {Function} callback (optional)
 * @return {DOMElement} Icon element
 */
MUIColorPicker.prototype.getColorIcon = function(colorable, type, callback) {
	this.checkColorable(colorable);

	var icon = document.createElement('div');
	icon.className = "color-picker";
	icon.title = colorable.pickerTitle || "Change item color";
	icon.pickerShown = false;
	icon.colorable = colorable;
	icon.colorableType = type || 'default';
	icon.style.backgroundColor = "#" + colorable.getColor(type);
	icon.callback = callback;
	
	var isClickable = function(colorable){
		var clickable = false;
		if(colorable.write_access == undefined){
			clickable = true;
		}
		if(colorable.write_access != undefined && colorable.write_access == true){
			clickable = true;
		}
		if(colorable.isDisabled){
			clickable = !colorable.isDisabled();
		}
		return clickable;
	};

	if (!colorable.viewOnly) {
		if(isClickable(colorable)){
			icon.className += " clickable";
		}
		var self = this;
		$(icon).click(function() {
			if(!isClickable(this.colorable)){
				return;
			}
			self.onIconClick(this.colorable, this.colorableType, this);
		});
	}

	return icon;
};

/**
 * Icon click event handler
 * 
 * @method onIconClick
 * @param {Colorable} colorable
 * @param {String} type color type
 * @param {DOMElement} icon that was clicked 
 */
MUIColorPicker.prototype.onIconClick = function(colorable, type, icon) {
	if (this.isPickerShown()) {
		var prevColorable = this.colorable;
		this.onRevert();

		if (prevColorable === colorable) {
			return;
		}	
 	}

	this.showPicker(colorable, type, icon);
};

/**
 * On revert event handler
 *
 * @method onRevert
 */
MUIColorPicker.prototype.onRevert = function() {
	this.setIconColor(this.prevColor);
	this.colorable.setColor(this.prevColor, this.icon.colorableType);
	this.hidePicker();
};


MUIColorPicker.prototype.setIconColor = function(color){
	this.icon.style.backgroundColor = "#" + color;
};

/**
 * Determin if picker is shown
 *
 * @method isPickerShown
 * @return {Boolean} true if show, false if not
 */
MUIColorPicker.prototype.isPickerShown = function() {
	return !!this.container;
};

/**
 * Show color picker UI
 *
 * @method showPicker
 * @param {Colorable} colorable
 * @param {String} type color type
 * @param {DOMElement} icon that was clicked
 */
MUIColorPicker.prototype.showPicker = function(colorable, type, icon) {
	this.checkColorable(colorable);

	this.prevColor = colorable.getColor(type);
	this.colorable = colorable;

	var container = document.createElement('div');
	container.id = 'colorpicker';

	var self = this;
	$(container).ColorPicker({
		'eventName': 'togglePicker',
		'flat': true,
		'livePreview': false,
		'onBeforeShow':	function() {},
		'onShow': function() {},
		'onChange': function(hsb, hex, rgb) {
			icon.style.backgroundColor = "#" + hex;
			colorable.setColor(hex, icon.colorableType);
		},
		'onSubmit': function(){
			icon.callback && icon.callback(icon);
		},
		'onHide': function() {
			self.hidePicker();
		}
	});

	var pointer = document.createElement('div');
	pointer.className = 'pointer';

	container.appendChild(pointer);

	$('body').append(container);
	container.style.display = 'block';

	this.icon = icon;
	this.container = container;

	this.adjustOffset();

	this.getManager().addMapObserver('sidepanelscroll', this.adjustOffset, this);
	this.getManager().addMapObserver('filterabletoggle', this.onFilterableToggle, this);
	this.getManager().addMapObserver('panel_resize', this.adjustOffset, this);
	this.getManager().addMapObserver('before_panel_close', this.hidePicker, this);
	this.getManager().addWindowObserver('resize', this.adjustOffset, this);
	
	$(container).ColorPickerSetColor(colorable.getColor(type));
	$(container).ColorPickerShow();
};

/**
 * Hide color picker
 *
 * @method hidePicker
 */
MUIColorPicker.prototype.hidePicker = function() {
	this.getManager().removeMapObserver('sidepanelscroll', this.adjustOffset, this);
	this.getManager().removeMapObserver('filterabletoggle', this.onFilterableToggle, this);
	this.getManager().removeMapObserver('panel_resize', this.adjustOffset, this);
	this.getManager().removeMapObserver('before_panel_close', this.hidePicker, this);
	this.getManager().removeWindowObserver('resize', this.adjustOffset, this);
	
	this.prevColor = null;
	this.colorable = null;
	this.icon = null;

	$(this.container).remove();
	this.container = null;
};

/**
 *  filterabletoggle (collapse) event handler
 *
 * @method onFilterableToggle
 * @private
 * @param {String} event
 * @param {Filterable} filterable Filterable toggled
 */
MUIColorPicker.prototype.onFilterableToggle = function(event, filterable) {
	
	if (filterable instanceof MDatasource) {
		if(this.colorable.getDatasource() == filterable){
			this.hidePicker();
		}else{
			this.adjustOffset();
		}
		return;
	}

	var filterablePath = filterable.getDataPath().join('.');	
	var colorablePath = this.colorable.getDataPath().join('.');

	if (colorablePath.indexOf(filterablePath + '.') === 0) {
		this.hidePicker();
	} else {
		this.adjustOffset();
	}
};

/**
 * Adjust position of color picker and align it with
 *
 * @method adjustOffset
 */
MUIColorPicker.prototype.adjustOffset = function() {
	var icon = this.icon;
	var container = this.container;

	if(!container){
		//XXX HACK to get around error for now
		return;
	}
	
	var offset = $(icon).offset();
	var windowHeight = $(document).height();
	var boxHeight = $(container).height();
	var boxWidth = $(container).width();
	var isLower = ((windowHeight / 2) < offset.top);

	$('.pointer', container).css('left', boxWidth + 'px');

	if(isLower) {
		$('.pointer', container).css('top', boxHeight - 20 - 17  + 'px');
	} else {
		$('.pointer', container).css('top', '');
	}

	container.style.left = offset.left - boxWidth - 15 + "px";
	container.style.top = offset.top - ((isLower) ? boxHeight - 33 : 20) +  'px';
};

/**
 * Class for creating an instance of a column sorter.
 *
 * @class MUIFilterableSorter
 * @param {Object} settings Object with key/values of settings
 * 		@property {Array} sortFunctions (optional) functions to run for sorting.
 * 			Needs 3 params: first item to be sorted, second item, and a sort order (1 or -1). Defaults to MUIFilterableSorter.predefinedSorting list
 * 		@property {String} columnSorterClassName (optional) Additional classname of the sorter ui.
 * 		@property {DOM, jQuery Object} sorterContainer (optional) Container to put the sorter ui.
 * 		@property {String} defaultsortby (optional) Name of default item to sort by (usually set in column settings).
 * 		@property {String} sortCriteriaClass (optional) jQuery selector of the elements in the columnDataContainer to select for sorting
 * 		@property {String} sortType (optional) Type of sort to be applied ("element", "array)
 * 		@property {DOM, jQuery Object} columnDataContainer (required if sortType: element) The container that has the items to sort.
 * 		@property {String} sortableArray (required if sortType: array) Array of items to sort.
 * 		@property {Integer} sortOrder (optional) Sort order to apply (1 or -1).
 * 		@property {Function} callback (optional) Function to call after sorting.
 * 		@property {Boolean} expandingContainer (optional) Whether to make a section in a data row for an expandable section
 * 		@property {Array} columnSettings (at least one required) Array of objects with settings for each column.
 * 			"value": (optional) is the text that will appear in the column header
 * 	 		"title": (optional) is the text that will display in a tooltop when hovered on the column
 * 			"sortby": (optional) is the name of the function to use for sorting (must be present in the options object)
 * 	 		"float": defined the column order. the floats marked 'left' will be first, respective to the
 * 	 			order in the array. ones marked 'right' need to be next and will represent the columns on the
 * 	 			right of the sorter. there needs to be one without a float, it will be the flexible element
 * 	 		"sortdefault": defines the option on which to sort by default
 * 	 		"spacer": (optional) a column to be used as a spacer element, looks like a regular column but is not interactable
 * 	 			Should be set to the id of the column (for styling)
 * 			"hidden": (optional) a column can start out as hidden and get shown with the method unhideColumn
 * 	 		EXAMPLE:
 * 			[{
 * 				"title": "Color",
 * 				"sortby": "color",
 * 				"float": "left"
 * 			},{
 * 				"title": "Filter",
 *				"sortby": "filter",
 *				"float": "left"
 *			},{
 *				"title": "Cardinality",
 *				"sortby": "cardinality",
 *				"float": "right"
 *			},{
 *				"title": "Purchased",
 *				"sortby": "purchased",
 *				"float": "right"
 *			},{
 *				"spacer": "spacerId"
 *				"float": "right"
 *			},{
 *				"title": "Name",
 *				"value": "Name"
 *				"sortby": "label",
 *				"sortdefault": true
 *			}]
 */

function MUIFilterableSorter(settings) {
	if(!settings){
		settings = {};
	}
	
	this.sortFunctions = settings.sortFunctions;
	this.columnSettings = settings.columnSettings;
	this.columnDataContainer = settings.columnDataContainer;
	this.columnSorterClassName = settings.columnSorterClassName;
	this.sorterContainer = settings.sorterContainer;
	this.defaultsortby = settings.defaultsortby;
	this.sortCriteriaClass = settings.sortCriteriaClass;
	this.sortOrder = settings.sortOrder || 1;
	this.expandingContainer = settings.expandingContainer;
	this.callback = settings.callback;
	
	this.sortType = settings.sortType || "element";
	this.sortableArray = settings.sortableArray;
	this.itemFetch = settings.itemFetch;
	
	this.currentSortBy;
	this.ui;
	
	if(settings.usePager){
		this.usePager = settings.usePager;
		this.setUpPager(settings);
	}
	
};

MUIFilterableSorter.prototype.setUpPager = function(settings){
	this.sortablePageNumber = settings.sortablePageNumber || 0;
	this.maxSortableItems = settings.maxSortableItems;
	
	this.pageRightTop;
	this.pageRightBottom;
	this.pageLeftTop;
	this.pageLeftBottom;
	this.lastPage;
	this.firstPage;
	this.sortFooter;
};

/**
 * Creates a sort column as the first column in the callers childContainer.
 *
 * @method makeColumnSorter
 * @param {} classOnly
 */
MUIFilterableSorter.prototype.makeColumnSorter = function(classOnly) {

	var self = this;
	var ce = Moonshadow.helpers.ce;

	this.ui = $(ce("div"))
		.addClass("colsorter")
		.addClass(this.columnSorterClassName); 
		
	var rlc = {
		"right": [],
		"left": [],
		"elastic": []
	};
	
	var pushCol = function(float, col){
		if(rlc[float]){
			rlc[float].push(col);
		}else{
			rlc["elastic"].push(col);
		}
	};
	
	for(var i = 0, l = this.columnSettings.length; i < l; ++i){
		var cs = this.columnSettings[i];
		var float = cs.float || "elastic";
		
		if(cs.control){
			pushCol(float, cs.control);
			continue;
		}
		
		var sb = cs.sortby || cs.spacer || "_";
		var sortableColumn = $(ce("div"))
			.addClass("left");
		
		pushCol(float, sortableColumn);
		
		if(!classOnly){
			$(sortableColumn)
				.attr({
					"id": sb
				});
		}else{
			$(sortableColumn)
				.addClass("sortable_column_" + sb);
		}
		
		if(cs.spacer){
			$(sortableColumn)
				.addClass("col_spacer");
			if(!classOnly){
				$(sortableColumn)
					.attr("id", cs.spacer)
			}
			continue;
		}
		
		if (cs.value) {
			$(sortableColumn)
				.addClass("sortable_title_added")
				.append(cs.value);
		}
			
		if (cs.title) {
			$(sortableColumn)
				.attr("title", "Sort by " + cs.title);	
		}

		$(sortableColumn)
			.addClass("col clickable")
			.on("click", {"sortBy": cs.sortby},
			function(e){
				self.sortOrder = self.sortOrder * -1;
				self.sortColumn(e.data.sortBy, this);
			});
		
		this.setHoverArrows(sortableColumn);
		
		if (cs.sortdefault) {
			this.defaultsortby = cs.sortby;
			this.adjustSortArrows(sortableColumn);
		}
		
		if(cs.hidden){
			$(sortableColumn)
				.css({
					"display": "none"
				});
		}
	}

	this.addPager(rlc);
	
	if(rlc.right.length){
		$(this.ui)
			.append(
				$(ce("div"))
					.addClass("right")
					.append(
						$(rlc.right).map(function(index, col){
							return $(col).get(0);
						})
					)
			);
	}
	if(rlc.left.length){
		$(this.ui)
			.append(
				$(rlc.left).map(function(index, col){
					return $(col).get(0);
				})
			);
	}
	
	if(rlc.elastic.length){
		$(this.ui)
			.append(
				$(ce("div"))
					.addClass("elastic")
					.append(
						$(rlc.elastic).map(function(index, col){
							var width = parseInt(100/rlc.elastic.length, 10);
							if(index == rlc.elastic.length - 1){
								--width;
							}
							return $(col)
								.css({
									"width": width + "%"
								})
								.get(0);
						})
					)
			);
	}

	$(this.columnDataContainer)
		.prepend(
			$(ce("div"))
				.addClass("colsortwait hide")
		);
	
	if(this.sorterContainer){
		$(this.sorterContainer)
			.append(this.ui);
	}
	
	this.makeExpandingContainer();
	
	return this.ui;
};

MUIFilterableSorter.prototype.addPager = function(rlc){
	if(!this.usePager){
		return;
	}
	var ce = Moonshadow.helpers.ce;
	var self = this;
	
	$(this.ui)
		.addClass("with_pager");
	
	var makePageTurner = function(title, dir, callback){
		return $(ce("div"))
			.addClass("left col clickable pager")
			.attr({
				"disabled": false,
				"title": title
			})
			.append(
				$(ce("div"))
					.addClass("sprite-page_" + dir + "_8d8d8d")
			)
			.on("click", function(){
				if($(this).attr("disabled") == "disabled"){
					return;
				}
				callback();
				self.refreshSort();
				self.adjustPager();
			});
	};
	
	this.pageRightTop = makePageTurner("Next page", "right", function(){
		++self.sortablePageNumber;
	});
	this.pageRightBottom = makePageTurner("Next page", "right", function(){
		++self.sortablePageNumber;
	});
	this.pageLeftTop = makePageTurner("Previous page", "left", function(){
		--self.sortablePageNumber;
	});
	this.pageLeftBottom = makePageTurner("Previous page", "left", function(){
		--self.sortablePageNumber;
	});
	this.lastPage = makePageTurner("Last page", "last", function(){
		self.sortablePageNumber =  Math.floor(self.sortableArray.length / self.maxSortableItems);
	});
	this.firstPage = makePageTurner("First page", "first", function(){
		self.sortablePageNumber = 0;
	});
	
	rlc.right.push(this.pageRightTop);
	rlc.left.unshift(this.pageLeftTop);
	
	var pageReadout = $(ce("span"))
		.addClass("sort_footer_page_readout")
		.append(this.sortablePageNumber + 1);
	
	var pageInput = $(ce("input"))
		.addClass("pager_input")
		.attr({
			"type": "number"
		});
	
	var attachInputHandlers = function(){
		$(pageInput)
			.on("keypress", function(e){
				if(e.which == 13){
					self.jumpToPage(pageInput, pageReadout);
				}
			})
			.on("blur", function(){
				self.jumpToPage(pageInput, pageReadout);
			});
	};
	
	this.sortFooter = $(ce("div"))
		.addClass("colsorter sort_footer")
		.append(
			$(ce("div"))
				.addClass("right")
				.append(
					this.lastPage,
					this.pageRightBottom
				),
			this.pageLeftBottom,
			this.firstPage,
			$(ce("div"))
				.addClass("elastic")
				.append(
					$(ce("div"))
						.addClass("sort_footer_page_number clickable")
						.append(
							$(ce("span"))
								.append("Page: "),
							pageReadout
						)
						.on("click", function(){
							if(!$(".pager_input", this).length){
								$(pageReadout).replaceWith(pageInput);
								attachInputHandlers();
								$(pageInput).focus();
							}
						})
				)
		);	
};

MUIFilterableSorter.prototype.jumpToPage = function(pageInput, pageReadout){
	var page = $(pageInput).val();
	$(pageInput).val("");
	$(pageInput).replaceWith(pageReadout);
	
	if(!page){
		return;
	}
	
	page = parseInt(page, 10);
	
	if(page < 1){
		page = 1;
	}

	var maxPage = Math.floor(this.sortableArray.length / this.maxSortableItems);
	if(this.sortableArray.length % this.maxSortableItems > 0){
		++maxPage;
	}
	
	if (page > maxPage){
		page = maxPage;
	}
	
	$(pageReadout)
		.empty()
		.append(page);
	
	this.sortablePageNumber = page - 1;
	this.refreshSort();
	this.adjustPager();
};

MUIFilterableSorter.prototype.adjustPager = function(){
	if(!this.usePager){
		return;
	}
	var lastIndex = (this.sortablePageNumber * this.maxSortableItems) 
		+ this.maxSortableItems;
	
	this.togglePager(true, "right");
	if(lastIndex >= this.sortableArray.length){
		this.togglePager(false, "right");
	}

	this.togglePager(true, "left");
	if(this.sortablePageNumber === 0){
		this.togglePager(false, "left");
	}
	
	if(this.columnDataContainer && this.sortFooter){
		$(this.columnDataContainer)
			.append(this.sortFooter);
		
		$(".sort_footer_page_readout", this.sortFooter)
			.empty()
			.append(this.sortablePageNumber + 1);
	}
};

MUIFilterableSorter.prototype.togglePager =  function(onOff, rightLeft){
	if(!this.usePager){
		return;
	}
	
	var variant = {
		"right": [this.pageRightTop, this.pageRightBottom, this.lastPage],
		"left": [this.pageLeftTop, this.pageLeftBottom, this.firstPage]
	}
	
	var elems = variant[rightLeft];
	if(!elems){
		return;
	}
	
	if(onOff == undefined){
		var isOn = $("div", elems[0])
			.hasClass("sprite-page_" + rightLeft + "_8d8d8d");
		onOff = !isOn;
	}
	
	for(var i = 0, l = elems.length; i < l; ++i){
		var dir = rightLeft;
		if(i == 2){
			if(dir == "right"){
				dir = "last"
			}
			if(dir == "left"){
				dir = "first"
			}
		}
		
		$("div", elems[i])
			.addClass(onOff ? "sprite-page_" + dir + "_8d8d8d" : "sprite-page_" + dir + "_c5c5c5")
			.removeClass(onOff ? "sprite-page_" + dir + "_c5c5c5" : "sprite-page_" + dir + "_8d8d8d");
		
		$(elems[i])
			.addClass(onOff ? "clickable" : null)
			.removeClass(onOff ? null : "clickable")
			.attr({
				"disabled": !onOff
			});
	}
};

MUIFilterableSorter.prototype.getDataRow = function(data){
	var ce = Moonshadow.helpers.ce;
	
	var dataRowObject = {};
	var sortClassName;
	if(this.sortCriteriaClass){
		sortClassName = this.sortCriteriaClass.replace(/\W/g, "");
	}
	
	var row = $(ce("div"))
		.addClass(sortClassName);

	if(!data){
		dataRowObject.columns = {};
	}
	
	var leftCols, rightCols, centerCols;
	var flex = 0;
	
	if(this.columnSettings && this.columnSettings.length){
		for(var i = 0, l = this.columnSettings.length; i < l; ++i){
			var ci = this.columnSettings[i];
			var sb = ci.sortby || ci.spacer || "_";
			
			if((data && ci.spacer) && !data[ci.spacer]){
				continue;
			}
			
			var cell = $(ce("div"))
				.addClass("left sortable_column")
				.addClass("sortable_data_column_" + sb);
			
			if(data && data[sb] != undefined){
				$(cell).append(data[sb]);
				if(typeof data[sb] == "string" || typeof data[sb] == "number"){
					$(cell).attr({
						"title": data[sb]
					});
				}
			}
			if(ci.float == "left"){
				if(!leftCols){
					leftCols = $(ce("div"))
						.addClass("left left_column");
				}
				$(leftCols)
					.append(cell);
			}else if(ci.float == "right"){
				if(!rightCols){
					rightCols = $(ce("div"))
						.addClass("right right_column");
				}
				$(rightCols)
					.append(cell);
			}else{
				if(!centerCols){
					centerCols = $(ce("div"))
						.addClass("elastic");
				}
				++flex;
				$(centerCols)
					.append(cell);
			}
			
			if(!data){
				dataRowObject.columns[sb] = cell;
			}
		}
	}
	
	if(rightCols){
		$(row).append(rightCols);
	}
	
	if(leftCols){
		$(row).append(leftCols);
	}
	
	if(centerCols){
		$(row).append(centerCols);
		$(centerCols).children().each(function(index, col){
			var width = parseInt(100/flex, 10);
			if(index == flex - 1){
				--width;
			}
			return $(col)
				.css({
					"width": width + "%"
				})
		})
	}

	var expandingContainer;
	if(this.expandingContainer){
		expandingContainer = this.getExpandingContainer();
		
		if(data.onExpand){
			$(expandingContainer).on("expand", data.onExpand);
			dataRowObject.triggerExpander = function(){
				$(expandingContainer).trigger("expand");
			}
		}
		
		if(data && data["expandingContainer"]){
			$(expandingContainer)
				.append(data["expandingContainer"]);
		}
		
		$(row).append(
			expandingContainer
		);
		
		dataRowObject.expandingContainer = expandingContainer;
	}
	
	dataRowObject.row = $(row).get(0);
	
	return dataRowObject;
};

MUIFilterableSorter.prototype.makeExpandingContainer = function(){
	if(this.expandingContainer){
		var ce = Moonshadow.helpers.ce;
		var expandingContainer;
		if(this.expandingContainer === true){
			expandingContainer = $(ce("div"));
		}else{
			expandingContainer = $(this.expandingContainer)
				.clone(true, true);
		}
		
		$(expandingContainer)
			.addClass("expanding_container");
		
		this.expandingContainer = expandingContainer;
	}	
};

MUIFilterableSorter.prototype.getExpandingContainer = function(){
	return $(this.expandingContainer).clone();
};

MUIFilterableSorter.prototype.displayMask = function(onOff){
	var csw = $(".colsortwait", this.columnDataContainer);
	onOff && (csw).css({
			"height": ($(this.columnDataContainer).innerHeight() - 13) + "px",
			"width": $(this.columnDataContainer).innerWidth() + "px"
		})
		.removeClass("hide");
	!onOff && (csw).addClass("hide");
};

/**
 *
 * @method doSort
 * @param {} sortby
 */
MUIFilterableSorter.prototype.doSort = function(sortby) {
	this.currentSortBy = sortby;
	this.displayMask(true);
	
	var fortSunc;
	if(this.sortFunctions && this.sortFunctions[sortby]){
		fortSunc = this.sortFunctions[sortby];
	}else{
		fortSunc = MUIFilterableSorter.predefinedSorting[sortby];	
	}
	if(!fortSunc){
		this.displayMask(false);
		return;
	}
	
	if(this.sortType == "element"){
		this.doElementSort(sortby, fortSunc);
	}
	if(this.sortType == "array" && this.sortableArray){
		this.doArraySort(sortby, fortSunc);
	}
	
	this.displayMask(false)
	this.callback && this.callback();
	this.adjustPager();
};

MUIFilterableSorter.prototype.doElementSort = function(sortby, fortSunc){
	var sortOrder = this.sortOrder;
	var self = this;
	$((this.sortCriteriaClass || "div"), this.columnDataContainer).sortElements(function(a, b) {
		return fortSunc.apply(self, [a, b, sortOrder]);
	});
};

MUIFilterableSorter.prototype.doArraySort =  function(sortby, fortSunc){
	if(!this.sortableArray){
		return;
	}
	var self = this;
	var sortOrder = this.sortOrder;
	this.sortableArray.sort(function(a, b) {
		if(self.itemFetch){
			a = self.itemFetch(a);
			b = self.itemFetch(b);
		}
		return fortSunc.apply(self, [a, b, sortOrder]);
	});
};

/**
 *
 * @method sortColumn
 * @param {} sortby
 * @param {} element
 */
MUIFilterableSorter.prototype.sortColumn = function(sortby, element) {
	if(!this.sortOrder){
		this.sortOrder = sortOrder || 1;
	}
	if(!sortby){
		sortby =  this.defaultsortby;
	}
	
	this.adjustSortArrows(element);	
	this.doSort(sortby);
};

MUIFilterableSorter.prototype.setHoverArrows = function(element){
	$(element)
		.addClass(this.sortOrder == -1 ? "hover_desc" : "hover_asc"); 
};

MUIFilterableSorter.prototype.adjustSortArrows = function(element){
	$(".col:not(.pager)", this.ui)
		.removeClass("currentsort_desc currentsort_asc hover_desc hover_asc")
		.addClass(this.sortOrder == -1 ? "hover_desc" : "hover_asc"); 

	$(element)
		.removeClass("hover_asc hover_desc")
		.addClass(this.sortOrder == -1 ? "currentsort_desc" : "currentsort_asc");
};

/**
 *
 * @method refreshSort
 * @param {} sortby
 *
 */
MUIFilterableSorter.prototype.refreshSort = function(sortby) {
	this.doSort(sortby || this.currentSortBy || this.defaultsortby);
};

/**
*
* @method hideColSorter
* 
*/
MUIFilterableSorter.prototype.hideColSorter = function(){
	$(this.ui)
		.addClass("hide");
};

/**
*
* @method unhideColSorter
* 
*/
MUIFilterableSorter.prototype.unhideColSorter = function(){
	$(this.ui)
		.removeClass("hide");
};

/**
*
* @method toggleHideColSorter
* 
*/
MUIFilterableSorter.prototype.toggleHideColSorter = function(){
	$(this.ui)
		.toggleClass("hide");
};

/**
*
* @method hideColumn
* 
*/
MUIFilterableSorter.prototype.hideColumn = function(columnId){
	$("#" + columnId, this.ui).hide();
};

/**
*
* @method unhideColumn
* 
*/
MUIFilterableSorter.prototype.unhideColumn = function(columnId){
	$("#" + columnId, this.ui).show();
};

MUIFilterableSorter.predefinedSorting = {
	"filter": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.checkboxBool(".checkbox input[type='checkbox']", a, b, sortOrder);
	},
	"filterFromObject": function(a, b, sortOrder){
		var abool = a.isChecked();
		var bbool = b.isChecked();
		var retVal = MUIFilterableSorter.predefinedSorting.returnBool(abool, bbool, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.labelFromObject(a, b, sortOrder);
		}
		return retVal;
	},
	"sscols": function(a, b, sortOrder){
		var abool = $(".ssbutton", a).hasClass("sprite-addColumnSelected");
		var bbool = $(".ssbutton", b).hasClass("sprite-addColumnSelected");
		var retVal = MUIFilterableSorter.predefinedSorting.returnBool(abool, bbool, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"sscolsFromObject": function(a, b, sortOrder){
		var abool = a.tableColSelected;
		var bbool = b.tableColSelected;
		var retVal = MUIFilterableSorter.predefinedSorting.returnBool(abool, bbool, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.labelFromObject(a, b, sortOrder);
		}
		return retVal;
	},
	"label": function(a, b, sortOrder){
		var avalue = $(".label", a).text();
		var bvalue = $(".label", b).text();
		return MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
	},
	"labelFromObject": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.stringSort(a.ext_name, b.ext_name, sortOrder);
	},
	"color": function(a, b, sortOrder){
		var avalue = $(".color-picker", a).get(0).style.backgroundColor;
		var bvalue = $(".color-picker", b).get(0).style.backgroundColor;
		
		function rgb2hex(color) {
		if (color[0] === '#') {
		return color;
		}
		var digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);
		var red = parseInt(digits[2],10);
		var green = parseInt(digits[3],10);
		var blue = parseInt(digits[4],10);
		var rgb = blue | (green << 8) | (red << 16);
		var rgbString = rgb.toString(16);
		while(rgbString.length < 6)
			rgbString = "0" + rgbString;
		return digits[1] + '#' + rgbString;
		};
		
		var aHex = rgb2hex(avalue);
		var bHex = rgb2hex(bvalue);
		return MUIFilterableSorter.predefinedSorting.colorValue(aHex, bHex, sortOrder);
	},
	"colorFromObject": function(a, b, sortOrder){		
		var retVal = MUIFilterableSorter.predefinedSorting.colorValue(a.color, b.color, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.labelFromObject(a, b, sortOrder);
		}
		return retVal;
	},
	"filteredTotalFromObject": function(a, b, sortOrder){
		var avalue = a.filteredCountTotal;
		var bvalue = b.filteredCountTotal;
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.totalFromObject(a, b, sortOrder);
		}
		return retVal;
	},
	"totalFromObject": function(a, b, sortOrder){
		var avalue = a.countTotal;
		var bvalue = b.countTotal;
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.labelFromObject(a, b, sortOrder);
		}
		return retVal;
	},
	"percentFromObject": function(a, b, sortOrder){
		var avalue = a.countPerc;
		var bvalue = b.countPerc;
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.totalFromObject(a, b, sortOrder);
		}
		return retVal;
	},
	"colorValue": function(avalue, bvalue, sortOrder){
		function rgb2hsv (color) {
			var hexArray = color.replace("#","").match(/../g);
			var rr, gg, bb, h, s;
			var r = parseInt(hexArray[0], 16) / 255;
			var g = parseInt(hexArray[1], 16) / 255;
			var b = parseInt(hexArray[2], 16) / 255;
			var v = Math.max(r, g, b);
			var diff = v - Math.min(r, g, b);
			
			var diffc = function(c){
				return (v - c) / 6 / diff + 1 / 2;
			};
			
			if (diff == 0) {
				h = s = 0;
			} else {
				s = diff / v;
				rr = diffc(r);
				gg = diffc(g);
				bb = diffc(b);
			
				if (r === v) {
					h = bb - gg;
				}else if (g === v) {
					h = (1 / 3) + rr - bb;
				}else if (b === v) {
					h = (2 / 3) + gg - rr;
				}
				if (h < 0) {
					h += 1;
				}else if (h > 1) {
					h -= 1;
				}
			}
			return {
				"h": Math.round(h * 360),
				"s": Math.round(s * 100),
				"v": Math.round(v * 100)
			};
		}
		
		var aHSVObj = rgb2hsv(avalue);
		var bHSVObj = rgb2hsv(bvalue);
		
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(
			aHSVObj.h, bHSVObj.h, sortOrder
		);
		if(retVal === 0){
			retVal = MUIFilterableSorter.predefinedSorting.returnVal(
				aHSVObj.v, bHSVObj.v, sortOrder
			);
		}
		if(retVal === 0){
			retVal = MUIFilterableSorter.predefinedSorting.returnVal(
				aHSVObj.s, bHSVObj.s, sortOrder
			);
		}

		return retVal;
	},
	"type": function(a, b, sortOrder){
		var avalue =  $(".icon", a).attr("class");
		var bvalue =  $(".icon", b).attr("class");
		var retVal = MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.downloadTitle(a, b, sortOrder);
		}
		return retVal;
	},
	"downloadTitle": function(a, b, sortOrder){
		var avalue =  $(".downloadable_export_title", a).text().toLowerCase();
		var bvalue =  $(".downloadable_export_title", b).text().toLowerCase();
		return MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
	},
	"dateCreated": function(a, b, sortOrder){
		var avalue =  $("input[name='date_created']", a).val();
		var bvalue =  $("input[name='date_created']", b).val();
		var retVal = MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.downloadTitle(a, b, sortOrder);
		}
		return retVal;
	},
	"percentDone": function(a, b, sortOrder){
		var avalue =  $("input[name='report_status']", a).val();
		var bvalue =  $("input[name='report_status']", b).val();
		var retVal =  MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			var selector = ".report_progress_bar span";
			var aperc = $(selector, a).text().replace("%","") * 10;
			var bperc = $(selector, b).text().replace("%","") * 10;
			var retVal = MUIFilterableSorter.predefinedSorting.returnVal(aperc, bperc, sortOrder);
			if(retVal === 0){
				return MUIFilterableSorter.predefinedSorting.downloadTitle(a, b, sortOrder * -1);
			}
		}
		return retVal;
	},
	"region": function(a, b, sortOrder){
		var avalue = $(".region", a).text().toLowerCase();
		var bvalue = $(".region", b).text().toLowerCase();
		return MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
	},
	"stringSort": function(avalue, bvalue, sortOrder){
		if(!avalue || !bvalue)
			return 0;
		
		var aInt = parseInt(avalue, 10);
		var bInt = parseInt(bvalue, 10);
		if(avalue == aInt && bvalue == bInt){
			return MUIFilterableSorter.predefinedSorting.returnVal(aInt, bInt, sortOrder);
		}
		
		function splt(val) {
			var vals = [], x = 0, y = -1, n = 0, i, j;
			while (i = (j = val.charAt(x++)).charCodeAt(0)) {
				var m = (i == 46 || (i >=48 && i <= 57));
				if (m !== n) {
					vals[++y] = "";
					n = m;
				}
				vals[y] += j;
			}
			return vals;
		}
		var aarr = splt(avalue.toLowerCase());
		var barr = splt(bvalue.toLowerCase());
		for (var i = 0; aarr[i] && barr[i]; i++) {
			if (aarr[i] !== barr[i]) {
				var c = Number(aarr[i]);
				var d = Number(barr[i]);
				if (c == aarr[i] && d == barr[i]) {
					return MUIFilterableSorter.predefinedSorting.returnVal(c, d, sortOrder);
				} else {
					return MUIFilterableSorter.predefinedSorting.returnVal(aarr[i], barr[i], sortOrder);
				}
			}
		}
		return MUIFilterableSorter.predefinedSorting.returnVal(aarr.length, barr.length, sortOrder);
	},
	"row_count": function(a, b, sortOrder, countVar){
		if(!countVar) {
			countVar = ".counts.row-group .count";
		}

		var avalue = parseInt($(countVar, a).text().replace(/,/g,""),10);
		var bvalue = parseInt($(countVar, b).text().replace(/,/g,""),10);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"row_total": function(a, b, sortOrder, countVar){
		if(!countVar) {
			countVar = ".counts.row-group > .total";
		}

		var avalue = parseInt($(countVar, a).text().replace(/,/g,""),10);
		var bvalue = parseInt($(countVar, b).text().replace(/,/g,""),10);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"row_perc": function(a, b, sortOrder){
		var selector = ".counts.row-group .perc";
		var avalue = $(selector, a).text().replace("%","") * 10;
		var bvalue = $(selector, b).text().replace("%","") * 10;
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.row_count(a, b, sortOrder);
		}
		return retVal;
	},
	"total_count": function(a, b, sortOrder, countVar){
		if(!countVar) {
			countVar = ".counts.total-group > .count";
		}

		var avalue = parseInt($(countVar, a).text().replace(/,/g,""),10);
		var bvalue = parseInt($(countVar, b).text().replace(/,/g,""),10);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"total_total": function(a, b, sortOrder, countVar){
		if(!countVar) {
			countVar = ".counts.total-group > .total";
		}

		var avalue = parseInt($(countVar, a).text().replace(/,/g,""),10);
		var bvalue = parseInt($(countVar, b).text().replace(/,/g,""),10);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"total_perc": function(a, b, sortOrder){
		var selector = ".counts.total-group .perc";
		var avalue = $(selector, a).text().replace("%","") * 10;
		var bvalue = $(selector, b).text().replace("%","") * 10;
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.row_count(a, b, sortOrder);
		}
		return retVal;
	},
	"cardinality": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.row_count(a, b, sortOrder, ".cardinality");
	},
	"order": function(a, b, sortOrder){
		var avalue = parseInt($(".univOrder", a).text(), 10);
		var bvalue = parseInt($(".univOrder", b).text(), 10);
		if(isNaN(avalue) || isNaN(bvalue)){
			sortOrder = 1;
			if(isNaN(avalue) && isNaN(bvalue)){
				bvalue = 0;
				avalue = 0;
			}else if(isNaN(avalue)){
				bvalue = 1;
				avalue = 2;
			}else if(isNaN(bvalue)){
				bvalue = 2;
				avalue = 1;
			}
		}
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"purchased": function(a, b, sortOrder){
		var getSortVal = function(elem){
			if($(".cartButton", elem).hasClass("sprite-cart_purchased"))
				return 1;
			if($(".cartButton", elem).hasClass("sprite-cart_out"))
				return 2;
			if($(".cartButton", elem).hasClass("sprite-cart_in"))
				return 3;
			if($(".cartButton", elem).hasClass("sprite-cart_wait"))
				return 4;
		};
		var avalue = getSortVal(a);
		var bvalue = getSortVal(b);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"line": function(a, b, sortOrder){
		var avalue = $(".line div", a).attr("class")
		var bvalue = $(".line div", b).attr("class") 
		return MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
	},
	"masker": function(a, b, sortOrder){
		var abool = $(".masker", a).hasClass("mask_selected");
		var bbool = $(".masker", b).hasClass("mask_selected");
		var retVal = MUIFilterableSorter.predefinedSorting.returnBool(abool, bbool, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"shapescount": function(a, b, sortOrder){
		var avalue = parseInt($(".count", a).text(), 10);
		var bvalue = parseInt($(".count", b).text(), 10);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"shapeselected": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.checkboxBool("input[name='selected-shape']", a, b, sortOrder);
	},
	"shapedisplayed": function(a, b, sortOrder){
		return MUIFilterableSorter.predefinedSorting.checkboxBool("input[name='display-shape']", a, b, sortOrder);
	},
	"checkboxBool": function(selector, a, b, sortOrder){
		var abool = $(selector, a).attr("checked");
		var bbool = $(selector, b).attr("checked");
		var retVal = MUIFilterableSorter.predefinedSorting.returnBool(abool, bbool, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.label(a, b, sortOrder);
		}
		return retVal;
	},
	"folder_count" : function(a, b, sortOrder){
		var avalue = parseInt($(".folder_count", a).text().replace(/\D/g, ""), 10);
		var bvalue = parseInt($(".folder_count", b).text().replace(/\D/g, ""), 10);
		var retVal = MUIFilterableSorter.predefinedSorting.returnVal(avalue, bvalue, sortOrder);
		if(retVal === 0){
			return MUIFilterableSorter.predefinedSorting.header_text(a, b, sortOrder);
		}
		return retVal;
	},
	"header_text": function(a, b, sortOrder){
		var avalue = $(".header_text", a).text().toLowerCase();
		var bvalue = $(".header_text", b).text().toLowerCase();
		return MUIFilterableSorter.predefinedSorting.stringSort(avalue, bvalue, sortOrder);
	},
	"returnBool": function(abool, bbool, sortOrder){
		if(abool && !bbool) {
			return -1 * sortOrder;
		}else if(!abool && bbool) {
			return 1 * sortOrder;
		}
		return 0;
	},
	"returnVal": function(avalue, bvalue, sortOrder){
		if(avalue > bvalue) {
			return 1 * sortOrder;
		}else if(avalue < bvalue) {
			return -1 * sortOrder;
		}
		return 0;
	}
};

MUIFormElements = {};

MUIFormElements.elem = function(settings){
	var ce = this.ce;
	var elem = this[settings.type](
		settings.title, settings.value || settings.options, 
		settings.required, settings.className, settings.events, 
		settings.attr, settings.valueName, settings.addClear, 
		settings.minDate || settings.ghost, settings.maxDate
	);
	
	if(settings.questionButton){
		var questionButton = $(ce("div"))
			.addClass("ms_question_button clickable")
			.addClass(settings.questionButton.className)
			.append("?");
		
		if(settings.questionButton.events){
			this._bindEvents(questionButton, settings.questionButton.events);
		}
		
		$(".ms_text_field_flex_container_inner", elem)
			.addClass("ms_text_field_added_control");
		$(".ms_text_field_flex_container_outer", elem)
			.prepend(questionButton);
		
		$(".ms_checkbox_label", elem)
			.after(questionButton);
		
		$(".ms_textarea_placeholder", elem)
			.before(questionButton);
	}
	
	if(settings.controlButton){
		$(".ms_text_field_flex_container_inner", elem)
			.addClass("ms_text_field_added_control");
		$(".ms_text_field_flex_container_outer", elem)
			.append(settings.controlButton);
		
		$(".ms_checkbox_label", elem)
			.after(settings.controlButton);
		
		$(".ms_textarea_placeholder", elem)
			.before(questionButton);
	}
	
	return elem;
}

MUIFormElements.textReadout = function(title, value, required, className){
	var ce = this.ce;
	return this.textContainer(
		title, 
		$(ce("div"))
			.addClass("ms_textfield_placeholder selectable")
			.addClass(className)
			.append(value),
		required
	);
};

MUIFormElements.textAreaReadout = function(title, value, required, className, events){
	var ce = this.ce;
	var _input = $(ce("div"))
		.addClass("ms_textarea_placeholder selectable")
		.addClass(className)
		.append(value);
	
	if(events){
		this._bindEvents(_input, events);
	}
	
	return this.textAreaContainer(
		title, _input, required
	);
};

MUIFormElements.select = function(title, options, required, className, events, attr){
	var ce = this.ce;
	
	var _select = $(ce("select"))
		.addClass("ms_select_input")
		.addClass(className)
		.attr(attr || {})
		.append(
			$.map(options, function(option){
				return $(ce("option"))
					.attr({
						"value": option.value,
						"selected": option.selected,
						"title": option.title,
						"disabled": option.disabled
					})
					.append(option.name)
					.get(0);
			})
		);
	
	if(events){
		this._bindEvents(_select, events);
	}
	
	return this.textContainer(
		title, _select, required
	);
};

MUIFormElements.checkBox = function(title, value, required, className, events, attr, valueName){
	var _input = this._inputCheck("checkbox", value, className, events, attr, valueName);
	if($(!_input).attr("id")){
		$(!_input).attr("id", MUIFormElements._generateElemId([title, value, className, valueName, new Date().getTime()]));
	}
	return this._checkboxLabel(title, _input, required);
};

MUIFormElements.textField = function(title, value, required, className, events, attr, valueName, addClear, ghost){
	var _input = this._inputField("text", value, className, events, attr, valueName, ghost);
	return this.textContainer(title, _input, required, addClear);
};

MUIFormElements.numberField = function(title, value, required, className, events, attr, valueName, addClear, ghost){
	var _input = this._inputField("number", value, className, events, attr, valueName, ghost);
	return this.textContainer(title, _input, required, addClear);
};

MUIFormElements.dateField = function(title, value, required, className, events, attr, valueName, addClear, minDate, maxDate, ghost){
	var _input = this._inputField("text", value, className, events, attr, valueName, ghost);
	$(_input).datepicker({
		"changeMonth": true,
		"changeYear": true,
		"maxDate": maxDate || "1/1/2100",
		"minDate": minDate || "1/1/1900",
		"yearRange": "1900:2100"
	});
	
	return this.textContainer(title, _input, required, addClear);
};

MUIFormElements.radioButtons = function(title, options, required, className, events, attr, valueName){
	var ce = this.ce;
	return $(ce("div"))
		.addClass("ms_text_area_container")
		.append(
			this._label(title, required),
			$(ce("ul"))
				.addClass("ms_radio_group")
				.append(
					$.map(options, function(option, index){
						var id = "_" + valueName + "_" + index;
						var attributes = {
							"id": id,
							"type": "radio",
							"name": valueName,
							"value": option.value,
							"checked": option.checked
						}
						for(var i in attr){
							if(!attr.hasOwnProperties(i)){
								continue;
							}
							
							attributes[i] = attr[i];
						} 
						
						var _inp = $(ce("input"))
							.addClass(className)
							.attr(attributes);
						
						if(events){
							MUIFormElements._bindEvents(_inp, events);
						}
						
						return $(ce("li"))
							.addClass("ms_radio_group_item")
							.append(
								_inp,
								$(ce("label"))
									.attr({
										"for": id
									})
									.append(option.title)
							)
							.get(0)
					})
				)
		);
};

MUIFormElements.textArea = function(title, value, required, className, events, attr){
	var ce = this.ce;
	
	var _textArea = $(ce("textarea"))
		.addClass("ms_text_area_input")
		.addClass(required ? "required" : null)
		.addClass(className)
		.attr(attr || {})
		.val(value);
	
	if(events){
		this._bindEvents(_textArea, events);
	}
		
	return this.textAreaContainer(
		title, _textArea, required
	);
};

MUIFormElements.textContainer = function(title, input, required, addClear){
	var ce = this.ce;
	var _c = "";
	if(addClear){
		_c = $(ce("span"))
			.addClass("ms_text_clear clickable")
			.append("x")
			.on("click", function(){
				$(input).val("")
					.trigger("onClear")
					.get(0)
					.focus();
			});
	}
	
	return $(ce("div"))
		.addClass("ms_text_field_container")
		.append(
			this._textLabel(title, required),
			$(ce("div"))
				.addClass("ms_text_field_flex_container_outer")
				.append(
					$(ce("div"))
						.addClass("ms_text_field_flex_container_inner")
						.append(
							input, _c
						)	
				)
		);
};

MUIFormElements.textAreaContainer = function(title, textArea, required){
	var ce = this.ce;
	return $(ce("div"))
		.addClass("ms_text_area_container")
		.append(
			this._textLabel(title, required),
			textArea
		);
};

MUIFormElements._bindEvents = function(input, events){
	$.map(events, function(callback, event){
		$(input).on(event, callback);
	});
}

MUIFormElements.ce = function(type){
	if(typeof Moonshadow != "undefined"){
		return Moonshadow.helpers.ce(type);
	}
	return document.createElement(type);
};

MUIFormElements._textLabel = function(title, required){
	if(title == undefined){
		return "";
	}
	var ce = this.ce;
	return $(ce("span"))
		.addClass("ms_text_field_small_label")
		.append(
			required? $(ce("span"))
				.addClass("required_ind")
				.append("*") : "",
			title
		);
};

MUIFormElements._label = function(title, required){
	var ce = this.ce;
	return $(ce("span"))
		.addClass("ms_text_field_label")
		.append(
			required? $(ce("span"))
				.addClass("required_ind")
				.append("*") : "",
			title
		);
};

MUIFormElements._generateElemId = function(values){
	if(!values instanceof Array){
		values = [values];
	}
	return "_" + values.join("").replace(/\W/g,"");
};

MUIFormElements._checkboxLabel = function(title, _input, required){
	var ce = this.ce;
	var id, a = {};
	if(id = $(_input).attr("id")){
		a["for"] = id;
	}

	return $(ce("div"))
		.addClass("ms_checkbox_container")
		.append(
			$(ce("label"))
				.attr(a)
				.addClass("ms_checkbox_label")
				.append(
					_input,
					required? $(ce("span"))
						.addClass("required_ind")
						.append("*") : "",
					title
				)
		);
};

MUIFormElements._inputCheck = function(type, value, className, events, attr, valueName){
	return $(MUIFormElements._input(type, value, className, events, attr, valueName))
		.addClass("ms_checkbox_input");
};

MUIFormElements._inputField = function(type, value, className, events, attr, valueName, ghost){
	return $(MUIFormElements._input(type, value, className, events, attr, valueName, ghost))
		.addClass("ms_text_field_input");
};

MUIFormElements._input = function(type, value, className, events, attr, valueName, ghost){
	var ce = this.ce;

	if(ghost && !value){
		value = ghost;
	}
	
	var a = {
		"type": type,
		"value": value
	}
	
	if(valueName){
		a.name = valueName;
	}
	
	if(attr){
		$.extend(a, attr);
	}
	
	var _input = $(ce("input"))
		.addClass(className)
		.attr(a);

	if(ghost){
		if(value == ghost){
			_input.addClass("ms_textfield_ghosted")
		}
		
		var showGhost = function(target){
			$(target).addClass("ms_textfield_ghosted")
				.val(ghost);
		}
		
		this._bindEvents(_input, {
			"onClear": function(){
				showGhost(this);
			},
			"focus": function(){
				if(this.value == ghost){
					this.value = "";
					$(this).removeClass("ms_textfield_ghosted");
				}
			},
			"blur": function(){
				if(!this.value){
					return showGhost(this);
				}
				$(this).removeClass("ms_textfield_ghosted");
			}
		});
	}
	
	if(events){
		this._bindEvents(_input, events);
	}
	
	return _input;
};
/** 
 * Displays and manages popup layover (overlay) panels
 *
 * @class MUILayoverPanel
 * @constructor
 * @param {Object} settings (required) An object which may contain the following properties:
 *		@property {String} 				id (required) The id of the panel, also used as an id on the element
 *		@property {DOM Object, String, Array} 	content (required) The content for the panel
 *		@property {String} 				title (optional) The string to display as the title in the panel
 *		@property {Function} 			onOpen (optional) Function to run right after the panel opens
 *		@property {Function} 			onClose (optional) Function to run right before the panel closes
 *						The onClose callback may have 2 optional parameters, the first is a callback to return 
 *						back to the panel control. This can be used to stop the closing of a panel
 *						if criteria is not met (exiting if panel is "dirty", for instance). The second
 *						parameter is a context to call onClose on.
 *		@property {Object} 				context (optional) The object that instantiates the panel
 *		@property {Boolean} 			fixed (optional, default: false) Whether the panel can be dragger and resized or not
 *		@property {String} 				resizeAlso (optional) Classname selector (starting with ".") or element id (starting
 *						with "#") to signify that the given element will also resize with it's parent (jailed to container)
 *		@property {Object} 				position (optional) Object having dimension attributes for the panel when opened. 
 *						There may be an "also" key as well, which will position the resizable "also" container (see resizeAlso):
 *						{"height": 300, "width": 300, "top": 100, "also": { "height": 300, "width": 300, "top": 100 }}
 *		@property {Object, Boolean} 	animate (optional, default: false) Whether or not to animate the opening, closing of the panel:
 *						{onOpen: false, onClose: true}
 *		@property {Object, Boolean}		displayLoading (optional, default: false) Whether or not to show an animated loading window
 *						over the top of the others when the panel is opening or closing or both:
 *						{onOpen: false, onClose: true}
 *						NOTE: The loading indicator can be turned on or off manually (MUILayoverPanel.loadIndicator(Boolean))
 *		@property {Integer} 			minWidth (optional, default: set below) when resizing, the minimum width allowed
 *		@property {Integer} 			maxHeight (optional, default: set below) when resizing, the maximum height allowed
 *		@property {Integer} 			minHeight (optional, default: set below) when resizing, the minimum height allowed
 *		@property {Function} 			onResizing (optional) Function to call when actively resizing
 *		@property {Function} 			onResizeStop (optional) Function to call when resizing has stopped
 *		@property {Boolean} 			modal (optional, default: true) Whether or not the dialog covers the screen 
 *						preventing interaction with page behind (Note: new non-modal panels will be displayed behind modal ones)
 *		@property {Object, Array} docs (optional) Object or array of objects that will build doc links and display them to the left of the closer.
 *						An object will contain:
 *							@property {String} url (optional if callback provided) A url link to the doc
 *							@property {Function} callback (optional if url provided) A funciton to call on click
 *							@property {String} icon (optional, defaults to blue "i" icon) classname of sprite. Other classes can be added as well.
 *							@property {String} title (required) Tooltip text to display on hover
 *		@property {DOM Object, Array[DOM Object]} tools (optional) An array of elements that will go in the title to the left of the docs or closer.
 *						Ideally, these are small icons that performs tasks
 *		@property {Boolean}				openNow (optional, default: false) Whether to immediately open the window
 *		@property {String, DOM Object}	titleIcon (optional) A string representing a className (like a sprite), or a Dom Element,
 *						or a jQuery element to be put to the left of the title.
 *		@property {Boolean}				scrollable (optional, default: false) If the content panel should scrollable. You may want to leave false and
 *						provide a different method for scrolling, (i.e., you have a header element you don't want to scroll)
 *		@property {DOM Object, String, Array}	footer (optional) Content to be displayed as a footer in the panel. It will always appear at the bottom
 *						and not be in the scrollable element
 *		
 */
function MUILayoverPanel(settings){
	
	if(!settings || (!settings.id && !settings.content)){
		return;
	}
	
	var docHeight = $(document).height() - 100;
	if(docHeight < 0){
		docHeight = 0;
	}
	var docWidth = $(document).width() - 100;
	if(docWidth < 0){
		docWidth = 0;
	}
	
	this.id = settings.id; 
	this.content = settings.content;
	this.title = settings.title;
	this.onOpen = settings.onOpen;
	this.onClose = settings.onClose;
	this.context = settings.context;
	this.closeText = settings.closeText;
	this.fixed = settings.fixed === false ? false : true;
	this.resizeAlso = settings.resizeAlso;
	this.position = settings.position || {};
	this.animate = settings.animate;
	this.displayLoading = settings.displayLoading;
	this.maxWidth = settings.maxWidth || docWidth || 1200;
	this.minWidth = settings.minWidth || 600;
	this.maxHeight = settings.maxHeight || docHeight || 900;
	this.minHeight = settings.minHeight || 300;
	this.onResizing = settings.onResizing;
	this.onResizeStop = settings.onResizeStop;
	this.scrollable = settings.scrollable;
	this.modal = settings.modal === false ?  false : true;
	
	if(settings.footer){
		this.footer = settings.footer;
	}
	
	if(settings.title){
		this.titleIcon = this._makeTitleIcon(settings.titleIcon);
	}
	
	if(settings.docs && !(settings.docs instanceof Array)){
		settings.docs = [settings.docs];
	}
	this.docs = settings.docs || [];
	
	if(settings.tools && !(settings.tools instanceof Array)){
		settings.tools = [settings.tools];
	}
	this.tools = settings.tools || [];
	
	this.isShown = false;
	this._loadShowing = false;
	this._dialogType = "panel";
	this._arrowObject;
	this._titleElement;
	this.defaultFocused;
	this.buttons;
	
	var attributes = this._getCascadeOffset();
	this._zindex = attributes._zindex;
	this._cascadeOffset = attributes._cascadeOffset;
	this._preventDarkening = attributes._preventDarkening;
	
	this._init();
	
	if(settings.openNow){
		this.open();
	}
}

/**
 * Storage for all open panels
 * 
 * @property panels
 * @static
 */
MUILayoverPanel.panels = {};

/**
 * Preset reference for panel stacking
 * 
 * @property zindex
 * @static
 */
MUILayoverPanel.zindex = {
	"panel": {
		"nonmodal": 1000,
		"modal": 3000
	},
	"alert": {
		"nonmodal": 2000,
		"modal": 4000
	},
	"confirm": {
		"nonmodal": 2000,
		"modal": 4000
	}
}

/**
 * Returns panel objects from static store
 * 
 * @method get
 * @param {String} id (required) The id of the desired panel
 * @returns {MUILayoverPanel} desired panel
 * @static
 */
MUILayoverPanel.get = function(id){
	if(MUILayoverPanel.panels[id]){
		return MUILayoverPanel.panels[id];
	}
};

/**
 * Returns panel objects from static store of type provided
 * 
 * @method getOfType
 * @param {String, Array} types (required) The type of the desired panels
 * 		["panel", "alert", "confirm"]
 * @returns {Array} array desired panels
 * @static
 */
MUILayoverPanel.getOfType = function(types){
	if(typeof types == "string"){
		types = [types];
	}
	var panels = [];
	for(var i in MUILayoverPanel.panels){
		if(!MUILayoverPanel.panels.hasOwnProperty(i))
			continue;
		if($.inArray(MUILayoverPanel.panels[i]._dialogType, types) > -1){
			panels.push(MUILayoverPanel.panels[i]);
		}
	}
	return panels;
};

/**
 * Returns panel object that is currently on top based on _zindex
 * 
 * @method getTopPanel
 * @returns {MUILayoverPanel} top panel
 * @static
 */
MUILayoverPanel.getTopPanel = function(){
	var topPanel;
	for(var i in MUILayoverPanel.panels){
		if(!MUILayoverPanel.panels.hasOwnProperty(i))
			continue;
		if(!topPanel || MUILayoverPanel.panels[i]._zindex > topPanel._zindex){
			topPanel = MUILayoverPanel.panels[i];
			continue;
		}
	}
	return topPanel;
};

/**
 * Adds window observers for repositioning when document resizes
 * 
 * @method set
 * @param {String} property (required) The name of the property to be set
 * @param {Any} value (required) The new value
 */
MUILayoverPanel.prototype.addObservers = function(){
	if(window.Moonshadow && Moonshadow.getManager){
		var manager = Moonshadow.getManager();
		manager.addWindowObserver('resize', this.adjustPosition, this);
	}
};

/**
 * Sets a property for the panel and reinitializes it
 * 		This method should only be used before opening the panel
 * 
 * @method set
 * @param {String} property (required) The name of the property to be set
 * @param {Any} value (required) The new value
 */
MUILayoverPanel.prototype.set = function(property, value){
	if(this.hasOwnProperty(property)){
		if(property == "tools"){
			this.tools.push(value);
		}else if(property == "docs"){
			this.docs.push(value);
		}else{
			this[property] = value;
		}
		this._init();
		if(this.isShown){
			this._setResize();
		}
		if(this._loadShowing){
			this.loadIndicator(true);
		}
	}
};

/**
 * Make icon for the left of title
 * 
 * @method _makeTitleIcon
 * @private
 * @param {String, DOM Object} String (classname) or DOM element
 */
MUILayoverPanel.prototype._makeTitleIcon = function(icon){
	var ce = this.ce
	if(typeof icon == "string"){
		return $(ce("div"))
			.addClass("panel_title_icon")
			.addClass(icon);
	}
	return icon;
};

/**
 * Centers the panel horizontally frame based on window and panel size
 * 
 * @method _centerWindow
 * @private
 */
MUILayoverPanel.prototype._centerWindow = function(){
	
	var left, top, attr = {};
	if(!this.position || !this.position.left){
		var contWidth = $(".panel_frame, .confirm_alert_shadow", this.container).width();
		var windowWidth = $(window).width();
		var left = Math.round((windowWidth / 2) - (contWidth / 2));
		if(this._cascadeOffset){
			left = left + (this._cascadeOffset * 10);
		}
		attr.left = left;
	}
	
	if((!this.position || !this.position.top) && this._cascadeOffset){
		top = $(".panel_frame, .confirm_alert_shadow", this.container).offset().top + (this._cascadeOffset * 10);
		attr.top = top;
	}
	
	if(left || top){
		$(".panel_frame, .confirm_alert_shadow", this.container)
			.css(attr);
	}
};

/**
 * Initializes the panel
 * 
 * @method _init
 * @private
 */
MUILayoverPanel.prototype._init = function(){
	if(!this.id){
		this.id = "panel_"+(new Date().getTime());
	}
	if(this.id && !this.container){
		this._makeContentContainer();
	}
	if(this.container && this.docs.length){
		this._buildDocs();
	}
	if(this.container && this.tools.length){
		this._buildTools();
	}
	if(this.content && this.container){
		this._prepContent();
		$(".panel_content", this.container).append(this.content);
	}
	if(!MUILayoverPanel.panels[this.id]){
		MUILayoverPanel.panels[this.id] = this;
	}
	
	this.addObservers();
}

MUILayoverPanel.prototype.ce = function(type){
	if(typeof Moonshadow != "undefined"){
		return Moonshadow.helpers.ce(type);
	}
	return document.createElement(type);
};

/**
 * Empty docs container and build tools from given array
 * 
 * @method _buildDocs
 * @private
 */
MUILayoverPanel.prototype._buildDocs = function(){
	var ce = this.ce
	$(".panel_docs", this.container).empty();
	for(var i = 0, l = this.docs.length; i < l; ++i){
		var doc = this.docs[i];
		
		if(!doc.url && !doc.callback){
			continue;
		}
		
		var button = $(ce("div"))
			.addClass("panel_doc clickable")
			.addClass(doc.icon || "sprite-info_shiny")
			.attr({
				"title": doc.title
			});
		
		if(doc.url){
			$(button)
				.on("click", {"url": doc.url}, function(e){
					window.open(e.data.url, "new");
				});
		}
		if(doc.callback){
			$(button)
				.on("click", function(e){
					doc.callback(e);
				});
		}
		
		$(".panel_docs", this.container)
			.append(button);
	}
};

/**
 * Builds tools from given array and stores ui
 * 
 * @method _buildTools
 * @private
 */
MUILayoverPanel.prototype._buildTools = function(){
	for(var i = 0, l = this.tools.length; i < l; ++i){
		var t = this.tools[i];
		if(!t.added && (t instanceof Element || t instanceof jQuery)){
			$(".panel_tools", this.container)
				.append(t);
			t.added = true;
		}
	}
};

/**
 * If content is not a DOM object, this method wraps it
 * 
 * @method _prepContent
 * @private
 */
MUILayoverPanel.prototype._prepContent = function(){
	if(this.content instanceof Array){
		var cont = $(this.ce("div"));
		for(var i = 0, l = this.content.length; i < l; ++i){
			$(cont).append($(this.content[i]).get(0));
		}
		this.content = cont;
	}
	if(this.content && $(this.content).html() == undefined){
		this.content = $(this.ce("div"))
			.append(this.content);
	}
	if(this.scrollable){
		$(this.content)
			.addClass("panel_content_scrollable scrollable");
	}
};

/**
 * Makes the element for the title and stores it
 * 
 * @method _makeTitleElement
 * @private
 */
MUILayoverPanel.prototype._makeTitleElement = function(){
	this._titleElement = $(this.ce("span"))
		.addClass("panel_heading")
		.append(this.title);
};

/**
 * Change the panel's title
 * 
 * @method setTitle
 * @param {String} title The new title
 */
MUILayoverPanel.prototype.setTitle = function(title){
	$(this._titleElement)
		.empty()
		.append(title);
};

/**
 * Puts a red asterisk after the title
 * 
 * @method showIsDirty
 * @param {Boolean} onOff
 */
MUILayoverPanel.prototype.showIsDirty = function(onOff){
	var d = $(".marked_dirty", this._titleElement);
	if(!d.length){
		if(!onOff){
			return;
		}
		d = $(this.ce("span"))
			.addClass("marked_dirty")
			.append(" *");
	}
	
	if(onOff){
		$(this._titleElement).append(d);
	}else{
		$(d).remove();
	}
};


/**
 * Creates panel's HTML elements
 * 
 * @method _makeContentContainer
 * @private
 */
MUILayoverPanel.prototype._makeContentContainer = function(){
	var ce = this.ce;
	var self = this;
	this._makeTitleElement();
	var panelFrame = $(ce("div"))
		.addClass("panel_frame")
		.attr(this._panelFramePosition(this.position))
		.append(
			$(ce("div"))
				.addClass("panel_frame_loading hide"),
			$(ce("div"))
				.addClass("panel_header")
				.append(
					self.titleIcon || "",
					this._titleElement,
					$(ce("span"))
						.addClass("panel_closer clickable")
						.attr({
							"title": "Close Panel"
						})
						.append("X")
						.on("click", {"id": this.id}, 
							function(e){
								MUILayoverPanel.close(e.data.id);
							}
						),
					$(ce("span"))
						.addClass("panel_docs"),
					$(ce("span"))
						.addClass("panel_tools")
				),
			$(ce("div"))
				.addClass("panel_feedback_holder hide")
				.append(
					$(ce("div"))
						.addClass("panel_feedback_panel")
				),
			$(ce("div"))
				.addClass("panel_content_holder")
				.append(
					$(ce("div"))
						.addClass("panel_content")
						.attr(this._panelContentPosition(this.position)),
					self.footer ? $(ce("div"))
						.addClass("panel_content_footer")
						.append(self.footer) : ""
				),
			$(ce("div"))
				.addClass("clear")
		)
		.on("mousedown", function(){
			if(!self.modal){
				self.bringToFront();
			}
		});
	
	this.container = $(ce("div"))
		.addClass("layover_panel")
		.attr({
			"id": this.id
		})
		
	if(this.modal){
		$(this.container)
			.addClass("modal")
			.css({
				"z-index": this._zindex
			})
			.append(
				$(ce("div"))
					.addClass("panel_scroller")
					.append(
						panelFrame
					),
				$(ce("div"))
					.addClass("layover_black")
					
			);
	}else{
		$(this.container)
			.append(panelFrame);
	}
};

/**
 * Brings panel to front of other panels
 * 
 * @method bringToFront
 */
MUILayoverPanel.prototype.bringToFront = function(){
	this._zindex = this._getCascadeOffset()._zindex;
	$(".panel_frame", this.container).css({"z-index": this._zindex});
};

/**
 * Displays panel
 * 
 * @method open
 * @param {Function} callback (optional) A function to callback after opening
 */
MUILayoverPanel.prototype.open = function(callback){
	if(this.isShown){
		return false;
	}
	$(document.body).prepend(this.container);
	this._centerWindow();
	this._addArrow();
	var self = this;
	if(this.displayLoading){
		if(typeof this.displayLoading == "object"){
			if(this.displayLoading.onOpen){
				this.loadIndicator(true);
			}
		}else{
			this.loadIndicator(true);
		}
	}
	this.adjustPosition();
	this._animateContainer(true, function(){
		self.isShown = true;
		self._setResize();
		self._highlightInput();
		self.onOpen && self.onOpen();
		callback && callback();
	});
};

MUILayoverPanel.prototype._highlightInput = function(){
	if(this.defaultFocused){
		$(this.defaultFocused).focus();
	}
};

/**
 * Display an already existing dialog
 * 
 * @method show
 */
MUILayoverPanel.prototype.show = function(){
	if(this.isShown){
		return false;
	}
	this.isShown = true;
	$(".panel_frame, .confirm_alert_shadow", this.container).fadeIn();
};

/**
 * Hides the panel but does not delete it
 * 
 * @method hide
 */
MUILayoverPanel.prototype.hide = function(){
	if(!this.isShown){
		return false;
	}
	this.isShown = false;
	$(".panel_frame, .confirm_alert_shadow", this.container).fadeOut();
};

/**
 * Maked the panel resizable and draggable
 * 
 * @method _setResize
 * @private
 */
MUILayoverPanel.prototype._setResize = function(){
	if(!this.fixed && $(".panel_frame, .confirm_alert_shadow", this.container).draggable){
		$(".panel_frame, .confirm_alert_shadow", this.container)
			.draggable({
				"handle":".panel_header, .confirm_alert_header",
				"containment": "document",
				"stop": function(){
					var offset = $(this).offset();
					if(offset.top && offset.top < 0){
						$(this).css({"top": 0});
					}
				}
			});
		
		if($(".panel_content", this.container).resizable){
		
			var resizingOptions = {
				"handles": "se",
				"minWidth": this.minWidth,
				"maxHeight": this.maxHeight,
				"minHeight": this.minHeight,
				"containment": "document"
			};
			
			if(this.onResizing){
				resizingOptions.resize = this.onResizing;
			}
			
			if(this.onResizeStop){
				resizingOptions.stop = this.onResizeStop;
			}
			
			var resizeA;
			if(this.resizeAlso){
				resizeA = $(this.resizeAlso);
				if(resizeA.length){
					resizingOptions.alsoResize = resizeA;
				}
			}
			
			if(this.position && this.position.also){
				$(resizeA).attr(this._panelContentPosition(this.position.also));
			}
			
			$(".panel_content", this.container)
				.resizable(resizingOptions);
		}
	}
};

/**
 * Animated the opening and closing of the panel
 * 
 * @method _animateContainer
 * @param {Boolean} onOff (optional, default: false) Whether the panel is opening or closing (true = open)
 * @param {Function} callback (optional) Function to call when final animation is done 
 * @private
 */
MUILayoverPanel.prototype._animateContainer = function(onOff, callback){
	
	var aminate = this.animate;
	if(typeof this.animate == "object"){
		if(onOff){
			aminate = !!this.animate.onOpen ? true : false;
		}else{
			aminate = !!this.animate.onClose ? true : false;
		}
	}
	
	var container = this.container;
	
	var pch = $(".panel_content_holder, .confirm_alert_body", container);
	var pf = $(".panel_frame, .confirm_alert_shadow", container);
	var bo = $(".layover_black", container);
	var lp = $(".confirm_alert_loading, .panel_frame_loading", container);
	
	var h = (pch && pch.height()) || 500;
	var t = (pf && pf.offset() && pf.offset().top) || 100;
	var lph = (lp && lp.height()) || 500;
	
	if(aminate){
		var startHeight = 0;
		var startLPHeight = 0;
		var startTop = t + Math.round(h / 2);
		var startOp = 0.1;
		var endHeight = h;
		var endLPHeight = lph;
		var endTop = t;
		var endOp = 0.5;
		
		if(!onOff){
			startHeight = endHeight;
			startLPHeight = endLPHeight;
			startTop = endTop;
			startOp = endOp;
			endHeight = 0;
			endLPHeight = 0;
			endTop = t + Math.round(h / 2);
			endOp = 0.1;
		}
		
		$(bo).css({
			"opacity": startOp 
		});
		
		$(pch).css({
			"height": startHeight + "px",
			"overflow": "hidden"
		});

		$(lp).css({
			"height": startLPHeight + "px",
			"overflow": "hidden"
		});
		
		$(pf).css({
			"top": startTop + "px"
		});
		
		if(onOff){
			$(container).removeClass("hide");
		}
		
		$(bo).animate({
				"opacity": endOp
			},{
				"duration": 100,
				"queue": false
			}
		);
		
		$(pf).animate({
			"top": endTop + "px"
		},{
			"duration": 200,
			"queue": false
		});
		
		if(onOff){
			this._showArrow();
		}else{
			this._hideArrow();
		}
		
		$(lp).animate({
			"height":  endLPHeight + "px"
		},{
			"duration": 180,
			"queue": false
		});
		
		var self = this;
		$(pch).animate({
			"height":  endHeight + "px"
		},{
			"duration": 200,
			"queue": false,
			"complete": function(){
				if(onOff){
					$([pch.get(0)]).removeAttr("style");
				}else{
					$(container).addClass("hide");
				}
				callback && setTimeout(callback, 50);
			}
		});
		
		return;
	}
	callback && callback();
};

/**
 * Determins the value of the position in px or percent
 * 
 */
MUILayoverPanel.prototype._getPositionValue = function(value, total){
	if(typeof value == "number"){
		return value + "px";
	}
	if(typeof value == "string"){
		var numVal = parseInt(value, 10);
		if(isNaN(numVal)){
			numVal = 0;
		}
		if(value.indexOf("%") > 1){
			numVal = parseInt((total / 100) * numVal, 10);
		}
		return numVal + "px";
	}
}

MUILayoverPanel.prototype._getPositionValueTop = function(value){
	return this._getPositionValue(value, $(window).height());
}
MUILayoverPanel.prototype._getPositionValueLeft = function(value){
	return this._getPositionValue(value, $(window).width());
}


/**
 * Sets to panel frame to given parameters
 * 
 * @method _panelFramePosition
 * @param {Object} position (required) Contains the left and top properties
 * 		@property {Integer} left The leftmost position of the frame
 * 		@property {Integer} top The topmost position of the frame
 * @return {String} A string to be used as the attributes for the panel frame
 * @private
 */
MUILayoverPanel.prototype._panelFramePosition = function(position){
	var zindex = this._zindex;
	if(this.modal){
		++zindex;
	}
	var attr = {
		"style": "z-index: " + zindex + ";"
	};
	if(!this.fixed){
		if(position.left != undefined){
			attr.style += "left: " + this._getPositionValueLeft(position.left) + ";";
		}
		if(position.top != undefined){
			attr.style += "top: " + this._getPositionValueTop(position.top) + ";";
		}
	}
	
	return attr;
};

/**
 * Sets to panel content to given parameters
 * 
 * @method _panelContentPosition
 * @param {Object} position (required) Contains the height and width properties
 * 		@property {Integer} height The height of the content
 * 		@property {Integer} width The width of the content
 * @return {String} A string to be used as the attributes for the panel content
 * @private
 */
MUILayoverPanel.prototype._panelContentPosition = function(position){
	var attr = {};
	if(position.height != undefined){
		if(!attr.style){
			attr.style = "";
		}
		if(position.height > this.maxHeight){
			position.height = this.maxHeight;
		}
		attr.style += "height: " + this._getPositionValueTop(position.height) + ";";
	}
	if(position.width != undefined){
		if(!attr.style){
			attr.style = "";
		}
		if(position.width > this.maxWidth){
			position.width = this.maxWidth;
		}
		attr.style += "width: " + this._getPositionValueLeft(position.width) + ";";
	}
	return attr;
};

/**
 * Adds feedback areas to a panel to display messages (errors) to the user
 * 
 * @method feedback
 * @param {String} id (required) The id of the desired panel
 * @param {String} message (optional) Message to display to the user, 
 * 					if string is empty (or param is false, feedback area will close
 * @param {String} className (optional) Classname to apply to the feedback area
 * @param {String} subInfo (optional) More text to display to the user
 * @static
 */
MUILayoverPanel.feedback = function(id, message, className, subInfo){
	var panel = MUILayoverPanel.get(id);
	if(!panel || !panel.container){
		return false;
	}
	var pc = panel.container;
	if(message){
		$(".panel_feedback_panel", pc)
			.addClass(className)
			.append(message);
		$(".panel_feedback_holder", pc)
			.removeClass("hide");
	}else{
		$(".panel_feedback_holder", pc)
			.addClass("hide");
		$(".panel_feedback_panel", pc)
			.empty();
	}
	if(subInfo){
		$(".panel_feedback_panel", pc)
			.append(
				$(panel.ce("span"))
					.addClass("panel_feedback_panel_subinfo")
					.append(subInfo)
			);
	}else{
		$(".panel_feedback_panel_subinfo", pc)
			.remove();
	}
};

/**
 * Closes the panel with given id
 * 
 * @method close
 * @param {String} id (required) The id of the desired panel
 * @static
 */
MUILayoverPanel.close = function(id){
	if(!id){
		return false;
	}
	var panel = MUILayoverPanel.get(id);
	if(!panel){
		return false;
	}
	
	panel.close();
};

/**
 * Closes the panel
 * 
 * @method close
 */
MUILayoverPanel.prototype.close = function(callback){
	if(this.displayLoading){
		if(typeof this.displayLoading == "object"){
			if(this.displayLoading.onClose){
				this.loadIndicator(true);
			}
		}else{
			this.loadIndicator(true);
		}
	}
	
	var highlighNextPanel = function(){
		var nextPanel = MUILayoverPanel.getTopPanel();
		if(nextPanel){
			nextPanel._highlightInput();
		}
	};
	
	var self = this;
	if(this.onClose){
		return this.onClose(function(){
			self._delete.call(self, highlighNextPanel);
			callback && callback();
		}, this.context);
	}
	
	this._delete(highlighNextPanel);
	callback && callback();
}

/**
 * actively adjusts panel
 * 
 * @method adjustOffset
 * @param {Object} position
 */
MUILayoverPanel.prototype.adjustOffset = function(position){
	if(!position){
		return;
	}
	var pf = $(".panel_frame, .confirm_alert_shadow", this.container);
	if(position.left){
		$(pf).css({"left": this._getPositionValueLeft(position.left)});
	}
	if(position.top){
		$(pf).css({"top": this._getPositionValueTop(position.top)});
	}
};

/**
 * Checks the position of the panel against the window dimentions and adjusts accordingly
 * 
 * @method adjustOffset
 */
MUILayoverPanel.prototype.adjustPosition = function(){
	var position = this.getCurrentPosition();
	var windowH = $(window).height();
	var windowW = $(window).width();
	var adjustmentMade = false;
	if(position.left + position.width > windowW){
		position.left = windowW - position.width;
		adjustmentMade = true;
	}
	if(position.top + position.height > windowH){
		position.top = windowH - position.height;
		adjustmentMade = true;
	}
	if(position.left < 0){
		position.left = 0;
		adjustmentMade = true;
	}
	if(position.top < 0){
		position.top = 0;
		adjustmentMade = true;
	}
	adjustmentMade && this.adjustOffset(position);
};

/**
 * Gets the current position of the panel
 * 
 * @method getCurrentPosition
 */
MUILayoverPanel.prototype.getCurrentPosition = function(){
	var pf = $(".panel_frame, .confirm_alert_shadow", this.container);
	var offset = $(pf).offset();
	offset.height = $(pf).height();
	offset.width = $(pf).width();
	return offset;
};

/**
 * Displays or hides the load indicator
 * 
 * @method loadIndicator
 * @param {Boolean} onOff (optional, default: false) Whether to show or hide the indicator (true = show) 
 */
MUILayoverPanel.prototype.loadIndicator = function(onOff){
	if(onOff){
		var t = $(".panel_frame, .confirm_alert_body", this.container);
		$(".panel_frame_loading, .confirm_alert_loading", this.container)
			.css({
				"height": t.height(),
				"width": t.width()
			})
			.removeClass("hide");
		this._loadShowing = true;
	}else{
		$(".panel_frame_loading, .confirm_alert_loading", this.container)
			.addClass("hide");
		this._loadShowing = false;
	}
};

/**
 * Hides the panel, removes it from DOM, and deletes from the panels collection
 * 
 * @method _delete
 * @private
 */
MUILayoverPanel.prototype._delete = function(callback){
	var self = this;
	this.loadIndicator(false);
	this.isShown = false;
	this.loadIndicator(false);
	
	this._animateContainer(false, function(){
		$(self.container).remove();
		delete MUILayoverPanel.panels[self.id];
		callback && callback();
	});
};

/**
 * Changes the title of an already opened panel (not confirm/alert)
 * 
 * @method changeTitle
 * @param {String} title
 */
MUILayoverPanel.prototype.changeTitle = function(title){
	$(".panel_heading", this.container)
		.empty()
		.append(title);
}

/**
 * Gets new left/top attrs for cascading panels. 
 * 		Also gets flag to assure screen is only darkened once.
 * 		Also gets next z-index of the dialog type
 * @method _getCascadeOffset
 * @return {Object} object with attributes
 * @private
 */

MUILayoverPanel.prototype._getCascadeOffset = function(){
	var zindex = this.modal ? 
			MUILayoverPanel.zindex[this._dialogType].modal : 
			MUILayoverPanel.zindex[this._dialogType].nonmodal;
	var attributes = {
		"_zindex": zindex,
		"_cascadeOffset": 0,
		"_preventDarkening": false
	};
	var types = [this._dialogType];
	if(this._dialogType == "alert"){
		types.push("confirm");
	}
	if(this._dialogType == "confirm"){
		types.push("alert");
	}
	var panels = MUILayoverPanel.getOfType(types);
	attributes._zindex = panels.length + attributes._zindex;
	attributes._cascadeOffset = panels.length;
	var darkened = 0;	
	for(var i = 0, l = panels.length; i < l; ++i){
		if(panels[i].modal){
			darkened++;
		}
		if(attributes._zindex <= panels[i]._zindex){
			attributes._zindex = panels[i]._zindex + 1;
		}
	}
	if(darkened > 1){
		attributes._preventDarkening = true;
	}
	return attributes;
};

/**
 * Simple overlay with small alert dialog. 
 * @method alert
 * @param {String/Object} settings (optional) 
 * 			{String}: The main message or question of the dialog
 * 			{Object}: An object containing the following attributes:
 *		@property {String} id (optional, if not provided, a unique id is generated) The id of the dialog 
 *		@property {String} title (optional) The title in the dialog 
 *		@property {String/HTML} message (optional) The main message or question of the dialog, 
 *				can be HTML elements or JQuery object
 *		@property {String} closeText (optional, default: "OK") Text to display for the button to close 
 *				the dialog and call the callback if provided
 *		@property {Boolean} displayLoading (optional, default: false) True will display an animated loading icon after
 *				confirming and before the dialog closes
 *		@property {Function} callback (optional) Function to apply when OK (or Cancel) button is pushed
 *				The callback will have 4 arguments:
 * 					- {Boolean} response: The button press response (Defaults to true, but in the case of a confirmation
 *						dialog, may be false) 
 *					- {String} id: The id of this alert 
 *					- {Function} hide: A function that will be called to invoke the closing of the dialog. If you
 *							include a callback with the creation of the dialog, this hide function needs to be called
 *							in order to close the dialog. Note: Normally, upon user response, just calling the hide callback 
 *							will close the dialog, however, if you wish to override the closing and keep it open, pass TRUE
 *							to this when calling it. It will kill the displayLoading icon and keep the dialog open.
 *							This is handy after the user confirms positive to an action, but conditions for the
 *							completion of the action have not been met, and the user should be returned to the dialog again.
 *					- {Any} value: the value of button (if any) that will be returned on click
 *		@property {Boolean} modal (optional, default: true) Whether or not the dialog covers the screen 
 *				preventing interaction with page behide (Note: only one modal backdrop will be displayed at a time. Any new
 *				modal or non-modal panels that are instantiated after a previous panel is modal will be on top of the modal stack)
 *		@property {Object} arrow (optional) An object with attributes to display an arrow from the alert
 *				{"direction": ["left", "right", "up", "down"], "placement": ["top", "bottom", "left", "right"], 
 *				"length": [length in px]}
 *		@property {Object} position (optional) Object with attributes to place the alert on the page
 *				{"left": [px], "top": [px]}
 *		@property {String} additionalClass (optional) extra class name to provide for more control over the display
 *		@property {Boolean} delayed (optional) Whether or not to show the alert immediately
 *		@property {Array} buttons (optional) An array of button elements (DOM or jQuery) who's values will be returned on click/close
 * @return {MUILayoverPanel} dialog object
 * @static
 */
MUILayoverPanel.alert = function(settings){
	if(typeof settings == "string"){
		settings = {"message": settings};
	}
	settings = settings || {};
	settings._dialogType = "alert";
	return MUILayoverPanel._confirmAlert(settings);
};

/**
 * Simple overlay with small confirmation dialog. 
 * @method confirm
 * @param {Object} settings (optional) An object containing attributes discribed in MUILayoverPanel.alert
 * @return {MUILayoverPanel} dialog object
 * @static
 */
MUILayoverPanel.confirm = function(settings){
	if(typeof settings == "string"){
		settings = {"message": settings};
	}
	settings = settings || {};
	settings._dialogType = "confirm";
	return MUILayoverPanel._confirmAlert(settings);
};

/**
 * Gets an MUILayoverPanel instance to override for alert or confirmation dialog. 
 * @method _confirmAlert
 * @param {Object} settings (required) An object containing attributes discribed in MUILayoverPanel.alert
 * @return {MUILayoverPanel} dialog object
 * @private
 * @static
 */
MUILayoverPanel._confirmAlert = function(settings){
	if(!settings.id){
		settings.id = "confirm_" + new Date().getTime();
	}
	
	var _confirmAlert = new MUILayoverPanel({
		"id": settings.id,
		"animate": true,
		"title": settings.title,
		"titleIcon": settings.titleIcon,
		"closeText": settings.closeText,
		"displayLoading": settings.displayLoading,
		"onOpen": settings.onOpen,
		"onClose": settings.onClose,
		"modal": settings.modal === false ? false : true,
		"fixed": settings.fixed === true ? true : false
	});
	
	_confirmAlert.message = settings.message;
	_confirmAlert.callback = settings.callback;
	_confirmAlert.position = settings.position;
	_confirmAlert.arrow = settings.arrow;
	_confirmAlert.additionalClass = settings.additionalClass;
	_confirmAlert._dialogType = settings._dialogType;
	if(settings.buttons){
		_confirmAlert._makeButtons(settings.buttons);
	}
	
	var attributes = _confirmAlert._getCascadeOffset();
	_confirmAlert._zindex = attributes._zindex;
	_confirmAlert._cascadeOffset = attributes._cascadeOffset;
	_confirmAlert._preventDarkening = attributes._preventDarkening;

	_confirmAlert._confirmAlertBody();
	!settings.delayed && _confirmAlert.open();
	
	return _confirmAlert;
};

/**
 * Builds the body for the confirmation and alert dialogs. 
 * @method _confirmAlertBody
 * @private
 */
MUILayoverPanel.prototype._confirmAlertBody = function() {
	var ce = this.ce;
	var self = this;
	
	var zindex = this._zindex;
	if(this.modal){
		++zindex;
	}
	
	var buttonsPanel = $(ce("div"))
		.addClass("confirm_alert_buttons");
	
	if(this.buttons){
		for(var i = 0, l = this.buttons.length; i < l; ++i){
			$(buttonsPanel).append(
				this.buttons[i]
			);
		}
	}else{
		$(buttonsPanel).append(
			function(){
				if(self._dialogType == "confirm"){
					return self.makeButton("Cancel", false, false, 2);
				}
				return "";
			}(),
			self.makeButton(this.closeText || "OK", true, true, 1)
		);
	}
	
	this.container = $(ce("div"))
		.addClass("confirm_alert_panel")
		.addClass(this.additionalClass ? this.additionalClass : "")
		.addClass(this.modal && "modal")
		.attr({"id": this.id})
		.append(
			$(ce("div"))
				.addClass("confirm_alert_shadow")
				.css({"z-index": zindex})
				.css(function(){
					var css = {};
					if(self.position){
						if(self.position.left){
							css.left = self._getPositionValueLeft(self.position.left);
						}
						if(self.position.top){
							css.top = self._getPositionValueTop(self.position.top);
						}
						if(self.position.width){
							css.width = self.position.width;
						}
					}
					return css;
				}())
				.append(
					$(ce("div"))
						.addClass("confirm_alert_loading hide"),
					$(ce("div"))
						.addClass("confirm_alert_body")
						.append(
							this.titleIcon || "",
							$(ce("div"))
								.addClass("confirm_alert_header")
								.append(this.title),
							$(ce("div"))
								.addClass("confirm_alert_message")
								.append(this.message),
							buttonsPanel
							
						)
				),
			function(){
				if(self.modal && !self._preventDarkening){
					return $(ce("div"))
						.addClass("layover_black")
						.css({
							"z-index": self._zindex
						});
				}
				return "";
			}()
		);
};

MUILayoverPanel.prototype._makeButtons = function(buttons){
	this.buttons = [];
	for(var i = 0, l = buttons.length; i < l; ++i){
		if(typeof buttons[i] == "string"){
			this.buttons.push(this.makeButton(buttons[i], null, false, i + 1));
			continue;
		}
		if($(buttons[i]).get(0) instanceof Element){
			this.buttons.push(buttons[i]);
			continue;
		}
		var b = buttons[i];
		this.buttons.push(
			this.makeButton(
				b.title, b.userResponse, b.highlighted, 
				b.tabindex != undefined ? b.tabindex : i + 1, b.value
			)
		);
	}
};

MUILayoverPanel.prototype.makeButton = function(title, userResponse, highlighted, tabindex, value){
	var ce = this.ce;
	return this._makeButton(
		$(ce("input"))
			.attr({
				"type": "button",
				"value": title,
				"tabindex":  tabindex
			}),
		userResponse, highlighted, tabindex, value
	);
};
	
MUILayoverPanel.prototype._makeButton = function(input, userResponse, highlighted, tabindex, value){
	var ce = this.ce;
	var self = this;
	
	var highlightNext = function(index){
		var next = $("input[tabIndex=" + (index + 1) +"]", self.container).get(0);
		if(next){
			return $(next).focus();
		}
		if(index <= 1){
			return;
		}
		return highlightNext(0);
	};
	
	$(input).on("click", function(e){
		this.blur();
		var button = this;
		if(self.displayLoading && userResponse === true){
			self._confirmAlertLoading(button, true);
		}
		if(self.callback){
			return self.callback(
				userResponse === false ? false : true,
				self.id, 
				function(keepOpen){
					self._confirmAlertLoading(button, false);
					if(!keepOpen){
						self.close();
					}
				},
				value || this.value
			);
		}
		self.close();
	})
	.on("keydown", function(e){
		var c = e.keyCode;
		if(c == 9){
			e.preventDefault();
			highlightNext(this.tabIndex);
		}
	});
	if(highlighted){
		self.defaultFocused = input;
	}
	return input;
};

MUILayoverPanel.prototype._confirmAlertLoading = function(target, onOff){
	
	var cal = $(target)
		.closest(".layover_panel")
		.find(".confirm_alert_loading")
	
	if(cal){
		if(onOff){
			var ab = $(target)
				.closest(".confirm_alert_body");

			$(cal).css({
				"height": ab.height(),
				"width": ab.width()
			})
			.removeClass("hide");
			
		}else{
			$(cal).addClass("hide");
		}
	}
};

/**
 * Adds an arrow to a confirmation/alert panel
 * 		(Note: right now only supports direction:right, placement:bottom/top)
 * @method _addArrow
 * @private
 */
MUILayoverPanel.prototype._addArrow =  function(){
	if(!this.arrow){
		return;
	}
	var direction = this.arrow.direction;
	var placement = this.arrow.placement;
	var length = this.arrow.length;
	
	if(!length){
		length = 100;
	}
	
	var aCssAttr = {}, bCssAttr = {}, sCssAttr = {}, dir;
	switch(direction){
		case "right":
		default:
			direction = "right";
			dir = "left";
			aCssAttr["border-width"] = [14, 0, 10, length].join("px ") + "px";
			bCssAttr["border-width"] = [15, 0, 12, length].join("px ") + "px";
			sCssAttr["border-width"] = [12, 0, 20, length - 15].join("px ") + "px";
			var moveright = $(".confirm_alert_body", this.container).width();
			aCssAttr["left"] = moveright + 5;
			bCssAttr["left"] = moveright + 6;
			sCssAttr["left"] = moveright + 12;
	}
	
	switch(placement){
		case "bottom":
			var movedown = $(".confirm_alert_body", this.container).height() - 25;
			aCssAttr["top"] = movedown;
			bCssAttr["top"] = movedown -1;
			sCssAttr["top"] = movedown;
			break;
		case "top":
		default:
			placement = "top";
			bCssAttr["top"] = -1;
	}
	
	var ce = this.ce;
	var arrow = $(ce("div"))
		.addClass("confirm_alert_arrow_container")
		.append(
			$(ce("div"))
				.addClass("confirm_alert_arrow_border")
				.addClass("confirm_alert_arrow_" + direction)
				.css(bCssAttr),
			$(ce("div"))
				.addClass("confirm_alert_arrow")
				.addClass("confirm_alert_arrow_" + direction)
				.css(aCssAttr)
		);
		
	var arrowShadow = $(ce("div"))
		.addClass("confirm_alert_arrow_shadow_container")
		.append(
			$(ce("div"))
				.addClass("confirm_alert_arrow_shadow")
				.addClass("confirm_alert_arrow_" + direction)
				.css(sCssAttr)
		);
	
	$(".confirm_alert_header", this.container)
		.prepend(arrow);
	
	$(".confirm_alert_shadow", this.container)
		.prepend(arrowShadow);
	
	this._arrowObject = {
		"arrow": arrow,
		"arrowShadow": arrowShadow
	};
};

/**
 * Animates the showing of the arrow when the panel opens
 * 		(Note: right now only supports direction:right, placement:bottom/top)
 * @method _showArrow
 * @private
 */
MUILayoverPanel.prototype._showArrow = function(){
	if(!this._arrowObject){
		return;
	}
	
	var self = this;
	$(this._arrowObject.arrow)
		.animate({
			"opacity": 1 
		},{
			"duration": 100,
			"queue": false,
			"complete": function(){
				$(self._arrowObject.arrowShadow)
					.css({"opacity": 1})
			}
		});
};

/**
 * Animates the hiding of the arrow when the panel closes
 * 		(Note: right now only supports direction:right, placement:bottom/top)
 * @method _hideArrow
 * @private
 */
MUILayoverPanel.prototype._hideArrow = function(){
	if(!this._arrowObject){
		return;
	}
	
	var self = this;
	$(this._arrowObject.arrow)
		.animate({
			"opacity": 0 
		},{
			"duration": 100,
			"queue": false
		});
	
	$(this._arrowObject.arrowShadow)
		.animate({
			"opacity": 0 
		},{
			"duration": 50,
			"queue": false,
			"complete": function(){
				$(self._arrowObject.arrow).remove()
				$(self._arrowObject.arrowShadow).remove();
			}
		});
};




function MUIWizardHelper(manager, panels, tabIndex, callback) {
	this.manager = manager;
	this.panels = panels;
	this.pos = {};
	this.defaultDimensions = {
		"height": 500,
		"width": 700
	}
	this.init(tabIndex, callback);
};

MUIWizardHelper.prototype.init = function(tabIndex, callback){
	if(tabIndex == undefined){
		tabIndex = 0;
	}
	if(typeof tabIndex == "string"){
		tabIndex = this.getTabIndex(tabIndex);
	}
	this.changeTab(tabIndex, true, this.defaultDimensions, callback);
};

MUIWizardHelper.prototype.buildNavHeader = function(activeTab){
	var self = this;
	var ce = Moonshadow.helpers.ce;

	return $(ce("div"))
		.addClass("wizard_header")
		.append(
			$(this.panels).map(function(index, panel){
				return $(ce("div"))
					.addClass(panel.id + "_nav wizard_nav_item")
					.addClass(activeTab == index ? " current" : " clickable")
					.append(
						panel.title,
						index == self.panels.length -1 ? "" : $(ce("div"))
							.addClass("wizard_nav_arrow")
					)
					.click(function(e){
						if(activeTab == index){
							return false;
						}
						self.changeTab(index, false);
					})
					.get(0);
			})
		);
};

MUIWizardHelper.prototype.buildControlButtons = function(controlButtons, activeTab, activeControl){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var controlButtonPanel = $(ce("div"))
		.addClass("wizard_list_header");
	
	return $(controlButtonPanel)
		.append(
			$(ce("input"))
				.addClass("wizard_nav_back_next hang_right")
				.attr({
					"type": "button",
					"value": "Next >",
					"disabled": (activeTab == this.panels.length - 1)
				})
				.click(function(e){
					self.changeTab(++activeTab, false);
				}),
			$(ce("input"))
				.addClass("wizard_nav_back_next")
				.attr({
					"type": "button",
					"value": "< Back",
					"disabled": (activeTab == 0)
				})
				.click(function(e){
					self.changeTab(--activeTab, false);
				}),
			$.map(controlButtons, function(button, index){
				button.elem = $(ce("input"))
					.addClass("wizard_nav")
					.addClass(button.right ? "hang_right" : null)
					.addClass(activeControl && activeControl == button.id ? "view_selected" : null)
					.attr({
						"type": "button",
						"value": button.title
					})
					.on("activate", function(e){
						if(button.filter){
							if(activeControl && activeControl == button.id){
								return;
							}
							activeControl = button.id;
							$(".view_selected", controlButtonPanel).removeClass("view_selected");
							$(this).addClass("view_selected");
						}
					})
					.on("click", function(e){
						$(this).trigger("activate");
						button.action();
					})
				return $(button.elem).get(0);
			}),
			$(ce("div"))
				.addClass("clear")
		);
};

MUIWizardHelper.prototype.buildPanel = function(activeTab, activeControl, callback){
	var ce = Moonshadow.helpers.ce;
	var self = this;
	var panel = this.panels[activeTab];
	var control = panel.control;
	var buttons = (control.controlButtons && control.controlButtons()) || [];
	var settings = control.wizard_settings || {};
	control.getContent(function(content, footer){
		callback(
			[self.buildNavHeader(activeTab),
			self.buildControlButtons(buttons, activeTab, activeControl),
			self.buildContentArea(content, !!footer, settings),
			self.buildFooter(footer)]
		);
	});
};

MUIWizardHelper.prototype.buildContentArea = function(content, hasFooter, settings){
	var ce = Moonshadow.helpers.ce;
	return $(ce("div"))
		.addClass("wizard_content")
		.addClass(hasFooter ? "with_footer" : null)
		.addClass(settings.className)
		.append(content);
};

MUIWizardHelper.prototype.buildFooter = function(footerContent){
	var ce = Moonshadow.helpers.ce;
	return footerContent ? $(ce("div"))
		.addClass("wizard_footer")
		.append(footerContent) : "";
};

MUIWizardHelper.prototype.getTabControl = function(tabId){
	var tabIndex = this.getTabIndex(tabId);
	return this.panels[tabIndex].control;
};

MUIWizardHelper.prototype.getTabIndex = function(tabId){
	for(var i = 0, l = this.panels.length; i < l; ++i){
		if(this.panels[i].id == tabId){
			return i;
		}
	}
	return false;
};

MUIWizardHelper.prototype.changeTab = function(activeTab, animate, position, callback){
	var self = this;
	if(!position){
		this.getWindowPositions();
		position = this.pos;
	}
	this.closePanel(null, function(){
		var panel = self.panels[activeTab];
		if(!panel){
			return false;
		}
		var control = panel.control;
		self.buildPanel(activeTab, control.activeControl, function(panelContent){
			var panelWindow = new MUILayoverPanel({
				"id": panel.id,
				"content": panelContent,
				"title": panel.header,
				"fixed": false,
				"resizeAlso": control.contentPanelSelector,
				"position": position,
				"docs":  panel.docs,
				"onOpen": function(){
					control.onOpen && control.onOpen()
				},
				"onClose": function(callback, context){
					if(control.onClose){
						return control.onClose(callback, context);
					}
					callback(true);
				}
			});
			
			if(control.displayLoading){
				panelWindow.loadIndicator(true);
			}
			
			control.openPanel = panelWindow;
			panelWindow.animate = animate;
			panelWindow.open(callback);
		});
	});
};

MUIWizardHelper.prototype.closePanel = function(id, callback){
	if(!id){
		id = this.currentlyViewingType;
	}
	if(!id){
		var panel = MUILayoverPanel.getOfType("panel")[0];
		if(!panel){
			callback && callback();
			return;
		}
		id = panel.id;
	}
	if(id){
		var panel = MUILayoverPanel.get(id);
		if(panel && panel.isShown){
			panel.animate = false;
			return panel.close(callback);
		}
	}
	callback && callback();
};

MUIWizardHelper.prototype.getWindowPositions = function(){
	if($(".panel_frame.ui-draggable").length && $(".panel_frame.ui-draggable").attr("style")){
		var vars = $(".panel_frame.ui-draggable").attr("style").split(";");
		for(var i = 0, l = vars.length; i < l; ++i){
			if(vars[i].search("left") > -1){
				this.pos.left = parseInt(vars[i].replace("left:", "").replace("px", "").trim(), 10);
			}
			if(vars[i].search("top") > -1){
				this.pos.top = parseInt(vars[i].replace("top:", "").replace("px", "").trim(), 10);
			}
		}
	}
	if($(".panel_content.ui-resizable").length && $(".panel_content.ui-resizable").attr("style")){
		var vars = $(".panel_content.ui-resizable").attr("style").split(";");
		for(var i = 0, l = vars.length; i < l; ++i){
			if(vars[i].search("height") > -1){
				
				this.pos.height = parseInt(vars[i].replace("height:", "").replace("px", "").trim(), 10);
			}
			if(vars[i].search("width") > -1){
				this.pos.width = parseInt(vars[i].replace("width:", "").replace("px", "").trim(), 10);
			}
		}
	}
	
//	//generalize this
//	var also = ".survey_list_universe, .survey_list_users, .survey_list";
//	if($(also).length && $(also).attr("style")){
//		var vars = $(also).attr("style").split(";");
//		this.pos.also = {};
//		for(var i = 0, l = vars.length; i < l; ++i){
//			if(vars[i].search("height") > -1){
//				this.pos.also.height = parseInt(vars[i].replace("height:", "").replace("px", "").trim(), 10);
//			}
//			if(vars[i].search("width") > -1){
//				this.pos.also.width = parseInt(vars[i].replace("width:", "").replace("px", "").trim(), 10);
//			}
//		}
//	}
};


function userAgreement(agreement, onClose, onAgree){
	this.agreed = false;
	var self = this;
	var ce = function(type){
		if(typeof Moonshadow != "undefined"){
			return Moonshadow.helpers.ce(type);
		}
		return document.createElement(type);
	};
	
	var content = $(ce("div"))
		.addClass("agreement_content")
		.append(
			$(ce("div"))
				.addClass("agreement_header"),
			$(ce("div"))
				.addClass("agreement_body scrollable")
				.append(agreement.agreement_text),
			$(ce("div"))
				.addClass("agreement_footer")
				.append(
					$(ce("input"))
						.addClass("agree_to_terms")
						.attr({
							"type": "button",
							"value": "OK"
						})
						.on("click", function(){
							self.agreed = true;
							onAgree && onAgree();
							MUILayoverPanel.close("agreementPanel");
						}),
					$(ce("input"))
						.addClass("disagree_to_terms")
						.attr({
							"type": "button",
							"value": "Cancel"
						})
						.on("click", function(){
							MUILayoverPanel.close("agreementPanel");
						})
				)
		);
	
	var _agreementPanel = new MUILayoverPanel({
		"id": "agreementPanel", 
		"content": content, 
		"title": agreement.title,
		"onClose": function(callback){
			onClose && onClose(self.agreed);
			callback();
		},
		"fixed": false,
		"animate": true,
		"position": {
			"height": 600,
			"width": 900
		}
	});
	_agreementPanel.open();
}
